/******/
(function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/
	var installedModules = {};
	/******/
	/******/ 	// The require function
	/******/
	function __webpack_require__(moduleId) {
		/******/
		/******/ 		// Check if module is in cache
		/******/
		if(installedModules[moduleId]) {
			/******/
			return installedModules[moduleId].exports;
			/******/
		}
		/******/ 		// Create a new module (and put it into the cache)
		/******/
		var module = installedModules[moduleId] = {
			/******/            i: moduleId,
			/******/            l: false,
			/******/            exports: {}
			/******/
		};
		/******/
		/******/ 		// Execute the module function
		/******/
		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
		/******/
		/******/ 		// Flag the module as loaded
		/******/
		module.l = true;
		/******/
		/******/ 		// Return the exports of the module
		/******/
		return module.exports;
		/******/
	}
	
	/******/
	/******/
	/******/ 	// expose the modules object (__webpack_modules__)
	/******/
	__webpack_require__.m = modules;
	/******/
	/******/ 	// expose the module cache
	/******/
	__webpack_require__.c = installedModules;
	/******/
	/******/ 	// define getter function for harmony exports
	/******/
	__webpack_require__.d = function(exports, name, getter) {
		/******/
		if(!__webpack_require__.o(exports, name)) {
			/******/
			Object.defineProperty(exports, name, {enumerable: true, get: getter});
			/******/
		}
		/******/
	};
	/******/
	/******/ 	// define __esModule on exports
	/******/
	__webpack_require__.r = function(exports) {
		/******/
		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
			/******/
			Object.defineProperty(exports, Symbol.toStringTag, {value: 'Module'});
			/******/
		}
		/******/
		Object.defineProperty(exports, '__esModule', {value: true});
		/******/
	};
	/******/
	/******/ 	// create a fake namespace object
	/******/ 	// mode & 1: value is a module id, require it
	/******/ 	// mode & 2: merge all properties of value into the ns
	/******/ 	// mode & 4: return value when already ns object
	/******/ 	// mode & 8|1: behave like require
	/******/
	__webpack_require__.t = function(value, mode) {
		/******/
		if(mode & 1) value = __webpack_require__(value);
		/******/
		if(mode & 8) return value;
		/******/
		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
		/******/
		var ns = Object.create(null);
		/******/
		__webpack_require__.r(ns);
		/******/
		Object.defineProperty(ns, 'default', {enumerable: true, value: value});
		/******/
		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) {
			return value[key];
		}.bind(null, key));
		/******/
		return ns;
		/******/
	};
	/******/
	/******/ 	// getDefaultExport function for compatibility with non-harmony modules
	/******/
	__webpack_require__.n = function(module) {
		/******/
		var getter = module && module.__esModule ?
			/******/            function getDefault() {
				return module['default'];
			} :
			/******/            function getModuleExports() {
				return module;
			};
		/******/
		__webpack_require__.d(getter, 'a', getter);
		/******/
		return getter;
		/******/
	};
	/******/
	/******/ 	// Object.prototype.hasOwnProperty.call
	/******/
	__webpack_require__.o = function(object, property) {
		return Object.prototype.hasOwnProperty.call(object, property);
	};
	/******/
	/******/ 	// __webpack_public_path__
	/******/
	__webpack_require__.p = "/";
	/******/
	/******/
	/******/ 	// Load entry module and return exports
	/******/
	return __webpack_require__(__webpack_require__.s = 12);
	/******/
})
/************************************************************************/
/******/({
	
	/***/ "./node_modules/chart.js/src/chart.js":
	/*!********************************************!*\
  !*** ./node_modules/chart.js/src/chart.js ***!
  \********************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		/**
		 * @namespace Chart
		 */
		var Chart = __webpack_require__(/*! ./core/core */ "./node_modules/chart.js/src/core/core.js")();
		
		Chart.helpers = __webpack_require__(/*! ./helpers/index */ "./node_modules/chart.js/src/helpers/index.js");

// @todo dispatch these helpers into appropriated helpers/helpers.* file and write unit tests!
		__webpack_require__(/*! ./core/core.helpers */ "./node_modules/chart.js/src/core/core.helpers.js")(Chart);
		
		Chart.Animation = __webpack_require__(/*! ./core/core.animation */ "./node_modules/chart.js/src/core/core.animation.js");
		Chart.animationService = __webpack_require__(/*! ./core/core.animations */ "./node_modules/chart.js/src/core/core.animations.js");
		Chart.defaults = __webpack_require__(/*! ./core/core.defaults */ "./node_modules/chart.js/src/core/core.defaults.js");
		Chart.Element = __webpack_require__(/*! ./core/core.element */ "./node_modules/chart.js/src/core/core.element.js");
		Chart.elements = __webpack_require__(/*! ./elements/index */ "./node_modules/chart.js/src/elements/index.js");
		Chart.Interaction = __webpack_require__(/*! ./core/core.interaction */ "./node_modules/chart.js/src/core/core.interaction.js");
		Chart.layouts = __webpack_require__(/*! ./core/core.layouts */ "./node_modules/chart.js/src/core/core.layouts.js");
		Chart.platform = __webpack_require__(/*! ./platforms/platform */ "./node_modules/chart.js/src/platforms/platform.js");
		Chart.plugins = __webpack_require__(/*! ./core/core.plugins */ "./node_modules/chart.js/src/core/core.plugins.js");
		Chart.Scale = __webpack_require__(/*! ./core/core.scale */ "./node_modules/chart.js/src/core/core.scale.js");
		Chart.scaleService = __webpack_require__(/*! ./core/core.scaleService */ "./node_modules/chart.js/src/core/core.scaleService.js");
		Chart.Ticks = __webpack_require__(/*! ./core/core.ticks */ "./node_modules/chart.js/src/core/core.ticks.js");
		Chart.Tooltip = __webpack_require__(/*! ./core/core.tooltip */ "./node_modules/chart.js/src/core/core.tooltip.js");
		
		__webpack_require__(/*! ./core/core.controller */ "./node_modules/chart.js/src/core/core.controller.js")(Chart);
		__webpack_require__(/*! ./core/core.datasetController */ "./node_modules/chart.js/src/core/core.datasetController.js")(Chart);
		
		__webpack_require__(/*! ./scales/scale.linearbase */ "./node_modules/chart.js/src/scales/scale.linearbase.js")(Chart);
		__webpack_require__(/*! ./scales/scale.category */ "./node_modules/chart.js/src/scales/scale.category.js")(Chart);
		__webpack_require__(/*! ./scales/scale.linear */ "./node_modules/chart.js/src/scales/scale.linear.js")(Chart);
		__webpack_require__(/*! ./scales/scale.logarithmic */ "./node_modules/chart.js/src/scales/scale.logarithmic.js")(Chart);
		__webpack_require__(/*! ./scales/scale.radialLinear */ "./node_modules/chart.js/src/scales/scale.radialLinear.js")(Chart);
		__webpack_require__(/*! ./scales/scale.time */ "./node_modules/chart.js/src/scales/scale.time.js")(Chart);

// Controllers must be loaded after elements
// See Chart.core.datasetController.dataElementType
		__webpack_require__(/*! ./controllers/controller.bar */ "./node_modules/chart.js/src/controllers/controller.bar.js")(Chart);
		__webpack_require__(/*! ./controllers/controller.bubble */ "./node_modules/chart.js/src/controllers/controller.bubble.js")(Chart);
		__webpack_require__(/*! ./controllers/controller.doughnut */ "./node_modules/chart.js/src/controllers/controller.doughnut.js")(Chart);
		__webpack_require__(/*! ./controllers/controller.line */ "./node_modules/chart.js/src/controllers/controller.line.js")(Chart);
		__webpack_require__(/*! ./controllers/controller.polarArea */ "./node_modules/chart.js/src/controllers/controller.polarArea.js")(Chart);
		__webpack_require__(/*! ./controllers/controller.radar */ "./node_modules/chart.js/src/controllers/controller.radar.js")(Chart);
		__webpack_require__(/*! ./controllers/controller.scatter */ "./node_modules/chart.js/src/controllers/controller.scatter.js")(Chart);
		
		__webpack_require__(/*! ./charts/Chart.Bar */ "./node_modules/chart.js/src/charts/Chart.Bar.js")(Chart);
		__webpack_require__(/*! ./charts/Chart.Bubble */ "./node_modules/chart.js/src/charts/Chart.Bubble.js")(Chart);
		__webpack_require__(/*! ./charts/Chart.Doughnut */ "./node_modules/chart.js/src/charts/Chart.Doughnut.js")(Chart);
		__webpack_require__(/*! ./charts/Chart.Line */ "./node_modules/chart.js/src/charts/Chart.Line.js")(Chart);
		__webpack_require__(/*! ./charts/Chart.PolarArea */ "./node_modules/chart.js/src/charts/Chart.PolarArea.js")(Chart);
		__webpack_require__(/*! ./charts/Chart.Radar */ "./node_modules/chart.js/src/charts/Chart.Radar.js")(Chart);
		__webpack_require__(/*! ./charts/Chart.Scatter */ "./node_modules/chart.js/src/charts/Chart.Scatter.js")(Chart);

// Loading built-in plugins
		var plugins = __webpack_require__(/*! ./plugins */ "./node_modules/chart.js/src/plugins/index.js");
		for(var k in plugins) {
			if(plugins.hasOwnProperty(k)) {
				Chart.plugins.register(plugins[k]);
			}
		}
		
		Chart.platform.initialize();
		
		module.exports = Chart;
		if(typeof window !== 'undefined') {
			window.Chart = Chart;
		}

// DEPRECATIONS
		
		/**
		 * Provided for backward compatibility, not available anymore
		 * @namespace Chart.Legend
		 * @deprecated since version 2.1.5
		 * @todo remove at version 3
		 * @private
		 */
		Chart.Legend = plugins.legend._element;
		
		/**
		 * Provided for backward compatibility, not available anymore
		 * @namespace Chart.Title
		 * @deprecated since version 2.1.5
		 * @todo remove at version 3
		 * @private
		 */
		Chart.Title = plugins.title._element;
		
		/**
		 * Provided for backward compatibility, use Chart.plugins instead
		 * @namespace Chart.pluginService
		 * @deprecated since version 2.1.5
		 * @todo remove at version 3
		 * @private
		 */
		Chart.pluginService = Chart.plugins;
		
		/**
		 * Provided for backward compatibility, inheriting from Chart.PlugingBase has no
		 * effect, instead simply create/register plugins via plain JavaScript objects.
		 * @interface Chart.PluginBase
		 * @deprecated since version 2.5.0
		 * @todo remove at version 3
		 * @private
		 */
		Chart.PluginBase = Chart.Element.extend({});
		
		/**
		 * Provided for backward compatibility, use Chart.helpers.canvas instead.
		 * @namespace Chart.canvasHelpers
		 * @deprecated since version 2.6.0
		 * @todo remove at version 3
		 * @private
		 */
		Chart.canvasHelpers = Chart.helpers.canvas;
		
		/**
		 * Provided for backward compatibility, use Chart.layouts instead.
		 * @namespace Chart.layoutService
		 * @deprecated since version 2.8.0
		 * @todo remove at version 3
		 * @private
		 */
		Chart.layoutService = Chart.layouts;
		
		
		/***/
	}),
	
	/***/ "./node_modules/chart.js/src/charts/Chart.Bar.js":
	/*!*******************************************************!*\
  !*** ./node_modules/chart.js/src/charts/Chart.Bar.js ***!
  \*******************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		module.exports = function(Chart) {
			
			Chart.Bar = function(context, config) {
				config.type = 'bar';
				
				return new Chart(context, config);
			};
			
		};
		
		
		/***/
	}),
	
	/***/ "./node_modules/chart.js/src/charts/Chart.Bubble.js":
	/*!**********************************************************!*\
  !*** ./node_modules/chart.js/src/charts/Chart.Bubble.js ***!
  \**********************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		module.exports = function(Chart) {
			
			Chart.Bubble = function(context, config) {
				config.type = 'bubble';
				return new Chart(context, config);
			};
			
		};
		
		
		/***/
	}),
	
	/***/ "./node_modules/chart.js/src/charts/Chart.Doughnut.js":
	/*!************************************************************!*\
  !*** ./node_modules/chart.js/src/charts/Chart.Doughnut.js ***!
  \************************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		module.exports = function(Chart) {
			
			Chart.Doughnut = function(context, config) {
				config.type = 'doughnut';
				
				return new Chart(context, config);
			};
			
		};
		
		
		/***/
	}),
	
	/***/ "./node_modules/chart.js/src/charts/Chart.Line.js":
	/*!********************************************************!*\
  !*** ./node_modules/chart.js/src/charts/Chart.Line.js ***!
  \********************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		module.exports = function(Chart) {
			
			Chart.Line = function(context, config) {
				config.type = 'line';
				
				return new Chart(context, config);
			};
			
		};
		
		
		/***/
	}),
	
	/***/ "./node_modules/chart.js/src/charts/Chart.PolarArea.js":
	/*!*************************************************************!*\
  !*** ./node_modules/chart.js/src/charts/Chart.PolarArea.js ***!
  \*************************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		module.exports = function(Chart) {
			
			Chart.PolarArea = function(context, config) {
				config.type = 'polarArea';
				
				return new Chart(context, config);
			};
			
		};
		
		
		/***/
	}),
	
	/***/ "./node_modules/chart.js/src/charts/Chart.Radar.js":
	/*!*********************************************************!*\
  !*** ./node_modules/chart.js/src/charts/Chart.Radar.js ***!
  \*********************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		module.exports = function(Chart) {
			
			Chart.Radar = function(context, config) {
				config.type = 'radar';
				
				return new Chart(context, config);
			};
			
		};
		
		
		/***/
	}),
	
	/***/ "./node_modules/chart.js/src/charts/Chart.Scatter.js":
	/*!***********************************************************!*\
  !*** ./node_modules/chart.js/src/charts/Chart.Scatter.js ***!
  \***********************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		module.exports = function(Chart) {
			Chart.Scatter = function(context, config) {
				config.type = 'scatter';
				return new Chart(context, config);
			};
		};
		
		
		/***/
	}),
	
	/***/ "./node_modules/chart.js/src/controllers/controller.bar.js":
	/*!*****************************************************************!*\
  !*** ./node_modules/chart.js/src/controllers/controller.bar.js ***!
  \*****************************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		var defaults = __webpack_require__(/*! ../core/core.defaults */ "./node_modules/chart.js/src/core/core.defaults.js");
		var elements = __webpack_require__(/*! ../elements/index */ "./node_modules/chart.js/src/elements/index.js");
		var helpers = __webpack_require__(/*! ../helpers/index */ "./node_modules/chart.js/src/helpers/index.js");
		
		defaults._set('bar', {
			hover: {
				mode: 'label'
			},
			
			scales: {
				xAxes: [{
					type: 'category',
					
					// Specific to Bar Controller
					categoryPercentage: 0.8,
					barPercentage: 0.9,
					
					// offset settings
					offset: true,
					
					// grid line settings
					gridLines: {
						offsetGridLines: true
					}
				}],
				
				yAxes: [{
					type: 'linear'
				}]
			}
		});
		
		defaults._set('horizontalBar', {
			hover: {
				mode: 'index',
				axis: 'y'
			},
			
			scales: {
				xAxes: [{
					type: 'linear',
					position: 'bottom'
				}],
				
				yAxes: [{
					position: 'left',
					type: 'category',
					
					// Specific to Horizontal Bar Controller
					categoryPercentage: 0.8,
					barPercentage: 0.9,
					
					// offset settings
					offset: true,
					
					// grid line settings
					gridLines: {
						offsetGridLines: true
					}
				}]
			},
			
			elements: {
				rectangle: {
					borderSkipped: 'left'
				}
			},
			
			tooltips: {
				callbacks: {
					title: function(item, data) {
						// Pick first xLabel for now
						var title = '';
						
						if(item.length > 0) {
							if(item[0].yLabel) {
								title = item[0].yLabel;
							} else if(data.labels.length > 0 && item[0].index < data.labels.length) {
								title = data.labels[item[0].index];
							}
						}
						
						return title;
					},
					
					label: function(item, data) {
						var datasetLabel = data.datasets[item.datasetIndex].label || '';
						return datasetLabel + ': ' + item.xLabel;
					}
				},
				mode: 'index',
				axis: 'y'
			}
		});
		
		/**
		 * Computes the "optimal" sample size to maintain bars equally sized while preventing overlap.
		 * @private
		 */
		function computeMinSampleSize(scale, pixels) {
			var min = scale.isHorizontal() ? scale.width : scale.height;
			var ticks = scale.getTicks();
			var prev, curr, i, ilen;
			
			for(i = 1, ilen = pixels.length; i < ilen; ++i) {
				min = Math.min(min, pixels[i] - pixels[i - 1]);
			}
			
			for(i = 0, ilen = ticks.length; i < ilen; ++i) {
				curr = scale.getPixelForTick(i);
				min = i > 0 ? Math.min(min, curr - prev) : min;
				prev = curr;
			}
			
			return min;
		}
		
		/**
		 * Computes an "ideal" category based on the absolute bar thickness or, if undefined or null,
		 * uses the smallest interval (see computeMinSampleSize) that prevents bar overlapping. This
		 * mode currently always generates bars equally sized (until we introduce scriptable options?).
		 * @private
		 */
		function computeFitCategoryTraits(index, ruler, options) {
			var thickness = options.barThickness;
			var count = ruler.stackCount;
			var curr = ruler.pixels[index];
			var size, ratio;
			
			if(helpers.isNullOrUndef(thickness)) {
				size = ruler.min * options.categoryPercentage;
				ratio = options.barPercentage;
			} else {
				// When bar thickness is enforced, category and bar percentages are ignored.
				// Note(SB): we could add support for relative bar thickness (e.g. barThickness: '50%')
				// and deprecate barPercentage since this value is ignored when thickness is absolute.
				size = thickness * count;
				ratio = 1;
			}
			
			return {
				chunk: size / count,
				ratio: ratio,
				start: curr - (size / 2)
			};
		}
		
		/**
		 * Computes an "optimal" category that globally arranges bars side by side (no gap when
		 * percentage options are 1), based on the previous and following categories. This mode
		 * generates bars with different widths when data are not evenly spaced.
		 * @private
		 */
		function computeFlexCategoryTraits(index, ruler, options) {
			var pixels = ruler.pixels;
			var curr = pixels[index];
			var prev = index > 0 ? pixels[index - 1] : null;
			var next = index < pixels.length - 1 ? pixels[index + 1] : null;
			var percent = options.categoryPercentage;
			var start, size;
			
			if(prev === null) {
				// first data: its size is double based on the next point or,
				// if it's also the last data, we use the scale end extremity.
				prev = curr - (next === null ? ruler.end - curr : next - curr);
			}
			
			if(next === null) {
				// last data: its size is also double based on the previous point.
				next = curr + curr - prev;
			}
			
			start = curr - ((curr - prev) / 2) * percent;
			size = ((next - prev) / 2) * percent;
			
			return {
				chunk: size / ruler.stackCount,
				ratio: options.barPercentage,
				start: start
			};
		}
		
		module.exports = function(Chart) {
			
			Chart.controllers.bar = Chart.DatasetController.extend({
				
				dataElementType: elements.Rectangle,
				
				initialize: function() {
					var me = this;
					var meta;
					
					Chart.DatasetController.prototype.initialize.apply(me, arguments);
					
					meta = me.getMeta();
					meta.stack = me.getDataset().stack;
					meta.bar = true;
				},
				
				update: function(reset) {
					var me = this;
					var rects = me.getMeta().data;
					var i, ilen;
					
					me._ruler = me.getRuler();
					
					for(i = 0, ilen = rects.length; i < ilen; ++i) {
						me.updateElement(rects[i], i, reset);
					}
				},
				
				updateElement: function(rectangle, index, reset) {
					var me = this;
					var chart = me.chart;
					var meta = me.getMeta();
					var dataset = me.getDataset();
					var custom = rectangle.custom || {};
					var rectangleOptions = chart.options.elements.rectangle;
					
					rectangle._xScale = me.getScaleForId(meta.xAxisID);
					rectangle._yScale = me.getScaleForId(meta.yAxisID);
					rectangle._datasetIndex = me.index;
					rectangle._index = index;
					
					rectangle._model = {
						datasetLabel: dataset.label,
						label: chart.data.labels[index],
						borderSkipped: custom.borderSkipped ? custom.borderSkipped : rectangleOptions.borderSkipped,
						backgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.backgroundColor, index, rectangleOptions.backgroundColor),
						borderColor: custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.borderColor, index, rectangleOptions.borderColor),
						borderWidth: custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.borderWidth, index, rectangleOptions.borderWidth)
					};
					
					me.updateElementGeometry(rectangle, index, reset);
					
					rectangle.pivot();
				},
				
				/**
				 * @private
				 */
				updateElementGeometry: function(rectangle, index, reset) {
					var me = this;
					var model = rectangle._model;
					var vscale = me.getValueScale();
					var base = vscale.getBasePixel();
					var horizontal = vscale.isHorizontal();
					var ruler = me._ruler || me.getRuler();
					var vpixels = me.calculateBarValuePixels(me.index, index);
					var ipixels = me.calculateBarIndexPixels(me.index, index, ruler);
					
					model.horizontal = horizontal;
					model.base = reset ? base : vpixels.base;
					model.x = horizontal ? reset ? base : vpixels.head : ipixels.center;
					model.y = horizontal ? ipixels.center : reset ? base : vpixels.head;
					model.height = horizontal ? ipixels.size : undefined;
					model.width = horizontal ? undefined : ipixels.size;
				},
				
				/**
				 * @private
				 */
				getValueScaleId: function() {
					return this.getMeta().yAxisID;
				},
				
				/**
				 * @private
				 */
				getIndexScaleId: function() {
					return this.getMeta().xAxisID;
				},
				
				/**
				 * @private
				 */
				getValueScale: function() {
					return this.getScaleForId(this.getValueScaleId());
				},
				
				/**
				 * @private
				 */
				getIndexScale: function() {
					return this.getScaleForId(this.getIndexScaleId());
				},
				
				/**
				 * Returns the stacks based on groups and bar visibility.
				 * @param {Number} [last] - The dataset index
				 * @returns {Array} The stack list
				 * @private
				 */
				_getStacks: function(last) {
					var me = this;
					var chart = me.chart;
					var scale = me.getIndexScale();
					var stacked = scale.options.stacked;
					var ilen = last === undefined ? chart.data.datasets.length : last + 1;
					var stacks = [];
					var i, meta;
					
					for(i = 0; i < ilen; ++i) {
						meta = chart.getDatasetMeta(i);
						if(meta.bar && chart.isDatasetVisible(i) &&
							(stacked === false ||
								(stacked === true && stacks.indexOf(meta.stack) === -1) ||
								(stacked === undefined && (meta.stack === undefined || stacks.indexOf(meta.stack) === -1)))) {
							stacks.push(meta.stack);
						}
					}
					
					return stacks;
				},
				
				/**
				 * Returns the effective number of stacks based on groups and bar visibility.
				 * @private
				 */
				getStackCount: function() {
					return this._getStacks().length;
				},
				
				/**
				 * Returns the stack index for the given dataset based on groups and bar visibility.
				 * @param {Number} [datasetIndex] - The dataset index
				 * @param {String} [name] - The stack name to find
				 * @returns {Number} The stack index
				 * @private
				 */
				getStackIndex: function(datasetIndex, name) {
					var stacks = this._getStacks(datasetIndex);
					var index = (name !== undefined)
						? stacks.indexOf(name)
						: -1; // indexOf returns -1 if element is not present
					
					return (index === -1)
						? stacks.length - 1
						: index;
				},
				
				/**
				 * @private
				 */
				getRuler: function() {
					var me = this;
					var scale = me.getIndexScale();
					var stackCount = me.getStackCount();
					var datasetIndex = me.index;
					var isHorizontal = scale.isHorizontal();
					var start = isHorizontal ? scale.left : scale.top;
					var end = start + (isHorizontal ? scale.width : scale.height);
					var pixels = [];
					var i, ilen, min;
					
					for(i = 0, ilen = me.getMeta().data.length; i < ilen; ++i) {
						pixels.push(scale.getPixelForValue(null, i, datasetIndex));
					}
					
					min = helpers.isNullOrUndef(scale.options.barThickness)
						? computeMinSampleSize(scale, pixels)
						: -1;
					
					return {
						min: min,
						pixels: pixels,
						start: start,
						end: end,
						stackCount: stackCount,
						scale: scale
					};
				},
				
				/**
				 * Note: pixel values are not clamped to the scale area.
				 * @private
				 */
				calculateBarValuePixels: function(datasetIndex, index) {
					var me = this;
					var chart = me.chart;
					var meta = me.getMeta();
					var scale = me.getValueScale();
					var datasets = chart.data.datasets;
					var value = scale.getRightValue(datasets[datasetIndex].data[index]);
					var stacked = scale.options.stacked;
					var stack = meta.stack;
					var start = 0;
					var i, imeta, ivalue, base, head, size;
					
					if(stacked || (stacked === undefined && stack !== undefined)) {
						for(i = 0; i < datasetIndex; ++i) {
							imeta = chart.getDatasetMeta(i);
							
							if(imeta.bar &&
								imeta.stack === stack &&
								imeta.controller.getValueScaleId() === scale.id &&
								chart.isDatasetVisible(i)) {
								
								ivalue = scale.getRightValue(datasets[i].data[index]);
								if((value < 0 && ivalue < 0) || (value >= 0 && ivalue > 0)) {
									start += ivalue;
								}
							}
						}
					}
					
					base = scale.getPixelForValue(start);
					head = scale.getPixelForValue(start + value);
					size = (head - base) / 2;
					
					return {
						size: size,
						base: base,
						head: head,
						center: head + size / 2
					};
				},
				
				/**
				 * @private
				 */
				calculateBarIndexPixels: function(datasetIndex, index, ruler) {
					var me = this;
					var options = ruler.scale.options;
					var range = options.barThickness === 'flex'
						? computeFlexCategoryTraits(index, ruler, options)
						: computeFitCategoryTraits(index, ruler, options);
					
					var stackIndex = me.getStackIndex(datasetIndex, me.getMeta().stack);
					var center = range.start + (range.chunk * stackIndex) + (range.chunk / 2);
					var size = Math.min(
						helpers.valueOrDefault(options.maxBarThickness, Infinity),
						range.chunk * range.ratio);
					
					return {
						base: center - size / 2,
						head: center + size / 2,
						center: center,
						size: size
					};
				},
				
				draw: function() {
					var me = this;
					var chart = me.chart;
					var scale = me.getValueScale();
					var rects = me.getMeta().data;
					var dataset = me.getDataset();
					var ilen = rects.length;
					var i = 0;
					
					helpers.canvas.clipArea(chart.ctx, chart.chartArea);
					
					for(; i < ilen; ++i) {
						if(!isNaN(scale.getRightValue(dataset.data[i]))) {
							rects[i].draw();
						}
					}
					
					helpers.canvas.unclipArea(chart.ctx);
				},
			});
			
			Chart.controllers.horizontalBar = Chart.controllers.bar.extend({
				/**
				 * @private
				 */
				getValueScaleId: function() {
					return this.getMeta().xAxisID;
				},
				
				/**
				 * @private
				 */
				getIndexScaleId: function() {
					return this.getMeta().yAxisID;
				}
			});
		};
		
		
		/***/
	}),
	
	/***/ "./node_modules/chart.js/src/controllers/controller.bubble.js":
	/*!********************************************************************!*\
  !*** ./node_modules/chart.js/src/controllers/controller.bubble.js ***!
  \********************************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		var defaults = __webpack_require__(/*! ../core/core.defaults */ "./node_modules/chart.js/src/core/core.defaults.js");
		var elements = __webpack_require__(/*! ../elements/index */ "./node_modules/chart.js/src/elements/index.js");
		var helpers = __webpack_require__(/*! ../helpers/index */ "./node_modules/chart.js/src/helpers/index.js");
		
		defaults._set('bubble', {
			hover: {
				mode: 'single'
			},
			
			scales: {
				xAxes: [{
					type: 'linear', // bubble should probably use a linear scale by default
					position: 'bottom',
					id: 'x-axis-0' // need an ID so datasets can reference the scale
				}],
				yAxes: [{
					type: 'linear',
					position: 'left',
					id: 'y-axis-0'
				}]
			},
			
			tooltips: {
				callbacks: {
					title: function() {
						// Title doesn't make sense for scatter since we format the data as a point
						return '';
					},
					label: function(item, data) {
						var datasetLabel = data.datasets[item.datasetIndex].label || '';
						var dataPoint = data.datasets[item.datasetIndex].data[item.index];
						return datasetLabel + ': (' + item.xLabel + ', ' + item.yLabel + ', ' + dataPoint.r + ')';
					}
				}
			}
		});
		
		
		module.exports = function(Chart) {
			
			Chart.controllers.bubble = Chart.DatasetController.extend({
				/**
				 * @protected
				 */
				dataElementType: elements.Point,
				
				/**
				 * @protected
				 */
				update: function(reset) {
					var me = this;
					var meta = me.getMeta();
					var points = meta.data;
					
					// Update Points
					helpers.each(points, function(point, index) {
						me.updateElement(point, index, reset);
					});
				},
				
				/**
				 * @protected
				 */
				updateElement: function(point, index, reset) {
					var me = this;
					var meta = me.getMeta();
					var custom = point.custom || {};
					var xScale = me.getScaleForId(meta.xAxisID);
					var yScale = me.getScaleForId(meta.yAxisID);
					var options = me._resolveElementOptions(point, index);
					var data = me.getDataset().data[index];
					var dsIndex = me.index;
					
					var x = reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(typeof data === 'object' ? data : NaN, index, dsIndex);
					var y = reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex);
					
					point._xScale = xScale;
					point._yScale = yScale;
					point._options = options;
					point._datasetIndex = dsIndex;
					point._index = index;
					point._model = {
						backgroundColor: options.backgroundColor,
						borderColor: options.borderColor,
						borderWidth: options.borderWidth,
						hitRadius: options.hitRadius,
						pointStyle: options.pointStyle,
						rotation: options.rotation,
						radius: reset ? 0 : options.radius,
						skip: custom.skip || isNaN(x) || isNaN(y),
						x: x,
						y: y,
					};
					
					point.pivot();
				},
				
				/**
				 * @protected
				 */
				setHoverStyle: function(point) {
					var model = point._model;
					var options = point._options;
					point.$previousStyle = {
						backgroundColor: model.backgroundColor,
						borderColor: model.borderColor,
						borderWidth: model.borderWidth,
						radius: model.radius
					};
					model.backgroundColor = helpers.valueOrDefault(options.hoverBackgroundColor, helpers.getHoverColor(options.backgroundColor));
					model.borderColor = helpers.valueOrDefault(options.hoverBorderColor, helpers.getHoverColor(options.borderColor));
					model.borderWidth = helpers.valueOrDefault(options.hoverBorderWidth, options.borderWidth);
					model.radius = options.radius + options.hoverRadius;
				},
				
				/**
				 * @private
				 */
				_resolveElementOptions: function(point, index) {
					var me = this;
					var chart = me.chart;
					var datasets = chart.data.datasets;
					var dataset = datasets[me.index];
					var custom = point.custom || {};
					var options = chart.options.elements.point;
					var resolve = helpers.options.resolve;
					var data = dataset.data[index];
					var values = {};
					var i, ilen, key;
					
					// Scriptable options
					var context = {
						chart: chart,
						dataIndex: index,
						dataset: dataset,
						datasetIndex: me.index
					};
					
					var keys = [
						'backgroundColor',
						'borderColor',
						'borderWidth',
						'hoverBackgroundColor',
						'hoverBorderColor',
						'hoverBorderWidth',
						'hoverRadius',
						'hitRadius',
						'pointStyle',
						'rotation'
					];
					
					for(i = 0, ilen = keys.length; i < ilen; ++i) {
						key = keys[i];
						values[key] = resolve([
							custom[key],
							dataset[key],
							options[key]
						], context, index);
					}
					
					// Custom radius resolution
					values.radius = resolve([
						custom.radius,
						data ? data.r : undefined,
						dataset.radius,
						options.radius
					], context, index);
					return values;
				}
			});
		};
		
		
		/***/
	}),
	
	/***/ "./node_modules/chart.js/src/controllers/controller.doughnut.js":
	/*!**********************************************************************!*\
  !*** ./node_modules/chart.js/src/controllers/controller.doughnut.js ***!
  \**********************************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		var defaults = __webpack_require__(/*! ../core/core.defaults */ "./node_modules/chart.js/src/core/core.defaults.js");
		var elements = __webpack_require__(/*! ../elements/index */ "./node_modules/chart.js/src/elements/index.js");
		var helpers = __webpack_require__(/*! ../helpers/index */ "./node_modules/chart.js/src/helpers/index.js");
		
		defaults._set('doughnut', {
			animation: {
				// Boolean - Whether we animate the rotation of the Doughnut
				animateRotate: true,
				// Boolean - Whether we animate scaling the Doughnut from the centre
				animateScale: false
			},
			hover: {
				mode: 'single'
			},
			legendCallback: function(chart) {
				var text = [];
				text.push('<ul class="' + chart.id + '-legend">');
				
				var data = chart.data;
				var datasets = data.datasets;
				var labels = data.labels;
				
				if(datasets.length) {
					for(var i = 0; i < datasets[0].data.length; ++i) {
						text.push('<li><span style="background-color:' + datasets[0].backgroundColor[i] + '"></span>');
						if(labels[i]) {
							text.push(labels[i]);
						}
						text.push('</li>');
					}
				}
				
				text.push('</ul>');
				return text.join('');
			},
			legend: {
				labels: {
					generateLabels: function(chart) {
						var data = chart.data;
						if(data.labels.length && data.datasets.length) {
							return data.labels.map(function(label, i) {
								var meta = chart.getDatasetMeta(0);
								var ds = data.datasets[0];
								var arc = meta.data[i];
								var custom = arc && arc.custom || {};
								var valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
								var arcOpts = chart.options.elements.arc;
								var fill = custom.backgroundColor ? custom.backgroundColor : valueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);
								var stroke = custom.borderColor ? custom.borderColor : valueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);
								var bw = custom.borderWidth ? custom.borderWidth : valueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);
								
								return {
									text: label,
									fillStyle: fill,
									strokeStyle: stroke,
									lineWidth: bw,
									hidden: isNaN(ds.data[i]) || meta.data[i].hidden,
									
									// Extra data used for toggling the correct item
									index: i
								};
							});
						}
						return [];
					}
				},
				
				onClick: function(e, legendItem) {
					var index = legendItem.index;
					var chart = this.chart;
					var i, ilen, meta;
					
					for(i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
						meta = chart.getDatasetMeta(i);
						// toggle visibility of index if exists
						if(meta.data[index]) {
							meta.data[index].hidden = !meta.data[index].hidden;
						}
					}
					
					chart.update();
				}
			},
			
			// The percentage of the chart that we cut out of the middle.
			cutoutPercentage: 50,
			
			// The rotation of the chart, where the first data arc begins.
			rotation: Math.PI * -0.5,
			
			// The total circumference of the chart.
			circumference: Math.PI * 2.0,
			
			// Need to override these to give a nice default
			tooltips: {
				callbacks: {
					title: function() {
						return '';
					},
					label: function(tooltipItem, data) {
						var dataLabel = data.labels[tooltipItem.index];
						var value = ': ' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];
						
						if(helpers.isArray(dataLabel)) {
							// show value on first line of multiline label
							// need to clone because we are changing the value
							dataLabel = dataLabel.slice();
							dataLabel[0] += value;
						} else {
							dataLabel += value;
						}
						
						return dataLabel;
					}
				}
			}
		});
		
		defaults._set('pie', helpers.clone(defaults.doughnut));
		defaults._set('pie', {
			cutoutPercentage: 0
		});
		
		module.exports = function(Chart) {
			
			Chart.controllers.doughnut = Chart.controllers.pie = Chart.DatasetController.extend({
				
				dataElementType: elements.Arc,
				
				linkScales: helpers.noop,
				
				// Get index of the dataset in relation to the visible datasets. This allows determining the inner and outer radius correctly
				getRingIndex: function(datasetIndex) {
					var ringIndex = 0;
					
					for(var j = 0; j < datasetIndex; ++j) {
						if(this.chart.isDatasetVisible(j)) {
							++ringIndex;
						}
					}
					
					return ringIndex;
				},
				
				update: function(reset) {
					var me = this;
					var chart = me.chart;
					var chartArea = chart.chartArea;
					var opts = chart.options;
					var arcOpts = opts.elements.arc;
					var availableWidth = chartArea.right - chartArea.left - arcOpts.borderWidth;
					var availableHeight = chartArea.bottom - chartArea.top - arcOpts.borderWidth;
					var minSize = Math.min(availableWidth, availableHeight);
					var offset = {x: 0, y: 0};
					var meta = me.getMeta();
					var cutoutPercentage = opts.cutoutPercentage;
					var circumference = opts.circumference;
					
					// If the chart's circumference isn't a full circle, calculate minSize as a ratio of the width/height of the arc
					if(circumference < Math.PI * 2.0) {
						var startAngle = opts.rotation % (Math.PI * 2.0);
						startAngle += Math.PI * 2.0 * (startAngle >= Math.PI ? -1 : startAngle < -Math.PI ? 1 : 0);
						var endAngle = startAngle + circumference;
						var start = {x: Math.cos(startAngle), y: Math.sin(startAngle)};
						var end = {x: Math.cos(endAngle), y: Math.sin(endAngle)};
						var contains0 = (startAngle <= 0 && endAngle >= 0) || (startAngle <= Math.PI * 2.0 && Math.PI * 2.0 <= endAngle);
						var contains90 = (startAngle <= Math.PI * 0.5 && Math.PI * 0.5 <= endAngle) || (startAngle <= Math.PI * 2.5 && Math.PI * 2.5 <= endAngle);
						var contains180 = (startAngle <= -Math.PI && -Math.PI <= endAngle) || (startAngle <= Math.PI && Math.PI <= endAngle);
						var contains270 = (startAngle <= -Math.PI * 0.5 && -Math.PI * 0.5 <= endAngle) || (startAngle <= Math.PI * 1.5 && Math.PI * 1.5 <= endAngle);
						var cutout = cutoutPercentage / 100.0;
						var min = {
							x: contains180 ? -1 : Math.min(start.x * (start.x < 0 ? 1 : cutout), end.x * (end.x < 0 ? 1 : cutout)),
							y: contains270 ? -1 : Math.min(start.y * (start.y < 0 ? 1 : cutout), end.y * (end.y < 0 ? 1 : cutout))
						};
						var max = {
							x: contains0 ? 1 : Math.max(start.x * (start.x > 0 ? 1 : cutout), end.x * (end.x > 0 ? 1 : cutout)),
							y: contains90 ? 1 : Math.max(start.y * (start.y > 0 ? 1 : cutout), end.y * (end.y > 0 ? 1 : cutout))
						};
						var size = {width: (max.x - min.x) * 0.5, height: (max.y - min.y) * 0.5};
						minSize = Math.min(availableWidth / size.width, availableHeight / size.height);
						offset = {x: (max.x + min.x) * -0.5, y: (max.y + min.y) * -0.5};
					}
					
					chart.borderWidth = me.getMaxBorderWidth(meta.data);
					chart.outerRadius = Math.max((minSize - chart.borderWidth) / 2, 0);
					chart.innerRadius = Math.max(cutoutPercentage ? (chart.outerRadius / 100) * (cutoutPercentage) : 0, 0);
					chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();
					chart.offsetX = offset.x * chart.outerRadius;
					chart.offsetY = offset.y * chart.outerRadius;
					
					meta.total = me.calculateTotal();
					
					me.outerRadius = chart.outerRadius - (chart.radiusLength * me.getRingIndex(me.index));
					me.innerRadius = Math.max(me.outerRadius - chart.radiusLength, 0);
					
					helpers.each(meta.data, function(arc, index) {
						me.updateElement(arc, index, reset);
					});
				},
				
				updateElement: function(arc, index, reset) {
					var me = this;
					var chart = me.chart;
					var chartArea = chart.chartArea;
					var opts = chart.options;
					var animationOpts = opts.animation;
					var centerX = (chartArea.left + chartArea.right) / 2;
					var centerY = (chartArea.top + chartArea.bottom) / 2;
					var startAngle = opts.rotation; // non reset case handled later
					var endAngle = opts.rotation; // non reset case handled later
					var dataset = me.getDataset();
					var circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / (2.0 * Math.PI));
					var innerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius;
					var outerRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius;
					var valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
					
					helpers.extend(arc, {
						// Utility
						_datasetIndex: me.index,
						_index: index,
						
						// Desired view properties
						_model: {
							x: centerX + chart.offsetX,
							y: centerY + chart.offsetY,
							startAngle: startAngle,
							endAngle: endAngle,
							circumference: circumference,
							outerRadius: outerRadius,
							innerRadius: innerRadius,
							label: valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])
						}
					});
					
					var model = arc._model;
					
					// Resets the visual styles
					var custom = arc.custom || {};
					var valueOrDefault = helpers.valueAtIndexOrDefault;
					var elementOpts = this.chart.options.elements.arc;
					model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : valueOrDefault(dataset.backgroundColor, index, elementOpts.backgroundColor);
					model.borderColor = custom.borderColor ? custom.borderColor : valueOrDefault(dataset.borderColor, index, elementOpts.borderColor);
					model.borderWidth = custom.borderWidth ? custom.borderWidth : valueOrDefault(dataset.borderWidth, index, elementOpts.borderWidth);
					
					// Set correct angles if not resetting
					if(!reset || !animationOpts.animateRotate) {
						if(index === 0) {
							model.startAngle = opts.rotation;
						} else {
							model.startAngle = me.getMeta().data[index - 1]._model.endAngle;
						}
						
						model.endAngle = model.startAngle + model.circumference;
					}
					
					arc.pivot();
				},
				
				calculateTotal: function() {
					var dataset = this.getDataset();
					var meta = this.getMeta();
					var total = 0;
					var value;
					
					helpers.each(meta.data, function(element, index) {
						value = dataset.data[index];
						if(!isNaN(value) && !element.hidden) {
							total += Math.abs(value);
						}
					});
					
					/* if (total === 0) {
				total = NaN;
			}*/
					
					return total;
				},
				
				calculateCircumference: function(value) {
					var total = this.getMeta().total;
					if(total > 0 && !isNaN(value)) {
						return (Math.PI * 2.0) * (Math.abs(value) / total);
					}
					return 0;
				},
				
				// gets the max border or hover width to properly scale pie charts
				getMaxBorderWidth: function(arcs) {
					var max = 0;
					var index = this.index;
					var length = arcs.length;
					var borderWidth;
					var hoverWidth;
					
					for(var i = 0; i < length; i++) {
						borderWidth = arcs[i]._model ? arcs[i]._model.borderWidth : 0;
						hoverWidth = arcs[i]._chart ? arcs[i]._chart.config.data.datasets[index].hoverBorderWidth : 0;
						
						max = borderWidth > max ? borderWidth : max;
						max = hoverWidth > max ? hoverWidth : max;
					}
					return max;
				}
			});
		};
		
		
		/***/
	}),
	
	/***/ "./node_modules/chart.js/src/controllers/controller.line.js":
	/*!******************************************************************!*\
  !*** ./node_modules/chart.js/src/controllers/controller.line.js ***!
  \******************************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		var defaults = __webpack_require__(/*! ../core/core.defaults */ "./node_modules/chart.js/src/core/core.defaults.js");
		var elements = __webpack_require__(/*! ../elements/index */ "./node_modules/chart.js/src/elements/index.js");
		var helpers = __webpack_require__(/*! ../helpers/index */ "./node_modules/chart.js/src/helpers/index.js");
		
		defaults._set('line', {
			showLines: true,
			spanGaps: false,
			
			hover: {
				mode: 'label'
			},
			
			scales: {
				xAxes: [{
					type: 'category',
					id: 'x-axis-0'
				}],
				yAxes: [{
					type: 'linear',
					id: 'y-axis-0'
				}]
			}
		});
		
		module.exports = function(Chart) {
			
			function lineEnabled(dataset, options) {
				return helpers.valueOrDefault(dataset.showLine, options.showLines);
			}
			
			Chart.controllers.line = Chart.DatasetController.extend({
				
				datasetElementType: elements.Line,
				
				dataElementType: elements.Point,
				
				update: function(reset) {
					var me = this;
					var meta = me.getMeta();
					var line = meta.dataset;
					var points = meta.data || [];
					var options = me.chart.options;
					var lineElementOptions = options.elements.line;
					var scale = me.getScaleForId(meta.yAxisID);
					var i, ilen, custom;
					var dataset = me.getDataset();
					var showLine = lineEnabled(dataset, options);
					
					// Update Line
					if(showLine) {
						custom = line.custom || {};
						
						// Compatibility: If the properties are defined with only the old name, use those values
						if((dataset.tension !== undefined) && (dataset.lineTension === undefined)) {
							dataset.lineTension = dataset.tension;
						}
						
						// Utility
						line._scale = scale;
						line._datasetIndex = me.index;
						// Data
						line._children = points;
						// Model
						line._model = {
							// Appearance
							// The default behavior of lines is to break at null values, according
							// to https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158
							// This option gives lines the ability to span gaps
							spanGaps: dataset.spanGaps ? dataset.spanGaps : options.spanGaps,
							tension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, lineElementOptions.tension),
							backgroundColor: custom.backgroundColor ? custom.backgroundColor : (dataset.backgroundColor || lineElementOptions.backgroundColor),
							borderWidth: custom.borderWidth ? custom.borderWidth : (dataset.borderWidth || lineElementOptions.borderWidth),
							borderColor: custom.borderColor ? custom.borderColor : (dataset.borderColor || lineElementOptions.borderColor),
							borderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : (dataset.borderCapStyle || lineElementOptions.borderCapStyle),
							borderDash: custom.borderDash ? custom.borderDash : (dataset.borderDash || lineElementOptions.borderDash),
							borderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : (dataset.borderDashOffset || lineElementOptions.borderDashOffset),
							borderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : (dataset.borderJoinStyle || lineElementOptions.borderJoinStyle),
							fill: custom.fill ? custom.fill : (dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill),
							steppedLine: custom.steppedLine ? custom.steppedLine : helpers.valueOrDefault(dataset.steppedLine, lineElementOptions.stepped),
							cubicInterpolationMode: custom.cubicInterpolationMode ? custom.cubicInterpolationMode : helpers.valueOrDefault(dataset.cubicInterpolationMode, lineElementOptions.cubicInterpolationMode),
						};
						
						line.pivot();
					}
					
					// Update Points
					for(i = 0, ilen = points.length; i < ilen; ++i) {
						me.updateElement(points[i], i, reset);
					}
					
					if(showLine && line._model.tension !== 0) {
						me.updateBezierControlPoints();
					}
					
					// Now pivot the point for animation
					for(i = 0, ilen = points.length; i < ilen; ++i) {
						points[i].pivot();
					}
				},
				
				getPointBackgroundColor: function(point, index) {
					var backgroundColor = this.chart.options.elements.point.backgroundColor;
					var dataset = this.getDataset();
					var custom = point.custom || {};
					
					if(custom.backgroundColor) {
						backgroundColor = custom.backgroundColor;
					} else if(dataset.pointBackgroundColor) {
						backgroundColor = helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, backgroundColor);
					} else if(dataset.backgroundColor) {
						backgroundColor = dataset.backgroundColor;
					}
					
					return backgroundColor;
				},
				
				getPointBorderColor: function(point, index) {
					var borderColor = this.chart.options.elements.point.borderColor;
					var dataset = this.getDataset();
					var custom = point.custom || {};
					
					if(custom.borderColor) {
						borderColor = custom.borderColor;
					} else if(dataset.pointBorderColor) {
						borderColor = helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, borderColor);
					} else if(dataset.borderColor) {
						borderColor = dataset.borderColor;
					}
					
					return borderColor;
				},
				
				getPointBorderWidth: function(point, index) {
					var borderWidth = this.chart.options.elements.point.borderWidth;
					var dataset = this.getDataset();
					var custom = point.custom || {};
					
					if(!isNaN(custom.borderWidth)) {
						borderWidth = custom.borderWidth;
					} else if(!isNaN(dataset.pointBorderWidth) || helpers.isArray(dataset.pointBorderWidth)) {
						borderWidth = helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, borderWidth);
					} else if(!isNaN(dataset.borderWidth)) {
						borderWidth = dataset.borderWidth;
					}
					
					return borderWidth;
				},
				
				getPointRotation: function(point, index) {
					var pointRotation = this.chart.options.elements.point.rotation;
					var dataset = this.getDataset();
					var custom = point.custom || {};
					
					if(!isNaN(custom.rotation)) {
						pointRotation = custom.rotation;
					} else if(!isNaN(dataset.pointRotation) || helpers.isArray(dataset.pointRotation)) {
						pointRotation = helpers.valueAtIndexOrDefault(dataset.pointRotation, index, pointRotation);
					}
					return pointRotation;
				},
				
				updateElement: function(point, index, reset) {
					var me = this;
					var meta = me.getMeta();
					var custom = point.custom || {};
					var dataset = me.getDataset();
					var datasetIndex = me.index;
					var value = dataset.data[index];
					var yScale = me.getScaleForId(meta.yAxisID);
					var xScale = me.getScaleForId(meta.xAxisID);
					var pointOptions = me.chart.options.elements.point;
					var x, y;
					
					// Compatibility: If the properties are defined with only the old name, use those values
					if((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {
						dataset.pointRadius = dataset.radius;
					}
					if((dataset.hitRadius !== undefined) && (dataset.pointHitRadius === undefined)) {
						dataset.pointHitRadius = dataset.hitRadius;
					}
					
					x = xScale.getPixelForValue(typeof value === 'object' ? value : NaN, index, datasetIndex);
					y = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex);
					
					// Utility
					point._xScale = xScale;
					point._yScale = yScale;
					point._datasetIndex = datasetIndex;
					point._index = index;
					
					// Desired view properties
					point._model = {
						x: x,
						y: y,
						skip: custom.skip || isNaN(x) || isNaN(y),
						// Appearance
						radius: custom.radius || helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointOptions.radius),
						pointStyle: custom.pointStyle || helpers.valueAtIndexOrDefault(dataset.pointStyle, index, pointOptions.pointStyle),
						rotation: me.getPointRotation(point, index),
						backgroundColor: me.getPointBackgroundColor(point, index),
						borderColor: me.getPointBorderColor(point, index),
						borderWidth: me.getPointBorderWidth(point, index),
						tension: meta.dataset._model ? meta.dataset._model.tension : 0,
						steppedLine: meta.dataset._model ? meta.dataset._model.steppedLine : false,
						// Tooltip
						hitRadius: custom.hitRadius || helpers.valueAtIndexOrDefault(dataset.pointHitRadius, index, pointOptions.hitRadius)
					};
				},
				
				calculatePointY: function(value, index, datasetIndex) {
					var me = this;
					var chart = me.chart;
					var meta = me.getMeta();
					var yScale = me.getScaleForId(meta.yAxisID);
					var sumPos = 0;
					var sumNeg = 0;
					var i, ds, dsMeta;
					
					if(yScale.options.stacked) {
						for(i = 0; i < datasetIndex; i++) {
							ds = chart.data.datasets[i];
							dsMeta = chart.getDatasetMeta(i);
							if(dsMeta.type === 'line' && dsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i)) {
								var stackedRightValue = Number(yScale.getRightValue(ds.data[index]));
								if(stackedRightValue < 0) {
									sumNeg += stackedRightValue || 0;
								} else {
									sumPos += stackedRightValue || 0;
								}
							}
						}
						
						var rightValue = Number(yScale.getRightValue(value));
						if(rightValue < 0) {
							return yScale.getPixelForValue(sumNeg + rightValue);
						}
						return yScale.getPixelForValue(sumPos + rightValue);
					}
					
					return yScale.getPixelForValue(value);
				},
				
				updateBezierControlPoints: function() {
					var me = this;
					var meta = me.getMeta();
					var area = me.chart.chartArea;
					var points = (meta.data || []);
					var i, ilen, point, model, controlPoints;
					
					// Only consider points that are drawn in case the spanGaps option is used
					if(meta.dataset._model.spanGaps) {
						points = points.filter(function(pt) {
							return !pt._model.skip;
						});
					}
					
					function capControlPoint(pt, min, max) {
						return Math.max(Math.min(pt, max), min);
					}
					
					if(meta.dataset._model.cubicInterpolationMode === 'monotone') {
						helpers.splineCurveMonotone(points);
					} else {
						for(i = 0, ilen = points.length; i < ilen; ++i) {
							point = points[i];
							model = point._model;
							controlPoints = helpers.splineCurve(
								helpers.previousItem(points, i)._model,
								model,
								helpers.nextItem(points, i)._model,
								meta.dataset._model.tension
							);
							model.controlPointPreviousX = controlPoints.previous.x;
							model.controlPointPreviousY = controlPoints.previous.y;
							model.controlPointNextX = controlPoints.next.x;
							model.controlPointNextY = controlPoints.next.y;
						}
					}
					
					if(me.chart.options.elements.line.capBezierPoints) {
						for(i = 0, ilen = points.length; i < ilen; ++i) {
							model = points[i]._model;
							model.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);
							model.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);
							model.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);
							model.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);
						}
					}
				},
				
				draw: function() {
					var me = this;
					var chart = me.chart;
					var meta = me.getMeta();
					var points = meta.data || [];
					var area = chart.chartArea;
					var ilen = points.length;
					var halfBorderWidth;
					var i = 0;
					
					if(lineEnabled(me.getDataset(), chart.options)) {
						halfBorderWidth = (meta.dataset._model.borderWidth || 0) / 2;
						
						helpers.canvas.clipArea(chart.ctx, {
							left: area.left,
							right: area.right,
							top: area.top - halfBorderWidth,
							bottom: area.bottom + halfBorderWidth
						});
						
						meta.dataset.draw();
						
						helpers.canvas.unclipArea(chart.ctx);
					}
					
					// Draw the points
					for(; i < ilen; ++i) {
						points[i].draw(area);
					}
				},
				
				setHoverStyle: function(element) {
					// Point
					var dataset = this.chart.data.datasets[element._datasetIndex];
					var index = element._index;
					var custom = element.custom || {};
					var model = element._model;
					
					element.$previousStyle = {
						backgroundColor: model.backgroundColor,
						borderColor: model.borderColor,
						borderWidth: model.borderWidth,
						radius: model.radius
					};
					
					model.backgroundColor = custom.hoverBackgroundColor || helpers.valueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
					model.borderColor = custom.hoverBorderColor || helpers.valueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));
					model.borderWidth = custom.hoverBorderWidth || helpers.valueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);
					model.radius = custom.hoverRadius || helpers.valueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);
				},
			});
		};
		
		
		/***/
	}),
	
	/***/ "./node_modules/chart.js/src/controllers/controller.polarArea.js":
	/*!***********************************************************************!*\
  !*** ./node_modules/chart.js/src/controllers/controller.polarArea.js ***!
  \***********************************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		var defaults = __webpack_require__(/*! ../core/core.defaults */ "./node_modules/chart.js/src/core/core.defaults.js");
		var elements = __webpack_require__(/*! ../elements/index */ "./node_modules/chart.js/src/elements/index.js");
		var helpers = __webpack_require__(/*! ../helpers/index */ "./node_modules/chart.js/src/helpers/index.js");
		
		defaults._set('polarArea', {
			scale: {
				type: 'radialLinear',
				angleLines: {
					display: false
				},
				gridLines: {
					circular: true
				},
				pointLabels: {
					display: false
				},
				ticks: {
					beginAtZero: true
				}
			},
			
			// Boolean - Whether to animate the rotation of the chart
			animation: {
				animateRotate: true,
				animateScale: true
			},
			
			startAngle: -0.5 * Math.PI,
			legendCallback: function(chart) {
				var text = [];
				text.push('<ul class="' + chart.id + '-legend">');
				
				var data = chart.data;
				var datasets = data.datasets;
				var labels = data.labels;
				
				if(datasets.length) {
					for(var i = 0; i < datasets[0].data.length; ++i) {
						text.push('<li><span style="background-color:' + datasets[0].backgroundColor[i] + '"></span>');
						if(labels[i]) {
							text.push(labels[i]);
						}
						text.push('</li>');
					}
				}
				
				text.push('</ul>');
				return text.join('');
			},
			legend: {
				labels: {
					generateLabels: function(chart) {
						var data = chart.data;
						if(data.labels.length && data.datasets.length) {
							return data.labels.map(function(label, i) {
								var meta = chart.getDatasetMeta(0);
								var ds = data.datasets[0];
								var arc = meta.data[i];
								var custom = arc.custom || {};
								var valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
								var arcOpts = chart.options.elements.arc;
								var fill = custom.backgroundColor ? custom.backgroundColor : valueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);
								var stroke = custom.borderColor ? custom.borderColor : valueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);
								var bw = custom.borderWidth ? custom.borderWidth : valueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);
								
								return {
									text: label,
									fillStyle: fill,
									strokeStyle: stroke,
									lineWidth: bw,
									hidden: isNaN(ds.data[i]) || meta.data[i].hidden,
									
									// Extra data used for toggling the correct item
									index: i
								};
							});
						}
						return [];
					}
				},
				
				onClick: function(e, legendItem) {
					var index = legendItem.index;
					var chart = this.chart;
					var i, ilen, meta;
					
					for(i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
						meta = chart.getDatasetMeta(i);
						meta.data[index].hidden = !meta.data[index].hidden;
					}
					
					chart.update();
				}
			},
			
			// Need to override these to give a nice default
			tooltips: {
				callbacks: {
					title: function() {
						return '';
					},
					label: function(item, data) {
						return data.labels[item.index] + ': ' + item.yLabel;
					}
				}
			}
		});
		
		module.exports = function(Chart) {
			
			Chart.controllers.polarArea = Chart.DatasetController.extend({
				
				dataElementType: elements.Arc,
				
				linkScales: helpers.noop,
				
				update: function(reset) {
					var me = this;
					var dataset = me.getDataset();
					var meta = me.getMeta();
					var start = me.chart.options.startAngle || 0;
					var starts = me._starts = [];
					var angles = me._angles = [];
					var i, ilen, angle;
					
					me._updateRadius();
					
					meta.count = me.countVisibleElements();
					
					for(i = 0, ilen = dataset.data.length; i < ilen; i++) {
						starts[i] = start;
						angle = me._computeAngle(i);
						angles[i] = angle;
						start += angle;
					}
					
					helpers.each(meta.data, function(arc, index) {
						me.updateElement(arc, index, reset);
					});
				},
				
				/**
				 * @private
				 */
				_updateRadius: function() {
					var me = this;
					var chart = me.chart;
					var chartArea = chart.chartArea;
					var opts = chart.options;
					var arcOpts = opts.elements.arc;
					var minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
					
					chart.outerRadius = Math.max((minSize - arcOpts.borderWidth / 2) / 2, 0);
					chart.innerRadius = Math.max(opts.cutoutPercentage ? (chart.outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);
					chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();
					
					me.outerRadius = chart.outerRadius - (chart.radiusLength * me.index);
					me.innerRadius = me.outerRadius - chart.radiusLength;
				},
				
				updateElement: function(arc, index, reset) {
					var me = this;
					var chart = me.chart;
					var dataset = me.getDataset();
					var opts = chart.options;
					var animationOpts = opts.animation;
					var scale = chart.scale;
					var labels = chart.data.labels;
					
					var centerX = scale.xCenter;
					var centerY = scale.yCenter;
					
					// var negHalfPI = -0.5 * Math.PI;
					var datasetStartAngle = opts.startAngle;
					var distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
					var startAngle = me._starts[index];
					var endAngle = startAngle + (arc.hidden ? 0 : me._angles[index]);
					
					var resetRadius = animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
					
					helpers.extend(arc, {
						// Utility
						_datasetIndex: me.index,
						_index: index,
						_scale: scale,
						
						// Desired view properties
						_model: {
							x: centerX,
							y: centerY,
							innerRadius: 0,
							outerRadius: reset ? resetRadius : distance,
							startAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,
							endAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,
							label: helpers.valueAtIndexOrDefault(labels, index, labels[index])
						}
					});
					
					// Apply border and fill style
					var elementOpts = this.chart.options.elements.arc;
					var custom = arc.custom || {};
					var valueOrDefault = helpers.valueAtIndexOrDefault;
					var model = arc._model;
					
					model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : valueOrDefault(dataset.backgroundColor, index, elementOpts.backgroundColor);
					model.borderColor = custom.borderColor ? custom.borderColor : valueOrDefault(dataset.borderColor, index, elementOpts.borderColor);
					model.borderWidth = custom.borderWidth ? custom.borderWidth : valueOrDefault(dataset.borderWidth, index, elementOpts.borderWidth);
					
					arc.pivot();
				},
				
				countVisibleElements: function() {
					var dataset = this.getDataset();
					var meta = this.getMeta();
					var count = 0;
					
					helpers.each(meta.data, function(element, index) {
						if(!isNaN(dataset.data[index]) && !element.hidden) {
							count++;
						}
					});
					
					return count;
				},
				
				/**
				 * @private
				 */
				_computeAngle: function(index) {
					var me = this;
					var count = this.getMeta().count;
					var dataset = me.getDataset();
					var meta = me.getMeta();
					
					if(isNaN(dataset.data[index]) || meta.data[index].hidden) {
						return 0;
					}
					
					// Scriptable options
					var context = {
						chart: me.chart,
						dataIndex: index,
						dataset: dataset,
						datasetIndex: me.index
					};
					
					return helpers.options.resolve([
						me.chart.options.elements.arc.angle,
						(2 * Math.PI) / count
					], context, index);
				}
			});
		};
		
		
		/***/
	}),
	
	/***/ "./node_modules/chart.js/src/controllers/controller.radar.js":
	/*!*******************************************************************!*\
  !*** ./node_modules/chart.js/src/controllers/controller.radar.js ***!
  \*******************************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		var defaults = __webpack_require__(/*! ../core/core.defaults */ "./node_modules/chart.js/src/core/core.defaults.js");
		var elements = __webpack_require__(/*! ../elements/index */ "./node_modules/chart.js/src/elements/index.js");
		var helpers = __webpack_require__(/*! ../helpers/index */ "./node_modules/chart.js/src/helpers/index.js");
		
		defaults._set('radar', {
			scale: {
				type: 'radialLinear'
			},
			elements: {
				line: {
					tension: 0 // no bezier in radar
				}
			}
		});
		
		module.exports = function(Chart) {
			
			Chart.controllers.radar = Chart.DatasetController.extend({
				
				datasetElementType: elements.Line,
				
				dataElementType: elements.Point,
				
				linkScales: helpers.noop,
				
				update: function(reset) {
					var me = this;
					var meta = me.getMeta();
					var line = meta.dataset;
					var points = meta.data;
					var custom = line.custom || {};
					var dataset = me.getDataset();
					var lineElementOptions = me.chart.options.elements.line;
					var scale = me.chart.scale;
					
					// Compatibility: If the properties are defined with only the old name, use those values
					if((dataset.tension !== undefined) && (dataset.lineTension === undefined)) {
						dataset.lineTension = dataset.tension;
					}
					
					helpers.extend(meta.dataset, {
						// Utility
						_datasetIndex: me.index,
						_scale: scale,
						// Data
						_children: points,
						_loop: true,
						// Model
						_model: {
							// Appearance
							tension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, lineElementOptions.tension),
							backgroundColor: custom.backgroundColor ? custom.backgroundColor : (dataset.backgroundColor || lineElementOptions.backgroundColor),
							borderWidth: custom.borderWidth ? custom.borderWidth : (dataset.borderWidth || lineElementOptions.borderWidth),
							borderColor: custom.borderColor ? custom.borderColor : (dataset.borderColor || lineElementOptions.borderColor),
							fill: custom.fill ? custom.fill : (dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill),
							borderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : (dataset.borderCapStyle || lineElementOptions.borderCapStyle),
							borderDash: custom.borderDash ? custom.borderDash : (dataset.borderDash || lineElementOptions.borderDash),
							borderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : (dataset.borderDashOffset || lineElementOptions.borderDashOffset),
							borderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : (dataset.borderJoinStyle || lineElementOptions.borderJoinStyle),
						}
					});
					
					meta.dataset.pivot();
					
					// Update Points
					helpers.each(points, function(point, index) {
						me.updateElement(point, index, reset);
					}, me);
					
					// Update bezier control points
					me.updateBezierControlPoints();
				},
				updateElement: function(point, index, reset) {
					var me = this;
					var custom = point.custom || {};
					var dataset = me.getDataset();
					var scale = me.chart.scale;
					var pointElementOptions = me.chart.options.elements.point;
					var pointPosition = scale.getPointPositionForValue(index, dataset.data[index]);
					
					// Compatibility: If the properties are defined with only the old name, use those values
					if((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {
						dataset.pointRadius = dataset.radius;
					}
					if((dataset.hitRadius !== undefined) && (dataset.pointHitRadius === undefined)) {
						dataset.pointHitRadius = dataset.hitRadius;
					}
					
					helpers.extend(point, {
						// Utility
						_datasetIndex: me.index,
						_index: index,
						_scale: scale,
						
						// Desired view properties
						_model: {
							x: reset ? scale.xCenter : pointPosition.x, // value not used in dataset scale, but we want a consistent API between scales
							y: reset ? scale.yCenter : pointPosition.y,
							
							// Appearance
							tension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, me.chart.options.elements.line.tension),
							radius: custom.radius ? custom.radius : helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius),
							backgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor),
							borderColor: custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor),
							borderWidth: custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth),
							pointStyle: custom.pointStyle ? custom.pointStyle : helpers.valueAtIndexOrDefault(dataset.pointStyle, index, pointElementOptions.pointStyle),
							rotation: custom.rotation ? custom.rotation : helpers.valueAtIndexOrDefault(dataset.pointRotation, index, pointElementOptions.rotation),
							
							// Tooltip
							hitRadius: custom.hitRadius ? custom.hitRadius : helpers.valueAtIndexOrDefault(dataset.pointHitRadius, index, pointElementOptions.hitRadius)
						}
					});
					
					point._model.skip = custom.skip ? custom.skip : (isNaN(point._model.x) || isNaN(point._model.y));
				},
				updateBezierControlPoints: function() {
					var chartArea = this.chart.chartArea;
					var meta = this.getMeta();
					
					helpers.each(meta.data, function(point, index) {
						var model = point._model;
						var controlPoints = helpers.splineCurve(
							helpers.previousItem(meta.data, index, true)._model,
							model,
							helpers.nextItem(meta.data, index, true)._model,
							model.tension
						);
						
						// Prevent the bezier going outside of the bounds of the graph
						model.controlPointPreviousX = Math.max(Math.min(controlPoints.previous.x, chartArea.right), chartArea.left);
						model.controlPointPreviousY = Math.max(Math.min(controlPoints.previous.y, chartArea.bottom), chartArea.top);
						
						model.controlPointNextX = Math.max(Math.min(controlPoints.next.x, chartArea.right), chartArea.left);
						model.controlPointNextY = Math.max(Math.min(controlPoints.next.y, chartArea.bottom), chartArea.top);
						
						// Now pivot the point for animation
						point.pivot();
					});
				},
				
				setHoverStyle: function(point) {
					// Point
					var dataset = this.chart.data.datasets[point._datasetIndex];
					var custom = point.custom || {};
					var index = point._index;
					var model = point._model;
					
					point.$previousStyle = {
						backgroundColor: model.backgroundColor,
						borderColor: model.borderColor,
						borderWidth: model.borderWidth,
						radius: model.radius
					};
					
					model.radius = custom.hoverRadius ? custom.hoverRadius : helpers.valueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);
					model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.valueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
					model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.valueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));
					model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.valueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);
				},
			});
		};
		
		
		/***/
	}),
	
	/***/ "./node_modules/chart.js/src/controllers/controller.scatter.js":
	/*!*********************************************************************!*\
  !*** ./node_modules/chart.js/src/controllers/controller.scatter.js ***!
  \*********************************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		var defaults = __webpack_require__(/*! ../core/core.defaults */ "./node_modules/chart.js/src/core/core.defaults.js");
		
		defaults._set('scatter', {
			hover: {
				mode: 'single'
			},
			
			scales: {
				xAxes: [{
					id: 'x-axis-1',    // need an ID so datasets can reference the scale
					type: 'linear',    // scatter should not use a category axis
					position: 'bottom'
				}],
				yAxes: [{
					id: 'y-axis-1',
					type: 'linear',
					position: 'left'
				}]
			},
			
			showLines: false,
			
			tooltips: {
				callbacks: {
					title: function() {
						return '';     // doesn't make sense for scatter since data are formatted as a point
					},
					label: function(item) {
						return '(' + item.xLabel + ', ' + item.yLabel + ')';
					}
				}
			}
		});
		
		module.exports = function(Chart) {
			
			// Scatter charts use line controllers
			Chart.controllers.scatter = Chart.controllers.line;
			
		};
		
		
		/***/
	}),
	
	/***/ "./node_modules/chart.js/src/core/core.animation.js":
	/*!**********************************************************!*\
  !*** ./node_modules/chart.js/src/core/core.animation.js ***!
  \**********************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		var Element = __webpack_require__(/*! ./core.element */ "./node_modules/chart.js/src/core/core.element.js");
		
		var exports = module.exports = Element.extend({
			chart: null, // the animation associated chart instance
			currentStep: 0, // the current animation step
			numSteps: 60, // default number of steps
			easing: '', // the easing to use for this animation
			render: null, // render function used by the animation service
			
			onAnimationProgress: null, // user specified callback to fire on each step of the animation
			onAnimationComplete: null, // user specified callback to fire when the animation finishes
		});

// DEPRECATIONS
		
		/**
		 * Provided for backward compatibility, use Chart.Animation instead
		 * @prop Chart.Animation#animationObject
		 * @deprecated since version 2.6.0
		 * @todo remove at version 3
		 */
		Object.defineProperty(exports.prototype, 'animationObject', {
			get: function() {
				return this;
			}
		});
		
		/**
		 * Provided for backward compatibility, use Chart.Animation#chart instead
		 * @prop Chart.Animation#chartInstance
		 * @deprecated since version 2.6.0
		 * @todo remove at version 3
		 */
		Object.defineProperty(exports.prototype, 'chartInstance', {
			get: function() {
				return this.chart;
			},
			set: function(value) {
				this.chart = value;
			}
		});
		
		
		/***/
	}),
	
	/***/ "./node_modules/chart.js/src/core/core.animations.js":
	/*!***********************************************************!*\
  !*** ./node_modules/chart.js/src/core/core.animations.js ***!
  \***********************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		/* global window: false */
		
		
		var defaults = __webpack_require__(/*! ./core.defaults */ "./node_modules/chart.js/src/core/core.defaults.js");
		var helpers = __webpack_require__(/*! ../helpers/index */ "./node_modules/chart.js/src/helpers/index.js");
		
		defaults._set('global', {
			animation: {
				duration: 1000,
				easing: 'easeOutQuart',
				onProgress: helpers.noop,
				onComplete: helpers.noop
			}
		});
		
		module.exports = {
			frameDuration: 17,
			animations: [],
			dropFrames: 0,
			request: null,
			
			/**
			 * @param {Chart} chart - The chart to animate.
			 * @param {Chart.Animation} animation - The animation that we will animate.
			 * @param {Number} duration - The animation duration in ms.
			 * @param {Boolean} lazy - if true, the chart is not marked as animating to enable more responsive interactions
			 */
			addAnimation: function(chart, animation, duration, lazy) {
				var animations = this.animations;
				var i, ilen;
				
				animation.chart = chart;
				
				if(!lazy) {
					chart.animating = true;
				}
				
				for(i = 0, ilen = animations.length; i < ilen; ++i) {
					if(animations[i].chart === chart) {
						animations[i] = animation;
						return;
					}
				}
				
				animations.push(animation);
				
				// If there are no animations queued, manually kickstart a digest, for lack of a better word
				if(animations.length === 1) {
					this.requestAnimationFrame();
				}
			},
			
			cancelAnimation: function(chart) {
				var index = helpers.findIndex(this.animations, function(animation) {
					return animation.chart === chart;
				});
				
				if(index !== -1) {
					this.animations.splice(index, 1);
					chart.animating = false;
				}
			},
			
			requestAnimationFrame: function() {
				var me = this;
				if(me.request === null) {
					// Skip animation frame requests until the active one is executed.
					// This can happen when processing mouse events, e.g. 'mousemove'
					// and 'mouseout' events will trigger multiple renders.
					me.request = helpers.requestAnimFrame.call(window, function() {
						me.request = null;
						me.startDigest();
					});
				}
			},
			
			/**
			 * @private
			 */
			startDigest: function() {
				var me = this;
				var startTime = Date.now();
				var framesToDrop = 0;
				
				if(me.dropFrames > 1) {
					framesToDrop = Math.floor(me.dropFrames);
					me.dropFrames = me.dropFrames % 1;
				}
				
				me.advance(1 + framesToDrop);
				
				var endTime = Date.now();
				
				me.dropFrames += (endTime - startTime) / me.frameDuration;
				
				// Do we have more stuff to animate?
				if(me.animations.length > 0) {
					me.requestAnimationFrame();
				}
			},
			
			/**
			 * @private
			 */
			advance: function(count) {
				var animations = this.animations;
				var animation, chart;
				var i = 0;
				
				while(i < animations.length) {
					animation = animations[i];
					chart = animation.chart;
					
					animation.currentStep = (animation.currentStep || 0) + count;
					animation.currentStep = Math.min(animation.currentStep, animation.numSteps);
					
					helpers.callback(animation.render, [chart, animation], chart);
					helpers.callback(animation.onAnimationProgress, [animation], chart);
					
					if(animation.currentStep >= animation.numSteps) {
						helpers.callback(animation.onAnimationComplete, [animation], chart);
						chart.animating = false;
						animations.splice(i, 1);
					} else {
						++i;
					}
				}
			}
		};
		
		
		/***/
	}),
	
	/***/ "./node_modules/chart.js/src/core/core.controller.js":
	/*!***********************************************************!*\
  !*** ./node_modules/chart.js/src/core/core.controller.js ***!
  \***********************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		var Animation = __webpack_require__(/*! ./core.animation */ "./node_modules/chart.js/src/core/core.animation.js");
		var animations = __webpack_require__(/*! ./core.animations */ "./node_modules/chart.js/src/core/core.animations.js");
		var defaults = __webpack_require__(/*! ./core.defaults */ "./node_modules/chart.js/src/core/core.defaults.js");
		var helpers = __webpack_require__(/*! ../helpers/index */ "./node_modules/chart.js/src/helpers/index.js");
		var Interaction = __webpack_require__(/*! ./core.interaction */ "./node_modules/chart.js/src/core/core.interaction.js");
		var layouts = __webpack_require__(/*! ./core.layouts */ "./node_modules/chart.js/src/core/core.layouts.js");
		var platform = __webpack_require__(/*! ../platforms/platform */ "./node_modules/chart.js/src/platforms/platform.js");
		var plugins = __webpack_require__(/*! ./core.plugins */ "./node_modules/chart.js/src/core/core.plugins.js");
		var scaleService = __webpack_require__(/*! ../core/core.scaleService */ "./node_modules/chart.js/src/core/core.scaleService.js");
		var Tooltip = __webpack_require__(/*! ./core.tooltip */ "./node_modules/chart.js/src/core/core.tooltip.js");
		
		module.exports = function(Chart) {
			
			// Create a dictionary of chart types, to allow for extension of existing types
			Chart.types = {};
			
			// Store a reference to each instance - allowing us to globally resize chart instances on window resize.
			// Destroy method on the chart will remove the instance of the chart from this reference.
			Chart.instances = {};
			
			// Controllers available for dataset visualization eg. bar, line, slice, etc.
			Chart.controllers = {};
			
			/**
			 * Initializes the given config with global and chart default values.
			 */
			function initConfig(config) {
				config = config || {};
				
				// Do NOT use configMerge() for the data object because this method merges arrays
				// and so would change references to labels and datasets, preventing data updates.
				var data = config.data = config.data || {};
				data.datasets = data.datasets || [];
				data.labels = data.labels || [];
				
				config.options = helpers.configMerge(
					defaults.global,
					defaults[config.type],
					config.options || {});
				
				return config;
			}
			
			/**
			 * Updates the config of the chart
			 * @param chart {Chart} chart to update the options for
			 */
			function updateConfig(chart) {
				var newOptions = chart.options;
				
				helpers.each(chart.scales, function(scale) {
					layouts.removeBox(chart, scale);
				});
				
				newOptions = helpers.configMerge(
					Chart.defaults.global,
					Chart.defaults[chart.config.type],
					newOptions);
				
				chart.options = chart.config.options = newOptions;
				chart.ensureScalesHaveIDs();
				chart.buildOrUpdateScales();
				// Tooltip
				chart.tooltip._options = newOptions.tooltips;
				chart.tooltip.initialize();
			}
			
			function positionIsHorizontal(position) {
				return position === 'top' || position === 'bottom';
			}
			
			helpers.extend(Chart.prototype, /** @lends Chart */ {
				/**
				 * @private
				 */
				construct: function(item, config) {
					var me = this;
					
					config = initConfig(config);
					
					var context = platform.acquireContext(item, config);
					var canvas = context && context.canvas;
					var height = canvas && canvas.height;
					var width = canvas && canvas.width;
					
					me.id = helpers.uid();
					me.ctx = context;
					me.canvas = canvas;
					me.config = config;
					me.width = width;
					me.height = height;
					me.aspectRatio = height ? width / height : null;
					me.options = config.options;
					me._bufferedRender = false;
					
					/**
					 * Provided for backward compatibility, Chart and Chart.Controller have been merged,
					 * the "instance" still need to be defined since it might be called from plugins.
					 * @prop Chart#chart
					 * @deprecated since version 2.6.0
					 * @todo remove at version 3
					 * @private
					 */
					me.chart = me;
					me.controller = me; // chart.chart.controller #inception
					
					// Add the chart instance to the global namespace
					Chart.instances[me.id] = me;
					
					// Define alias to the config data: `chart.data === chart.config.data`
					Object.defineProperty(me, 'data', {
						get: function() {
							return me.config.data;
						},
						set: function(value) {
							me.config.data = value;
						}
					});
					
					if(!context || !canvas) {
						// The given item is not a compatible context2d element, let's return before finalizing
						// the chart initialization but after setting basic chart / controller properties that
						// can help to figure out that the chart is not valid (e.g chart.canvas !== null);
						// https://github.com/chartjs/Chart.js/issues/2807
						console.error("Failed to create chart: can't acquire context from the given item");
						return;
					}
					
					me.initialize();
					me.update();
				},
				
				/**
				 * @private
				 */
				initialize: function() {
					var me = this;
					
					// Before init plugin notification
					plugins.notify(me, 'beforeInit');
					
					helpers.retinaScale(me, me.options.devicePixelRatio);
					
					me.bindEvents();
					
					if(me.options.responsive) {
						// Initial resize before chart draws (must be silent to preserve initial animations).
						me.resize(true);
					}
					
					// Make sure scales have IDs and are built before we build any controllers.
					me.ensureScalesHaveIDs();
					me.buildOrUpdateScales();
					me.initToolTip();
					
					// After init plugin notification
					plugins.notify(me, 'afterInit');
					
					return me;
				},
				
				clear: function() {
					helpers.canvas.clear(this);
					return this;
				},
				
				stop: function() {
					// Stops any current animation loop occurring
					animations.cancelAnimation(this);
					return this;
				},
				
				resize: function(silent) {
					var me = this;
					var options = me.options;
					var canvas = me.canvas;
					var aspectRatio = (options.maintainAspectRatio && me.aspectRatio) || null;
					
					// the canvas render width and height will be casted to integers so make sure that
					// the canvas display style uses the same integer values to avoid blurring effect.
					
					// Set to 0 instead of canvas.size because the size defaults to 300x150 if the element is collapsed
					var newWidth = Math.max(0, Math.floor(helpers.getMaximumWidth(canvas)));
					var newHeight = Math.max(0, Math.floor(aspectRatio ? newWidth / aspectRatio : helpers.getMaximumHeight(canvas)));
					
					if(me.width === newWidth && me.height === newHeight) {
						return;
					}
					
					canvas.width = me.width = newWidth;
					canvas.height = me.height = newHeight;
					canvas.style.width = newWidth + 'px';
					canvas.style.height = newHeight + 'px';
					
					helpers.retinaScale(me, options.devicePixelRatio);
					
					if(!silent) {
						// Notify any plugins about the resize
						var newSize = {width: newWidth, height: newHeight};
						plugins.notify(me, 'resize', [newSize]);
						
						// Notify of resize
						if(me.options.onResize) {
							me.options.onResize(me, newSize);
						}
						
						me.stop();
						me.update({
							duration: me.options.responsiveAnimationDuration
						});
					}
				},
				
				ensureScalesHaveIDs: function() {
					var options = this.options;
					var scalesOptions = options.scales || {};
					var scaleOptions = options.scale;
					
					helpers.each(scalesOptions.xAxes, function(xAxisOptions, index) {
						xAxisOptions.id = xAxisOptions.id || ('x-axis-' + index);
					});
					
					helpers.each(scalesOptions.yAxes, function(yAxisOptions, index) {
						yAxisOptions.id = yAxisOptions.id || ('y-axis-' + index);
					});
					
					if(scaleOptions) {
						scaleOptions.id = scaleOptions.id || 'scale';
					}
				},
				
				/**
				 * Builds a map of scale ID to scale object for future lookup.
				 */
				buildOrUpdateScales: function() {
					var me = this;
					var options = me.options;
					var scales = me.scales || {};
					var items = [];
					var updated = Object.keys(scales).reduce(function(obj, id) {
						obj[id] = false;
						return obj;
					}, {});
					
					if(options.scales) {
						items = items.concat(
							(options.scales.xAxes || []).map(function(xAxisOptions) {
								return {options: xAxisOptions, dtype: 'category', dposition: 'bottom'};
							}),
							(options.scales.yAxes || []).map(function(yAxisOptions) {
								return {options: yAxisOptions, dtype: 'linear', dposition: 'left'};
							})
						);
					}
					
					if(options.scale) {
						items.push({
							options: options.scale,
							dtype: 'radialLinear',
							isDefault: true,
							dposition: 'chartArea'
						});
					}
					
					helpers.each(items, function(item) {
						var scaleOptions = item.options;
						var id = scaleOptions.id;
						var scaleType = helpers.valueOrDefault(scaleOptions.type, item.dtype);
						
						if(positionIsHorizontal(scaleOptions.position) !== positionIsHorizontal(item.dposition)) {
							scaleOptions.position = item.dposition;
						}
						
						updated[id] = true;
						var scale = null;
						if(id in scales && scales[id].type === scaleType) {
							scale = scales[id];
							scale.options = scaleOptions;
							scale.ctx = me.ctx;
							scale.chart = me;
						} else {
							var scaleClass = scaleService.getScaleConstructor(scaleType);
							if(!scaleClass) {
								return;
							}
							scale = new scaleClass({
								id: id,
								type: scaleType,
								options: scaleOptions,
								ctx: me.ctx,
								chart: me
							});
							scales[scale.id] = scale;
						}
						
						scale.mergeTicksOptions();
						
						// TODO(SB): I think we should be able to remove this custom case (options.scale)
						// and consider it as a regular scale part of the "scales"" map only! This would
						// make the logic easier and remove some useless? custom code.
						if(item.isDefault) {
							me.scale = scale;
						}
					});
					// clear up discarded scales
					helpers.each(updated, function(hasUpdated, id) {
						if(!hasUpdated) {
							delete scales[id];
						}
					});
					
					me.scales = scales;
					
					scaleService.addScalesToLayout(this);
				},
				
				buildOrUpdateControllers: function() {
					var me = this;
					var types = [];
					var newControllers = [];
					
					helpers.each(me.data.datasets, function(dataset, datasetIndex) {
						var meta = me.getDatasetMeta(datasetIndex);
						var type = dataset.type || me.config.type;
						
						if(meta.type && meta.type !== type) {
							me.destroyDatasetMeta(datasetIndex);
							meta = me.getDatasetMeta(datasetIndex);
						}
						meta.type = type;
						
						types.push(meta.type);
						
						if(meta.controller) {
							meta.controller.updateIndex(datasetIndex);
							meta.controller.linkScales();
						} else {
							var ControllerClass = Chart.controllers[meta.type];
							if(ControllerClass === undefined) {
								throw new Error('"' + meta.type + '" is not a chart type.');
							}
							
							meta.controller = new ControllerClass(me, datasetIndex);
							newControllers.push(meta.controller);
						}
					}, me);
					
					return newControllers;
				},
				
				/**
				 * Reset the elements of all datasets
				 * @private
				 */
				resetElements: function() {
					var me = this;
					helpers.each(me.data.datasets, function(dataset, datasetIndex) {
						me.getDatasetMeta(datasetIndex).controller.reset();
					}, me);
				},
				
				/**
				 * Resets the chart back to it's state before the initial animation
				 */
				reset: function() {
					this.resetElements();
					this.tooltip.initialize();
				},
				
				update: function(config) {
					var me = this;
					
					if(!config || typeof config !== 'object') {
						// backwards compatibility
						config = {
							duration: config,
							lazy: arguments[1]
						};
					}
					
					updateConfig(me);
					
					// plugins options references might have change, let's invalidate the cache
					// https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167
					plugins._invalidate(me);
					
					if(plugins.notify(me, 'beforeUpdate') === false) {
						return;
					}
					
					// In case the entire data object changed
					me.tooltip._data = me.data;
					
					// Make sure dataset controllers are updated and new controllers are reset
					var newControllers = me.buildOrUpdateControllers();
					
					// Make sure all dataset controllers have correct meta data counts
					helpers.each(me.data.datasets, function(dataset, datasetIndex) {
						me.getDatasetMeta(datasetIndex).controller.buildOrUpdateElements();
					}, me);
					
					me.updateLayout();
					
					// Can only reset the new controllers after the scales have been updated
					if(me.options.animation && me.options.animation.duration) {
						helpers.each(newControllers, function(controller) {
							controller.reset();
						});
					}
					
					me.updateDatasets();
					
					// Need to reset tooltip in case it is displayed with elements that are removed
					// after update.
					me.tooltip.initialize();
					
					// Last active contains items that were previously in the tooltip.
					// When we reset the tooltip, we need to clear it
					me.lastActive = [];
					
					// Do this before render so that any plugins that need final scale updates can use it
					plugins.notify(me, 'afterUpdate');
					
					if(me._bufferedRender) {
						me._bufferedRequest = {
							duration: config.duration,
							easing: config.easing,
							lazy: config.lazy
						};
					} else {
						me.render(config);
					}
				},
				
				/**
				 * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`
				 * hook, in which case, plugins will not be called on `afterLayout`.
				 * @private
				 */
				updateLayout: function() {
					var me = this;
					
					if(plugins.notify(me, 'beforeLayout') === false) {
						return;
					}
					
					layouts.update(this, this.width, this.height);
					
					/**
					 * Provided for backward compatibility, use `afterLayout` instead.
					 * @method IPlugin#afterScaleUpdate
					 * @deprecated since version 2.5.0
					 * @todo remove at version 3
					 * @private
					 */
					plugins.notify(me, 'afterScaleUpdate');
					plugins.notify(me, 'afterLayout');
				},
				
				/**
				 * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`
				 * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.
				 * @private
				 */
				updateDatasets: function() {
					var me = this;
					
					if(plugins.notify(me, 'beforeDatasetsUpdate') === false) {
						return;
					}
					
					for(var i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
						me.updateDataset(i);
					}
					
					plugins.notify(me, 'afterDatasetsUpdate');
				},
				
				/**
				 * Updates dataset at index unless a plugin returns `false` to the `beforeDatasetUpdate`
				 * hook, in which case, plugins will not be called on `afterDatasetUpdate`.
				 * @private
				 */
				updateDataset: function(index) {
					var me = this;
					var meta = me.getDatasetMeta(index);
					var args = {
						meta: meta,
						index: index
					};
					
					if(plugins.notify(me, 'beforeDatasetUpdate', [args]) === false) {
						return;
					}
					
					meta.controller.update();
					
					plugins.notify(me, 'afterDatasetUpdate', [args]);
				},
				
				render: function(config) {
					var me = this;
					
					if(!config || typeof config !== 'object') {
						// backwards compatibility
						config = {
							duration: config,
							lazy: arguments[1]
						};
					}
					
					var duration = config.duration;
					var lazy = config.lazy;
					
					if(plugins.notify(me, 'beforeRender') === false) {
						return;
					}
					
					var animationOptions = me.options.animation;
					var onComplete = function(animation) {
						plugins.notify(me, 'afterRender');
						helpers.callback(animationOptions && animationOptions.onComplete, [animation], me);
					};
					
					if(animationOptions && ((typeof duration !== 'undefined' && duration !== 0) || (typeof duration === 'undefined' && animationOptions.duration !== 0))) {
						var animation = new Animation({
							numSteps: (duration || animationOptions.duration) / 16.66, // 60 fps
							easing: config.easing || animationOptions.easing,
							
							render: function(chart, animationObject) {
								var easingFunction = helpers.easing.effects[animationObject.easing];
								var currentStep = animationObject.currentStep;
								var stepDecimal = currentStep / animationObject.numSteps;
								
								chart.draw(easingFunction(stepDecimal), stepDecimal, currentStep);
							},
							
							onAnimationProgress: animationOptions.onProgress,
							onAnimationComplete: onComplete
						});
						
						animations.addAnimation(me, animation, duration, lazy);
					} else {
						me.draw();
						
						// See https://github.com/chartjs/Chart.js/issues/3781
						onComplete(new Animation({numSteps: 0, chart: me}));
					}
					
					return me;
				},
				
				draw: function(easingValue) {
					var me = this;
					
					me.clear();
					
					if(helpers.isNullOrUndef(easingValue)) {
						easingValue = 1;
					}
					
					me.transition(easingValue);
					
					if(me.width <= 0 || me.height <= 0) {
						return;
					}
					
					if(plugins.notify(me, 'beforeDraw', [easingValue]) === false) {
						return;
					}
					
					// Draw all the scales
					helpers.each(me.boxes, function(box) {
						box.draw(me.chartArea);
					}, me);
					
					if(me.scale) {
						me.scale.draw();
					}
					
					me.drawDatasets(easingValue);
					me._drawTooltip(easingValue);
					
					plugins.notify(me, 'afterDraw', [easingValue]);
				},
				
				/**
				 * @private
				 */
				transition: function(easingValue) {
					var me = this;
					
					for(var i = 0, ilen = (me.data.datasets || []).length; i < ilen; ++i) {
						if(me.isDatasetVisible(i)) {
							me.getDatasetMeta(i).controller.transition(easingValue);
						}
					}
					
					me.tooltip.transition(easingValue);
				},
				
				/**
				 * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`
				 * hook, in which case, plugins will not be called on `afterDatasetsDraw`.
				 * @private
				 */
				drawDatasets: function(easingValue) {
					var me = this;
					
					if(plugins.notify(me, 'beforeDatasetsDraw', [easingValue]) === false) {
						return;
					}
					
					// Draw datasets reversed to support proper line stacking
					for(var i = (me.data.datasets || []).length - 1; i >= 0; --i) {
						if(me.isDatasetVisible(i)) {
							me.drawDataset(i, easingValue);
						}
					}
					
					plugins.notify(me, 'afterDatasetsDraw', [easingValue]);
				},
				
				/**
				 * Draws dataset at index unless a plugin returns `false` to the `beforeDatasetDraw`
				 * hook, in which case, plugins will not be called on `afterDatasetDraw`.
				 * @private
				 */
				drawDataset: function(index, easingValue) {
					var me = this;
					var meta = me.getDatasetMeta(index);
					var args = {
						meta: meta,
						index: index,
						easingValue: easingValue
					};
					
					if(plugins.notify(me, 'beforeDatasetDraw', [args]) === false) {
						return;
					}
					
					meta.controller.draw(easingValue);
					
					plugins.notify(me, 'afterDatasetDraw', [args]);
				},
				
				/**
				 * Draws tooltip unless a plugin returns `false` to the `beforeTooltipDraw`
				 * hook, in which case, plugins will not be called on `afterTooltipDraw`.
				 * @private
				 */
				_drawTooltip: function(easingValue) {
					var me = this;
					var tooltip = me.tooltip;
					var args = {
						tooltip: tooltip,
						easingValue: easingValue
					};
					
					if(plugins.notify(me, 'beforeTooltipDraw', [args]) === false) {
						return;
					}
					
					tooltip.draw();
					
					plugins.notify(me, 'afterTooltipDraw', [args]);
				},
				
				// Get the single element that was clicked on
				// @return : An object containing the dataset index and element index of the matching element. Also contains the rectangle that was draw
				getElementAtEvent: function(e) {
					return Interaction.modes.single(this, e);
				},
				
				getElementsAtEvent: function(e) {
					return Interaction.modes.label(this, e, {intersect: true});
				},
				
				getElementsAtXAxis: function(e) {
					return Interaction.modes['x-axis'](this, e, {intersect: true});
				},
				
				getElementsAtEventForMode: function(e, mode, options) {
					var method = Interaction.modes[mode];
					if(typeof method === 'function') {
						return method(this, e, options);
					}
					
					return [];
				},
				
				getDatasetAtEvent: function(e) {
					return Interaction.modes.dataset(this, e, {intersect: true});
				},
				
				getDatasetMeta: function(datasetIndex) {
					var me = this;
					var dataset = me.data.datasets[datasetIndex];
					if(!dataset._meta) {
						dataset._meta = {};
					}
					
					var meta = dataset._meta[me.id];
					if(!meta) {
						meta = dataset._meta[me.id] = {
							type: null,
							data: [],
							dataset: null,
							controller: null,
							hidden: null,			// See isDatasetVisible() comment
							xAxisID: null,
							yAxisID: null
						};
					}
					
					return meta;
				},
				
				getVisibleDatasetCount: function() {
					var count = 0;
					for(var i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
						if(this.isDatasetVisible(i)) {
							count++;
						}
					}
					return count;
				},
				
				isDatasetVisible: function(datasetIndex) {
					var meta = this.getDatasetMeta(datasetIndex);
					
					// meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,
					// the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.
					return typeof meta.hidden === 'boolean' ? !meta.hidden : !this.data.datasets[datasetIndex].hidden;
				},
				
				generateLegend: function() {
					return this.options.legendCallback(this);
				},
				
				/**
				 * @private
				 */
				destroyDatasetMeta: function(datasetIndex) {
					var id = this.id;
					var dataset = this.data.datasets[datasetIndex];
					var meta = dataset._meta && dataset._meta[id];
					
					if(meta) {
						meta.controller.destroy();
						delete dataset._meta[id];
					}
				},
				
				destroy: function() {
					var me = this;
					var canvas = me.canvas;
					var i, ilen;
					
					me.stop();
					
					// dataset controllers need to cleanup associated data
					for(i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
						me.destroyDatasetMeta(i);
					}
					
					if(canvas) {
						me.unbindEvents();
						helpers.canvas.clear(me);
						platform.releaseContext(me.ctx);
						me.canvas = null;
						me.ctx = null;
					}
					
					plugins.notify(me, 'destroy');
					
					delete Chart.instances[me.id];
				},
				
				toBase64Image: function() {
					return this.canvas.toDataURL.apply(this.canvas, arguments);
				},
				
				initToolTip: function() {
					var me = this;
					me.tooltip = new Tooltip({
						_chart: me,
						_chartInstance: me, // deprecated, backward compatibility
						_data: me.data,
						_options: me.options.tooltips
					}, me);
				},
				
				/**
				 * @private
				 */
				bindEvents: function() {
					var me = this;
					var listeners = me._listeners = {};
					var listener = function() {
						me.eventHandler.apply(me, arguments);
					};
					
					helpers.each(me.options.events, function(type) {
						platform.addEventListener(me, type, listener);
						listeners[type] = listener;
					});
					
					// Elements used to detect size change should not be injected for non responsive charts.
					// See https://github.com/chartjs/Chart.js/issues/2210
					if(me.options.responsive) {
						listener = function() {
							me.resize();
						};
						
						platform.addEventListener(me, 'resize', listener);
						listeners.resize = listener;
					}
				},
				
				/**
				 * @private
				 */
				unbindEvents: function() {
					var me = this;
					var listeners = me._listeners;
					if(!listeners) {
						return;
					}
					
					delete me._listeners;
					helpers.each(listeners, function(listener, type) {
						platform.removeEventListener(me, type, listener);
					});
				},
				
				updateHoverStyle: function(elements, mode, enabled) {
					var method = enabled ? 'setHoverStyle' : 'removeHoverStyle';
					var element, i, ilen;
					
					for(i = 0, ilen = elements.length; i < ilen; ++i) {
						element = elements[i];
						if(element) {
							this.getDatasetMeta(element._datasetIndex).controller[method](element);
						}
					}
				},
				
				/**
				 * @private
				 */
				eventHandler: function(e) {
					var me = this;
					var tooltip = me.tooltip;
					
					if(plugins.notify(me, 'beforeEvent', [e]) === false) {
						return;
					}
					
					// Buffer any update calls so that renders do not occur
					me._bufferedRender = true;
					me._bufferedRequest = null;
					
					var changed = me.handleEvent(e);
					// for smooth tooltip animations issue #4989
					// the tooltip should be the source of change
					// Animation check workaround:
					// tooltip._start will be null when tooltip isn't animating
					if(tooltip) {
						changed = tooltip._start
							? tooltip.handleEvent(e)
							: changed | tooltip.handleEvent(e);
					}
					
					plugins.notify(me, 'afterEvent', [e]);
					
					var bufferedRequest = me._bufferedRequest;
					if(bufferedRequest) {
						// If we have an update that was triggered, we need to do a normal render
						me.render(bufferedRequest);
					} else if(changed && !me.animating) {
						// If entering, leaving, or changing elements, animate the change via pivot
						me.stop();
						
						// We only need to render at this point. Updating will cause scales to be
						// recomputed generating flicker & using more memory than necessary.
						me.render({
							duration: me.options.hover.animationDuration,
							lazy: true
						});
					}
					
					me._bufferedRender = false;
					me._bufferedRequest = null;
					
					return me;
				},
				
				/**
				 * Handle an event
				 * @private
				 * @param {IEvent} event the event to handle
				 * @return {Boolean} true if the chart needs to re-render
				 */
				handleEvent: function(e) {
					var me = this;
					var options = me.options || {};
					var hoverOptions = options.hover;
					var changed = false;
					
					me.lastActive = me.lastActive || [];
					
					// Find Active Elements for hover and tooltips
					if(e.type === 'mouseout') {
						me.active = [];
					} else {
						me.active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);
					}
					
					// Invoke onHover hook
					// Need to call with native event here to not break backwards compatibility
					helpers.callback(options.onHover || options.hover.onHover, [e.native, me.active], me);
					
					if(e.type === 'mouseup' || e.type === 'click') {
						if(options.onClick) {
							// Use e.native here for backwards compatibility
							options.onClick.call(me, e.native, me.active);
						}
					}
					
					// Remove styling for last active (even if it may still be active)
					if(me.lastActive.length) {
						me.updateHoverStyle(me.lastActive, hoverOptions.mode, false);
					}
					
					// Built in hover styling
					if(me.active.length && hoverOptions.mode) {
						me.updateHoverStyle(me.active, hoverOptions.mode, true);
					}
					
					changed = !helpers.arrayEquals(me.active, me.lastActive);
					
					// Remember Last Actives
					me.lastActive = me.active;
					
					return changed;
				}
			});
			
			/**
			 * Provided for backward compatibility, use Chart instead.
			 * @class Chart.Controller
			 * @deprecated since version 2.6.0
			 * @todo remove at version 3
			 * @private
			 */
			Chart.Controller = Chart;
		};
		
		
		/***/
	}),
	
	/***/ "./node_modules/chart.js/src/core/core.datasetController.js":
	/*!******************************************************************!*\
  !*** ./node_modules/chart.js/src/core/core.datasetController.js ***!
  \******************************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		var helpers = __webpack_require__(/*! ../helpers/index */ "./node_modules/chart.js/src/helpers/index.js");
		
		module.exports = function(Chart) {
			
			var arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];
			
			/**
			 * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',
			 * 'unshift') and notify the listener AFTER the array has been altered. Listeners are
			 * called on the 'onData*' callbacks (e.g. onDataPush, etc.) with same arguments.
			 */
			function listenArrayEvents(array, listener) {
				if(array._chartjs) {
					array._chartjs.listeners.push(listener);
					return;
				}
				
				Object.defineProperty(array, '_chartjs', {
					configurable: true,
					enumerable: false,
					value: {
						listeners: [listener]
					}
				});
				
				arrayEvents.forEach(function(key) {
					var method = 'onData' + key.charAt(0).toUpperCase() + key.slice(1);
					var base = array[key];
					
					Object.defineProperty(array, key, {
						configurable: true,
						enumerable: false,
						value: function() {
							var args = Array.prototype.slice.call(arguments);
							var res = base.apply(this, args);
							
							helpers.each(array._chartjs.listeners, function(object) {
								if(typeof object[method] === 'function') {
									object[method].apply(object, args);
								}
							});
							
							return res;
						}
					});
				});
			}
			
			/**
			 * Removes the given array event listener and cleanup extra attached properties (such as
			 * the _chartjs stub and overridden methods) if array doesn't have any more listeners.
			 */
			function unlistenArrayEvents(array, listener) {
				var stub = array._chartjs;
				if(!stub) {
					return;
				}
				
				var listeners = stub.listeners;
				var index = listeners.indexOf(listener);
				if(index !== -1) {
					listeners.splice(index, 1);
				}
				
				if(listeners.length > 0) {
					return;
				}
				
				arrayEvents.forEach(function(key) {
					delete array[key];
				});
				
				delete array._chartjs;
			}
			
			// Base class for all dataset controllers (line, bar, etc)
			Chart.DatasetController = function(chart, datasetIndex) {
				this.initialize(chart, datasetIndex);
			};
			
			helpers.extend(Chart.DatasetController.prototype, {
				
				/**
				 * Element type used to generate a meta dataset (e.g. Chart.element.Line).
				 * @type {Chart.core.element}
				 */
				datasetElementType: null,
				
				/**
				 * Element type used to generate a meta data (e.g. Chart.element.Point).
				 * @type {Chart.core.element}
				 */
				dataElementType: null,
				
				initialize: function(chart, datasetIndex) {
					var me = this;
					me.chart = chart;
					me.index = datasetIndex;
					me.linkScales();
					me.addElements();
				},
				
				updateIndex: function(datasetIndex) {
					this.index = datasetIndex;
				},
				
				linkScales: function() {
					var me = this;
					var meta = me.getMeta();
					var dataset = me.getDataset();
					
					if(meta.xAxisID === null || !(meta.xAxisID in me.chart.scales)) {
						meta.xAxisID = dataset.xAxisID || me.chart.options.scales.xAxes[0].id;
					}
					if(meta.yAxisID === null || !(meta.yAxisID in me.chart.scales)) {
						meta.yAxisID = dataset.yAxisID || me.chart.options.scales.yAxes[0].id;
					}
				},
				
				getDataset: function() {
					return this.chart.data.datasets[this.index];
				},
				
				getMeta: function() {
					return this.chart.getDatasetMeta(this.index);
				},
				
				getScaleForId: function(scaleID) {
					return this.chart.scales[scaleID];
				},
				
				reset: function() {
					this.update(true);
				},
				
				/**
				 * @private
				 */
				destroy: function() {
					if(this._data) {
						unlistenArrayEvents(this._data, this);
					}
				},
				
				createMetaDataset: function() {
					var me = this;
					var type = me.datasetElementType;
					return type && new type({
						_chart: me.chart,
						_datasetIndex: me.index
					});
				},
				
				createMetaData: function(index) {
					var me = this;
					var type = me.dataElementType;
					return type && new type({
						_chart: me.chart,
						_datasetIndex: me.index,
						_index: index
					});
				},
				
				addElements: function() {
					var me = this;
					var meta = me.getMeta();
					var data = me.getDataset().data || [];
					var metaData = meta.data;
					var i, ilen;
					
					for(i = 0, ilen = data.length; i < ilen; ++i) {
						metaData[i] = metaData[i] || me.createMetaData(i);
					}
					
					meta.dataset = meta.dataset || me.createMetaDataset();
				},
				
				addElementAndReset: function(index) {
					var element = this.createMetaData(index);
					this.getMeta().data.splice(index, 0, element);
					this.updateElement(element, index, true);
				},
				
				buildOrUpdateElements: function() {
					var me = this;
					var dataset = me.getDataset();
					var data = dataset.data || (dataset.data = []);
					
					// In order to correctly handle data addition/deletion animation (an thus simulate
					// real-time charts), we need to monitor these data modifications and synchronize
					// the internal meta data accordingly.
					if(me._data !== data) {
						if(me._data) {
							// This case happens when the user replaced the data array instance.
							unlistenArrayEvents(me._data, me);
						}
						
						listenArrayEvents(data, me);
						me._data = data;
					}
					
					// Re-sync meta data in case the user replaced the data array or if we missed
					// any updates and so make sure that we handle number of datapoints changing.
					me.resyncElements();
				},
				
				update: helpers.noop,
				
				transition: function(easingValue) {
					var meta = this.getMeta();
					var elements = meta.data || [];
					var ilen = elements.length;
					var i = 0;
					
					for(; i < ilen; ++i) {
						elements[i].transition(easingValue);
					}
					
					if(meta.dataset) {
						meta.dataset.transition(easingValue);
					}
				},
				
				draw: function() {
					var meta = this.getMeta();
					var elements = meta.data || [];
					var ilen = elements.length;
					var i = 0;
					
					if(meta.dataset) {
						meta.dataset.draw();
					}
					
					for(; i < ilen; ++i) {
						elements[i].draw();
					}
				},
				
				removeHoverStyle: function(element) {
					helpers.merge(element._model, element.$previousStyle || {});
					delete element.$previousStyle;
				},
				
				setHoverStyle: function(element) {
					var dataset = this.chart.data.datasets[element._datasetIndex];
					var index = element._index;
					var custom = element.custom || {};
					var valueOrDefault = helpers.valueAtIndexOrDefault;
					var getHoverColor = helpers.getHoverColor;
					var model = element._model;
					
					element.$previousStyle = {
						backgroundColor: model.backgroundColor,
						borderColor: model.borderColor,
						borderWidth: model.borderWidth
					};
					
					model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : valueOrDefault(dataset.hoverBackgroundColor, index, getHoverColor(model.backgroundColor));
					model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : valueOrDefault(dataset.hoverBorderColor, index, getHoverColor(model.borderColor));
					model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : valueOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);
				},
				
				/**
				 * @private
				 */
				resyncElements: function() {
					var me = this;
					var meta = me.getMeta();
					var data = me.getDataset().data;
					var numMeta = meta.data.length;
					var numData = data.length;
					
					if(numData < numMeta) {
						meta.data.splice(numData, numMeta - numData);
					} else if(numData > numMeta) {
						me.insertElements(numMeta, numData - numMeta);
					}
				},
				
				/**
				 * @private
				 */
				insertElements: function(start, count) {
					for(var i = 0; i < count; ++i) {
						this.addElementAndReset(start + i);
					}
				},
				
				/**
				 * @private
				 */
				onDataPush: function() {
					this.insertElements(this.getDataset().data.length - 1, arguments.length);
				},
				
				/**
				 * @private
				 */
				onDataPop: function() {
					this.getMeta().data.pop();
				},
				
				/**
				 * @private
				 */
				onDataShift: function() {
					this.getMeta().data.shift();
				},
				
				/**
				 * @private
				 */
				onDataSplice: function(start, count) {
					this.getMeta().data.splice(start, count);
					this.insertElements(start, arguments.length - 2);
				},
				
				/**
				 * @private
				 */
				onDataUnshift: function() {
					this.insertElements(0, arguments.length);
				}
			});
			
			Chart.DatasetController.extend = helpers.inherits;
		};
		
		
		/***/
	}),
	
	/***/ "./node_modules/chart.js/src/core/core.defaults.js":
	/*!*********************************************************!*\
  !*** ./node_modules/chart.js/src/core/core.defaults.js ***!
  \*********************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		var helpers = __webpack_require__(/*! ../helpers/index */ "./node_modules/chart.js/src/helpers/index.js");
		
		module.exports = {
			/**
			 * @private
			 */
			_set: function(scope, values) {
				return helpers.merge(this[scope] || (this[scope] = {}), values);
			}
		};
		
		
		/***/
	}),
	
	/***/ "./node_modules/chart.js/src/core/core.element.js":
	/*!********************************************************!*\
  !*** ./node_modules/chart.js/src/core/core.element.js ***!
  \********************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		var color = __webpack_require__(/*! chartjs-color */ "./node_modules/chartjs-color/index.js");
		var helpers = __webpack_require__(/*! ../helpers/index */ "./node_modules/chart.js/src/helpers/index.js");
		
		function interpolate(start, view, model, ease) {
			var keys = Object.keys(model);
			var i, ilen, key, actual, origin, target, type, c0, c1;
			
			for(i = 0, ilen = keys.length; i < ilen; ++i) {
				key = keys[i];
				
				target = model[key];
				
				// if a value is added to the model after pivot() has been called, the view
				// doesn't contain it, so let's initialize the view to the target value.
				if(!view.hasOwnProperty(key)) {
					view[key] = target;
				}
				
				actual = view[key];
				
				if(actual === target || key[0] === '_') {
					continue;
				}
				
				if(!start.hasOwnProperty(key)) {
					start[key] = actual;
				}
				
				origin = start[key];
				
				type = typeof target;
				
				if(type === typeof origin) {
					if(type === 'string') {
						c0 = color(origin);
						if(c0.valid) {
							c1 = color(target);
							if(c1.valid) {
								view[key] = c1.mix(c0, ease).rgbString();
								continue;
							}
						}
					} else if(type === 'number' && isFinite(origin) && isFinite(target)) {
						view[key] = origin + (target - origin) * ease;
						continue;
					}
				}
				
				view[key] = target;
			}
		}
		
		var Element = function(configuration) {
			helpers.extend(this, configuration);
			this.initialize.apply(this, arguments);
		};
		
		helpers.extend(Element.prototype, {
			
			initialize: function() {
				this.hidden = false;
			},
			
			pivot: function() {
				var me = this;
				if(!me._view) {
					me._view = helpers.clone(me._model);
				}
				me._start = {};
				return me;
			},
			
			transition: function(ease) {
				var me = this;
				var model = me._model;
				var start = me._start;
				var view = me._view;
				
				// No animation -> No Transition
				if(!model || ease === 1) {
					me._view = model;
					me._start = null;
					return me;
				}
				
				if(!view) {
					view = me._view = {};
				}
				
				if(!start) {
					start = me._start = {};
				}
				
				interpolate(start, view, model, ease);
				
				return me;
			},
			
			tooltipPosition: function() {
				return {
					x: this._model.x,
					y: this._model.y
				};
			},
			
			hasValue: function() {
				return helpers.isNumber(this._model.x) && helpers.isNumber(this._model.y);
			}
		});
		
		Element.extend = helpers.inherits;
		
		module.exports = Element;
		
		
		/***/
	}),
	
	/***/ "./node_modules/chart.js/src/core/core.helpers.js":
	/*!********************************************************!*\
  !*** ./node_modules/chart.js/src/core/core.helpers.js ***!
  \********************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		/* global window: false */
		/* global document: false */
		
		
		var color = __webpack_require__(/*! chartjs-color */ "./node_modules/chartjs-color/index.js");
		var defaults = __webpack_require__(/*! ./core.defaults */ "./node_modules/chart.js/src/core/core.defaults.js");
		var helpers = __webpack_require__(/*! ../helpers/index */ "./node_modules/chart.js/src/helpers/index.js");
		var scaleService = __webpack_require__(/*! ../core/core.scaleService */ "./node_modules/chart.js/src/core/core.scaleService.js");
		
		module.exports = function() {
			
			// -- Basic js utility methods
			
			helpers.configMerge = function(/* objects ... */) {
				return helpers.merge(helpers.clone(arguments[0]), [].slice.call(arguments, 1), {
					merger: function(key, target, source, options) {
						var tval = target[key] || {};
						var sval = source[key];
						
						if(key === 'scales') {
							// scale config merging is complex. Add our own function here for that
							target[key] = helpers.scaleMerge(tval, sval);
						} else if(key === 'scale') {
							// used in polar area & radar charts since there is only one scale
							target[key] = helpers.merge(tval, [scaleService.getScaleDefaults(sval.type), sval]);
						} else {
							helpers._merger(key, target, source, options);
						}
					}
				});
			};
			
			helpers.scaleMerge = function(/* objects ... */) {
				return helpers.merge(helpers.clone(arguments[0]), [].slice.call(arguments, 1), {
					merger: function(key, target, source, options) {
						if(key === 'xAxes' || key === 'yAxes') {
							var slen = source[key].length;
							var i, type, scale;
							
							if(!target[key]) {
								target[key] = [];
							}
							
							for(i = 0; i < slen; ++i) {
								scale = source[key][i];
								type = helpers.valueOrDefault(scale.type, key === 'xAxes' ? 'category' : 'linear');
								
								if(i >= target[key].length) {
									target[key].push({});
								}
								
								if(!target[key][i].type || (scale.type && scale.type !== target[key][i].type)) {
									// new/untyped scale or type changed: let's apply the new defaults
									// then merge source scale to correctly overwrite the defaults.
									helpers.merge(target[key][i], [scaleService.getScaleDefaults(type), scale]);
								} else {
									// scales type are the same
									helpers.merge(target[key][i], scale);
								}
							}
						} else {
							helpers._merger(key, target, source, options);
						}
					}
				});
			};
			
			helpers.where = function(collection, filterCallback) {
				if(helpers.isArray(collection) && Array.prototype.filter) {
					return collection.filter(filterCallback);
				}
				var filtered = [];
				
				helpers.each(collection, function(item) {
					if(filterCallback(item)) {
						filtered.push(item);
					}
				});
				
				return filtered;
			};
			helpers.findIndex = Array.prototype.findIndex ?
				function(array, callback, scope) {
					return array.findIndex(callback, scope);
				} :
				function(array, callback, scope) {
					scope = scope === undefined ? array : scope;
					for(var i = 0, ilen = array.length; i < ilen; ++i) {
						if(callback.call(scope, array[i], i, array)) {
							return i;
						}
					}
					return -1;
				};
			helpers.findNextWhere = function(arrayToSearch, filterCallback, startIndex) {
				// Default to start of the array
				if(helpers.isNullOrUndef(startIndex)) {
					startIndex = -1;
				}
				for(var i = startIndex + 1; i < arrayToSearch.length; i++) {
					var currentItem = arrayToSearch[i];
					if(filterCallback(currentItem)) {
						return currentItem;
					}
				}
			};
			helpers.findPreviousWhere = function(arrayToSearch, filterCallback, startIndex) {
				// Default to end of the array
				if(helpers.isNullOrUndef(startIndex)) {
					startIndex = arrayToSearch.length;
				}
				for(var i = startIndex - 1; i >= 0; i--) {
					var currentItem = arrayToSearch[i];
					if(filterCallback(currentItem)) {
						return currentItem;
					}
				}
			};
			
			// -- Math methods
			helpers.isNumber = function(n) {
				return !isNaN(parseFloat(n)) && isFinite(n);
			};
			helpers.almostEquals = function(x, y, epsilon) {
				return Math.abs(x - y) < epsilon;
			};
			helpers.almostWhole = function(x, epsilon) {
				var rounded = Math.round(x);
				return (((rounded - epsilon) < x) && ((rounded + epsilon) > x));
			};
			helpers.max = function(array) {
				return array.reduce(function(max, value) {
					if(!isNaN(value)) {
						return Math.max(max, value);
					}
					return max;
				}, Number.NEGATIVE_INFINITY);
			};
			helpers.min = function(array) {
				return array.reduce(function(min, value) {
					if(!isNaN(value)) {
						return Math.min(min, value);
					}
					return min;
				}, Number.POSITIVE_INFINITY);
			};
			helpers.sign = Math.sign ?
				function(x) {
					return Math.sign(x);
				} :
				function(x) {
					x = +x; // convert to a number
					if(x === 0 || isNaN(x)) {
						return x;
					}
					return x > 0 ? 1 : -1;
				};
			helpers.log10 = Math.log10 ?
				function(x) {
					return Math.log10(x);
				} :
				function(x) {
					var exponent = Math.log(x) * Math.LOG10E; // Math.LOG10E = 1 / Math.LN10.
					// Check for whole powers of 10,
					// which due to floating point rounding error should be corrected.
					var powerOf10 = Math.round(exponent);
					var isPowerOf10 = x === Math.pow(10, powerOf10);
					
					return isPowerOf10 ? powerOf10 : exponent;
				};
			helpers.toRadians = function(degrees) {
				return degrees * (Math.PI / 180);
			};
			helpers.toDegrees = function(radians) {
				return radians * (180 / Math.PI);
			};
			// Gets the angle from vertical upright to the point about a centre.
			helpers.getAngleFromPoint = function(centrePoint, anglePoint) {
				var distanceFromXCenter = anglePoint.x - centrePoint.x;
				var distanceFromYCenter = anglePoint.y - centrePoint.y;
				var radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
				
				var angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
				
				if(angle < (-0.5 * Math.PI)) {
					angle += 2.0 * Math.PI; // make sure the returned angle is in the range of (-PI/2, 3PI/2]
				}
				
				return {
					angle: angle,
					distance: radialDistanceFromCenter
				};
			};
			helpers.distanceBetweenPoints = function(pt1, pt2) {
				return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
			};
			helpers.aliasPixel = function(pixelWidth) {
				return (pixelWidth % 2 === 0) ? 0 : 0.5;
			};
			helpers.splineCurve = function(firstPoint, middlePoint, afterPoint, t) {
				// Props to Rob Spencer at scaled innovation for his post on splining between points
				// http://scaledinnovation.com/analytics/splines/aboutSplines.html
				
				// This function must also respect "skipped" points
				
				var previous = firstPoint.skip ? middlePoint : firstPoint;
				var current = middlePoint;
				var next = afterPoint.skip ? middlePoint : afterPoint;
				
				var d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));
				var d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));
				
				var s01 = d01 / (d01 + d12);
				var s12 = d12 / (d01 + d12);
				
				// If all points are the same, s01 & s02 will be inf
				s01 = isNaN(s01) ? 0 : s01;
				s12 = isNaN(s12) ? 0 : s12;
				
				var fa = t * s01; // scaling factor for triangle Ta
				var fb = t * s12;
				
				return {
					previous: {
						x: current.x - fa * (next.x - previous.x),
						y: current.y - fa * (next.y - previous.y)
					},
					next: {
						x: current.x + fb * (next.x - previous.x),
						y: current.y + fb * (next.y - previous.y)
					}
				};
			};
			helpers.EPSILON = Number.EPSILON || 1e-14;
			helpers.splineCurveMonotone = function(points) {
				// This function calculates Bzier control points in a similar way than |splineCurve|,
				// but preserves monotonicity of the provided data and ensures no local extremums are added
				// between the dataset discrete points due to the interpolation.
				// See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation
				
				var pointsWithTangents = (points || []).map(function(point) {
					return {
						model: point._model,
						deltaK: 0,
						mK: 0
					};
				});
				
				// Calculate slopes (deltaK) and initialize tangents (mK)
				var pointsLen = pointsWithTangents.length;
				var i, pointBefore, pointCurrent, pointAfter;
				for(i = 0; i < pointsLen; ++i) {
					pointCurrent = pointsWithTangents[i];
					if(pointCurrent.model.skip) {
						continue;
					}
					
					pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
					pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;
					if(pointAfter && !pointAfter.model.skip) {
						var slopeDeltaX = (pointAfter.model.x - pointCurrent.model.x);
						
						// In the case of two points that appear at the same x pixel, slopeDeltaX is 0
						pointCurrent.deltaK = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;
					}
					
					if(!pointBefore || pointBefore.model.skip) {
						pointCurrent.mK = pointCurrent.deltaK;
					} else if(!pointAfter || pointAfter.model.skip) {
						pointCurrent.mK = pointBefore.deltaK;
					} else if(this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {
						pointCurrent.mK = 0;
					} else {
						pointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;
					}
				}
				
				// Adjust tangents to ensure monotonic properties
				var alphaK, betaK, tauK, squaredMagnitude;
				for(i = 0; i < pointsLen - 1; ++i) {
					pointCurrent = pointsWithTangents[i];
					pointAfter = pointsWithTangents[i + 1];
					if(pointCurrent.model.skip || pointAfter.model.skip) {
						continue;
					}
					
					if(helpers.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {
						pointCurrent.mK = pointAfter.mK = 0;
						continue;
					}
					
					alphaK = pointCurrent.mK / pointCurrent.deltaK;
					betaK = pointAfter.mK / pointCurrent.deltaK;
					squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
					if(squaredMagnitude <= 9) {
						continue;
					}
					
					tauK = 3 / Math.sqrt(squaredMagnitude);
					pointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;
					pointAfter.mK = betaK * tauK * pointCurrent.deltaK;
				}
				
				// Compute control points
				var deltaX;
				for(i = 0; i < pointsLen; ++i) {
					pointCurrent = pointsWithTangents[i];
					if(pointCurrent.model.skip) {
						continue;
					}
					
					pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
					pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;
					if(pointBefore && !pointBefore.model.skip) {
						deltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;
						pointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;
						pointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;
					}
					if(pointAfter && !pointAfter.model.skip) {
						deltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;
						pointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;
						pointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;
					}
				}
			};
			helpers.nextItem = function(collection, index, loop) {
				if(loop) {
					return index >= collection.length - 1 ? collection[0] : collection[index + 1];
				}
				return index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];
			};
			helpers.previousItem = function(collection, index, loop) {
				if(loop) {
					return index <= 0 ? collection[collection.length - 1] : collection[index - 1];
				}
				return index <= 0 ? collection[0] : collection[index - 1];
			};
			// Implementation of the nice number algorithm used in determining where axis labels will go
			helpers.niceNum = function(range, round) {
				var exponent = Math.floor(helpers.log10(range));
				var fraction = range / Math.pow(10, exponent);
				var niceFraction;
				
				if(round) {
					if(fraction < 1.5) {
						niceFraction = 1;
					} else if(fraction < 3) {
						niceFraction = 2;
					} else if(fraction < 7) {
						niceFraction = 5;
					} else {
						niceFraction = 10;
					}
				} else if(fraction <= 1.0) {
					niceFraction = 1;
				} else if(fraction <= 2) {
					niceFraction = 2;
				} else if(fraction <= 5) {
					niceFraction = 5;
				} else {
					niceFraction = 10;
				}
				
				return niceFraction * Math.pow(10, exponent);
			};
			// Request animation polyfill - http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/
			helpers.requestAnimFrame = (function() {
				if(typeof window === 'undefined') {
					return function(callback) {
						callback();
					};
				}
				return window.requestAnimationFrame ||
					window.webkitRequestAnimationFrame ||
					window.mozRequestAnimationFrame ||
					window.oRequestAnimationFrame ||
					window.msRequestAnimationFrame ||
					function(callback) {
						return window.setTimeout(callback, 1000 / 60);
					};
			}());
			// -- DOM methods
			helpers.getRelativePosition = function(evt, chart) {
				var mouseX, mouseY;
				var e = evt.originalEvent || evt;
				var canvas = evt.target || evt.srcElement;
				var boundingRect = canvas.getBoundingClientRect();
				
				var touches = e.touches;
				if(touches && touches.length > 0) {
					mouseX = touches[0].clientX;
					mouseY = touches[0].clientY;
					
				} else {
					mouseX = e.clientX;
					mouseY = e.clientY;
				}
				
				// Scale mouse coordinates into canvas coordinates
				// by following the pattern laid out by 'jerryj' in the comments of
				// http://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/
				var paddingLeft = parseFloat(helpers.getStyle(canvas, 'padding-left'));
				var paddingTop = parseFloat(helpers.getStyle(canvas, 'padding-top'));
				var paddingRight = parseFloat(helpers.getStyle(canvas, 'padding-right'));
				var paddingBottom = parseFloat(helpers.getStyle(canvas, 'padding-bottom'));
				var width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;
				var height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom;
				
				// We divide by the current device pixel ratio, because the canvas is scaled up by that amount in each direction. However
				// the backend model is in unscaled coordinates. Since we are going to deal with our model coordinates, we go back here
				mouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / (width) * canvas.width / chart.currentDevicePixelRatio);
				mouseY = Math.round((mouseY - boundingRect.top - paddingTop) / (height) * canvas.height / chart.currentDevicePixelRatio);
				
				return {
					x: mouseX,
					y: mouseY
				};
				
			};
			
			// Private helper function to convert max-width/max-height values that may be percentages into a number
			function parseMaxStyle(styleValue, node, parentProperty) {
				var valueInPixels;
				if(typeof styleValue === 'string') {
					valueInPixels = parseInt(styleValue, 10);
					
					if(styleValue.indexOf('%') !== -1) {
						// percentage * size in dimension
						valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
					}
				} else {
					valueInPixels = styleValue;
				}
				
				return valueInPixels;
			}
			
			/**
			 * Returns if the given value contains an effective constraint.
			 * @private
			 */
			function isConstrainedValue(value) {
				return value !== undefined && value !== null && value !== 'none';
			}
			
			// Private helper to get a constraint dimension
			// @param domNode : the node to check the constraint on
			// @param maxStyle : the style that defines the maximum for the direction we are using (maxWidth / maxHeight)
			// @param percentageProperty : property of parent to use when calculating width as a percentage
			// @see http://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser
			function getConstraintDimension(domNode, maxStyle, percentageProperty) {
				var view = document.defaultView;
				var parentNode = helpers._getParentNode(domNode);
				var constrainedNode = view.getComputedStyle(domNode)[maxStyle];
				var constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];
				var hasCNode = isConstrainedValue(constrainedNode);
				var hasCContainer = isConstrainedValue(constrainedContainer);
				var infinity = Number.POSITIVE_INFINITY;
				
				if(hasCNode || hasCContainer) {
					return Math.min(
						hasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity,
						hasCContainer ? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);
				}
				
				return 'none';
			}
			
			// returns Number or undefined if no constraint
			helpers.getConstraintWidth = function(domNode) {
				return getConstraintDimension(domNode, 'max-width', 'clientWidth');
			};
			// returns Number or undefined if no constraint
			helpers.getConstraintHeight = function(domNode) {
				return getConstraintDimension(domNode, 'max-height', 'clientHeight');
			};
			/**
			 * @private
			 */
			helpers._calculatePadding = function(container, padding, parentDimension) {
				padding = helpers.getStyle(container, padding);
				
				return padding.indexOf('%') > -1 ? parentDimension / parseInt(padding, 10) : parseInt(padding, 10);
			};
			/**
			 * @private
			 */
			helpers._getParentNode = function(domNode) {
				var parent = domNode.parentNode;
				if(parent && parent.host) {
					parent = parent.host;
				}
				return parent;
			};
			helpers.getMaximumWidth = function(domNode) {
				var container = helpers._getParentNode(domNode);
				if(!container) {
					return domNode.clientWidth;
				}
				
				var clientWidth = container.clientWidth;
				var paddingLeft = helpers._calculatePadding(container, 'padding-left', clientWidth);
				var paddingRight = helpers._calculatePadding(container, 'padding-right', clientWidth);
				
				var w = clientWidth - paddingLeft - paddingRight;
				var cw = helpers.getConstraintWidth(domNode);
				return isNaN(cw) ? w : Math.min(w, cw);
			};
			helpers.getMaximumHeight = function(domNode) {
				var container = helpers._getParentNode(domNode);
				if(!container) {
					return domNode.clientHeight;
				}
				
				var clientHeight = container.clientHeight;
				var paddingTop = helpers._calculatePadding(container, 'padding-top', clientHeight);
				var paddingBottom = helpers._calculatePadding(container, 'padding-bottom', clientHeight);
				
				var h = clientHeight - paddingTop - paddingBottom;
				var ch = helpers.getConstraintHeight(domNode);
				return isNaN(ch) ? h : Math.min(h, ch);
			};
			helpers.getStyle = function(el, property) {
				return el.currentStyle ?
					el.currentStyle[property] :
					document.defaultView.getComputedStyle(el, null).getPropertyValue(property);
			};
			helpers.retinaScale = function(chart, forceRatio) {
				var pixelRatio = chart.currentDevicePixelRatio = forceRatio || (typeof window !== 'undefined' && window.devicePixelRatio) || 1;
				if(pixelRatio === 1) {
					return;
				}
				
				var canvas = chart.canvas;
				var height = chart.height;
				var width = chart.width;
				
				canvas.height = height * pixelRatio;
				canvas.width = width * pixelRatio;
				chart.ctx.scale(pixelRatio, pixelRatio);
				
				// If no style has been set on the canvas, the render size is used as display size,
				// making the chart visually bigger, so let's enforce it to the "correct" values.
				// See https://github.com/chartjs/Chart.js/issues/3575
				if(!canvas.style.height && !canvas.style.width) {
					canvas.style.height = height + 'px';
					canvas.style.width = width + 'px';
				}
			};
			// -- Canvas methods
			helpers.fontString = function(pixelSize, fontStyle, fontFamily) {
				return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;
			};
			helpers.longestText = function(ctx, font, arrayOfThings, cache) {
				cache = cache || {};
				var data = cache.data = cache.data || {};
				var gc = cache.garbageCollect = cache.garbageCollect || [];
				
				if(cache.font !== font) {
					data = cache.data = {};
					gc = cache.garbageCollect = [];
					cache.font = font;
				}
				
				ctx.font = font;
				var longest = 0;
				helpers.each(arrayOfThings, function(thing) {
					// Undefined strings and arrays should not be measured
					if(thing !== undefined && thing !== null && helpers.isArray(thing) !== true) {
						longest = helpers.measureText(ctx, data, gc, longest, thing);
					} else if(helpers.isArray(thing)) {
						// if it is an array lets measure each element
						// to do maybe simplify this function a bit so we can do this more recursively?
						helpers.each(thing, function(nestedThing) {
							// Undefined strings and arrays should not be measured
							if(nestedThing !== undefined && nestedThing !== null && !helpers.isArray(nestedThing)) {
								longest = helpers.measureText(ctx, data, gc, longest, nestedThing);
							}
						});
					}
				});
				
				var gcLen = gc.length / 2;
				if(gcLen > arrayOfThings.length) {
					for(var i = 0; i < gcLen; i++) {
						delete data[gc[i]];
					}
					gc.splice(0, gcLen);
				}
				return longest;
			};
			helpers.measureText = function(ctx, data, gc, longest, string) {
				var textWidth = data[string];
				if(!textWidth) {
					textWidth = data[string] = ctx.measureText(string).width;
					gc.push(string);
				}
				if(textWidth > longest) {
					longest = textWidth;
				}
				return longest;
			};
			helpers.numberOfLabelLines = function(arrayOfThings) {
				var numberOfLines = 1;
				helpers.each(arrayOfThings, function(thing) {
					if(helpers.isArray(thing)) {
						if(thing.length > numberOfLines) {
							numberOfLines = thing.length;
						}
					}
				});
				return numberOfLines;
			};
			
			helpers.color = !color ?
				function(value) {
					console.error('Color.js not found!');
					return value;
				} :
				function(value) {
					/* global CanvasGradient */
					if(value instanceof CanvasGradient) {
						value = defaults.global.defaultColor;
					}
					
					return color(value);
				};
			
			helpers.getHoverColor = function(colorValue) {
				/* global CanvasPattern */
				return (colorValue instanceof CanvasPattern) ?
					colorValue :
					helpers.color(colorValue).saturate(0.5).darken(0.1).rgbString();
			};
		};
		
		
		/***/
	}),
	
	/***/ "./node_modules/chart.js/src/core/core.interaction.js":
	/*!************************************************************!*\
  !*** ./node_modules/chart.js/src/core/core.interaction.js ***!
  \************************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		var helpers = __webpack_require__(/*! ../helpers/index */ "./node_modules/chart.js/src/helpers/index.js");
		
		/**
		 * Helper function to get relative position for an event
		 * @param {Event|IEvent} event - The event to get the position for
		 * @param {Chart} chart - The chart
		 * @returns {Point} the event position
		 */
		function getRelativePosition(e, chart) {
			if(e.native) {
				return {
					x: e.x,
					y: e.y
				};
			}
			
			return helpers.getRelativePosition(e, chart);
		}
		
		/**
		 * Helper function to traverse all of the visible elements in the chart
		 * @param chart {chart} the chart
		 * @param handler {Function} the callback to execute for each visible item
		 */
		function parseVisibleItems(chart, handler) {
			var datasets = chart.data.datasets;
			var meta, i, j, ilen, jlen;
			
			for(i = 0, ilen = datasets.length; i < ilen; ++i) {
				if(!chart.isDatasetVisible(i)) {
					continue;
				}
				
				meta = chart.getDatasetMeta(i);
				for(j = 0, jlen = meta.data.length; j < jlen; ++j) {
					var element = meta.data[j];
					if(!element._view.skip) {
						handler(element);
					}
				}
			}
		}
		
		/**
		 * Helper function to get the items that intersect the event position
		 * @param items {ChartElement[]} elements to filter
		 * @param position {Point} the point to be nearest to
		 * @return {ChartElement[]} the nearest items
		 */
		function getIntersectItems(chart, position) {
			var elements = [];
			
			parseVisibleItems(chart, function(element) {
				if(element.inRange(position.x, position.y)) {
					elements.push(element);
				}
			});
			
			return elements;
		}
		
		/**
		 * Helper function to get the items nearest to the event position considering all visible items in teh chart
		 * @param chart {Chart} the chart to look at elements from
		 * @param position {Point} the point to be nearest to
		 * @param intersect {Boolean} if true, only consider items that intersect the position
		 * @param distanceMetric {Function} function to provide the distance between points
		 * @return {ChartElement[]} the nearest items
		 */
		function getNearestItems(chart, position, intersect, distanceMetric) {
			var minDistance = Number.POSITIVE_INFINITY;
			var nearestItems = [];
			
			parseVisibleItems(chart, function(element) {
				if(intersect && !element.inRange(position.x, position.y)) {
					return;
				}
				
				var center = element.getCenterPoint();
				var distance = distanceMetric(position, center);
				
				if(distance < minDistance) {
					nearestItems = [element];
					minDistance = distance;
				} else if(distance === minDistance) {
					// Can have multiple items at the same distance in which case we sort by size
					nearestItems.push(element);
				}
			});
			
			return nearestItems;
		}
		
		/**
		 * Get a distance metric function for two points based on the
		 * axis mode setting
		 * @param {String} axis the axis mode. x|y|xy
		 */
		function getDistanceMetricForAxis(axis) {
			var useX = axis.indexOf('x') !== -1;
			var useY = axis.indexOf('y') !== -1;
			
			return function(pt1, pt2) {
				var deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
				var deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
				return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
			};
		}
		
		function indexMode(chart, e, options) {
			var position = getRelativePosition(e, chart);
			// Default axis for index mode is 'x' to match old behaviour
			options.axis = options.axis || 'x';
			var distanceMetric = getDistanceMetricForAxis(options.axis);
			var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);
			var elements = [];
			
			if(!items.length) {
				return [];
			}
			
			chart.data.datasets.forEach(function(dataset, datasetIndex) {
				if(chart.isDatasetVisible(datasetIndex)) {
					var meta = chart.getDatasetMeta(datasetIndex);
					var element = meta.data[items[0]._index];
					
					// don't count items that are skipped (null data)
					if(element && !element._view.skip) {
						elements.push(element);
					}
				}
			});
			
			return elements;
		}
		
		/**
		 * @interface IInteractionOptions
		 */
		/**
		 * If true, only consider items that intersect the point
		 * @name IInterfaceOptions#boolean
		 * @type Boolean
		 */
		
		/**
		 * Contains interaction related functions
		 * @namespace Chart.Interaction
		 */
		module.exports = {
			// Helper function for different modes
			modes: {
				single: function(chart, e) {
					var position = getRelativePosition(e, chart);
					var elements = [];
					
					parseVisibleItems(chart, function(element) {
						if(element.inRange(position.x, position.y)) {
							elements.push(element);
							return elements;
						}
					});
					
					return elements.slice(0, 1);
				},
				
				/**
				 * @function Chart.Interaction.modes.label
				 * @deprecated since version 2.4.0
				 * @todo remove at version 3
				 * @private
				 */
				label: indexMode,
				
				/**
				 * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something
				 * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item
				 * @function Chart.Interaction.modes.index
				 * @since v2.4.0
				 * @param chart {chart} the chart we are returning items from
				 * @param e {Event} the event we are find things at
				 * @param options {IInteractionOptions} options to use during interaction
				 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
				 */
				index: indexMode,
				
				/**
				 * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something
				 * If the options.intersect is false, we find the nearest item and return the items in that dataset
				 * @function Chart.Interaction.modes.dataset
				 * @param chart {chart} the chart we are returning items from
				 * @param e {Event} the event we are find things at
				 * @param options {IInteractionOptions} options to use during interaction
				 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
				 */
				dataset: function(chart, e, options) {
					var position = getRelativePosition(e, chart);
					options.axis = options.axis || 'xy';
					var distanceMetric = getDistanceMetricForAxis(options.axis);
					var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);
					
					if(items.length > 0) {
						items = chart.getDatasetMeta(items[0]._datasetIndex).data;
					}
					
					return items;
				},
				
				/**
				 * @function Chart.Interaction.modes.x-axis
				 * @deprecated since version 2.4.0. Use index mode and intersect == true
				 * @todo remove at version 3
				 * @private
				 */
				'x-axis': function(chart, e) {
					return indexMode(chart, e, {intersect: false});
				},
				
				/**
				 * Point mode returns all elements that hit test based on the event position
				 * of the event
				 * @function Chart.Interaction.modes.intersect
				 * @param chart {chart} the chart we are returning items from
				 * @param e {Event} the event we are find things at
				 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
				 */
				point: function(chart, e) {
					var position = getRelativePosition(e, chart);
					return getIntersectItems(chart, position);
				},
				
				/**
				 * nearest mode returns the element closest to the point
				 * @function Chart.Interaction.modes.intersect
				 * @param chart {chart} the chart we are returning items from
				 * @param e {Event} the event we are find things at
				 * @param options {IInteractionOptions} options to use
				 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
				 */
				nearest: function(chart, e, options) {
					var position = getRelativePosition(e, chart);
					options.axis = options.axis || 'xy';
					var distanceMetric = getDistanceMetricForAxis(options.axis);
					var nearestItems = getNearestItems(chart, position, options.intersect, distanceMetric);
					
					// We have multiple items at the same distance from the event. Now sort by smallest
					if(nearestItems.length > 1) {
						nearestItems.sort(function(a, b) {
							var sizeA = a.getArea();
							var sizeB = b.getArea();
							var ret = sizeA - sizeB;
							
							if(ret === 0) {
								// if equal sort by dataset index
								ret = a._datasetIndex - b._datasetIndex;
							}
							
							return ret;
						});
					}
					
					// Return only 1 item
					return nearestItems.slice(0, 1);
				},
				
				/**
				 * x mode returns the elements that hit-test at the current x coordinate
				 * @function Chart.Interaction.modes.x
				 * @param chart {chart} the chart we are returning items from
				 * @param e {Event} the event we are find things at
				 * @param options {IInteractionOptions} options to use
				 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
				 */
				x: function(chart, e, options) {
					var position = getRelativePosition(e, chart);
					var items = [];
					var intersectsItem = false;
					
					parseVisibleItems(chart, function(element) {
						if(element.inXRange(position.x)) {
							items.push(element);
						}
						
						if(element.inRange(position.x, position.y)) {
							intersectsItem = true;
						}
					});
					
					// If we want to trigger on an intersect and we don't have any items
					// that intersect the position, return nothing
					if(options.intersect && !intersectsItem) {
						items = [];
					}
					return items;
				},
				
				/**
				 * y mode returns the elements that hit-test at the current y coordinate
				 * @function Chart.Interaction.modes.y
				 * @param chart {chart} the chart we are returning items from
				 * @param e {Event} the event we are find things at
				 * @param options {IInteractionOptions} options to use
				 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
				 */
				y: function(chart, e, options) {
					var position = getRelativePosition(e, chart);
					var items = [];
					var intersectsItem = false;
					
					parseVisibleItems(chart, function(element) {
						if(element.inYRange(position.y)) {
							items.push(element);
						}
						
						if(element.inRange(position.x, position.y)) {
							intersectsItem = true;
						}
					});
					
					// If we want to trigger on an intersect and we don't have any items
					// that intersect the position, return nothing
					if(options.intersect && !intersectsItem) {
						items = [];
					}
					return items;
				}
			}
		};
		
		
		/***/
	}),
	
	/***/ "./node_modules/chart.js/src/core/core.js":
	/*!************************************************!*\
  !*** ./node_modules/chart.js/src/core/core.js ***!
  \************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		var defaults = __webpack_require__(/*! ./core.defaults */ "./node_modules/chart.js/src/core/core.defaults.js");
		
		defaults._set('global', {
			responsive: true,
			responsiveAnimationDuration: 0,
			maintainAspectRatio: true,
			events: ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove'],
			hover: {
				onHover: null,
				mode: 'nearest',
				intersect: true,
				animationDuration: 400
			},
			onClick: null,
			defaultColor: 'rgba(0,0,0,0.1)',
			defaultFontColor: '#666',
			defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
			defaultFontSize: 12,
			defaultFontStyle: 'normal',
			showLines: true,
			
			// Element defaults defined in element extensions
			elements: {},
			
			// Layout options such as padding
			layout: {
				padding: {
					top: 0,
					right: 0,
					bottom: 0,
					left: 0
				}
			}
		});
		
		module.exports = function() {
			
			// Occupy the global variable of Chart, and create a simple base class
			var Chart = function(item, config) {
				this.construct(item, config);
				return this;
			};
			
			Chart.Chart = Chart;
			
			return Chart;
		};
		
		
		/***/
	}),
	
	/***/ "./node_modules/chart.js/src/core/core.layouts.js":
	/*!********************************************************!*\
  !*** ./node_modules/chart.js/src/core/core.layouts.js ***!
  \********************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		var helpers = __webpack_require__(/*! ../helpers/index */ "./node_modules/chart.js/src/helpers/index.js");
		
		function filterByPosition(array, position) {
			return helpers.where(array, function(v) {
				return v.position === position;
			});
		}
		
		function sortByWeight(array, reverse) {
			array.forEach(function(v, i) {
				v._tmpIndex_ = i;
				return v;
			});
			array.sort(function(a, b) {
				var v0 = reverse ? b : a;
				var v1 = reverse ? a : b;
				return v0.weight === v1.weight ?
					v0._tmpIndex_ - v1._tmpIndex_ :
					v0.weight - v1.weight;
			});
			array.forEach(function(v) {
				delete v._tmpIndex_;
			});
		}
		
		/**
		 * @interface ILayoutItem
		 * @prop {String} position - The position of the item in the chart layout. Possible values are
		 * 'left', 'top', 'right', 'bottom', and 'chartArea'
		 * @prop {Number} weight - The weight used to sort the item. Higher weights are further away from the chart area
		 * @prop {Boolean} fullWidth - if true, and the item is horizontal, then push vertical boxes down
		 * @prop {Function} isHorizontal - returns true if the layout item is horizontal (ie. top or bottom)
		 * @prop {Function} update - Takes two parameters: width and height. Returns size of item
		 * @prop {Function} getPadding -  Returns an object with padding on the edges
		 * @prop {Number} width - Width of item. Must be valid after update()
		 * @prop {Number} height - Height of item. Must be valid after update()
		 * @prop {Number} left - Left edge of the item. Set by layout system and cannot be used in update
		 * @prop {Number} top - Top edge of the item. Set by layout system and cannot be used in update
		 * @prop {Number} right - Right edge of the item. Set by layout system and cannot be used in update
		 * @prop {Number} bottom - Bottom edge of the item. Set by layout system and cannot be used in update
		 */

// The layout service is very self explanatory.  It's responsible for the layout within a chart.
// Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need
// It is this service's responsibility of carrying out that layout.
		module.exports = {
			defaults: {},
			
			/**
			 * Register a box to a chart.
			 * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.
			 * @param {Chart} chart - the chart to use
			 * @param {ILayoutItem} item - the item to add to be layed out
			 */
			addBox: function(chart, item) {
				if(!chart.boxes) {
					chart.boxes = [];
				}
				
				// initialize item with default values
				item.fullWidth = item.fullWidth || false;
				item.position = item.position || 'top';
				item.weight = item.weight || 0;
				
				chart.boxes.push(item);
			},
			
			/**
			 * Remove a layoutItem from a chart
			 * @param {Chart} chart - the chart to remove the box from
			 * @param {Object} layoutItem - the item to remove from the layout
			 */
			removeBox: function(chart, layoutItem) {
				var index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
				if(index !== -1) {
					chart.boxes.splice(index, 1);
				}
			},
			
			/**
			 * Sets (or updates) options on the given `item`.
			 * @param {Chart} chart - the chart in which the item lives (or will be added to)
			 * @param {Object} item - the item to configure with the given options
			 * @param {Object} options - the new item options.
			 */
			configure: function(chart, item, options) {
				var props = ['fullWidth', 'position', 'weight'];
				var ilen = props.length;
				var i = 0;
				var prop;
				
				for(; i < ilen; ++i) {
					prop = props[i];
					if(options.hasOwnProperty(prop)) {
						item[prop] = options[prop];
					}
				}
			},
			
			/**
			 * Fits boxes of the given chart into the given size by having each box measure itself
			 * then running a fitting algorithm
			 * @param {Chart} chart - the chart
			 * @param {Number} width - the width to fit into
			 * @param {Number} height - the height to fit into
			 */
			update: function(chart, width, height) {
				if(!chart) {
					return;
				}
				
				var layoutOptions = chart.options.layout || {};
				var padding = helpers.options.toPadding(layoutOptions.padding);
				var leftPadding = padding.left;
				var rightPadding = padding.right;
				var topPadding = padding.top;
				var bottomPadding = padding.bottom;
				
				var leftBoxes = filterByPosition(chart.boxes, 'left');
				var rightBoxes = filterByPosition(chart.boxes, 'right');
				var topBoxes = filterByPosition(chart.boxes, 'top');
				var bottomBoxes = filterByPosition(chart.boxes, 'bottom');
				var chartAreaBoxes = filterByPosition(chart.boxes, 'chartArea');
				
				// Sort boxes by weight. A higher weight is further away from the chart area
				sortByWeight(leftBoxes, true);
				sortByWeight(rightBoxes, false);
				sortByWeight(topBoxes, true);
				sortByWeight(bottomBoxes, false);
				
				// Essentially we now have any number of boxes on each of the 4 sides.
				// Our canvas looks like the following.
				// The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and
				// B1 is the bottom axis
				// There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays
				// These locations are single-box locations only, when trying to register a chartArea location that is already taken,
				// an error will be thrown.
				//
				// |----------------------------------------------------|
				// |                  T1 (Full Width)                   |
				// |----------------------------------------------------|
				// |    |    |                 T2                  |    |
				// |    |----|-------------------------------------|----|
				// |    |    | C1 |                           | C2 |    |
				// |    |    |----|                           |----|    |
				// |    |    |                                     |    |
				// | L1 | L2 |           ChartArea (C0)            | R1 |
				// |    |    |                                     |    |
				// |    |    |----|                           |----|    |
				// |    |    | C3 |                           | C4 |    |
				// |    |----|-------------------------------------|----|
				// |    |    |                 B1                  |    |
				// |----------------------------------------------------|
				// |                  B2 (Full Width)                   |
				// |----------------------------------------------------|
				//
				// What we do to find the best sizing, we do the following
				// 1. Determine the minimum size of the chart area.
				// 2. Split the remaining width equally between each vertical axis
				// 3. Split the remaining height equally between each horizontal axis
				// 4. Give each layout the maximum size it can be. The layout will return it's minimum size
				// 5. Adjust the sizes of each axis based on it's minimum reported size.
				// 6. Refit each axis
				// 7. Position each axis in the final location
				// 8. Tell the chart the final location of the chart area
				// 9. Tell any axes that overlay the chart area the positions of the chart area
				
				// Step 1
				var chartWidth = width - leftPadding - rightPadding;
				var chartHeight = height - topPadding - bottomPadding;
				var chartAreaWidth = chartWidth / 2; // min 50%
				var chartAreaHeight = chartHeight / 2; // min 50%
				
				// Step 2
				var verticalBoxWidth = (width - chartAreaWidth) / (leftBoxes.length + rightBoxes.length);
				
				// Step 3
				var horizontalBoxHeight = (height - chartAreaHeight) / (topBoxes.length + bottomBoxes.length);
				
				// Step 4
				var maxChartAreaWidth = chartWidth;
				var maxChartAreaHeight = chartHeight;
				var minBoxSizes = [];
				
				function getMinimumBoxSize(box) {
					var minSize;
					var isHorizontal = box.isHorizontal();
					
					if(isHorizontal) {
						minSize = box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, horizontalBoxHeight);
						maxChartAreaHeight -= minSize.height;
					} else {
						minSize = box.update(verticalBoxWidth, maxChartAreaHeight);
						maxChartAreaWidth -= minSize.width;
					}
					
					minBoxSizes.push({
						horizontal: isHorizontal,
						minSize: minSize,
						box: box,
					});
				}
				
				helpers.each(leftBoxes.concat(rightBoxes, topBoxes, bottomBoxes), getMinimumBoxSize);
				
				// If a horizontal box has padding, we move the left boxes over to avoid ugly charts (see issue #2478)
				var maxHorizontalLeftPadding = 0;
				var maxHorizontalRightPadding = 0;
				var maxVerticalTopPadding = 0;
				var maxVerticalBottomPadding = 0;
				
				helpers.each(topBoxes.concat(bottomBoxes), function(horizontalBox) {
					if(horizontalBox.getPadding) {
						var boxPadding = horizontalBox.getPadding();
						maxHorizontalLeftPadding = Math.max(maxHorizontalLeftPadding, boxPadding.left);
						maxHorizontalRightPadding = Math.max(maxHorizontalRightPadding, boxPadding.right);
					}
				});
				
				helpers.each(leftBoxes.concat(rightBoxes), function(verticalBox) {
					if(verticalBox.getPadding) {
						var boxPadding = verticalBox.getPadding();
						maxVerticalTopPadding = Math.max(maxVerticalTopPadding, boxPadding.top);
						maxVerticalBottomPadding = Math.max(maxVerticalBottomPadding, boxPadding.bottom);
					}
				});
				
				// At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could
				// be if the axes are drawn at their minimum sizes.
				// Steps 5 & 6
				var totalLeftBoxesWidth = leftPadding;
				var totalRightBoxesWidth = rightPadding;
				var totalTopBoxesHeight = topPadding;
				var totalBottomBoxesHeight = bottomPadding;
				
				// Function to fit a box
				function fitBox(box) {
					var minBoxSize = helpers.findNextWhere(minBoxSizes, function(minBox) {
						return minBox.box === box;
					});
					
					if(minBoxSize) {
						if(box.isHorizontal()) {
							var scaleMargin = {
								left: Math.max(totalLeftBoxesWidth, maxHorizontalLeftPadding),
								right: Math.max(totalRightBoxesWidth, maxHorizontalRightPadding),
								top: 0,
								bottom: 0
							};
							
							// Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends
							// on the margin. Sometimes they need to increase in size slightly
							box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);
						} else {
							box.update(minBoxSize.minSize.width, maxChartAreaHeight);
						}
					}
				}
				
				// Update, and calculate the left and right margins for the horizontal boxes
				helpers.each(leftBoxes.concat(rightBoxes), fitBox);
				
				helpers.each(leftBoxes, function(box) {
					totalLeftBoxesWidth += box.width;
				});
				
				helpers.each(rightBoxes, function(box) {
					totalRightBoxesWidth += box.width;
				});
				
				// Set the Left and Right margins for the horizontal boxes
				helpers.each(topBoxes.concat(bottomBoxes), fitBox);
				
				// Figure out how much margin is on the top and bottom of the vertical boxes
				helpers.each(topBoxes, function(box) {
					totalTopBoxesHeight += box.height;
				});
				
				helpers.each(bottomBoxes, function(box) {
					totalBottomBoxesHeight += box.height;
				});
				
				function finalFitVerticalBox(box) {
					var minBoxSize = helpers.findNextWhere(minBoxSizes, function(minSize) {
						return minSize.box === box;
					});
					
					var scaleMargin = {
						left: 0,
						right: 0,
						top: totalTopBoxesHeight,
						bottom: totalBottomBoxesHeight
					};
					
					if(minBoxSize) {
						box.update(minBoxSize.minSize.width, maxChartAreaHeight, scaleMargin);
					}
				}
				
				// Let the left layout know the final margin
				helpers.each(leftBoxes.concat(rightBoxes), finalFitVerticalBox);
				
				// Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)
				totalLeftBoxesWidth = leftPadding;
				totalRightBoxesWidth = rightPadding;
				totalTopBoxesHeight = topPadding;
				totalBottomBoxesHeight = bottomPadding;
				
				helpers.each(leftBoxes, function(box) {
					totalLeftBoxesWidth += box.width;
				});
				
				helpers.each(rightBoxes, function(box) {
					totalRightBoxesWidth += box.width;
				});
				
				helpers.each(topBoxes, function(box) {
					totalTopBoxesHeight += box.height;
				});
				helpers.each(bottomBoxes, function(box) {
					totalBottomBoxesHeight += box.height;
				});
				
				// We may be adding some padding to account for rotated x axis labels
				var leftPaddingAddition = Math.max(maxHorizontalLeftPadding - totalLeftBoxesWidth, 0);
				totalLeftBoxesWidth += leftPaddingAddition;
				totalRightBoxesWidth += Math.max(maxHorizontalRightPadding - totalRightBoxesWidth, 0);
				
				var topPaddingAddition = Math.max(maxVerticalTopPadding - totalTopBoxesHeight, 0);
				totalTopBoxesHeight += topPaddingAddition;
				totalBottomBoxesHeight += Math.max(maxVerticalBottomPadding - totalBottomBoxesHeight, 0);
				
				// Figure out if our chart area changed. This would occur if the dataset layout label rotation
				// changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do
				// without calling `fit` again
				var newMaxChartAreaHeight = height - totalTopBoxesHeight - totalBottomBoxesHeight;
				var newMaxChartAreaWidth = width - totalLeftBoxesWidth - totalRightBoxesWidth;
				
				if(newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {
					helpers.each(leftBoxes, function(box) {
						box.height = newMaxChartAreaHeight;
					});
					
					helpers.each(rightBoxes, function(box) {
						box.height = newMaxChartAreaHeight;
					});
					
					helpers.each(topBoxes, function(box) {
						if(!box.fullWidth) {
							box.width = newMaxChartAreaWidth;
						}
					});
					
					helpers.each(bottomBoxes, function(box) {
						if(!box.fullWidth) {
							box.width = newMaxChartAreaWidth;
						}
					});
					
					maxChartAreaHeight = newMaxChartAreaHeight;
					maxChartAreaWidth = newMaxChartAreaWidth;
				}
				
				// Step 7 - Position the boxes
				var left = leftPadding + leftPaddingAddition;
				var top = topPadding + topPaddingAddition;
				
				function placeBox(box) {
					if(box.isHorizontal()) {
						box.left = box.fullWidth ? leftPadding : totalLeftBoxesWidth;
						box.right = box.fullWidth ? width - rightPadding : totalLeftBoxesWidth + maxChartAreaWidth;
						box.top = top;
						box.bottom = top + box.height;
						
						// Move to next point
						top = box.bottom;
						
					} else {
						
						box.left = left;
						box.right = left + box.width;
						box.top = totalTopBoxesHeight;
						box.bottom = totalTopBoxesHeight + maxChartAreaHeight;
						
						// Move to next point
						left = box.right;
					}
				}
				
				helpers.each(leftBoxes.concat(topBoxes), placeBox);
				
				// Account for chart width and height
				left += maxChartAreaWidth;
				top += maxChartAreaHeight;
				
				helpers.each(rightBoxes, placeBox);
				helpers.each(bottomBoxes, placeBox);
				
				// Step 8
				chart.chartArea = {
					left: totalLeftBoxesWidth,
					top: totalTopBoxesHeight,
					right: totalLeftBoxesWidth + maxChartAreaWidth,
					bottom: totalTopBoxesHeight + maxChartAreaHeight
				};
				
				// Step 9
				helpers.each(chartAreaBoxes, function(box) {
					box.left = chart.chartArea.left;
					box.top = chart.chartArea.top;
					box.right = chart.chartArea.right;
					box.bottom = chart.chartArea.bottom;
					
					box.update(maxChartAreaWidth, maxChartAreaHeight);
				});
			}
		};
		
		
		/***/
	}),
	
	/***/ "./node_modules/chart.js/src/core/core.plugins.js":
	/*!********************************************************!*\
  !*** ./node_modules/chart.js/src/core/core.plugins.js ***!
  \********************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		var defaults = __webpack_require__(/*! ./core.defaults */ "./node_modules/chart.js/src/core/core.defaults.js");
		var helpers = __webpack_require__(/*! ../helpers/index */ "./node_modules/chart.js/src/helpers/index.js");
		
		defaults._set('global', {
			plugins: {}
		});
		
		/**
		 * The plugin service singleton
		 * @namespace Chart.plugins
		 * @since 2.1.0
		 */
		module.exports = {
			/**
			 * Globally registered plugins.
			 * @private
			 */
			_plugins: [],
			
			/**
			 * This identifier is used to invalidate the descriptors cache attached to each chart
			 * when a global plugin is registered or unregistered. In this case, the cache ID is
			 * incremented and descriptors are regenerated during following API calls.
			 * @private
			 */
			_cacheId: 0,
			
			/**
			 * Registers the given plugin(s) if not already registered.
			 * @param {Array|Object} plugins plugin instance(s).
			 */
			register: function(plugins) {
				var p = this._plugins;
				([]).concat(plugins).forEach(function(plugin) {
					if(p.indexOf(plugin) === -1) {
						p.push(plugin);
					}
				});
				
				this._cacheId++;
			},
			
			/**
			 * Unregisters the given plugin(s) only if registered.
			 * @param {Array|Object} plugins plugin instance(s).
			 */
			unregister: function(plugins) {
				var p = this._plugins;
				([]).concat(plugins).forEach(function(plugin) {
					var idx = p.indexOf(plugin);
					if(idx !== -1) {
						p.splice(idx, 1);
					}
				});
				
				this._cacheId++;
			},
			
			/**
			 * Remove all registered plugins.
			 * @since 2.1.5
			 */
			clear: function() {
				this._plugins = [];
				this._cacheId++;
			},
			
			/**
			 * Returns the number of registered plugins?
			 * @returns {Number}
			 * @since 2.1.5
			 */
			count: function() {
				return this._plugins.length;
			},
			
			/**
			 * Returns all registered plugin instances.
			 * @returns {Array} array of plugin objects.
			 * @since 2.1.5
			 */
			getAll: function() {
				return this._plugins;
			},
			
			/**
			 * Calls enabled plugins for `chart` on the specified hook and with the given args.
			 * This method immediately returns as soon as a plugin explicitly returns false. The
			 * returned value can be used, for instance, to interrupt the current action.
			 * @param {Object} chart - The chart instance for which plugins should be called.
			 * @param {String} hook - The name of the plugin method to call (e.g. 'beforeUpdate').
			 * @param {Array} [args] - Extra arguments to apply to the hook call.
			 * @returns {Boolean} false if any of the plugins return false, else returns true.
			 */
			notify: function(chart, hook, args) {
				var descriptors = this.descriptors(chart);
				var ilen = descriptors.length;
				var i, descriptor, plugin, params, method;
				
				for(i = 0; i < ilen; ++i) {
					descriptor = descriptors[i];
					plugin = descriptor.plugin;
					method = plugin[hook];
					if(typeof method === 'function') {
						params = [chart].concat(args || []);
						params.push(descriptor.options);
						if(method.apply(plugin, params) === false) {
							return false;
						}
					}
				}
				
				return true;
			},
			
			/**
			 * Returns descriptors of enabled plugins for the given chart.
			 * @returns {Array} [{ plugin, options }]
			 * @private
			 */
			descriptors: function(chart) {
				var cache = chart.$plugins || (chart.$plugins = {});
				if(cache.id === this._cacheId) {
					return cache.descriptors;
				}
				
				var plugins = [];
				var descriptors = [];
				var config = (chart && chart.config) || {};
				var options = (config.options && config.options.plugins) || {};
				
				this._plugins.concat(config.plugins || []).forEach(function(plugin) {
					var idx = plugins.indexOf(plugin);
					if(idx !== -1) {
						return;
					}
					
					var id = plugin.id;
					var opts = options[id];
					if(opts === false) {
						return;
					}
					
					if(opts === true) {
						opts = helpers.clone(defaults.global.plugins[id]);
					}
					
					plugins.push(plugin);
					descriptors.push({
						plugin: plugin,
						options: opts || {}
					});
				});
				
				cache.descriptors = descriptors;
				cache.id = this._cacheId;
				return descriptors;
			},
			
			/**
			 * Invalidates cache for the given chart: descriptors hold a reference on plugin option,
			 * but in some cases, this reference can be changed by the user when updating options.
			 * https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167
			 * @private
			 */
			_invalidate: function(chart) {
				delete chart.$plugins;
			}
		};
		
		/**
		 * Plugin extension hooks.
		 * @interface IPlugin
		 * @since 2.1.0
		 */
		/**
		 * @method IPlugin#beforeInit
		 * @desc Called before initializing `chart`.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {Object} options - The plugin options.
		 */
		/**
		 * @method IPlugin#afterInit
		 * @desc Called after `chart` has been initialized and before the first update.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {Object} options - The plugin options.
		 */
		/**
		 * @method IPlugin#beforeUpdate
		 * @desc Called before updating `chart`. If any plugin returns `false`, the update
		 * is cancelled (and thus subsequent render(s)) until another `update` is triggered.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {Object} options - The plugin options.
		 * @returns {Boolean} `false` to cancel the chart update.
		 */
		/**
		 * @method IPlugin#afterUpdate
		 * @desc Called after `chart` has been updated and before rendering. Note that this
		 * hook will not be called if the chart update has been previously cancelled.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {Object} options - The plugin options.
		 */
		/**
		 * @method IPlugin#beforeDatasetsUpdate
		 * @desc Called before updating the `chart` datasets. If any plugin returns `false`,
		 * the datasets update is cancelled until another `update` is triggered.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {Object} options - The plugin options.
		 * @returns {Boolean} false to cancel the datasets update.
		 * @since version 2.1.5
		 */
		/**
		 * @method IPlugin#afterDatasetsUpdate
		 * @desc Called after the `chart` datasets have been updated. Note that this hook
		 * will not be called if the datasets update has been previously cancelled.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {Object} options - The plugin options.
		 * @since version 2.1.5
		 */
		/**
		 * @method IPlugin#beforeDatasetUpdate
		 * @desc Called before updating the `chart` dataset at the given `args.index`. If any plugin
		 * returns `false`, the datasets update is cancelled until another `update` is triggered.
		 * @param {Chart} chart - The chart instance.
		 * @param {Object} args - The call arguments.
		 * @param {Number} args.index - The dataset index.
		 * @param {Object} args.meta - The dataset metadata.
		 * @param {Object} options - The plugin options.
		 * @returns {Boolean} `false` to cancel the chart datasets drawing.
		 */
		/**
		 * @method IPlugin#afterDatasetUpdate
		 * @desc Called after the `chart` datasets at the given `args.index` has been updated. Note
		 * that this hook will not be called if the datasets update has been previously cancelled.
		 * @param {Chart} chart - The chart instance.
		 * @param {Object} args - The call arguments.
		 * @param {Number} args.index - The dataset index.
		 * @param {Object} args.meta - The dataset metadata.
		 * @param {Object} options - The plugin options.
		 */
		/**
		 * @method IPlugin#beforeLayout
		 * @desc Called before laying out `chart`. If any plugin returns `false`,
		 * the layout update is cancelled until another `update` is triggered.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {Object} options - The plugin options.
		 * @returns {Boolean} `false` to cancel the chart layout.
		 */
		/**
		 * @method IPlugin#afterLayout
		 * @desc Called after the `chart` has been layed out. Note that this hook will not
		 * be called if the layout update has been previously cancelled.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {Object} options - The plugin options.
		 */
		/**
		 * @method IPlugin#beforeRender
		 * @desc Called before rendering `chart`. If any plugin returns `false`,
		 * the rendering is cancelled until another `render` is triggered.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {Object} options - The plugin options.
		 * @returns {Boolean} `false` to cancel the chart rendering.
		 */
		/**
		 * @method IPlugin#afterRender
		 * @desc Called after the `chart` has been fully rendered (and animation completed). Note
		 * that this hook will not be called if the rendering has been previously cancelled.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {Object} options - The plugin options.
		 */
		/**
		 * @method IPlugin#beforeDraw
		 * @desc Called before drawing `chart` at every animation frame specified by the given
		 * easing value. If any plugin returns `false`, the frame drawing is cancelled until
		 * another `render` is triggered.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
		 * @param {Object} options - The plugin options.
		 * @returns {Boolean} `false` to cancel the chart drawing.
		 */
		/**
		 * @method IPlugin#afterDraw
		 * @desc Called after the `chart` has been drawn for the specific easing value. Note
		 * that this hook will not be called if the drawing has been previously cancelled.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
		 * @param {Object} options - The plugin options.
		 */
		/**
		 * @method IPlugin#beforeDatasetsDraw
		 * @desc Called before drawing the `chart` datasets. If any plugin returns `false`,
		 * the datasets drawing is cancelled until another `render` is triggered.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
		 * @param {Object} options - The plugin options.
		 * @returns {Boolean} `false` to cancel the chart datasets drawing.
		 */
		/**
		 * @method IPlugin#afterDatasetsDraw
		 * @desc Called after the `chart` datasets have been drawn. Note that this hook
		 * will not be called if the datasets drawing has been previously cancelled.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
		 * @param {Object} options - The plugin options.
		 */
		/**
		 * @method IPlugin#beforeDatasetDraw
		 * @desc Called before drawing the `chart` dataset at the given `args.index` (datasets
		 * are drawn in the reverse order). If any plugin returns `false`, the datasets drawing
		 * is cancelled until another `render` is triggered.
		 * @param {Chart} chart - The chart instance.
		 * @param {Object} args - The call arguments.
		 * @param {Number} args.index - The dataset index.
		 * @param {Object} args.meta - The dataset metadata.
		 * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.
		 * @param {Object} options - The plugin options.
		 * @returns {Boolean} `false` to cancel the chart datasets drawing.
		 */
		/**
		 * @method IPlugin#afterDatasetDraw
		 * @desc Called after the `chart` datasets at the given `args.index` have been drawn
		 * (datasets are drawn in the reverse order). Note that this hook will not be called
		 * if the datasets drawing has been previously cancelled.
		 * @param {Chart} chart - The chart instance.
		 * @param {Object} args - The call arguments.
		 * @param {Number} args.index - The dataset index.
		 * @param {Object} args.meta - The dataset metadata.
		 * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.
		 * @param {Object} options - The plugin options.
		 */
		/**
		 * @method IPlugin#beforeTooltipDraw
		 * @desc Called before drawing the `tooltip`. If any plugin returns `false`,
		 * the tooltip drawing is cancelled until another `render` is triggered.
		 * @param {Chart} chart - The chart instance.
		 * @param {Object} args - The call arguments.
		 * @param {Object} args.tooltip - The tooltip.
		 * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.
		 * @param {Object} options - The plugin options.
		 * @returns {Boolean} `false` to cancel the chart tooltip drawing.
		 */
		/**
		 * @method IPlugin#afterTooltipDraw
		 * @desc Called after drawing the `tooltip`. Note that this hook will not
		 * be called if the tooltip drawing has been previously cancelled.
		 * @param {Chart} chart - The chart instance.
		 * @param {Object} args - The call arguments.
		 * @param {Object} args.tooltip - The tooltip.
		 * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.
		 * @param {Object} options - The plugin options.
		 */
		/**
		 * @method IPlugin#beforeEvent
		 * @desc Called before processing the specified `event`. If any plugin returns `false`,
		 * the event will be discarded.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {IEvent} event - The event object.
		 * @param {Object} options - The plugin options.
		 */
		/**
		 * @method IPlugin#afterEvent
		 * @desc Called after the `event` has been consumed. Note that this hook
		 * will not be called if the `event` has been previously discarded.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {IEvent} event - The event object.
		 * @param {Object} options - The plugin options.
		 */
		/**
		 * @method IPlugin#resize
		 * @desc Called after the chart as been resized.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {Number} size - The new canvas display size (eq. canvas.style width & height).
		 * @param {Object} options - The plugin options.
		 */
		/**
		 * @method IPlugin#destroy
		 * @desc Called after the chart as been destroyed.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {Object} options - The plugin options.
		 */
		
		
		/***/
	}),
	
	/***/ "./node_modules/chart.js/src/core/core.scale.js":
	/*!******************************************************!*\
  !*** ./node_modules/chart.js/src/core/core.scale.js ***!
  \******************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		var defaults = __webpack_require__(/*! ./core.defaults */ "./node_modules/chart.js/src/core/core.defaults.js");
		var Element = __webpack_require__(/*! ./core.element */ "./node_modules/chart.js/src/core/core.element.js");
		var helpers = __webpack_require__(/*! ../helpers/index */ "./node_modules/chart.js/src/helpers/index.js");
		var Ticks = __webpack_require__(/*! ./core.ticks */ "./node_modules/chart.js/src/core/core.ticks.js");
		
		defaults._set('scale', {
			display: true,
			position: 'left',
			offset: false,
			
			// grid line settings
			gridLines: {
				display: true,
				color: 'rgba(0, 0, 0, 0.1)',
				lineWidth: 1,
				drawBorder: true,
				drawOnChartArea: true,
				drawTicks: true,
				tickMarkLength: 10,
				zeroLineWidth: 1,
				zeroLineColor: 'rgba(0,0,0,0.25)',
				zeroLineBorderDash: [],
				zeroLineBorderDashOffset: 0.0,
				offsetGridLines: false,
				borderDash: [],
				borderDashOffset: 0.0
			},
			
			// scale label
			scaleLabel: {
				// display property
				display: false,
				
				// actual label
				labelString: '',
				
				// line height
				lineHeight: 1.2,
				
				// top/bottom padding
				padding: {
					top: 4,
					bottom: 4
				}
			},
			
			// label settings
			ticks: {
				beginAtZero: false,
				minRotation: 0,
				maxRotation: 50,
				mirror: false,
				padding: 0,
				reverse: false,
				display: true,
				autoSkip: true,
				autoSkipPadding: 0,
				labelOffset: 0,
				// We pass through arrays to be rendered as multiline labels, we convert Others to strings here.
				callback: Ticks.formatters.values,
				minor: {},
				major: {}
			}
		});
		
		function labelsFromTicks(ticks) {
			var labels = [];
			var i, ilen;
			
			for(i = 0, ilen = ticks.length; i < ilen; ++i) {
				labels.push(ticks[i].label);
			}
			
			return labels;
		}
		
		function getLineValue(scale, index, offsetGridLines) {
			var lineValue = scale.getPixelForTick(index);
			
			if(offsetGridLines) {
				if(index === 0) {
					lineValue -= (scale.getPixelForTick(1) - lineValue) / 2;
				} else {
					lineValue -= (lineValue - scale.getPixelForTick(index - 1)) / 2;
				}
			}
			return lineValue;
		}
		
		function computeTextSize(context, tick, font) {
			return helpers.isArray(tick) ?
				helpers.longestText(context, font, tick) :
				context.measureText(tick).width;
		}
		
		function parseFontOptions(options) {
			var valueOrDefault = helpers.valueOrDefault;
			var globalDefaults = defaults.global;
			var size = valueOrDefault(options.fontSize, globalDefaults.defaultFontSize);
			var style = valueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle);
			var family = valueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily);
			
			return {
				size: size,
				style: style,
				family: family,
				font: helpers.fontString(size, style, family)
			};
		}
		
		function parseLineHeight(options) {
			return helpers.options.toLineHeight(
				helpers.valueOrDefault(options.lineHeight, 1.2),
				helpers.valueOrDefault(options.fontSize, defaults.global.defaultFontSize));
		}
		
		module.exports = Element.extend({
			/**
			 * Get the padding needed for the scale
			 * @method getPadding
			 * @private
			 * @returns {Padding} the necessary padding
			 */
			getPadding: function() {
				var me = this;
				return {
					left: me.paddingLeft || 0,
					top: me.paddingTop || 0,
					right: me.paddingRight || 0,
					bottom: me.paddingBottom || 0
				};
			},
			
			/**
			 * Returns the scale tick objects ({label, major})
			 * @since 2.7
			 */
			getTicks: function() {
				return this._ticks;
			},
			
			// These methods are ordered by lifecyle. Utilities then follow.
			// Any function defined here is inherited by all scale types.
			// Any function can be extended by the scale type
			
			mergeTicksOptions: function() {
				var ticks = this.options.ticks;
				if(ticks.minor === false) {
					ticks.minor = {
						display: false
					};
				}
				if(ticks.major === false) {
					ticks.major = {
						display: false
					};
				}
				for(var key in ticks) {
					if(key !== 'major' && key !== 'minor') {
						if(typeof ticks.minor[key] === 'undefined') {
							ticks.minor[key] = ticks[key];
						}
						if(typeof ticks.major[key] === 'undefined') {
							ticks.major[key] = ticks[key];
						}
					}
				}
			},
			beforeUpdate: function() {
				helpers.callback(this.options.beforeUpdate, [this]);
			},
			
			update: function(maxWidth, maxHeight, margins) {
				var me = this;
				var i, ilen, labels, label, ticks, tick;
				
				// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)
				me.beforeUpdate();
				
				// Absorb the master measurements
				me.maxWidth = maxWidth;
				me.maxHeight = maxHeight;
				me.margins = helpers.extend({
					left: 0,
					right: 0,
					top: 0,
					bottom: 0
				}, margins);
				me.longestTextCache = me.longestTextCache || {};
				
				// Dimensions
				me.beforeSetDimensions();
				me.setDimensions();
				me.afterSetDimensions();
				
				// Data min/max
				me.beforeDataLimits();
				me.determineDataLimits();
				me.afterDataLimits();
				
				// Ticks - `this.ticks` is now DEPRECATED!
				// Internal ticks are now stored as objects in the PRIVATE `this._ticks` member
				// and must not be accessed directly from outside this class. `this.ticks` being
				// around for long time and not marked as private, we can't change its structure
				// without unexpected breaking changes. If you need to access the scale ticks,
				// use scale.getTicks() instead.
				
				me.beforeBuildTicks();
				
				// New implementations should return an array of objects but for BACKWARD COMPAT,
				// we still support no return (`this.ticks` internally set by calling this method).
				ticks = me.buildTicks() || [];
				
				me.afterBuildTicks();
				
				me.beforeTickToLabelConversion();
				
				// New implementations should return the formatted tick labels but for BACKWARD
				// COMPAT, we still support no return (`this.ticks` internally changed by calling
				// this method and supposed to contain only string values).
				labels = me.convertTicksToLabels(ticks) || me.ticks;
				
				me.afterTickToLabelConversion();
				
				me.ticks = labels;   // BACKWARD COMPATIBILITY
				
				// IMPORTANT: from this point, we consider that `this.ticks` will NEVER change!
				
				// BACKWARD COMPAT: synchronize `_ticks` with labels (so potentially `this.ticks`)
				for(i = 0, ilen = labels.length; i < ilen; ++i) {
					label = labels[i];
					tick = ticks[i];
					if(!tick) {
						ticks.push(tick = {
							label: label,
							major: false
						});
					} else {
						tick.label = label;
					}
				}
				
				me._ticks = ticks;
				
				// Tick Rotation
				me.beforeCalculateTickRotation();
				me.calculateTickRotation();
				me.afterCalculateTickRotation();
				// Fit
				me.beforeFit();
				me.fit();
				me.afterFit();
				//
				me.afterUpdate();
				
				return me.minSize;
				
			},
			afterUpdate: function() {
				helpers.callback(this.options.afterUpdate, [this]);
			},
			
			//
			
			beforeSetDimensions: function() {
				helpers.callback(this.options.beforeSetDimensions, [this]);
			},
			setDimensions: function() {
				var me = this;
				// Set the unconstrained dimension before label rotation
				if(me.isHorizontal()) {
					// Reset position before calculating rotation
					me.width = me.maxWidth;
					me.left = 0;
					me.right = me.width;
				} else {
					me.height = me.maxHeight;
					
					// Reset position before calculating rotation
					me.top = 0;
					me.bottom = me.height;
				}
				
				// Reset padding
				me.paddingLeft = 0;
				me.paddingTop = 0;
				me.paddingRight = 0;
				me.paddingBottom = 0;
			},
			afterSetDimensions: function() {
				helpers.callback(this.options.afterSetDimensions, [this]);
			},
			
			// Data limits
			beforeDataLimits: function() {
				helpers.callback(this.options.beforeDataLimits, [this]);
			},
			determineDataLimits: helpers.noop,
			afterDataLimits: function() {
				helpers.callback(this.options.afterDataLimits, [this]);
			},
			
			//
			beforeBuildTicks: function() {
				helpers.callback(this.options.beforeBuildTicks, [this]);
			},
			buildTicks: helpers.noop,
			afterBuildTicks: function() {
				helpers.callback(this.options.afterBuildTicks, [this]);
			},
			
			beforeTickToLabelConversion: function() {
				helpers.callback(this.options.beforeTickToLabelConversion, [this]);
			},
			convertTicksToLabels: function() {
				var me = this;
				// Convert ticks to strings
				var tickOpts = me.options.ticks;
				me.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback, this);
			},
			afterTickToLabelConversion: function() {
				helpers.callback(this.options.afterTickToLabelConversion, [this]);
			},
			
			//
			
			beforeCalculateTickRotation: function() {
				helpers.callback(this.options.beforeCalculateTickRotation, [this]);
			},
			calculateTickRotation: function() {
				var me = this;
				var context = me.ctx;
				var tickOpts = me.options.ticks;
				var labels = labelsFromTicks(me._ticks);
				
				// Get the width of each grid by calculating the difference
				// between x offsets between 0 and 1.
				var tickFont = parseFontOptions(tickOpts);
				context.font = tickFont.font;
				
				var labelRotation = tickOpts.minRotation || 0;
				
				if(labels.length && me.options.display && me.isHorizontal()) {
					var originalLabelWidth = helpers.longestText(context, tickFont.font, labels, me.longestTextCache);
					var labelWidth = originalLabelWidth;
					var cosRotation, sinRotation;
					
					// Allow 3 pixels x2 padding either side for label readability
					var tickWidth = me.getPixelForTick(1) - me.getPixelForTick(0) - 6;
					
					// Max label rotation can be set or default to 90 - also act as a loop counter
					while(labelWidth > tickWidth && labelRotation < tickOpts.maxRotation) {
						var angleRadians = helpers.toRadians(labelRotation);
						cosRotation = Math.cos(angleRadians);
						sinRotation = Math.sin(angleRadians);
						
						if(sinRotation * originalLabelWidth > me.maxHeight) {
							// go back one step
							labelRotation--;
							break;
						}
						
						labelRotation++;
						labelWidth = cosRotation * originalLabelWidth;
					}
				}
				
				me.labelRotation = labelRotation;
			},
			afterCalculateTickRotation: function() {
				helpers.callback(this.options.afterCalculateTickRotation, [this]);
			},
			
			//
			
			beforeFit: function() {
				helpers.callback(this.options.beforeFit, [this]);
			},
			fit: function() {
				var me = this;
				// Reset
				var minSize = me.minSize = {
					width: 0,
					height: 0
				};
				
				var labels = labelsFromTicks(me._ticks);
				
				var opts = me.options;
				var tickOpts = opts.ticks;
				var scaleLabelOpts = opts.scaleLabel;
				var gridLineOpts = opts.gridLines;
				var display = opts.display;
				var isHorizontal = me.isHorizontal();
				
				var tickFont = parseFontOptions(tickOpts);
				var tickMarkLength = opts.gridLines.tickMarkLength;
				
				// Width
				if(isHorizontal) {
					// subtract the margins to line up with the chartArea if we are a full width scale
					minSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;
				} else {
					minSize.width = display && gridLineOpts.drawTicks ? tickMarkLength : 0;
				}
				
				// height
				if(isHorizontal) {
					minSize.height = display && gridLineOpts.drawTicks ? tickMarkLength : 0;
				} else {
					minSize.height = me.maxHeight; // fill all the height
				}
				
				// Are we showing a title for the scale?
				if(scaleLabelOpts.display && display) {
					var scaleLabelLineHeight = parseLineHeight(scaleLabelOpts);
					var scaleLabelPadding = helpers.options.toPadding(scaleLabelOpts.padding);
					var deltaHeight = scaleLabelLineHeight + scaleLabelPadding.height;
					
					if(isHorizontal) {
						minSize.height += deltaHeight;
					} else {
						minSize.width += deltaHeight;
					}
				}
				
				// Don't bother fitting the ticks if we are not showing them
				if(tickOpts.display && display) {
					var largestTextWidth = helpers.longestText(me.ctx, tickFont.font, labels, me.longestTextCache);
					var tallestLabelHeightInLines = helpers.numberOfLabelLines(labels);
					var lineSpace = tickFont.size * 0.5;
					var tickPadding = me.options.ticks.padding;
					
					if(isHorizontal) {
						// A horizontal axis is more constrained by the height.
						me.longestLabelWidth = largestTextWidth;
						
						var angleRadians = helpers.toRadians(me.labelRotation);
						var cosRotation = Math.cos(angleRadians);
						var sinRotation = Math.sin(angleRadians);
						
						// TODO - improve this calculation
						var labelHeight = (sinRotation * largestTextWidth)
							+ (tickFont.size * tallestLabelHeightInLines)
							+ (lineSpace * (tallestLabelHeightInLines - 1))
							+ lineSpace; // padding
						
						minSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);
						
						me.ctx.font = tickFont.font;
						var firstLabelWidth = computeTextSize(me.ctx, labels[0], tickFont.font);
						var lastLabelWidth = computeTextSize(me.ctx, labels[labels.length - 1], tickFont.font);
						
						// Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned
						// which means that the right padding is dominated by the font height
						if(me.labelRotation !== 0) {
							me.paddingLeft = opts.position === 'bottom' ? (cosRotation * firstLabelWidth) + 3 : (cosRotation * lineSpace) + 3; // add 3 px to move away from canvas edges
							me.paddingRight = opts.position === 'bottom' ? (cosRotation * lineSpace) + 3 : (cosRotation * lastLabelWidth) + 3;
						} else {
							me.paddingLeft = firstLabelWidth / 2 + 3; // add 3 px to move away from canvas edges
							me.paddingRight = lastLabelWidth / 2 + 3;
						}
					} else {
						// A vertical axis is more constrained by the width. Labels are the
						// dominant factor here, so get that length first and account for padding
						if(tickOpts.mirror) {
							largestTextWidth = 0;
						} else {
							// use lineSpace for consistency with horizontal axis
							// tickPadding is not implemented for horizontal
							largestTextWidth += tickPadding + lineSpace;
						}
						
						minSize.width = Math.min(me.maxWidth, minSize.width + largestTextWidth);
						
						me.paddingTop = tickFont.size / 2;
						me.paddingBottom = tickFont.size / 2;
					}
				}
				
				me.handleMargins();
				
				me.width = minSize.width;
				me.height = minSize.height;
			},
			
			/**
			 * Handle margins and padding interactions
			 * @private
			 */
			handleMargins: function() {
				var me = this;
				if(me.margins) {
					me.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);
					me.paddingTop = Math.max(me.paddingTop - me.margins.top, 0);
					me.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);
					me.paddingBottom = Math.max(me.paddingBottom - me.margins.bottom, 0);
				}
			},
			
			afterFit: function() {
				helpers.callback(this.options.afterFit, [this]);
			},
			
			// Shared Methods
			isHorizontal: function() {
				return this.options.position === 'top' || this.options.position === 'bottom';
			},
			isFullWidth: function() {
				return (this.options.fullWidth);
			},
			
			// Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not
			getRightValue: function(rawValue) {
				// Null and undefined values first
				if(helpers.isNullOrUndef(rawValue)) {
					return NaN;
				}
				// isNaN(object) returns true, so make sure NaN is checking for a number; Discard Infinite values
				if(typeof rawValue === 'number' && !isFinite(rawValue)) {
					return NaN;
				}
				// If it is in fact an object, dive in one more level
				if(rawValue) {
					if(this.isHorizontal()) {
						if(rawValue.x !== undefined) {
							return this.getRightValue(rawValue.x);
						}
					} else if(rawValue.y !== undefined) {
						return this.getRightValue(rawValue.y);
					}
				}
				
				// Value is good, return it
				return rawValue;
			},
			
			/**
			 * Used to get the value to display in the tooltip for the data at the given index
			 * @param index
			 * @param datasetIndex
			 */
			getLabelForIndex: helpers.noop,
			
			/**
			 * Returns the location of the given data point. Value can either be an index or a numerical value
			 * The coordinate (0, 0) is at the upper-left corner of the canvas
			 * @param value
			 * @param index
			 * @param datasetIndex
			 */
			getPixelForValue: helpers.noop,
			
			/**
			 * Used to get the data value from a given pixel. This is the inverse of getPixelForValue
			 * The coordinate (0, 0) is at the upper-left corner of the canvas
			 * @param pixel
			 */
			getValueForPixel: helpers.noop,
			
			/**
			 * Returns the location of the tick at the given index
			 * The coordinate (0, 0) is at the upper-left corner of the canvas
			 */
			getPixelForTick: function(index) {
				var me = this;
				var offset = me.options.offset;
				if(me.isHorizontal()) {
					var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
					var tickWidth = innerWidth / Math.max((me._ticks.length - (offset ? 0 : 1)), 1);
					var pixel = (tickWidth * index) + me.paddingLeft;
					
					if(offset) {
						pixel += tickWidth / 2;
					}
					
					var finalVal = me.left + Math.round(pixel);
					finalVal += me.isFullWidth() ? me.margins.left : 0;
					return finalVal;
				}
				var innerHeight = me.height - (me.paddingTop + me.paddingBottom);
				return me.top + (index * (innerHeight / (me._ticks.length - 1)));
			},
			
			/**
			 * Utility for getting the pixel location of a percentage of scale
			 * The coordinate (0, 0) is at the upper-left corner of the canvas
			 */
			getPixelForDecimal: function(decimal) {
				var me = this;
				if(me.isHorizontal()) {
					var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
					var valueOffset = (innerWidth * decimal) + me.paddingLeft;
					
					var finalVal = me.left + Math.round(valueOffset);
					finalVal += me.isFullWidth() ? me.margins.left : 0;
					return finalVal;
				}
				return me.top + (decimal * me.height);
			},
			
			/**
			 * Returns the pixel for the minimum chart value
			 * The coordinate (0, 0) is at the upper-left corner of the canvas
			 */
			getBasePixel: function() {
				return this.getPixelForValue(this.getBaseValue());
			},
			
			getBaseValue: function() {
				var me = this;
				var min = me.min;
				var max = me.max;
				
				return me.beginAtZero ? 0 :
					min < 0 && max < 0 ? max :
						min > 0 && max > 0 ? min :
							0;
			},
			
			/**
			 * Returns a subset of ticks to be plotted to avoid overlapping labels.
			 * @private
			 */
			_autoSkip: function(ticks) {
				var skipRatio;
				var me = this;
				var isHorizontal = me.isHorizontal();
				var optionTicks = me.options.ticks.minor;
				var tickCount = ticks.length;
				var labelRotationRadians = helpers.toRadians(me.labelRotation);
				var cosRotation = Math.cos(labelRotationRadians);
				var longestRotatedLabel = me.longestLabelWidth * cosRotation;
				var result = [];
				var i, tick, shouldSkip;
				
				// figure out the maximum number of gridlines to show
				var maxTicks;
				if(optionTicks.maxTicksLimit) {
					maxTicks = optionTicks.maxTicksLimit;
				}
				
				if(isHorizontal) {
					skipRatio = false;
					
					if((longestRotatedLabel + optionTicks.autoSkipPadding) * tickCount > (me.width - (me.paddingLeft + me.paddingRight))) {
						skipRatio = 1 + Math.floor(((longestRotatedLabel + optionTicks.autoSkipPadding) * tickCount) / (me.width - (me.paddingLeft + me.paddingRight)));
					}
					
					// if they defined a max number of optionTicks,
					// increase skipRatio until that number is met
					if(maxTicks && tickCount > maxTicks) {
						skipRatio = Math.max(skipRatio, Math.floor(tickCount / maxTicks));
					}
				}
				
				for(i = 0; i < tickCount; i++) {
					tick = ticks[i];
					
					// Since we always show the last tick,we need may need to hide the last shown one before
					shouldSkip = (skipRatio > 1 && i % skipRatio > 0) || (i % skipRatio === 0 && i + skipRatio >= tickCount);
					if(shouldSkip && i !== tickCount - 1) {
						// leave tick in place but make sure it's not displayed (#4635)
						delete tick.label;
					}
					result.push(tick);
				}
				return result;
			},
			
			// Actually draw the scale on the canvas
			// @param {rectangle} chartArea : the area of the chart to draw full grid lines on
			draw: function(chartArea) {
				var me = this;
				var options = me.options;
				if(!options.display) {
					return;
				}
				
				var context = me.ctx;
				var globalDefaults = defaults.global;
				var optionTicks = options.ticks.minor;
				var optionMajorTicks = options.ticks.major || optionTicks;
				var gridLines = options.gridLines;
				var scaleLabel = options.scaleLabel;
				
				var isRotated = me.labelRotation !== 0;
				var isHorizontal = me.isHorizontal();
				
				var ticks = optionTicks.autoSkip ? me._autoSkip(me.getTicks()) : me.getTicks();
				var tickFontColor = helpers.valueOrDefault(optionTicks.fontColor, globalDefaults.defaultFontColor);
				var tickFont = parseFontOptions(optionTicks);
				var majorTickFontColor = helpers.valueOrDefault(optionMajorTicks.fontColor, globalDefaults.defaultFontColor);
				var majorTickFont = parseFontOptions(optionMajorTicks);
				
				var tl = gridLines.drawTicks ? gridLines.tickMarkLength : 0;
				
				var scaleLabelFontColor = helpers.valueOrDefault(scaleLabel.fontColor, globalDefaults.defaultFontColor);
				var scaleLabelFont = parseFontOptions(scaleLabel);
				var scaleLabelPadding = helpers.options.toPadding(scaleLabel.padding);
				var labelRotationRadians = helpers.toRadians(me.labelRotation);
				
				var itemsToDraw = [];
				
				var axisWidth = me.options.gridLines.lineWidth;
				var xTickStart = options.position === 'right' ? me.left : me.right - axisWidth - tl;
				var xTickEnd = options.position === 'right' ? me.left + tl : me.right;
				var yTickStart = options.position === 'bottom' ? me.top + axisWidth : me.bottom - tl - axisWidth;
				var yTickEnd = options.position === 'bottom' ? me.top + axisWidth + tl : me.bottom + axisWidth;
				
				helpers.each(ticks, function(tick, index) {
					// autoskipper skipped this tick (#4635)
					if(helpers.isNullOrUndef(tick.label)) {
						return;
					}
					
					var label = tick.label;
					var lineWidth, lineColor, borderDash, borderDashOffset;
					if(index === me.zeroLineIndex && options.offset === gridLines.offsetGridLines) {
						// Draw the first index specially
						lineWidth = gridLines.zeroLineWidth;
						lineColor = gridLines.zeroLineColor;
						borderDash = gridLines.zeroLineBorderDash;
						borderDashOffset = gridLines.zeroLineBorderDashOffset;
					} else {
						lineWidth = helpers.valueAtIndexOrDefault(gridLines.lineWidth, index);
						lineColor = helpers.valueAtIndexOrDefault(gridLines.color, index);
						borderDash = helpers.valueOrDefault(gridLines.borderDash, globalDefaults.borderDash);
						borderDashOffset = helpers.valueOrDefault(gridLines.borderDashOffset, globalDefaults.borderDashOffset);
					}
					
					// Common properties
					var tx1, ty1, tx2, ty2, x1, y1, x2, y2, labelX, labelY;
					var textAlign = 'middle';
					var textBaseline = 'middle';
					var tickPadding = optionTicks.padding;
					
					if(isHorizontal) {
						var labelYOffset = tl + tickPadding;
						
						if(options.position === 'bottom') {
							// bottom
							textBaseline = !isRotated ? 'top' : 'middle';
							textAlign = !isRotated ? 'center' : 'right';
							labelY = me.top + labelYOffset;
						} else {
							// top
							textBaseline = !isRotated ? 'bottom' : 'middle';
							textAlign = !isRotated ? 'center' : 'left';
							labelY = me.bottom - labelYOffset;
						}
						
						var xLineValue = getLineValue(me, index, gridLines.offsetGridLines && ticks.length > 1);
						if(xLineValue < me.left) {
							lineColor = 'rgba(0,0,0,0)';
						}
						xLineValue += helpers.aliasPixel(lineWidth);
						
						labelX = me.getPixelForTick(index) + optionTicks.labelOffset; // x values for optionTicks (need to consider offsetLabel option)
						
						tx1 = tx2 = x1 = x2 = xLineValue;
						ty1 = yTickStart;
						ty2 = yTickEnd;
						y1 = chartArea.top;
						y2 = chartArea.bottom + axisWidth;
					} else {
						var isLeft = options.position === 'left';
						var labelXOffset;
						
						if(optionTicks.mirror) {
							textAlign = isLeft ? 'left' : 'right';
							labelXOffset = tickPadding;
						} else {
							textAlign = isLeft ? 'right' : 'left';
							labelXOffset = tl + tickPadding;
						}
						
						labelX = isLeft ? me.right - labelXOffset : me.left + labelXOffset;
						
						var yLineValue = getLineValue(me, index, gridLines.offsetGridLines && ticks.length > 1);
						if(yLineValue < me.top) {
							lineColor = 'rgba(0,0,0,0)';
						}
						yLineValue += helpers.aliasPixel(lineWidth);
						
						labelY = me.getPixelForTick(index) + optionTicks.labelOffset;
						
						tx1 = xTickStart;
						tx2 = xTickEnd;
						x1 = chartArea.left;
						x2 = chartArea.right + axisWidth;
						ty1 = ty2 = y1 = y2 = yLineValue;
					}
					
					itemsToDraw.push({
						tx1: tx1,
						ty1: ty1,
						tx2: tx2,
						ty2: ty2,
						x1: x1,
						y1: y1,
						x2: x2,
						y2: y2,
						labelX: labelX,
						labelY: labelY,
						glWidth: lineWidth,
						glColor: lineColor,
						glBorderDash: borderDash,
						glBorderDashOffset: borderDashOffset,
						rotation: -1 * labelRotationRadians,
						label: label,
						major: tick.major,
						textBaseline: textBaseline,
						textAlign: textAlign
					});
				});
				
				// Draw all of the tick labels, tick marks, and grid lines at the correct places
				helpers.each(itemsToDraw, function(itemToDraw) {
					if(gridLines.display) {
						context.save();
						context.lineWidth = itemToDraw.glWidth;
						context.strokeStyle = itemToDraw.glColor;
						if(context.setLineDash) {
							context.setLineDash(itemToDraw.glBorderDash);
							context.lineDashOffset = itemToDraw.glBorderDashOffset;
						}
						
						context.beginPath();
						
						if(gridLines.drawTicks) {
							context.moveTo(itemToDraw.tx1, itemToDraw.ty1);
							context.lineTo(itemToDraw.tx2, itemToDraw.ty2);
						}
						
						if(gridLines.drawOnChartArea) {
							context.moveTo(itemToDraw.x1, itemToDraw.y1);
							context.lineTo(itemToDraw.x2, itemToDraw.y2);
						}
						
						context.stroke();
						context.restore();
					}
					
					if(optionTicks.display) {
						// Make sure we draw text in the correct color and font
						context.save();
						context.translate(itemToDraw.labelX, itemToDraw.labelY);
						context.rotate(itemToDraw.rotation);
						context.font = itemToDraw.major ? majorTickFont.font : tickFont.font;
						context.fillStyle = itemToDraw.major ? majorTickFontColor : tickFontColor;
						context.textBaseline = itemToDraw.textBaseline;
						context.textAlign = itemToDraw.textAlign;
						
						var label = itemToDraw.label;
						if(helpers.isArray(label)) {
							var lineCount = label.length;
							var lineHeight = tickFont.size * 1.5;
							var y = me.isHorizontal() ? 0 : -lineHeight * (lineCount - 1) / 2;
							
							for(var i = 0; i < lineCount; ++i) {
								// We just make sure the multiline element is a string here..
								context.fillText('' + label[i], 0, y);
								// apply same lineSpacing as calculated @ L#320
								y += lineHeight;
							}
						} else {
							context.fillText(label, 0, 0);
						}
						context.restore();
					}
				});
				
				if(scaleLabel.display) {
					// Draw the scale label
					var scaleLabelX;
					var scaleLabelY;
					var rotation = 0;
					var halfLineHeight = parseLineHeight(scaleLabel) / 2;
					
					if(isHorizontal) {
						scaleLabelX = me.left + ((me.right - me.left) / 2); // midpoint of the width
						scaleLabelY = options.position === 'bottom'
							? me.bottom - halfLineHeight - scaleLabelPadding.bottom
							: me.top + halfLineHeight + scaleLabelPadding.top;
					} else {
						var isLeft = options.position === 'left';
						scaleLabelX = isLeft
							? me.left + halfLineHeight + scaleLabelPadding.top
							: me.right - halfLineHeight - scaleLabelPadding.top;
						scaleLabelY = me.top + ((me.bottom - me.top) / 2);
						rotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;
					}
					
					context.save();
					context.translate(scaleLabelX, scaleLabelY);
					context.rotate(rotation);
					context.textAlign = 'center';
					context.textBaseline = 'middle';
					context.fillStyle = scaleLabelFontColor; // render in correct colour
					context.font = scaleLabelFont.font;
					context.fillText(scaleLabel.labelString, 0, 0);
					context.restore();
				}
				
				if(gridLines.drawBorder) {
					// Draw the line at the edge of the axis
					context.lineWidth = helpers.valueAtIndexOrDefault(gridLines.lineWidth, 0);
					context.strokeStyle = helpers.valueAtIndexOrDefault(gridLines.color, 0);
					var x1 = me.left;
					var x2 = me.right + axisWidth;
					var y1 = me.top;
					var y2 = me.bottom + axisWidth;
					
					var aliasPixel = helpers.aliasPixel(context.lineWidth);
					if(isHorizontal) {
						y1 = y2 = options.position === 'top' ? me.bottom : me.top;
						y1 += aliasPixel;
						y2 += aliasPixel;
					} else {
						x1 = x2 = options.position === 'left' ? me.right : me.left;
						x1 += aliasPixel;
						x2 += aliasPixel;
					}
					
					context.beginPath();
					context.moveTo(x1, y1);
					context.lineTo(x2, y2);
					context.stroke();
				}
			}
		});
		
		
		/***/
	}),
	
	/***/ "./node_modules/chart.js/src/core/core.scaleService.js":
	/*!*************************************************************!*\
  !*** ./node_modules/chart.js/src/core/core.scaleService.js ***!
  \*************************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		var defaults = __webpack_require__(/*! ./core.defaults */ "./node_modules/chart.js/src/core/core.defaults.js");
		var helpers = __webpack_require__(/*! ../helpers/index */ "./node_modules/chart.js/src/helpers/index.js");
		var layouts = __webpack_require__(/*! ./core.layouts */ "./node_modules/chart.js/src/core/core.layouts.js");
		
		module.exports = {
			// Scale registration object. Extensions can register new scale types (such as log or DB scales) and then
			// use the new chart options to grab the correct scale
			constructors: {},
			// Use a registration function so that we can move to an ES6 map when we no longer need to support
			// old browsers
			
			// Scale config defaults
			defaults: {},
			registerScaleType: function(type, scaleConstructor, scaleDefaults) {
				this.constructors[type] = scaleConstructor;
				this.defaults[type] = helpers.clone(scaleDefaults);
			},
			getScaleConstructor: function(type) {
				return this.constructors.hasOwnProperty(type) ? this.constructors[type] : undefined;
			},
			getScaleDefaults: function(type) {
				// Return the scale defaults merged with the global settings so that we always use the latest ones
				return this.defaults.hasOwnProperty(type) ? helpers.merge({}, [defaults.scale, this.defaults[type]]) : {};
			},
			updateScaleDefaults: function(type, additions) {
				var me = this;
				if(me.defaults.hasOwnProperty(type)) {
					me.defaults[type] = helpers.extend(me.defaults[type], additions);
				}
			},
			addScalesToLayout: function(chart) {
				// Adds each scale to the chart.boxes array to be sized accordingly
				helpers.each(chart.scales, function(scale) {
					// Set ILayoutItem parameters for backwards compatibility
					scale.fullWidth = scale.options.fullWidth;
					scale.position = scale.options.position;
					scale.weight = scale.options.weight;
					layouts.addBox(chart, scale);
				});
			}
		};
		
		
		/***/
	}),
	
	/***/ "./node_modules/chart.js/src/core/core.ticks.js":
	/*!******************************************************!*\
  !*** ./node_modules/chart.js/src/core/core.ticks.js ***!
  \******************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		var helpers = __webpack_require__(/*! ../helpers/index */ "./node_modules/chart.js/src/helpers/index.js");
		
		/**
		 * Namespace to hold static tick generation functions
		 * @namespace Chart.Ticks
		 */
		module.exports = {
			/**
			 * Namespace to hold formatters for different types of ticks
			 * @namespace Chart.Ticks.formatters
			 */
			formatters: {
				/**
				 * Formatter for value labels
				 * @method Chart.Ticks.formatters.values
				 * @param value the value to display
				 * @return {String|Array} the label to display
				 */
				values: function(value) {
					return helpers.isArray(value) ? value : '' + value;
				},
				
				/**
				 * Formatter for linear numeric ticks
				 * @method Chart.Ticks.formatters.linear
				 * @param tickValue {Number} the value to be formatted
				 * @param index {Number} the position of the tickValue parameter in the ticks array
				 * @param ticks {Array<Number>} the list of ticks being converted
				 * @return {String} string representation of the tickValue parameter
				 */
				linear: function(tickValue, index, ticks) {
					// If we have lots of ticks, don't use the ones
					var delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];
					
					// If we have a number like 2.5 as the delta, figure out how many decimal places we need
					if(Math.abs(delta) > 1) {
						if(tickValue !== Math.floor(tickValue)) {
							// not an integer
							delta = tickValue - Math.floor(tickValue);
						}
					}
					
					var logDelta = helpers.log10(Math.abs(delta));
					var tickString = '';
					
					if(tickValue !== 0) {
						var maxTick = Math.max(Math.abs(ticks[0]), Math.abs(ticks[ticks.length - 1]));
						if(maxTick < 1e-4) { // all ticks are small numbers; use scientific notation
							var logTick = helpers.log10(Math.abs(tickValue));
							tickString = tickValue.toExponential(Math.floor(logTick) - Math.floor(logDelta));
						} else {
							var numDecimal = -1 * Math.floor(logDelta);
							numDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places
							tickString = tickValue.toFixed(numDecimal);
						}
					} else {
						tickString = '0'; // never show decimal places for 0
					}
					
					return tickString;
				},
				
				logarithmic: function(tickValue, index, ticks) {
					var remain = tickValue / (Math.pow(10, Math.floor(helpers.log10(tickValue))));
					
					if(tickValue === 0) {
						return '0';
					} else if(remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {
						return tickValue.toExponential();
					}
					return '';
				}
			}
		};
		
		
		/***/
	}),
	
	/***/ "./node_modules/chart.js/src/core/core.tooltip.js":
	/*!********************************************************!*\
  !*** ./node_modules/chart.js/src/core/core.tooltip.js ***!
  \********************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		var defaults = __webpack_require__(/*! ./core.defaults */ "./node_modules/chart.js/src/core/core.defaults.js");
		var Element = __webpack_require__(/*! ./core.element */ "./node_modules/chart.js/src/core/core.element.js");
		var helpers = __webpack_require__(/*! ../helpers/index */ "./node_modules/chart.js/src/helpers/index.js");
		
		defaults._set('global', {
			tooltips: {
				enabled: true,
				custom: null,
				mode: 'nearest',
				position: 'average',
				intersect: true,
				backgroundColor: 'rgba(0,0,0,0.8)',
				titleFontStyle: 'bold',
				titleSpacing: 2,
				titleMarginBottom: 6,
				titleFontColor: '#fff',
				titleAlign: 'left',
				bodySpacing: 2,
				bodyFontColor: '#fff',
				bodyAlign: 'left',
				footerFontStyle: 'bold',
				footerSpacing: 2,
				footerMarginTop: 6,
				footerFontColor: '#fff',
				footerAlign: 'left',
				yPadding: 6,
				xPadding: 6,
				caretPadding: 2,
				caretSize: 5,
				cornerRadius: 6,
				multiKeyBackground: '#fff',
				displayColors: true,
				borderColor: 'rgba(0,0,0,0)',
				borderWidth: 0,
				callbacks: {
					// Args are: (tooltipItems, data)
					beforeTitle: helpers.noop,
					title: function(tooltipItems, data) {
						// Pick first xLabel for now
						var title = '';
						var labels = data.labels;
						var labelCount = labels ? labels.length : 0;
						
						if(tooltipItems.length > 0) {
							var item = tooltipItems[0];
							
							if(item.xLabel) {
								title = item.xLabel;
							} else if(labelCount > 0 && item.index < labelCount) {
								title = labels[item.index];
							}
						}
						
						return title;
					},
					afterTitle: helpers.noop,
					
					// Args are: (tooltipItems, data)
					beforeBody: helpers.noop,
					
					// Args are: (tooltipItem, data)
					beforeLabel: helpers.noop,
					label: function(tooltipItem, data) {
						var label = data.datasets[tooltipItem.datasetIndex].label || '';
						
						if(label) {
							label += ': ';
						}
						label += tooltipItem.yLabel;
						return label;
					},
					labelColor: function(tooltipItem, chart) {
						var meta = chart.getDatasetMeta(tooltipItem.datasetIndex);
						var activeElement = meta.data[tooltipItem.index];
						var view = activeElement._view;
						return {
							borderColor: view.borderColor,
							backgroundColor: view.backgroundColor
						};
					},
					labelTextColor: function() {
						return this._options.bodyFontColor;
					},
					afterLabel: helpers.noop,
					
					// Args are: (tooltipItems, data)
					afterBody: helpers.noop,
					
					// Args are: (tooltipItems, data)
					beforeFooter: helpers.noop,
					footer: helpers.noop,
					afterFooter: helpers.noop
				}
			}
		});
		
		var positioners = {
			/**
			 * Average mode places the tooltip at the average position of the elements shown
			 * @function Chart.Tooltip.positioners.average
			 * @param elements {ChartElement[]} the elements being displayed in the tooltip
			 * @returns {Point} tooltip position
			 */
			average: function(elements) {
				if(!elements.length) {
					return false;
				}
				
				var i, len;
				var x = 0;
				var y = 0;
				var count = 0;
				
				for(i = 0, len = elements.length; i < len; ++i) {
					var el = elements[i];
					if(el && el.hasValue()) {
						var pos = el.tooltipPosition();
						x += pos.x;
						y += pos.y;
						++count;
					}
				}
				
				return {
					x: Math.round(x / count),
					y: Math.round(y / count)
				};
			},
			
			/**
			 * Gets the tooltip position nearest of the item nearest to the event position
			 * @function Chart.Tooltip.positioners.nearest
			 * @param elements {Chart.Element[]} the tooltip elements
			 * @param eventPosition {Point} the position of the event in canvas coordinates
			 * @returns {Point} the tooltip position
			 */
			nearest: function(elements, eventPosition) {
				var x = eventPosition.x;
				var y = eventPosition.y;
				var minDistance = Number.POSITIVE_INFINITY;
				var i, len, nearestElement;
				
				for(i = 0, len = elements.length; i < len; ++i) {
					var el = elements[i];
					if(el && el.hasValue()) {
						var center = el.getCenterPoint();
						var d = helpers.distanceBetweenPoints(eventPosition, center);
						
						if(d < minDistance) {
							minDistance = d;
							nearestElement = el;
						}
					}
				}
				
				if(nearestElement) {
					var tp = nearestElement.tooltipPosition();
					x = tp.x;
					y = tp.y;
				}
				
				return {
					x: x,
					y: y
				};
			}
		};
		
		/**
		 * Helper method to merge the opacity into a color
		 */
		function mergeOpacity(colorString, opacity) {
			var color = helpers.color(colorString);
			return color.alpha(opacity * color.alpha()).rgbaString();
		}

// Helper to push or concat based on if the 2nd parameter is an array or not
		function pushOrConcat(base, toPush) {
			if(toPush) {
				if(helpers.isArray(toPush)) {
					// base = base.concat(toPush);
					Array.prototype.push.apply(base, toPush);
				} else {
					base.push(toPush);
				}
			}
			
			return base;
		}
		
		/**
		 * Returns array of strings split by newline
		 * @param {String} value - The value to split by newline.
		 * @returns {Array} value if newline present - Returned from String split() method
		 * @function
		 */
		function splitNewlines(str) {
			if((typeof str === 'string' || str instanceof String) && str.indexOf('\n') > -1) {
				return str.split('\n');
			}
			return str;
		}


// Private helper to create a tooltip item model
// @param element : the chart element (point, arc, bar) to create the tooltip item for
// @return : new tooltip item
		function createTooltipItem(element) {
			var xScale = element._xScale;
			var yScale = element._yScale || element._scale; // handle radar || polarArea charts
			var index = element._index;
			var datasetIndex = element._datasetIndex;
			
			return {
				xLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : '',
				yLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : '',
				index: index,
				datasetIndex: datasetIndex,
				x: element._model.x,
				y: element._model.y
			};
		}
		
		/**
		 * Helper to get the reset model for the tooltip
		 * @param tooltipOpts {Object} the tooltip options
		 */
		function getBaseModel(tooltipOpts) {
			var globalDefaults = defaults.global;
			var valueOrDefault = helpers.valueOrDefault;
			
			return {
				// Positioning
				xPadding: tooltipOpts.xPadding,
				yPadding: tooltipOpts.yPadding,
				xAlign: tooltipOpts.xAlign,
				yAlign: tooltipOpts.yAlign,
				
				// Body
				bodyFontColor: tooltipOpts.bodyFontColor,
				_bodyFontFamily: valueOrDefault(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),
				_bodyFontStyle: valueOrDefault(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),
				_bodyAlign: tooltipOpts.bodyAlign,
				bodyFontSize: valueOrDefault(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),
				bodySpacing: tooltipOpts.bodySpacing,
				
				// Title
				titleFontColor: tooltipOpts.titleFontColor,
				_titleFontFamily: valueOrDefault(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),
				_titleFontStyle: valueOrDefault(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),
				titleFontSize: valueOrDefault(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),
				_titleAlign: tooltipOpts.titleAlign,
				titleSpacing: tooltipOpts.titleSpacing,
				titleMarginBottom: tooltipOpts.titleMarginBottom,
				
				// Footer
				footerFontColor: tooltipOpts.footerFontColor,
				_footerFontFamily: valueOrDefault(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),
				_footerFontStyle: valueOrDefault(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),
				footerFontSize: valueOrDefault(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),
				_footerAlign: tooltipOpts.footerAlign,
				footerSpacing: tooltipOpts.footerSpacing,
				footerMarginTop: tooltipOpts.footerMarginTop,
				
				// Appearance
				caretSize: tooltipOpts.caretSize,
				cornerRadius: tooltipOpts.cornerRadius,
				backgroundColor: tooltipOpts.backgroundColor,
				opacity: 0,
				legendColorBackground: tooltipOpts.multiKeyBackground,
				displayColors: tooltipOpts.displayColors,
				borderColor: tooltipOpts.borderColor,
				borderWidth: tooltipOpts.borderWidth
			};
		}
		
		/**
		 * Get the size of the tooltip
		 */
		function getTooltipSize(tooltip, model) {
			var ctx = tooltip._chart.ctx;
			
			var height = model.yPadding * 2; // Tooltip Padding
			var width = 0;
			
			// Count of all lines in the body
			var body = model.body;
			var combinedBodyLength = body.reduce(function(count, bodyItem) {
				return count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;
			}, 0);
			combinedBodyLength += model.beforeBody.length + model.afterBody.length;
			
			var titleLineCount = model.title.length;
			var footerLineCount = model.footer.length;
			var titleFontSize = model.titleFontSize;
			var bodyFontSize = model.bodyFontSize;
			var footerFontSize = model.footerFontSize;
			
			height += titleLineCount * titleFontSize; // Title Lines
			height += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0; // Title Line Spacing
			height += titleLineCount ? model.titleMarginBottom : 0; // Title's bottom Margin
			height += combinedBodyLength * bodyFontSize; // Body Lines
			height += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0; // Body Line Spacing
			height += footerLineCount ? model.footerMarginTop : 0; // Footer Margin
			height += footerLineCount * (footerFontSize); // Footer Lines
			height += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0; // Footer Line Spacing
			
			// Title width
			var widthPadding = 0;
			var maxLineWidth = function(line) {
				width = Math.max(width, ctx.measureText(line).width + widthPadding);
			};
			
			ctx.font = helpers.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);
			helpers.each(model.title, maxLineWidth);
			
			// Body width
			ctx.font = helpers.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);
			helpers.each(model.beforeBody.concat(model.afterBody), maxLineWidth);
			
			// Body lines may include some extra width due to the color box
			widthPadding = model.displayColors ? (bodyFontSize + 2) : 0;
			helpers.each(body, function(bodyItem) {
				helpers.each(bodyItem.before, maxLineWidth);
				helpers.each(bodyItem.lines, maxLineWidth);
				helpers.each(bodyItem.after, maxLineWidth);
			});
			
			// Reset back to 0
			widthPadding = 0;
			
			// Footer width
			ctx.font = helpers.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);
			helpers.each(model.footer, maxLineWidth);
			
			// Add padding
			width += 2 * model.xPadding;
			
			return {
				width: width,
				height: height
			};
		}
		
		/**
		 * Helper to get the alignment of a tooltip given the size
		 */
		function determineAlignment(tooltip, size) {
			var model = tooltip._model;
			var chart = tooltip._chart;
			var chartArea = tooltip._chart.chartArea;
			var xAlign = 'center';
			var yAlign = 'center';
			
			if(model.y < size.height) {
				yAlign = 'top';
			} else if(model.y > (chart.height - size.height)) {
				yAlign = 'bottom';
			}
			
			var lf, rf; // functions to determine left, right alignment
			var olf, orf; // functions to determine if left/right alignment causes tooltip to go outside chart
			var yf; // function to get the y alignment if the tooltip goes outside of the left or right edges
			var midX = (chartArea.left + chartArea.right) / 2;
			var midY = (chartArea.top + chartArea.bottom) / 2;
			
			if(yAlign === 'center') {
				lf = function(x) {
					return x <= midX;
				};
				rf = function(x) {
					return x > midX;
				};
			} else {
				lf = function(x) {
					return x <= (size.width / 2);
				};
				rf = function(x) {
					return x >= (chart.width - (size.width / 2));
				};
			}
			
			olf = function(x) {
				return x + size.width + model.caretSize + model.caretPadding > chart.width;
			};
			orf = function(x) {
				return x - size.width - model.caretSize - model.caretPadding < 0;
			};
			yf = function(y) {
				return y <= midY ? 'top' : 'bottom';
			};
			
			if(lf(model.x)) {
				xAlign = 'left';
				
				// Is tooltip too wide and goes over the right side of the chart.?
				if(olf(model.x)) {
					xAlign = 'center';
					yAlign = yf(model.y);
				}
			} else if(rf(model.x)) {
				xAlign = 'right';
				
				// Is tooltip too wide and goes outside left edge of canvas?
				if(orf(model.x)) {
					xAlign = 'center';
					yAlign = yf(model.y);
				}
			}
			
			var opts = tooltip._options;
			return {
				xAlign: opts.xAlign ? opts.xAlign : xAlign,
				yAlign: opts.yAlign ? opts.yAlign : yAlign
			};
		}
		
		/**
		 * Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment
		 */
		function getBackgroundPoint(vm, size, alignment, chart) {
			// Background Position
			var x = vm.x;
			var y = vm.y;
			
			var caretSize = vm.caretSize;
			var caretPadding = vm.caretPadding;
			var cornerRadius = vm.cornerRadius;
			var xAlign = alignment.xAlign;
			var yAlign = alignment.yAlign;
			var paddingAndSize = caretSize + caretPadding;
			var radiusAndPadding = cornerRadius + caretPadding;
			
			if(xAlign === 'right') {
				x -= size.width;
			} else if(xAlign === 'center') {
				x -= (size.width / 2);
				if(x + size.width > chart.width) {
					x = chart.width - size.width;
				}
				if(x < 0) {
					x = 0;
				}
			}
			
			if(yAlign === 'top') {
				y += paddingAndSize;
			} else if(yAlign === 'bottom') {
				y -= size.height + paddingAndSize;
			} else {
				y -= (size.height / 2);
			}
			
			if(yAlign === 'center') {
				if(xAlign === 'left') {
					x += paddingAndSize;
				} else if(xAlign === 'right') {
					x -= paddingAndSize;
				}
			} else if(xAlign === 'left') {
				x -= radiusAndPadding;
			} else if(xAlign === 'right') {
				x += radiusAndPadding;
			}
			
			return {
				x: x,
				y: y
			};
		}
		
		/**
		 * Helper to build before and after body lines
		 */
		function getBeforeAfterBodyLines(callback) {
			return pushOrConcat([], splitNewlines(callback));
		}
		
		var exports = module.exports = Element.extend({
			initialize: function() {
				this._model = getBaseModel(this._options);
				this._lastActive = [];
			},
			
			// Get the title
			// Args are: (tooltipItem, data)
			getTitle: function() {
				var me = this;
				var opts = me._options;
				var callbacks = opts.callbacks;
				
				var beforeTitle = callbacks.beforeTitle.apply(me, arguments);
				var title = callbacks.title.apply(me, arguments);
				var afterTitle = callbacks.afterTitle.apply(me, arguments);
				
				var lines = [];
				lines = pushOrConcat(lines, splitNewlines(beforeTitle));
				lines = pushOrConcat(lines, splitNewlines(title));
				lines = pushOrConcat(lines, splitNewlines(afterTitle));
				
				return lines;
			},
			
			// Args are: (tooltipItem, data)
			getBeforeBody: function() {
				return getBeforeAfterBodyLines(this._options.callbacks.beforeBody.apply(this, arguments));
			},
			
			// Args are: (tooltipItem, data)
			getBody: function(tooltipItems, data) {
				var me = this;
				var callbacks = me._options.callbacks;
				var bodyItems = [];
				
				helpers.each(tooltipItems, function(tooltipItem) {
					var bodyItem = {
						before: [],
						lines: [],
						after: []
					};
					pushOrConcat(bodyItem.before, splitNewlines(callbacks.beforeLabel.call(me, tooltipItem, data)));
					pushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));
					pushOrConcat(bodyItem.after, splitNewlines(callbacks.afterLabel.call(me, tooltipItem, data)));
					
					bodyItems.push(bodyItem);
				});
				
				return bodyItems;
			},
			
			// Args are: (tooltipItem, data)
			getAfterBody: function() {
				return getBeforeAfterBodyLines(this._options.callbacks.afterBody.apply(this, arguments));
			},
			
			// Get the footer and beforeFooter and afterFooter lines
			// Args are: (tooltipItem, data)
			getFooter: function() {
				var me = this;
				var callbacks = me._options.callbacks;
				
				var beforeFooter = callbacks.beforeFooter.apply(me, arguments);
				var footer = callbacks.footer.apply(me, arguments);
				var afterFooter = callbacks.afterFooter.apply(me, arguments);
				
				var lines = [];
				lines = pushOrConcat(lines, splitNewlines(beforeFooter));
				lines = pushOrConcat(lines, splitNewlines(footer));
				lines = pushOrConcat(lines, splitNewlines(afterFooter));
				
				return lines;
			},
			
			update: function(changed) {
				var me = this;
				var opts = me._options;
				
				// Need to regenerate the model because its faster than using extend and it is necessary due to the optimization in Chart.Element.transition
				// that does _view = _model if ease === 1. This causes the 2nd tooltip update to set properties in both the view and model at the same time
				// which breaks any animations.
				var existingModel = me._model;
				var model = me._model = getBaseModel(opts);
				var active = me._active;
				
				var data = me._data;
				
				// In the case where active.length === 0 we need to keep these at existing values for good animations
				var alignment = {
					xAlign: existingModel.xAlign,
					yAlign: existingModel.yAlign
				};
				var backgroundPoint = {
					x: existingModel.x,
					y: existingModel.y
				};
				var tooltipSize = {
					width: existingModel.width,
					height: existingModel.height
				};
				var tooltipPosition = {
					x: existingModel.caretX,
					y: existingModel.caretY
				};
				
				var i, len;
				
				if(active.length) {
					model.opacity = 1;
					
					var labelColors = [];
					var labelTextColors = [];
					tooltipPosition = positioners[opts.position].call(me, active, me._eventPosition);
					
					var tooltipItems = [];
					for(i = 0, len = active.length; i < len; ++i) {
						tooltipItems.push(createTooltipItem(active[i]));
					}
					
					// If the user provided a filter function, use it to modify the tooltip items
					if(opts.filter) {
						tooltipItems = tooltipItems.filter(function(a) {
							return opts.filter(a, data);
						});
					}
					
					// If the user provided a sorting function, use it to modify the tooltip items
					if(opts.itemSort) {
						tooltipItems = tooltipItems.sort(function(a, b) {
							return opts.itemSort(a, b, data);
						});
					}
					
					// Determine colors for boxes
					helpers.each(tooltipItems, function(tooltipItem) {
						labelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, me._chart));
						labelTextColors.push(opts.callbacks.labelTextColor.call(me, tooltipItem, me._chart));
					});
					
					
					// Build the Text Lines
					model.title = me.getTitle(tooltipItems, data);
					model.beforeBody = me.getBeforeBody(tooltipItems, data);
					model.body = me.getBody(tooltipItems, data);
					model.afterBody = me.getAfterBody(tooltipItems, data);
					model.footer = me.getFooter(tooltipItems, data);
					
					// Initial positioning and colors
					model.x = Math.round(tooltipPosition.x);
					model.y = Math.round(tooltipPosition.y);
					model.caretPadding = opts.caretPadding;
					model.labelColors = labelColors;
					model.labelTextColors = labelTextColors;
					
					// data points
					model.dataPoints = tooltipItems;
					
					// We need to determine alignment of the tooltip
					tooltipSize = getTooltipSize(this, model);
					alignment = determineAlignment(this, tooltipSize);
					// Final Size and Position
					backgroundPoint = getBackgroundPoint(model, tooltipSize, alignment, me._chart);
				} else {
					model.opacity = 0;
				}
				
				model.xAlign = alignment.xAlign;
				model.yAlign = alignment.yAlign;
				model.x = backgroundPoint.x;
				model.y = backgroundPoint.y;
				model.width = tooltipSize.width;
				model.height = tooltipSize.height;
				
				// Point where the caret on the tooltip points to
				model.caretX = tooltipPosition.x;
				model.caretY = tooltipPosition.y;
				
				me._model = model;
				
				if(changed && opts.custom) {
					opts.custom.call(me, model);
				}
				
				return me;
			},
			
			drawCaret: function(tooltipPoint, size) {
				var ctx = this._chart.ctx;
				var vm = this._view;
				var caretPosition = this.getCaretPosition(tooltipPoint, size, vm);
				
				ctx.lineTo(caretPosition.x1, caretPosition.y1);
				ctx.lineTo(caretPosition.x2, caretPosition.y2);
				ctx.lineTo(caretPosition.x3, caretPosition.y3);
			},
			getCaretPosition: function(tooltipPoint, size, vm) {
				var x1, x2, x3, y1, y2, y3;
				var caretSize = vm.caretSize;
				var cornerRadius = vm.cornerRadius;
				var xAlign = vm.xAlign;
				var yAlign = vm.yAlign;
				var ptX = tooltipPoint.x;
				var ptY = tooltipPoint.y;
				var width = size.width;
				var height = size.height;
				
				if(yAlign === 'center') {
					y2 = ptY + (height / 2);
					
					if(xAlign === 'left') {
						x1 = ptX;
						x2 = x1 - caretSize;
						x3 = x1;
						
						y1 = y2 + caretSize;
						y3 = y2 - caretSize;
					} else {
						x1 = ptX + width;
						x2 = x1 + caretSize;
						x3 = x1;
						
						y1 = y2 - caretSize;
						y3 = y2 + caretSize;
					}
				} else {
					if(xAlign === 'left') {
						x2 = ptX + cornerRadius + (caretSize);
						x1 = x2 - caretSize;
						x3 = x2 + caretSize;
					} else if(xAlign === 'right') {
						x2 = ptX + width - cornerRadius - caretSize;
						x1 = x2 - caretSize;
						x3 = x2 + caretSize;
					} else {
						x2 = vm.caretX;
						x1 = x2 - caretSize;
						x3 = x2 + caretSize;
					}
					if(yAlign === 'top') {
						y1 = ptY;
						y2 = y1 - caretSize;
						y3 = y1;
					} else {
						y1 = ptY + height;
						y2 = y1 + caretSize;
						y3 = y1;
						// invert drawing order
						var tmp = x3;
						x3 = x1;
						x1 = tmp;
					}
				}
				return {x1: x1, x2: x2, x3: x3, y1: y1, y2: y2, y3: y3};
			},
			
			drawTitle: function(pt, vm, ctx, opacity) {
				var title = vm.title;
				
				if(title.length) {
					ctx.textAlign = vm._titleAlign;
					ctx.textBaseline = 'top';
					
					var titleFontSize = vm.titleFontSize;
					var titleSpacing = vm.titleSpacing;
					
					ctx.fillStyle = mergeOpacity(vm.titleFontColor, opacity);
					ctx.font = helpers.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);
					
					var i, len;
					for(i = 0, len = title.length; i < len; ++i) {
						ctx.fillText(title[i], pt.x, pt.y);
						pt.y += titleFontSize + titleSpacing; // Line Height and spacing
						
						if(i + 1 === title.length) {
							pt.y += vm.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing
						}
					}
				}
			},
			
			drawBody: function(pt, vm, ctx, opacity) {
				var bodyFontSize = vm.bodyFontSize;
				var bodySpacing = vm.bodySpacing;
				var body = vm.body;
				
				ctx.textAlign = vm._bodyAlign;
				ctx.textBaseline = 'top';
				ctx.font = helpers.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);
				
				// Before Body
				var xLinePadding = 0;
				var fillLineOfText = function(line) {
					ctx.fillText(line, pt.x + xLinePadding, pt.y);
					pt.y += bodyFontSize + bodySpacing;
				};
				
				// Before body lines
				ctx.fillStyle = mergeOpacity(vm.bodyFontColor, opacity);
				helpers.each(vm.beforeBody, fillLineOfText);
				
				var drawColorBoxes = vm.displayColors;
				xLinePadding = drawColorBoxes ? (bodyFontSize + 2) : 0;
				
				// Draw body lines now
				helpers.each(body, function(bodyItem, i) {
					var textColor = mergeOpacity(vm.labelTextColors[i], opacity);
					ctx.fillStyle = textColor;
					helpers.each(bodyItem.before, fillLineOfText);
					
					helpers.each(bodyItem.lines, function(line) {
						// Draw Legend-like boxes if needed
						if(drawColorBoxes) {
							// Fill a white rect so that colours merge nicely if the opacity is < 1
							ctx.fillStyle = mergeOpacity(vm.legendColorBackground, opacity);
							ctx.fillRect(pt.x, pt.y, bodyFontSize, bodyFontSize);
							
							// Border
							ctx.lineWidth = 1;
							ctx.strokeStyle = mergeOpacity(vm.labelColors[i].borderColor, opacity);
							ctx.strokeRect(pt.x, pt.y, bodyFontSize, bodyFontSize);
							
							// Inner square
							ctx.fillStyle = mergeOpacity(vm.labelColors[i].backgroundColor, opacity);
							ctx.fillRect(pt.x + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);
							ctx.fillStyle = textColor;
						}
						
						fillLineOfText(line);
					});
					
					helpers.each(bodyItem.after, fillLineOfText);
				});
				
				// Reset back to 0 for after body
				xLinePadding = 0;
				
				// After body lines
				helpers.each(vm.afterBody, fillLineOfText);
				pt.y -= bodySpacing; // Remove last body spacing
			},
			
			drawFooter: function(pt, vm, ctx, opacity) {
				var footer = vm.footer;
				
				if(footer.length) {
					pt.y += vm.footerMarginTop;
					
					ctx.textAlign = vm._footerAlign;
					ctx.textBaseline = 'top';
					
					ctx.fillStyle = mergeOpacity(vm.footerFontColor, opacity);
					ctx.font = helpers.fontString(vm.footerFontSize, vm._footerFontStyle, vm._footerFontFamily);
					
					helpers.each(footer, function(line) {
						ctx.fillText(line, pt.x, pt.y);
						pt.y += vm.footerFontSize + vm.footerSpacing;
					});
				}
			},
			
			drawBackground: function(pt, vm, ctx, tooltipSize, opacity) {
				ctx.fillStyle = mergeOpacity(vm.backgroundColor, opacity);
				ctx.strokeStyle = mergeOpacity(vm.borderColor, opacity);
				ctx.lineWidth = vm.borderWidth;
				var xAlign = vm.xAlign;
				var yAlign = vm.yAlign;
				var x = pt.x;
				var y = pt.y;
				var width = tooltipSize.width;
				var height = tooltipSize.height;
				var radius = vm.cornerRadius;
				
				ctx.beginPath();
				ctx.moveTo(x + radius, y);
				if(yAlign === 'top') {
					this.drawCaret(pt, tooltipSize);
				}
				ctx.lineTo(x + width - radius, y);
				ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
				if(yAlign === 'center' && xAlign === 'right') {
					this.drawCaret(pt, tooltipSize);
				}
				ctx.lineTo(x + width, y + height - radius);
				ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
				if(yAlign === 'bottom') {
					this.drawCaret(pt, tooltipSize);
				}
				ctx.lineTo(x + radius, y + height);
				ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
				if(yAlign === 'center' && xAlign === 'left') {
					this.drawCaret(pt, tooltipSize);
				}
				ctx.lineTo(x, y + radius);
				ctx.quadraticCurveTo(x, y, x + radius, y);
				ctx.closePath();
				
				ctx.fill();
				
				if(vm.borderWidth > 0) {
					ctx.stroke();
				}
			},
			
			draw: function() {
				var ctx = this._chart.ctx;
				var vm = this._view;
				
				if(vm.opacity === 0) {
					return;
				}
				
				var tooltipSize = {
					width: vm.width,
					height: vm.height
				};
				var pt = {
					x: vm.x,
					y: vm.y
				};
				
				// IE11/Edge does not like very small opacities, so snap to 0
				var opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity;
				
				// Truthy/falsey value for empty tooltip
				var hasTooltipContent = vm.title.length || vm.beforeBody.length || vm.body.length || vm.afterBody.length || vm.footer.length;
				
				if(this._options.enabled && hasTooltipContent) {
					// Draw Background
					this.drawBackground(pt, vm, ctx, tooltipSize, opacity);
					
					// Draw Title, Body, and Footer
					pt.x += vm.xPadding;
					pt.y += vm.yPadding;
					
					// Titles
					this.drawTitle(pt, vm, ctx, opacity);
					
					// Body
					this.drawBody(pt, vm, ctx, opacity);
					
					// Footer
					this.drawFooter(pt, vm, ctx, opacity);
				}
			},
			
			/**
			 * Handle an event
			 * @private
			 * @param {IEvent} event - The event to handle
			 * @returns {Boolean} true if the tooltip changed
			 */
			handleEvent: function(e) {
				var me = this;
				var options = me._options;
				var changed = false;
				
				me._lastActive = me._lastActive || [];
				
				// Find Active Elements for tooltips
				if(e.type === 'mouseout') {
					me._active = [];
				} else {
					me._active = me._chart.getElementsAtEventForMode(e, options.mode, options);
				}
				
				// Remember Last Actives
				changed = !helpers.arrayEquals(me._active, me._lastActive);
				
				// Only handle target event on tooltip change
				if(changed) {
					me._lastActive = me._active;
					
					if(options.enabled || options.custom) {
						me._eventPosition = {
							x: e.x,
							y: e.y
						};
						
						me.update(true);
						me.pivot();
					}
				}
				
				return changed;
			}
		});
		
		/**
		 * @namespace Chart.Tooltip.positioners
		 */
		exports.positioners = positioners;
		
		
		/***/
	}),
	
	/***/ "./node_modules/chart.js/src/elements/element.arc.js":
	/*!***********************************************************!*\
  !*** ./node_modules/chart.js/src/elements/element.arc.js ***!
  \***********************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		var defaults = __webpack_require__(/*! ../core/core.defaults */ "./node_modules/chart.js/src/core/core.defaults.js");
		var Element = __webpack_require__(/*! ../core/core.element */ "./node_modules/chart.js/src/core/core.element.js");
		var helpers = __webpack_require__(/*! ../helpers/index */ "./node_modules/chart.js/src/helpers/index.js");
		
		defaults._set('global', {
			elements: {
				arc: {
					backgroundColor: defaults.global.defaultColor,
					borderColor: '#fff',
					borderWidth: 2
				}
			}
		});
		
		module.exports = Element.extend({
			inLabelRange: function(mouseX) {
				var vm = this._view;
				
				if(vm) {
					return (Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2));
				}
				return false;
			},
			
			inRange: function(chartX, chartY) {
				var vm = this._view;
				
				if(vm) {
					var pointRelativePosition = helpers.getAngleFromPoint(vm, {x: chartX, y: chartY});
					var angle = pointRelativePosition.angle;
					var distance = pointRelativePosition.distance;
					
					// Sanitise angle range
					var startAngle = vm.startAngle;
					var endAngle = vm.endAngle;
					while(endAngle < startAngle) {
						endAngle += 2.0 * Math.PI;
					}
					while(angle > endAngle) {
						angle -= 2.0 * Math.PI;
					}
					while(angle < startAngle) {
						angle += 2.0 * Math.PI;
					}
					
					// Check if within the range of the open/close angle
					var betweenAngles = (angle >= startAngle && angle <= endAngle);
					var withinRadius = (distance >= vm.innerRadius && distance <= vm.outerRadius);
					
					return (betweenAngles && withinRadius);
				}
				return false;
			},
			
			getCenterPoint: function() {
				var vm = this._view;
				var halfAngle = (vm.startAngle + vm.endAngle) / 2;
				var halfRadius = (vm.innerRadius + vm.outerRadius) / 2;
				return {
					x: vm.x + Math.cos(halfAngle) * halfRadius,
					y: vm.y + Math.sin(halfAngle) * halfRadius
				};
			},
			
			getArea: function() {
				var vm = this._view;
				return Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));
			},
			
			tooltipPosition: function() {
				var vm = this._view;
				var centreAngle = vm.startAngle + ((vm.endAngle - vm.startAngle) / 2);
				var rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;
				
				return {
					x: vm.x + (Math.cos(centreAngle) * rangeFromCentre),
					y: vm.y + (Math.sin(centreAngle) * rangeFromCentre)
				};
			},
			
			draw: function() {
				var ctx = this._chart.ctx;
				var vm = this._view;
				var sA = vm.startAngle;
				var eA = vm.endAngle;
				
				ctx.beginPath();
				
				ctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);
				ctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);
				
				ctx.closePath();
				ctx.strokeStyle = vm.borderColor;
				ctx.lineWidth = vm.borderWidth;
				
				ctx.fillStyle = vm.backgroundColor;
				
				ctx.fill();
				ctx.lineJoin = 'bevel';
				
				if(vm.borderWidth) {
					ctx.stroke();
				}
			}
		});
		
		
		/***/
	}),
	
	/***/ "./node_modules/chart.js/src/elements/element.line.js":
	/*!************************************************************!*\
  !*** ./node_modules/chart.js/src/elements/element.line.js ***!
  \************************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		var defaults = __webpack_require__(/*! ../core/core.defaults */ "./node_modules/chart.js/src/core/core.defaults.js");
		var Element = __webpack_require__(/*! ../core/core.element */ "./node_modules/chart.js/src/core/core.element.js");
		var helpers = __webpack_require__(/*! ../helpers/index */ "./node_modules/chart.js/src/helpers/index.js");
		
		var globalDefaults = defaults.global;
		
		defaults._set('global', {
			elements: {
				line: {
					tension: 0.4,
					backgroundColor: globalDefaults.defaultColor,
					borderWidth: 3,
					borderColor: globalDefaults.defaultColor,
					borderCapStyle: 'butt',
					borderDash: [],
					borderDashOffset: 0.0,
					borderJoinStyle: 'miter',
					capBezierPoints: true,
					fill: true, // do we fill in the area between the line and its base axis
				}
			}
		});
		
		module.exports = Element.extend({
			draw: function() {
				var me = this;
				var vm = me._view;
				var ctx = me._chart.ctx;
				var spanGaps = vm.spanGaps;
				var points = me._children.slice(); // clone array
				var globalOptionLineElements = globalDefaults.elements.line;
				var lastDrawnIndex = -1;
				var index, current, previous, currentVM;
				
				// If we are looping, adding the first point again
				if(me._loop && points.length) {
					points.push(points[0]);
				}
				
				ctx.save();
				
				// Stroke Line Options
				ctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle;
				
				// IE 9 and 10 do not support line dash
				if(ctx.setLineDash) {
					ctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);
				}
				
				ctx.lineDashOffset = vm.borderDashOffset || globalOptionLineElements.borderDashOffset;
				ctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;
				ctx.lineWidth = vm.borderWidth || globalOptionLineElements.borderWidth;
				ctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor;
				
				// Stroke Line
				ctx.beginPath();
				lastDrawnIndex = -1;
				
				for(index = 0; index < points.length; ++index) {
					current = points[index];
					previous = helpers.previousItem(points, index);
					currentVM = current._view;
					
					// First point moves to it's starting position no matter what
					if(index === 0) {
						if(!currentVM.skip) {
							ctx.moveTo(currentVM.x, currentVM.y);
							lastDrawnIndex = index;
						}
					} else {
						previous = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];
						
						if(!currentVM.skip) {
							if((lastDrawnIndex !== (index - 1) && !spanGaps) || lastDrawnIndex === -1) {
								// There was a gap and this is the first point after the gap
								ctx.moveTo(currentVM.x, currentVM.y);
							} else {
								// Line to next point
								helpers.canvas.lineTo(ctx, previous._view, current._view);
							}
							lastDrawnIndex = index;
						}
					}
				}
				
				ctx.stroke();
				ctx.restore();
			}
		});
		
		
		/***/
	}),
	
	/***/ "./node_modules/chart.js/src/elements/element.point.js":
	/*!*************************************************************!*\
  !*** ./node_modules/chart.js/src/elements/element.point.js ***!
  \*************************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		var defaults = __webpack_require__(/*! ../core/core.defaults */ "./node_modules/chart.js/src/core/core.defaults.js");
		var Element = __webpack_require__(/*! ../core/core.element */ "./node_modules/chart.js/src/core/core.element.js");
		var helpers = __webpack_require__(/*! ../helpers/index */ "./node_modules/chart.js/src/helpers/index.js");
		
		var defaultColor = defaults.global.defaultColor;
		
		defaults._set('global', {
			elements: {
				point: {
					radius: 3,
					pointStyle: 'circle',
					backgroundColor: defaultColor,
					borderColor: defaultColor,
					borderWidth: 1,
					// Hover
					hitRadius: 1,
					hoverRadius: 4,
					hoverBorderWidth: 1
				}
			}
		});
		
		function xRange(mouseX) {
			var vm = this._view;
			return vm ? (Math.abs(mouseX - vm.x) < vm.radius + vm.hitRadius) : false;
		}
		
		function yRange(mouseY) {
			var vm = this._view;
			return vm ? (Math.abs(mouseY - vm.y) < vm.radius + vm.hitRadius) : false;
		}
		
		module.exports = Element.extend({
			inRange: function(mouseX, mouseY) {
				var vm = this._view;
				return vm ? ((Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2)) < Math.pow(vm.hitRadius + vm.radius, 2)) : false;
			},
			
			inLabelRange: xRange,
			inXRange: xRange,
			inYRange: yRange,
			
			getCenterPoint: function() {
				var vm = this._view;
				return {
					x: vm.x,
					y: vm.y
				};
			},
			
			getArea: function() {
				return Math.PI * Math.pow(this._view.radius, 2);
			},
			
			tooltipPosition: function() {
				var vm = this._view;
				return {
					x: vm.x,
					y: vm.y,
					padding: vm.radius + vm.borderWidth
				};
			},
			
			draw: function(chartArea) {
				var vm = this._view;
				var model = this._model;
				var ctx = this._chart.ctx;
				var pointStyle = vm.pointStyle;
				var rotation = vm.rotation;
				var radius = vm.radius;
				var x = vm.x;
				var y = vm.y;
				var errMargin = 1.01; // 1.01 is margin for Accumulated error. (Especially Edge, IE.)
				
				if(vm.skip) {
					return;
				}
				
				// Clipping for Points.
				if(chartArea === undefined || (model.x >= chartArea.left && chartArea.right * errMargin >= model.x && model.y >= chartArea.top && chartArea.bottom * errMargin >= model.y)) {
					ctx.strokeStyle = vm.borderColor || defaultColor;
					ctx.lineWidth = helpers.valueOrDefault(vm.borderWidth, defaults.global.elements.point.borderWidth);
					ctx.fillStyle = vm.backgroundColor || defaultColor;
					helpers.canvas.drawPoint(ctx, pointStyle, radius, x, y, rotation);
				}
			}
		});
		
		
		/***/
	}),
	
	/***/ "./node_modules/chart.js/src/elements/element.rectangle.js":
	/*!*****************************************************************!*\
  !*** ./node_modules/chart.js/src/elements/element.rectangle.js ***!
  \*****************************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		var defaults = __webpack_require__(/*! ../core/core.defaults */ "./node_modules/chart.js/src/core/core.defaults.js");
		var Element = __webpack_require__(/*! ../core/core.element */ "./node_modules/chart.js/src/core/core.element.js");
		
		defaults._set('global', {
			elements: {
				rectangle: {
					backgroundColor: defaults.global.defaultColor,
					borderColor: defaults.global.defaultColor,
					borderSkipped: 'bottom',
					borderWidth: 0
				}
			}
		});
		
		function isVertical(bar) {
			return bar._view.width !== undefined;
		}
		
		/**
		 * Helper function to get the bounds of the bar regardless of the orientation
		 * @param bar {Chart.Element.Rectangle} the bar
		 * @return {Bounds} bounds of the bar
		 * @private
		 */
		function getBarBounds(bar) {
			var vm = bar._view;
			var x1, x2, y1, y2;
			
			if(isVertical(bar)) {
				// vertical
				var halfWidth = vm.width / 2;
				x1 = vm.x - halfWidth;
				x2 = vm.x + halfWidth;
				y1 = Math.min(vm.y, vm.base);
				y2 = Math.max(vm.y, vm.base);
			} else {
				// horizontal bar
				var halfHeight = vm.height / 2;
				x1 = Math.min(vm.x, vm.base);
				x2 = Math.max(vm.x, vm.base);
				y1 = vm.y - halfHeight;
				y2 = vm.y + halfHeight;
			}
			
			return {
				left: x1,
				top: y1,
				right: x2,
				bottom: y2
			};
		}
		
		module.exports = Element.extend({
			draw: function() {
				var ctx = this._chart.ctx;
				var vm = this._view;
				var left, right, top, bottom, signX, signY, borderSkipped;
				var borderWidth = vm.borderWidth;
				
				if(!vm.horizontal) {
					// bar
					left = vm.x - vm.width / 2;
					right = vm.x + vm.width / 2;
					top = vm.y;
					bottom = vm.base;
					signX = 1;
					signY = bottom > top ? 1 : -1;
					borderSkipped = vm.borderSkipped || 'bottom';
				} else {
					// horizontal bar
					left = vm.base;
					right = vm.x;
					top = vm.y - vm.height / 2;
					bottom = vm.y + vm.height / 2;
					signX = right > left ? 1 : -1;
					signY = 1;
					borderSkipped = vm.borderSkipped || 'left';
				}
				
				// Canvas doesn't allow us to stroke inside the width so we can
				// adjust the sizes to fit if we're setting a stroke on the line
				if(borderWidth) {
					// borderWidth shold be less than bar width and bar height.
					var barSize = Math.min(Math.abs(left - right), Math.abs(top - bottom));
					borderWidth = borderWidth > barSize ? barSize : borderWidth;
					var halfStroke = borderWidth / 2;
					// Adjust borderWidth when bar top position is near vm.base(zero).
					var borderLeft = left + (borderSkipped !== 'left' ? halfStroke * signX : 0);
					var borderRight = right + (borderSkipped !== 'right' ? -halfStroke * signX : 0);
					var borderTop = top + (borderSkipped !== 'top' ? halfStroke * signY : 0);
					var borderBottom = bottom + (borderSkipped !== 'bottom' ? -halfStroke * signY : 0);
					// not become a vertical line?
					if(borderLeft !== borderRight) {
						top = borderTop;
						bottom = borderBottom;
					}
					// not become a horizontal line?
					if(borderTop !== borderBottom) {
						left = borderLeft;
						right = borderRight;
					}
				}
				
				ctx.beginPath();
				ctx.fillStyle = vm.backgroundColor;
				ctx.strokeStyle = vm.borderColor;
				ctx.lineWidth = borderWidth;
				
				// Corner points, from bottom-left to bottom-right clockwise
				// | 1 2 |
				// | 0 3 |
				var corners = [
					[left, bottom],
					[left, top],
					[right, top],
					[right, bottom]
				];
				
				// Find first (starting) corner with fallback to 'bottom'
				var borders = ['bottom', 'left', 'top', 'right'];
				var startCorner = borders.indexOf(borderSkipped, 0);
				if(startCorner === -1) {
					startCorner = 0;
				}
				
				function cornerAt(index) {
					return corners[(startCorner + index) % 4];
				}
				
				// Draw rectangle from 'startCorner'
				var corner = cornerAt(0);
				ctx.moveTo(corner[0], corner[1]);
				
				for(var i = 1; i < 4; i++) {
					corner = cornerAt(i);
					ctx.lineTo(corner[0], corner[1]);
				}
				
				ctx.fill();
				if(borderWidth) {
					ctx.stroke();
				}
			},
			
			height: function() {
				var vm = this._view;
				return vm.base - vm.y;
			},
			
			inRange: function(mouseX, mouseY) {
				var inRange = false;
				
				if(this._view) {
					var bounds = getBarBounds(this);
					inRange = mouseX >= bounds.left && mouseX <= bounds.right && mouseY >= bounds.top && mouseY <= bounds.bottom;
				}
				
				return inRange;
			},
			
			inLabelRange: function(mouseX, mouseY) {
				var me = this;
				if(!me._view) {
					return false;
				}
				
				var inRange = false;
				var bounds = getBarBounds(me);
				
				if(isVertical(me)) {
					inRange = mouseX >= bounds.left && mouseX <= bounds.right;
				} else {
					inRange = mouseY >= bounds.top && mouseY <= bounds.bottom;
				}
				
				return inRange;
			},
			
			inXRange: function(mouseX) {
				var bounds = getBarBounds(this);
				return mouseX >= bounds.left && mouseX <= bounds.right;
			},
			
			inYRange: function(mouseY) {
				var bounds = getBarBounds(this);
				return mouseY >= bounds.top && mouseY <= bounds.bottom;
			},
			
			getCenterPoint: function() {
				var vm = this._view;
				var x, y;
				if(isVertical(this)) {
					x = vm.x;
					y = (vm.y + vm.base) / 2;
				} else {
					x = (vm.x + vm.base) / 2;
					y = vm.y;
				}
				
				return {x: x, y: y};
			},
			
			getArea: function() {
				var vm = this._view;
				return vm.width * Math.abs(vm.y - vm.base);
			},
			
			tooltipPosition: function() {
				var vm = this._view;
				return {
					x: vm.x,
					y: vm.y
				};
			}
		});
		
		
		/***/
	}),
	
	/***/ "./node_modules/chart.js/src/elements/index.js":
	/*!*****************************************************!*\
  !*** ./node_modules/chart.js/src/elements/index.js ***!
  \*****************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		module.exports = {};
		module.exports.Arc = __webpack_require__(/*! ./element.arc */ "./node_modules/chart.js/src/elements/element.arc.js");
		module.exports.Line = __webpack_require__(/*! ./element.line */ "./node_modules/chart.js/src/elements/element.line.js");
		module.exports.Point = __webpack_require__(/*! ./element.point */ "./node_modules/chart.js/src/elements/element.point.js");
		module.exports.Rectangle = __webpack_require__(/*! ./element.rectangle */ "./node_modules/chart.js/src/elements/element.rectangle.js");
		
		
		/***/
	}),
	
	/***/ "./node_modules/chart.js/src/helpers/helpers.canvas.js":
	/*!*************************************************************!*\
  !*** ./node_modules/chart.js/src/helpers/helpers.canvas.js ***!
  \*************************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		var helpers = __webpack_require__(/*! ./helpers.core */ "./node_modules/chart.js/src/helpers/helpers.core.js");
		
		/**
		 * @namespace Chart.helpers.canvas
		 */
		var exports = module.exports = {
			/**
			 * Clears the entire canvas associated to the given `chart`.
			 * @param {Chart} chart - The chart for which to clear the canvas.
			 */
			clear: function(chart) {
				chart.ctx.clearRect(0, 0, chart.width, chart.height);
			},
			
			/**
			 * Creates a "path" for a rectangle with rounded corners at position (x, y) with a
			 * given size (width, height) and the same `radius` for all corners.
			 * @param {CanvasRenderingContext2D} ctx - The canvas 2D Context.
			 * @param {Number} x - The x axis of the coordinate for the rectangle starting point.
			 * @param {Number} y - The y axis of the coordinate for the rectangle starting point.
			 * @param {Number} width - The rectangle's width.
			 * @param {Number} height - The rectangle's height.
			 * @param {Number} radius - The rounded amount (in pixels) for the four corners.
			 * @todo handle `radius` as top-left, top-right, bottom-right, bottom-left array/object?
			 */
			roundedRect: function(ctx, x, y, width, height, radius) {
				if(radius) {
					// NOTE(SB) `epsilon` helps to prevent minor artifacts appearing
					// on Chrome when `r` is exactly half the height or the width.
					var epsilon = 0.0000001;
					var r = Math.min(radius, (height / 2) - epsilon, (width / 2) - epsilon);
					
					ctx.moveTo(x + r, y);
					ctx.lineTo(x + width - r, y);
					ctx.arcTo(x + width, y, x + width, y + r, r);
					ctx.lineTo(x + width, y + height - r);
					ctx.arcTo(x + width, y + height, x + width - r, y + height, r);
					ctx.lineTo(x + r, y + height);
					ctx.arcTo(x, y + height, x, y + height - r, r);
					ctx.lineTo(x, y + r);
					ctx.arcTo(x, y, x + r, y, r);
					ctx.closePath();
					ctx.moveTo(x, y);
				} else {
					ctx.rect(x, y, width, height);
				}
			},
			
			drawPoint: function(ctx, style, radius, x, y, rotation) {
				var type, edgeLength, xOffset, yOffset, height, size;
				rotation = rotation || 0;
				
				if(style && typeof style === 'object') {
					type = style.toString();
					if(type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {
						ctx.drawImage(style, x - style.width / 2, y - style.height / 2, style.width, style.height);
						return;
					}
				}
				
				if(isNaN(radius) || radius <= 0) {
					return;
				}
				
				ctx.save();
				ctx.translate(x, y);
				ctx.rotate(rotation * Math.PI / 180);
				ctx.beginPath();
				
				switch(style) {
					// Default includes circle
					default:
						ctx.arc(0, 0, radius, 0, Math.PI * 2);
						ctx.closePath();
						break;
					case 'triangle':
						edgeLength = 3 * radius / Math.sqrt(3);
						height = edgeLength * Math.sqrt(3) / 2;
						ctx.moveTo(-edgeLength / 2, height / 3);
						ctx.lineTo(edgeLength / 2, height / 3);
						ctx.lineTo(0, -2 * height / 3);
						ctx.closePath();
						break;
					case 'rect':
						size = 1 / Math.SQRT2 * radius;
						ctx.rect(-size, -size, 2 * size, 2 * size);
						break;
					case 'rectRounded':
						var offset = radius / Math.SQRT2;
						var leftX = -offset;
						var topY = -offset;
						var sideSize = Math.SQRT2 * radius;
						
						// NOTE(SB) the rounded rect implementation changed to use `arcTo`
						// instead of `quadraticCurveTo` since it generates better results
						// when rect is almost a circle. 0.425 (instead of 0.5) produces
						// results visually closer to the previous impl.
						this.roundedRect(ctx, leftX, topY, sideSize, sideSize, radius * 0.425);
						break;
					case 'rectRot':
						size = 1 / Math.SQRT2 * radius;
						ctx.moveTo(-size, 0);
						ctx.lineTo(0, size);
						ctx.lineTo(size, 0);
						ctx.lineTo(0, -size);
						ctx.closePath();
						break;
					case 'cross':
						ctx.moveTo(0, radius);
						ctx.lineTo(0, -radius);
						ctx.moveTo(-radius, 0);
						ctx.lineTo(radius, 0);
						break;
					case 'crossRot':
						xOffset = Math.cos(Math.PI / 4) * radius;
						yOffset = Math.sin(Math.PI / 4) * radius;
						ctx.moveTo(-xOffset, -yOffset);
						ctx.lineTo(xOffset, yOffset);
						ctx.moveTo(-xOffset, yOffset);
						ctx.lineTo(xOffset, -yOffset);
						break;
					case 'star':
						ctx.moveTo(0, radius);
						ctx.lineTo(0, -radius);
						ctx.moveTo(-radius, 0);
						ctx.lineTo(radius, 0);
						xOffset = Math.cos(Math.PI / 4) * radius;
						yOffset = Math.sin(Math.PI / 4) * radius;
						ctx.moveTo(-xOffset, -yOffset);
						ctx.lineTo(xOffset, yOffset);
						ctx.moveTo(-xOffset, yOffset);
						ctx.lineTo(xOffset, -yOffset);
						break;
					case 'line':
						ctx.moveTo(-radius, 0);
						ctx.lineTo(radius, 0);
						break;
					case 'dash':
						ctx.moveTo(0, 0);
						ctx.lineTo(radius, 0);
						break;
				}
				
				ctx.fill();
				ctx.stroke();
				ctx.restore();
			},
			
			clipArea: function(ctx, area) {
				ctx.save();
				ctx.beginPath();
				ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
				ctx.clip();
			},
			
			unclipArea: function(ctx) {
				ctx.restore();
			},
			
			lineTo: function(ctx, previous, target, flip) {
				if(target.steppedLine) {
					if((target.steppedLine === 'after' && !flip) || (target.steppedLine !== 'after' && flip)) {
						ctx.lineTo(previous.x, target.y);
					} else {
						ctx.lineTo(target.x, previous.y);
					}
					ctx.lineTo(target.x, target.y);
					return;
				}
				
				if(!target.tension) {
					ctx.lineTo(target.x, target.y);
					return;
				}
				
				ctx.bezierCurveTo(
					flip ? previous.controlPointPreviousX : previous.controlPointNextX,
					flip ? previous.controlPointPreviousY : previous.controlPointNextY,
					flip ? target.controlPointNextX : target.controlPointPreviousX,
					flip ? target.controlPointNextY : target.controlPointPreviousY,
					target.x,
					target.y);
			}
		};

// DEPRECATIONS
		
		/**
		 * Provided for backward compatibility, use Chart.helpers.canvas.clear instead.
		 * @namespace Chart.helpers.clear
		 * @deprecated since version 2.7.0
		 * @todo remove at version 3
		 * @private
		 */
		helpers.clear = exports.clear;
		
		/**
		 * Provided for backward compatibility, use Chart.helpers.canvas.roundedRect instead.
		 * @namespace Chart.helpers.drawRoundedRectangle
		 * @deprecated since version 2.7.0
		 * @todo remove at version 3
		 * @private
		 */
		helpers.drawRoundedRectangle = function(ctx) {
			ctx.beginPath();
			exports.roundedRect.apply(exports, arguments);
		};
		
		
		/***/
	}),
	
	/***/ "./node_modules/chart.js/src/helpers/helpers.core.js":
	/*!***********************************************************!*\
  !*** ./node_modules/chart.js/src/helpers/helpers.core.js ***!
  \***********************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		/**
		 * @namespace Chart.helpers
		 */
		var helpers = {
			/**
			 * An empty function that can be used, for example, for optional callback.
			 */
			noop: function() {
			},
			
			/**
			 * Returns a unique id, sequentially generated from a global variable.
			 * @returns {Number}
			 * @function
			 */
			uid: (function() {
				var id = 0;
				return function() {
					return id++;
				};
			}()),
			
			/**
			 * Returns true if `value` is neither null nor undefined, else returns false.
			 * @param {*} value - The value to test.
			 * @returns {Boolean}
			 * @since 2.7.0
			 */
			isNullOrUndef: function(value) {
				return value === null || typeof value === 'undefined';
			},
			
			/**
			 * Returns true if `value` is an array, else returns false.
			 * @param {*} value - The value to test.
			 * @returns {Boolean}
			 * @function
			 */
			isArray: Array.isArray ? Array.isArray : function(value) {
				return Object.prototype.toString.call(value) === '[object Array]';
			},
			
			/**
			 * Returns true if `value` is an object (excluding null), else returns false.
			 * @param {*} value - The value to test.
			 * @returns {Boolean}
			 * @since 2.7.0
			 */
			isObject: function(value) {
				return value !== null && Object.prototype.toString.call(value) === '[object Object]';
			},
			
			/**
			 * Returns `value` if defined, else returns `defaultValue`.
			 * @param {*} value - The value to return if defined.
			 * @param {*} defaultValue - The value to return if `value` is undefined.
			 * @returns {*}
			 */
			valueOrDefault: function(value, defaultValue) {
				return typeof value === 'undefined' ? defaultValue : value;
			},
			
			/**
			 * Returns value at the given `index` in array if defined, else returns `defaultValue`.
			 * @param {Array} value - The array to lookup for value at `index`.
			 * @param {Number} index - The index in `value` to lookup for value.
			 * @param {*} defaultValue - The value to return if `value[index]` is undefined.
			 * @returns {*}
			 */
			valueAtIndexOrDefault: function(value, index, defaultValue) {
				return helpers.valueOrDefault(helpers.isArray(value) ? value[index] : value, defaultValue);
			},
			
			/**
			 * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the
			 * value returned by `fn`. If `fn` is not a function, this method returns undefined.
			 * @param {Function} fn - The function to call.
			 * @param {Array|undefined|null} args - The arguments with which `fn` should be called.
			 * @param {Object} [thisArg] - The value of `this` provided for the call to `fn`.
			 * @returns {*}
			 */
			callback: function(fn, args, thisArg) {
				if(fn && typeof fn.call === 'function') {
					return fn.apply(thisArg, args);
				}
			},
			
			/**
			 * Note(SB) for performance sake, this method should only be used when loopable type
			 * is unknown or in none intensive code (not called often and small loopable). Else
			 * it's preferable to use a regular for() loop and save extra function calls.
			 * @param {Object|Array} loopable - The object or array to be iterated.
			 * @param {Function} fn - The function to call for each item.
			 * @param {Object} [thisArg] - The value of `this` provided for the call to `fn`.
			 * @param {Boolean} [reverse] - If true, iterates backward on the loopable.
			 */
			each: function(loopable, fn, thisArg, reverse) {
				var i, len, keys;
				if(helpers.isArray(loopable)) {
					len = loopable.length;
					if(reverse) {
						for(i = len - 1; i >= 0; i--) {
							fn.call(thisArg, loopable[i], i);
						}
					} else {
						for(i = 0; i < len; i++) {
							fn.call(thisArg, loopable[i], i);
						}
					}
				} else if(helpers.isObject(loopable)) {
					keys = Object.keys(loopable);
					len = keys.length;
					for(i = 0; i < len; i++) {
						fn.call(thisArg, loopable[keys[i]], keys[i]);
					}
				}
			},
			
			/**
			 * Returns true if the `a0` and `a1` arrays have the same content, else returns false.
			 * @see http://stackoverflow.com/a/14853974
			 * @param {Array} a0 - The array to compare
			 * @param {Array} a1 - The array to compare
			 * @returns {Boolean}
			 */
			arrayEquals: function(a0, a1) {
				var i, ilen, v0, v1;
				
				if(!a0 || !a1 || a0.length !== a1.length) {
					return false;
				}
				
				for(i = 0, ilen = a0.length; i < ilen; ++i) {
					v0 = a0[i];
					v1 = a1[i];
					
					if(v0 instanceof Array && v1 instanceof Array) {
						if(!helpers.arrayEquals(v0, v1)) {
							return false;
						}
					} else if(v0 !== v1) {
						// NOTE: two different object instances will never be equal: {x:20} != {x:20}
						return false;
					}
				}
				
				return true;
			},
			
			/**
			 * Returns a deep copy of `source` without keeping references on objects and arrays.
			 * @param {*} source - The value to clone.
			 * @returns {*}
			 */
			clone: function(source) {
				if(helpers.isArray(source)) {
					return source.map(helpers.clone);
				}
				
				if(helpers.isObject(source)) {
					var target = {};
					var keys = Object.keys(source);
					var klen = keys.length;
					var k = 0;
					
					for(; k < klen; ++k) {
						target[keys[k]] = helpers.clone(source[keys[k]]);
					}
					
					return target;
				}
				
				return source;
			},
			
			/**
			 * The default merger when Chart.helpers.merge is called without merger option.
			 * Note(SB): this method is also used by configMerge and scaleMerge as fallback.
			 * @private
			 */
			_merger: function(key, target, source, options) {
				var tval = target[key];
				var sval = source[key];
				
				if(helpers.isObject(tval) && helpers.isObject(sval)) {
					helpers.merge(tval, sval, options);
				} else {
					target[key] = helpers.clone(sval);
				}
			},
			
			/**
			 * Merges source[key] in target[key] only if target[key] is undefined.
			 * @private
			 */
			_mergerIf: function(key, target, source) {
				var tval = target[key];
				var sval = source[key];
				
				if(helpers.isObject(tval) && helpers.isObject(sval)) {
					helpers.mergeIf(tval, sval);
				} else if(!target.hasOwnProperty(key)) {
					target[key] = helpers.clone(sval);
				}
			},
			
			/**
			 * Recursively deep copies `source` properties into `target` with the given `options`.
			 * IMPORTANT: `target` is not cloned and will be updated with `source` properties.
			 * @param {Object} target - The target object in which all sources are merged into.
			 * @param {Object|Array(Object)} source - Object(s) to merge into `target`.
			 * @param {Object} [options] - Merging options:
			 * @param {Function} [options.merger] - The merge method (key, target, source, options)
			 * @returns {Object} The `target` object.
			 */
			merge: function(target, source, options) {
				var sources = helpers.isArray(source) ? source : [source];
				var ilen = sources.length;
				var merge, i, keys, klen, k;
				
				if(!helpers.isObject(target)) {
					return target;
				}
				
				options = options || {};
				merge = options.merger || helpers._merger;
				
				for(i = 0; i < ilen; ++i) {
					source = sources[i];
					if(!helpers.isObject(source)) {
						continue;
					}
					
					keys = Object.keys(source);
					for(k = 0, klen = keys.length; k < klen; ++k) {
						merge(keys[k], target, source, options);
					}
				}
				
				return target;
			},
			
			/**
			 * Recursively deep copies `source` properties into `target` *only* if not defined in target.
			 * IMPORTANT: `target` is not cloned and will be updated with `source` properties.
			 * @param {Object} target - The target object in which all sources are merged into.
			 * @param {Object|Array(Object)} source - Object(s) to merge into `target`.
			 * @returns {Object} The `target` object.
			 */
			mergeIf: function(target, source) {
				return helpers.merge(target, source, {merger: helpers._mergerIf});
			},
			
			/**
			 * Applies the contents of two or more objects together into the first object.
			 * @param {Object} target - The target object in which all objects are merged into.
			 * @param {Object} arg1 - Object containing additional properties to merge in target.
			 * @param {Object} argN - Additional objects containing properties to merge in target.
			 * @returns {Object} The `target` object.
			 */
			extend: function(target) {
				var setFn = function(value, key) {
					target[key] = value;
				};
				for(var i = 1, ilen = arguments.length; i < ilen; ++i) {
					helpers.each(arguments[i], setFn);
				}
				return target;
			},
			
			/**
			 * Basic javascript inheritance based on the model created in Backbone.js
			 */
			inherits: function(extensions) {
				var me = this;
				var ChartElement = (extensions && extensions.hasOwnProperty('constructor')) ? extensions.constructor : function() {
					return me.apply(this, arguments);
				};
				
				var Surrogate = function() {
					this.constructor = ChartElement;
				};
				
				Surrogate.prototype = me.prototype;
				ChartElement.prototype = new Surrogate();
				ChartElement.extend = helpers.inherits;
				
				if(extensions) {
					helpers.extend(ChartElement.prototype, extensions);
				}
				
				ChartElement.__super__ = me.prototype;
				return ChartElement;
			}
		};
		
		module.exports = helpers;

// DEPRECATIONS
		
		/**
		 * Provided for backward compatibility, use Chart.helpers.callback instead.
		 * @function Chart.helpers.callCallback
		 * @deprecated since version 2.6.0
		 * @todo remove at version 3
		 * @private
		 */
		helpers.callCallback = helpers.callback;
		
		/**
		 * Provided for backward compatibility, use Array.prototype.indexOf instead.
		 * Array.prototype.indexOf compatibility: Chrome, Opera, Safari, FF1.5+, IE9+
		 * @function Chart.helpers.indexOf
		 * @deprecated since version 2.7.0
		 * @todo remove at version 3
		 * @private
		 */
		helpers.indexOf = function(array, item, fromIndex) {
			return Array.prototype.indexOf.call(array, item, fromIndex);
		};
		
		/**
		 * Provided for backward compatibility, use Chart.helpers.valueOrDefault instead.
		 * @function Chart.helpers.getValueOrDefault
		 * @deprecated since version 2.7.0
		 * @todo remove at version 3
		 * @private
		 */
		helpers.getValueOrDefault = helpers.valueOrDefault;
		
		/**
		 * Provided for backward compatibility, use Chart.helpers.valueAtIndexOrDefault instead.
		 * @function Chart.helpers.getValueAtIndexOrDefault
		 * @deprecated since version 2.7.0
		 * @todo remove at version 3
		 * @private
		 */
		helpers.getValueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
		
		
		/***/
	}),
	
	/***/ "./node_modules/chart.js/src/helpers/helpers.easing.js":
	/*!*************************************************************!*\
  !*** ./node_modules/chart.js/src/helpers/helpers.easing.js ***!
  \*************************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		var helpers = __webpack_require__(/*! ./helpers.core */ "./node_modules/chart.js/src/helpers/helpers.core.js");
		
		/**
		 * Easing functions adapted from Robert Penner's easing equations.
		 * @namespace Chart.helpers.easingEffects
		 * @see http://www.robertpenner.com/easing/
		 */
		var effects = {
			linear: function(t) {
				return t;
			},
			
			easeInQuad: function(t) {
				return t * t;
			},
			
			easeOutQuad: function(t) {
				return -t * (t - 2);
			},
			
			easeInOutQuad: function(t) {
				if((t /= 0.5) < 1) {
					return 0.5 * t * t;
				}
				return -0.5 * ((--t) * (t - 2) - 1);
			},
			
			easeInCubic: function(t) {
				return t * t * t;
			},
			
			easeOutCubic: function(t) {
				return (t = t - 1) * t * t + 1;
			},
			
			easeInOutCubic: function(t) {
				if((t /= 0.5) < 1) {
					return 0.5 * t * t * t;
				}
				return 0.5 * ((t -= 2) * t * t + 2);
			},
			
			easeInQuart: function(t) {
				return t * t * t * t;
			},
			
			easeOutQuart: function(t) {
				return -((t = t - 1) * t * t * t - 1);
			},
			
			easeInOutQuart: function(t) {
				if((t /= 0.5) < 1) {
					return 0.5 * t * t * t * t;
				}
				return -0.5 * ((t -= 2) * t * t * t - 2);
			},
			
			easeInQuint: function(t) {
				return t * t * t * t * t;
			},
			
			easeOutQuint: function(t) {
				return (t = t - 1) * t * t * t * t + 1;
			},
			
			easeInOutQuint: function(t) {
				if((t /= 0.5) < 1) {
					return 0.5 * t * t * t * t * t;
				}
				return 0.5 * ((t -= 2) * t * t * t * t + 2);
			},
			
			easeInSine: function(t) {
				return -Math.cos(t * (Math.PI / 2)) + 1;
			},
			
			easeOutSine: function(t) {
				return Math.sin(t * (Math.PI / 2));
			},
			
			easeInOutSine: function(t) {
				return -0.5 * (Math.cos(Math.PI * t) - 1);
			},
			
			easeInExpo: function(t) {
				return (t === 0) ? 0 : Math.pow(2, 10 * (t - 1));
			},
			
			easeOutExpo: function(t) {
				return (t === 1) ? 1 : -Math.pow(2, -10 * t) + 1;
			},
			
			easeInOutExpo: function(t) {
				if(t === 0) {
					return 0;
				}
				if(t === 1) {
					return 1;
				}
				if((t /= 0.5) < 1) {
					return 0.5 * Math.pow(2, 10 * (t - 1));
				}
				return 0.5 * (-Math.pow(2, -10 * --t) + 2);
			},
			
			easeInCirc: function(t) {
				if(t >= 1) {
					return t;
				}
				return -(Math.sqrt(1 - t * t) - 1);
			},
			
			easeOutCirc: function(t) {
				return Math.sqrt(1 - (t = t - 1) * t);
			},
			
			easeInOutCirc: function(t) {
				if((t /= 0.5) < 1) {
					return -0.5 * (Math.sqrt(1 - t * t) - 1);
				}
				return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
			},
			
			easeInElastic: function(t) {
				var s = 1.70158;
				var p = 0;
				var a = 1;
				if(t === 0) {
					return 0;
				}
				if(t === 1) {
					return 1;
				}
				if(!p) {
					p = 0.3;
				}
				if(a < 1) {
					a = 1;
					s = p / 4;
				} else {
					s = p / (2 * Math.PI) * Math.asin(1 / a);
				}
				return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
			},
			
			easeOutElastic: function(t) {
				var s = 1.70158;
				var p = 0;
				var a = 1;
				if(t === 0) {
					return 0;
				}
				if(t === 1) {
					return 1;
				}
				if(!p) {
					p = 0.3;
				}
				if(a < 1) {
					a = 1;
					s = p / 4;
				} else {
					s = p / (2 * Math.PI) * Math.asin(1 / a);
				}
				return a * Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;
			},
			
			easeInOutElastic: function(t) {
				var s = 1.70158;
				var p = 0;
				var a = 1;
				if(t === 0) {
					return 0;
				}
				if((t /= 0.5) === 2) {
					return 1;
				}
				if(!p) {
					p = 0.45;
				}
				if(a < 1) {
					a = 1;
					s = p / 4;
				} else {
					s = p / (2 * Math.PI) * Math.asin(1 / a);
				}
				if(t < 1) {
					return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
				}
				return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p) * 0.5 + 1;
			},
			easeInBack: function(t) {
				var s = 1.70158;
				return t * t * ((s + 1) * t - s);
			},
			
			easeOutBack: function(t) {
				var s = 1.70158;
				return (t = t - 1) * t * ((s + 1) * t + s) + 1;
			},
			
			easeInOutBack: function(t) {
				var s = 1.70158;
				if((t /= 0.5) < 1) {
					return 0.5 * (t * t * (((s *= (1.525)) + 1) * t - s));
				}
				return 0.5 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);
			},
			
			easeInBounce: function(t) {
				return 1 - effects.easeOutBounce(1 - t);
			},
			
			easeOutBounce: function(t) {
				if(t < (1 / 2.75)) {
					return 7.5625 * t * t;
				}
				if(t < (2 / 2.75)) {
					return 7.5625 * (t -= (1.5 / 2.75)) * t + 0.75;
				}
				if(t < (2.5 / 2.75)) {
					return 7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375;
				}
				return 7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375;
			},
			
			easeInOutBounce: function(t) {
				if(t < 0.5) {
					return effects.easeInBounce(t * 2) * 0.5;
				}
				return effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5;
			}
		};
		
		module.exports = {
			effects: effects
		};

// DEPRECATIONS
		
		/**
		 * Provided for backward compatibility, use Chart.helpers.easing.effects instead.
		 * @function Chart.helpers.easingEffects
		 * @deprecated since version 2.7.0
		 * @todo remove at version 3
		 * @private
		 */
		helpers.easingEffects = effects;
		
		
		/***/
	}),
	
	/***/ "./node_modules/chart.js/src/helpers/helpers.options.js":
	/*!**************************************************************!*\
  !*** ./node_modules/chart.js/src/helpers/helpers.options.js ***!
  \**************************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		var helpers = __webpack_require__(/*! ./helpers.core */ "./node_modules/chart.js/src/helpers/helpers.core.js");
		
		/**
		 * @alias Chart.helpers.options
		 * @namespace
		 */
		module.exports = {
			/**
			 * Converts the given line height `value` in pixels for a specific font `size`.
			 * @param {Number|String} value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').
			 * @param {Number} size - The font size (in pixels) used to resolve relative `value`.
			 * @returns {Number} The effective line height in pixels (size * 1.2 if value is invalid).
			 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height
			 * @since 2.7.0
			 */
			toLineHeight: function(value, size) {
				var matches = ('' + value).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
				if(!matches || matches[1] === 'normal') {
					return size * 1.2;
				}
				
				value = +matches[2];
				
				switch(matches[3]) {
					case 'px':
						return value;
					case '%':
						value /= 100;
						break;
					default:
						break;
				}
				
				return size * value;
			},
			
			/**
			 * Converts the given value into a padding object with pre-computed width/height.
			 * @param {Number|Object} value - If a number, set the value to all TRBL component,
			 *  else, if and object, use defined properties and sets undefined ones to 0.
			 * @returns {Object} The padding values (top, right, bottom, left, width, height)
			 * @since 2.7.0
			 */
			toPadding: function(value) {
				var t, r, b, l;
				
				if(helpers.isObject(value)) {
					t = +value.top || 0;
					r = +value.right || 0;
					b = +value.bottom || 0;
					l = +value.left || 0;
				} else {
					t = r = b = l = +value || 0;
				}
				
				return {
					top: t,
					right: r,
					bottom: b,
					left: l,
					height: t + b,
					width: l + r
				};
			},
			
			/**
			 * Evaluates the given `inputs` sequentially and returns the first defined value.
			 * @param {Array[]} inputs - An array of values, falling back to the last value.
			 * @param {Object} [context] - If defined and the current value is a function, the value
			 * is called with `context` as first argument and the result becomes the new input.
			 * @param {Number} [index] - If defined and the current value is an array, the value
			 * at `index` become the new input.
			 * @since 2.7.0
			 */
			resolve: function(inputs, context, index) {
				var i, ilen, value;
				
				for(i = 0, ilen = inputs.length; i < ilen; ++i) {
					value = inputs[i];
					if(value === undefined) {
						continue;
					}
					if(context !== undefined && typeof value === 'function') {
						value = value(context);
					}
					if(index !== undefined && helpers.isArray(value)) {
						value = value[index];
					}
					if(value !== undefined) {
						return value;
					}
				}
			}
		};
		
		
		/***/
	}),
	
	/***/ "./node_modules/chart.js/src/helpers/index.js":
	/*!****************************************************!*\
  !*** ./node_modules/chart.js/src/helpers/index.js ***!
  \****************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		module.exports = __webpack_require__(/*! ./helpers.core */ "./node_modules/chart.js/src/helpers/helpers.core.js");
		module.exports.easing = __webpack_require__(/*! ./helpers.easing */ "./node_modules/chart.js/src/helpers/helpers.easing.js");
		module.exports.canvas = __webpack_require__(/*! ./helpers.canvas */ "./node_modules/chart.js/src/helpers/helpers.canvas.js");
		module.exports.options = __webpack_require__(/*! ./helpers.options */ "./node_modules/chart.js/src/helpers/helpers.options.js");
		
		
		/***/
	}),
	
	/***/ "./node_modules/chart.js/src/platforms/platform.basic.js":
	/*!***************************************************************!*\
  !*** ./node_modules/chart.js/src/platforms/platform.basic.js ***!
  \***************************************************************/
	/*! no static exports found */
	/***/ (function(module, exports) {
		
		/**
		 * Platform fallback implementation (minimal).
		 * @see https://github.com/chartjs/Chart.js/pull/4591#issuecomment-319575939
		 */
		
		module.exports = {
			acquireContext: function(item) {
				if(item && item.canvas) {
					// Support for any object associated to a canvas (including a context2d)
					item = item.canvas;
				}
				
				return item && item.getContext('2d') || null;
			}
		};
		
		
		/***/
	}),
	
	/***/ "./node_modules/chart.js/src/platforms/platform.dom.js":
	/*!*************************************************************!*\
  !*** ./node_modules/chart.js/src/platforms/platform.dom.js ***!
  \*************************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		/**
		 * Chart.Platform implementation for targeting a web browser
		 */
		
		
		
		var helpers = __webpack_require__(/*! ../helpers/index */ "./node_modules/chart.js/src/helpers/index.js");
		
		var EXPANDO_KEY = '$chartjs';
		var CSS_PREFIX = 'chartjs-';
		var CSS_RENDER_MONITOR = CSS_PREFIX + 'render-monitor';
		var CSS_RENDER_ANIMATION = CSS_PREFIX + 'render-animation';
		var ANIMATION_START_EVENTS = ['animationstart', 'webkitAnimationStart'];
		
		/**
		 * DOM event types -> Chart.js event types.
		 * Note: only events with different types are mapped.
		 * @see https://developer.mozilla.org/en-US/docs/Web/Events
		 */
		var EVENT_TYPES = {
			touchstart: 'mousedown',
			touchmove: 'mousemove',
			touchend: 'mouseup',
			pointerenter: 'mouseenter',
			pointerdown: 'mousedown',
			pointermove: 'mousemove',
			pointerup: 'mouseup',
			pointerleave: 'mouseout',
			pointerout: 'mouseout'
		};
		
		/**
		 * The "used" size is the final value of a dimension property after all calculations have
		 * been performed. This method uses the computed style of `element` but returns undefined
		 * if the computed style is not expressed in pixels. That can happen in some cases where
		 * `element` has a size relative to its parent and this last one is not yet displayed,
		 * for example because of `display: none` on a parent node.
		 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value
		 * @returns {Number} Size in pixels or undefined if unknown.
		 */
		function readUsedSize(element, property) {
			var value = helpers.getStyle(element, property);
			var matches = value && value.match(/^(\d+)(\.\d+)?px$/);
			return matches ? Number(matches[1]) : undefined;
		}
		
		/**
		 * Initializes the canvas style and render size without modifying the canvas display size,
		 * since responsiveness is handled by the controller.resize() method. The config is used
		 * to determine the aspect ratio to apply in case no explicit height has been specified.
		 */
		function initCanvas(canvas, config) {
			var style = canvas.style;
			
			// NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it
			// returns null or '' if no explicit value has been set to the canvas attribute.
			var renderHeight = canvas.getAttribute('height');
			var renderWidth = canvas.getAttribute('width');
			
			// Chart.js modifies some canvas values that we want to restore on destroy
			canvas[EXPANDO_KEY] = {
				initial: {
					height: renderHeight,
					width: renderWidth,
					style: {
						display: style.display,
						height: style.height,
						width: style.width
					}
				}
			};
			
			// Force canvas to display as block to avoid extra space caused by inline
			// elements, which would interfere with the responsive resize process.
			// https://github.com/chartjs/Chart.js/issues/2538
			style.display = style.display || 'block';
			
			if(renderWidth === null || renderWidth === '') {
				var displayWidth = readUsedSize(canvas, 'width');
				if(displayWidth !== undefined) {
					canvas.width = displayWidth;
				}
			}
			
			if(renderHeight === null || renderHeight === '') {
				if(canvas.style.height === '') {
					// If no explicit render height and style height, let's apply the aspect ratio,
					// which one can be specified by the user but also by charts as default option
					// (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.
					canvas.height = canvas.width / (config.options.aspectRatio || 2);
				} else {
					var displayHeight = readUsedSize(canvas, 'height');
					if(displayWidth !== undefined) {
						canvas.height = displayHeight;
					}
				}
			}
			
			return canvas;
		}
		
		/**
		 * Detects support for options object argument in addEventListener.
		 * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support
		 * @private
		 */
		var supportsEventListenerOptions = (function() {
			var supports = false;
			try {
				var options = Object.defineProperty({}, 'passive', {
					get: function() {
						supports = true;
					}
				});
				window.addEventListener('e', null, options);
			} catch(e) {
				// continue regardless of error
			}
			return supports;
		}());

// Default passive to true as expected by Chrome for 'touchstart' and 'touchend' events.
// https://github.com/chartjs/Chart.js/issues/4287
		var eventListenerOptions = supportsEventListenerOptions ? {passive: true} : false;
		
		function addEventListener(node, type, listener) {
			node.addEventListener(type, listener, eventListenerOptions);
		}
		
		function removeEventListener(node, type, listener) {
			node.removeEventListener(type, listener, eventListenerOptions);
		}
		
		function createEvent(type, chart, x, y, nativeEvent) {
			return {
				type: type,
				chart: chart,
				native: nativeEvent || null,
				x: x !== undefined ? x : null,
				y: y !== undefined ? y : null,
			};
		}
		
		function fromNativeEvent(event, chart) {
			var type = EVENT_TYPES[event.type] || event.type;
			var pos = helpers.getRelativePosition(event, chart);
			return createEvent(type, chart, pos.x, pos.y, event);
		}
		
		function throttled(fn, thisArg) {
			var ticking = false;
			var args = [];
			
			return function() {
				args = Array.prototype.slice.call(arguments);
				thisArg = thisArg || this;
				
				if(!ticking) {
					ticking = true;
					helpers.requestAnimFrame.call(window, function() {
						ticking = false;
						fn.apply(thisArg, args);
					});
				}
			};
		}

// Implementation based on https://github.com/marcj/css-element-queries
		function createResizer(handler) {
			var resizer = document.createElement('div');
			var cls = CSS_PREFIX + 'size-monitor';
			var maxSize = 1000000;
			var style =
				'position:absolute;' +
				'left:0;' +
				'top:0;' +
				'right:0;' +
				'bottom:0;' +
				'overflow:hidden;' +
				'pointer-events:none;' +
				'visibility:hidden;' +
				'z-index:-1;';
			
			resizer.style.cssText = style;
			resizer.className = cls;
			resizer.innerHTML =
				'<div class="' + cls + '-expand" style="' + style + '">' +
				'<div style="' +
				'position:absolute;' +
				'width:' + maxSize + 'px;' +
				'height:' + maxSize + 'px;' +
				'left:0;' +
				'top:0">' +
				'</div>' +
				'</div>' +
				'<div class="' + cls + '-shrink" style="' + style + '">' +
				'<div style="' +
				'position:absolute;' +
				'width:200%;' +
				'height:200%;' +
				'left:0; ' +
				'top:0">' +
				'</div>' +
				'</div>';
			
			var expand = resizer.childNodes[0];
			var shrink = resizer.childNodes[1];
			
			resizer._reset = function() {
				expand.scrollLeft = maxSize;
				expand.scrollTop = maxSize;
				shrink.scrollLeft = maxSize;
				shrink.scrollTop = maxSize;
			};
			var onScroll = function() {
				resizer._reset();
				handler();
			};
			
			addEventListener(expand, 'scroll', onScroll.bind(expand, 'expand'));
			addEventListener(shrink, 'scroll', onScroll.bind(shrink, 'shrink'));
			
			return resizer;
		}

// https://davidwalsh.name/detect-node-insertion
		function watchForRender(node, handler) {
			var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});
			var proxy = expando.renderProxy = function(e) {
				if(e.animationName === CSS_RENDER_ANIMATION) {
					handler();
				}
			};
			
			helpers.each(ANIMATION_START_EVENTS, function(type) {
				addEventListener(node, type, proxy);
			});
			
			// #4737: Chrome might skip the CSS animation when the CSS_RENDER_MONITOR class
			// is removed then added back immediately (same animation frame?). Accessing the
			// `offsetParent` property will force a reflow and re-evaluate the CSS animation.
			// https://gist.github.com/paulirish/5d52fb081b3570c81e3a#box-metrics
			// https://github.com/chartjs/Chart.js/issues/4737
			expando.reflow = !!node.offsetParent;
			
			node.classList.add(CSS_RENDER_MONITOR);
		}
		
		function unwatchForRender(node) {
			var expando = node[EXPANDO_KEY] || {};
			var proxy = expando.renderProxy;
			
			if(proxy) {
				helpers.each(ANIMATION_START_EVENTS, function(type) {
					removeEventListener(node, type, proxy);
				});
				
				delete expando.renderProxy;
			}
			
			node.classList.remove(CSS_RENDER_MONITOR);
		}
		
		function addResizeListener(node, listener, chart) {
			var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});
			
			// Let's keep track of this added resizer and thus avoid DOM query when removing it.
			var resizer = expando.resizer = createResizer(throttled(function() {
				if(expando.resizer) {
					return listener(createEvent('resize', chart));
				}
			}));
			
			// The resizer needs to be attached to the node parent, so we first need to be
			// sure that `node` is attached to the DOM before injecting the resizer element.
			watchForRender(node, function() {
				if(expando.resizer) {
					var container = node.parentNode;
					if(container && container !== resizer.parentNode) {
						container.insertBefore(resizer, container.firstChild);
					}
					
					// The container size might have changed, let's reset the resizer state.
					resizer._reset();
				}
			});
		}
		
		function removeResizeListener(node) {
			var expando = node[EXPANDO_KEY] || {};
			var resizer = expando.resizer;
			
			delete expando.resizer;
			unwatchForRender(node);
			
			if(resizer && resizer.parentNode) {
				resizer.parentNode.removeChild(resizer);
			}
		}
		
		function injectCSS(platform, css) {
			// http://stackoverflow.com/q/3922139
			var style = platform._style || document.createElement('style');
			if(!platform._style) {
				platform._style = style;
				css = '/* Chart.js */\n' + css;
				style.setAttribute('type', 'text/css');
				document.getElementsByTagName('head')[0].appendChild(style);
			}
			
			style.appendChild(document.createTextNode(css));
		}
		
		module.exports = {
			/**
			 * This property holds whether this platform is enabled for the current environment.
			 * Currently used by platform.js to select the proper implementation.
			 * @private
			 */
			_enabled: typeof window !== 'undefined' && typeof document !== 'undefined',
			
			initialize: function() {
				var keyframes = 'from{opacity:0.99}to{opacity:1}';
				
				injectCSS(this,
					// DOM rendering detection
					// https://davidwalsh.name/detect-node-insertion
					'@-webkit-keyframes ' + CSS_RENDER_ANIMATION + '{' + keyframes + '}' +
					'@keyframes ' + CSS_RENDER_ANIMATION + '{' + keyframes + '}' +
					'.' + CSS_RENDER_MONITOR + '{' +
					'-webkit-animation:' + CSS_RENDER_ANIMATION + ' 0.001s;' +
					'animation:' + CSS_RENDER_ANIMATION + ' 0.001s;' +
					'}'
				);
			},
			
			acquireContext: function(item, config) {
				if(typeof item === 'string') {
					item = document.getElementById(item);
				} else if(item.length) {
					// Support for array based queries (such as jQuery)
					item = item[0];
				}
				
				if(item && item.canvas) {
					// Support for any object associated to a canvas (including a context2d)
					item = item.canvas;
				}
				
				// To prevent canvas fingerprinting, some add-ons undefine the getContext
				// method, for example: https://github.com/kkapsner/CanvasBlocker
				// https://github.com/chartjs/Chart.js/issues/2807
				var context = item && item.getContext && item.getContext('2d');
				
				// `instanceof HTMLCanvasElement/CanvasRenderingContext2D` fails when the item is
				// inside an iframe or when running in a protected environment. We could guess the
				// types from their toString() value but let's keep things flexible and assume it's
				// a sufficient condition if the item has a context2D which has item as `canvas`.
				// https://github.com/chartjs/Chart.js/issues/3887
				// https://github.com/chartjs/Chart.js/issues/4102
				// https://github.com/chartjs/Chart.js/issues/4152
				if(context && context.canvas === item) {
					initCanvas(item, config);
					return context;
				}
				
				return null;
			},
			
			releaseContext: function(context) {
				var canvas = context.canvas;
				if(!canvas[EXPANDO_KEY]) {
					return;
				}
				
				var initial = canvas[EXPANDO_KEY].initial;
				['height', 'width'].forEach(function(prop) {
					var value = initial[prop];
					if(helpers.isNullOrUndef(value)) {
						canvas.removeAttribute(prop);
					} else {
						canvas.setAttribute(prop, value);
					}
				});
				
				helpers.each(initial.style || {}, function(value, key) {
					canvas.style[key] = value;
				});
				
				// The canvas render size might have been changed (and thus the state stack discarded),
				// we can't use save() and restore() to restore the initial state. So make sure that at
				// least the canvas context is reset to the default state by setting the canvas width.
				// https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html
				canvas.width = canvas.width;
				
				delete canvas[EXPANDO_KEY];
			},
			
			addEventListener: function(chart, type, listener) {
				var canvas = chart.canvas;
				if(type === 'resize') {
					// Note: the resize event is not supported on all browsers.
					addResizeListener(canvas, listener, chart);
					return;
				}
				
				var expando = listener[EXPANDO_KEY] || (listener[EXPANDO_KEY] = {});
				var proxies = expando.proxies || (expando.proxies = {});
				var proxy = proxies[chart.id + '_' + type] = function(event) {
					listener(fromNativeEvent(event, chart));
				};
				
				addEventListener(canvas, type, proxy);
			},
			
			removeEventListener: function(chart, type, listener) {
				var canvas = chart.canvas;
				if(type === 'resize') {
					// Note: the resize event is not supported on all browsers.
					removeResizeListener(canvas, listener);
					return;
				}
				
				var expando = listener[EXPANDO_KEY] || {};
				var proxies = expando.proxies || {};
				var proxy = proxies[chart.id + '_' + type];
				if(!proxy) {
					return;
				}
				
				removeEventListener(canvas, type, proxy);
			}
		};

// DEPRECATIONS
		
		/**
		 * Provided for backward compatibility, use EventTarget.addEventListener instead.
		 * EventTarget.addEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+
		 * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
		 * @function Chart.helpers.addEvent
		 * @deprecated since version 2.7.0
		 * @todo remove at version 3
		 * @private
		 */
		helpers.addEvent = addEventListener;
		
		/**
		 * Provided for backward compatibility, use EventTarget.removeEventListener instead.
		 * EventTarget.removeEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+
		 * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener
		 * @function Chart.helpers.removeEvent
		 * @deprecated since version 2.7.0
		 * @todo remove at version 3
		 * @private
		 */
		helpers.removeEvent = removeEventListener;
		
		
		/***/
	}),
	
	/***/ "./node_modules/chart.js/src/platforms/platform.js":
	/*!*********************************************************!*\
  !*** ./node_modules/chart.js/src/platforms/platform.js ***!
  \*********************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		var helpers = __webpack_require__(/*! ../helpers/index */ "./node_modules/chart.js/src/helpers/index.js");
		var basic = __webpack_require__(/*! ./platform.basic */ "./node_modules/chart.js/src/platforms/platform.basic.js");
		var dom = __webpack_require__(/*! ./platform.dom */ "./node_modules/chart.js/src/platforms/platform.dom.js");

// @TODO Make possible to select another platform at build time.
		var implementation = dom._enabled ? dom : basic;
		
		/**
		 * @namespace Chart.platform
		 * @see https://chartjs.gitbooks.io/proposals/content/Platform.html
		 * @since 2.4.0
		 */
		module.exports = helpers.extend({
			/**
			 * @since 2.7.0
			 */
			initialize: function() {
			},
			
			/**
			 * Called at chart construction time, returns a context2d instance implementing
			 * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.
			 * @param {*} item - The native item from which to acquire context (platform specific)
			 * @param {Object} options - The chart options
			 * @returns {CanvasRenderingContext2D} context2d instance
			 */
			acquireContext: function() {
			},
			
			/**
			 * Called at chart destruction time, releases any resources associated to the context
			 * previously returned by the acquireContext() method.
			 * @param {CanvasRenderingContext2D} context - The context2d instance
			 * @returns {Boolean} true if the method succeeded, else false
			 */
			releaseContext: function() {
			},
			
			/**
			 * Registers the specified listener on the given chart.
			 * @param {Chart} chart - Chart from which to listen for event
			 * @param {String} type - The ({@link IEvent}) type to listen for
			 * @param {Function} listener - Receives a notification (an object that implements
			 * the {@link IEvent} interface) when an event of the specified type occurs.
			 */
			addEventListener: function() {
			},
			
			/**
			 * Removes the specified listener previously registered with addEventListener.
			 * @param {Chart} chart -Chart from which to remove the listener
			 * @param {String} type - The ({@link IEvent}) type to remove
			 * @param {Function} listener - The listener function to remove from the event target.
			 */
			removeEventListener: function() {
			}
			
		}, implementation);
		
		/**
		 * @interface IPlatform
		 * Allows abstracting platform dependencies away from the chart
		 * @borrows Chart.platform.acquireContext as acquireContext
		 * @borrows Chart.platform.releaseContext as releaseContext
		 * @borrows Chart.platform.addEventListener as addEventListener
		 * @borrows Chart.platform.removeEventListener as removeEventListener
		 */
		
		/**
		 * @interface IEvent
		 * @prop {String} type - The event type name, possible values are:
		 * 'contextmenu', 'mouseenter', 'mousedown', 'mousemove', 'mouseup', 'mouseout',
		 * 'click', 'dblclick', 'keydown', 'keypress', 'keyup' and 'resize'
		 * @prop {*} native - The original native event (null for emulated events, e.g. 'resize')
		 * @prop {Number} x - The mouse x position, relative to the canvas (null for incompatible events)
		 * @prop {Number} y - The mouse y position, relative to the canvas (null for incompatible events)
		 */
		
		
		/***/
	}),
	
	/***/ "./node_modules/chart.js/src/plugins/index.js":
	/*!****************************************************!*\
  !*** ./node_modules/chart.js/src/plugins/index.js ***!
  \****************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		module.exports = {};
		module.exports.filler = __webpack_require__(/*! ./plugin.filler */ "./node_modules/chart.js/src/plugins/plugin.filler.js");
		module.exports.legend = __webpack_require__(/*! ./plugin.legend */ "./node_modules/chart.js/src/plugins/plugin.legend.js");
		module.exports.title = __webpack_require__(/*! ./plugin.title */ "./node_modules/chart.js/src/plugins/plugin.title.js");
		
		
		/***/
	}),
	
	/***/ "./node_modules/chart.js/src/plugins/plugin.filler.js":
	/*!************************************************************!*\
  !*** ./node_modules/chart.js/src/plugins/plugin.filler.js ***!
  \************************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		/**
		 * Plugin based on discussion from the following Chart.js issues:
		 * @see https://github.com/chartjs/Chart.js/issues/2380#issuecomment-279961569
		 * @see https://github.com/chartjs/Chart.js/issues/2440#issuecomment-256461897
		 */
		
		
		
		var defaults = __webpack_require__(/*! ../core/core.defaults */ "./node_modules/chart.js/src/core/core.defaults.js");
		var elements = __webpack_require__(/*! ../elements/index */ "./node_modules/chart.js/src/elements/index.js");
		var helpers = __webpack_require__(/*! ../helpers/index */ "./node_modules/chart.js/src/helpers/index.js");
		
		defaults._set('global', {
			plugins: {
				filler: {
					propagate: true
				}
			}
		});
		
		var mappers = {
			dataset: function(source) {
				var index = source.fill;
				var chart = source.chart;
				var meta = chart.getDatasetMeta(index);
				var visible = meta && chart.isDatasetVisible(index);
				var points = (visible && meta.dataset._children) || [];
				var length = points.length || 0;
				
				return !length ? null : function(point, i) {
					return (i < length && points[i]._view) || null;
				};
			},
			
			boundary: function(source) {
				var boundary = source.boundary;
				var x = boundary ? boundary.x : null;
				var y = boundary ? boundary.y : null;
				
				return function(point) {
					return {
						x: x === null ? point.x : x,
						y: y === null ? point.y : y,
					};
				};
			}
		};

// @todo if (fill[0] === '#')
		function decodeFill(el, index, count) {
			var model = el._model || {};
			var fill = model.fill;
			var target;
			
			if(fill === undefined) {
				fill = !!model.backgroundColor;
			}
			
			if(fill === false || fill === null) {
				return false;
			}
			
			if(fill === true) {
				return 'origin';
			}
			
			target = parseFloat(fill, 10);
			if(isFinite(target) && Math.floor(target) === target) {
				if(fill[0] === '-' || fill[0] === '+') {
					target = index + target;
				}
				
				if(target === index || target < 0 || target >= count) {
					return false;
				}
				
				return target;
			}
			
			switch(fill) {
				// compatibility
				case 'bottom':
					return 'start';
				case 'top':
					return 'end';
				case 'zero':
					return 'origin';
				// supported boundaries
				case 'origin':
				case 'start':
				case 'end':
					return fill;
				// invalid fill values
				default:
					return false;
			}
		}
		
		function computeBoundary(source) {
			var model = source.el._model || {};
			var scale = source.el._scale || {};
			var fill = source.fill;
			var target = null;
			var horizontal;
			
			if(isFinite(fill)) {
				return null;
			}
			
			// Backward compatibility: until v3, we still need to support boundary values set on
			// the model (scaleTop, scaleBottom and scaleZero) because some external plugins and
			// controllers might still use it (e.g. the Smith chart).
			
			if(fill === 'start') {
				target = model.scaleBottom === undefined ? scale.bottom : model.scaleBottom;
			} else if(fill === 'end') {
				target = model.scaleTop === undefined ? scale.top : model.scaleTop;
			} else if(model.scaleZero !== undefined) {
				target = model.scaleZero;
			} else if(scale.getBasePosition) {
				target = scale.getBasePosition();
			} else if(scale.getBasePixel) {
				target = scale.getBasePixel();
			}
			
			if(target !== undefined && target !== null) {
				if(target.x !== undefined && target.y !== undefined) {
					return target;
				}
				
				if(typeof target === 'number' && isFinite(target)) {
					horizontal = scale.isHorizontal();
					return {
						x: horizontal ? target : null,
						y: horizontal ? null : target
					};
				}
			}
			
			return null;
		}
		
		function resolveTarget(sources, index, propagate) {
			var source = sources[index];
			var fill = source.fill;
			var visited = [index];
			var target;
			
			if(!propagate) {
				return fill;
			}
			
			while(fill !== false && visited.indexOf(fill) === -1) {
				if(!isFinite(fill)) {
					return fill;
				}
				
				target = sources[fill];
				if(!target) {
					return false;
				}
				
				if(target.visible) {
					return fill;
				}
				
				visited.push(fill);
				fill = target.fill;
			}
			
			return false;
		}
		
		function createMapper(source) {
			var fill = source.fill;
			var type = 'dataset';
			
			if(fill === false) {
				return null;
			}
			
			if(!isFinite(fill)) {
				type = 'boundary';
			}
			
			return mappers[type](source);
		}
		
		function isDrawable(point) {
			return point && !point.skip;
		}
		
		function drawArea(ctx, curve0, curve1, len0, len1) {
			var i;
			
			if(!len0 || !len1) {
				return;
			}
			
			// building first area curve (normal)
			ctx.moveTo(curve0[0].x, curve0[0].y);
			for(i = 1; i < len0; ++i) {
				helpers.canvas.lineTo(ctx, curve0[i - 1], curve0[i]);
			}
			
			// joining the two area curves
			ctx.lineTo(curve1[len1 - 1].x, curve1[len1 - 1].y);
			
			// building opposite area curve (reverse)
			for(i = len1 - 1; i > 0; --i) {
				helpers.canvas.lineTo(ctx, curve1[i], curve1[i - 1], true);
			}
		}
		
		function doFill(ctx, points, mapper, view, color, loop) {
			var count = points.length;
			var span = view.spanGaps;
			var curve0 = [];
			var curve1 = [];
			var len0 = 0;
			var len1 = 0;
			var i, ilen, index, p0, p1, d0, d1;
			
			ctx.beginPath();
			
			for(i = 0, ilen = (count + !!loop); i < ilen; ++i) {
				index = i % count;
				p0 = points[index]._view;
				p1 = mapper(p0, index, view);
				d0 = isDrawable(p0);
				d1 = isDrawable(p1);
				
				if(d0 && d1) {
					len0 = curve0.push(p0);
					len1 = curve1.push(p1);
				} else if(len0 && len1) {
					if(!span) {
						drawArea(ctx, curve0, curve1, len0, len1);
						len0 = len1 = 0;
						curve0 = [];
						curve1 = [];
					} else {
						if(d0) {
							curve0.push(p0);
						}
						if(d1) {
							curve1.push(p1);
						}
					}
				}
			}
			
			drawArea(ctx, curve0, curve1, len0, len1);
			
			ctx.closePath();
			ctx.fillStyle = color;
			ctx.fill();
		}
		
		module.exports = {
			id: 'filler',
			
			afterDatasetsUpdate: function(chart, options) {
				var count = (chart.data.datasets || []).length;
				var propagate = options.propagate;
				var sources = [];
				var meta, i, el, source;
				
				for(i = 0; i < count; ++i) {
					meta = chart.getDatasetMeta(i);
					el = meta.dataset;
					source = null;
					
					if(el && el._model && el instanceof elements.Line) {
						source = {
							visible: chart.isDatasetVisible(i),
							fill: decodeFill(el, i, count),
							chart: chart,
							el: el
						};
					}
					
					meta.$filler = source;
					sources.push(source);
				}
				
				for(i = 0; i < count; ++i) {
					source = sources[i];
					if(!source) {
						continue;
					}
					
					source.fill = resolveTarget(sources, i, propagate);
					source.boundary = computeBoundary(source);
					source.mapper = createMapper(source);
				}
			},
			
			beforeDatasetDraw: function(chart, args) {
				var meta = args.meta.$filler;
				if(!meta) {
					return;
				}
				
				var ctx = chart.ctx;
				var el = meta.el;
				var view = el._view;
				var points = el._children || [];
				var mapper = meta.mapper;
				var color = view.backgroundColor || defaults.global.defaultColor;
				
				if(mapper && color && points.length) {
					helpers.canvas.clipArea(ctx, chart.chartArea);
					doFill(ctx, points, mapper, view, color, el._loop);
					helpers.canvas.unclipArea(ctx);
				}
			}
		};
		
		
		/***/
	}),
	
	/***/ "./node_modules/chart.js/src/plugins/plugin.legend.js":
	/*!************************************************************!*\
  !*** ./node_modules/chart.js/src/plugins/plugin.legend.js ***!
  \************************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		var defaults = __webpack_require__(/*! ../core/core.defaults */ "./node_modules/chart.js/src/core/core.defaults.js");
		var Element = __webpack_require__(/*! ../core/core.element */ "./node_modules/chart.js/src/core/core.element.js");
		var helpers = __webpack_require__(/*! ../helpers/index */ "./node_modules/chart.js/src/helpers/index.js");
		var layouts = __webpack_require__(/*! ../core/core.layouts */ "./node_modules/chart.js/src/core/core.layouts.js");
		
		var noop = helpers.noop;
		
		defaults._set('global', {
			legend: {
				display: true,
				position: 'top',
				fullWidth: true,
				reverse: false,
				weight: 1000,
				
				// a callback that will handle
				onClick: function(e, legendItem) {
					var index = legendItem.datasetIndex;
					var ci = this.chart;
					var meta = ci.getDatasetMeta(index);
					
					// See controller.isDatasetVisible comment
					meta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null;
					
					// We hid a dataset ... rerender the chart
					ci.update();
				},
				
				onHover: null,
				
				labels: {
					boxWidth: 40,
					padding: 10,
					// Generates labels shown in the legend
					// Valid properties to return:
					// text : text to display
					// fillStyle : fill of coloured box
					// strokeStyle: stroke of coloured box
					// hidden : if this legend item refers to a hidden item
					// lineCap : cap style for line
					// lineDash
					// lineDashOffset :
					// lineJoin :
					// lineWidth :
					generateLabels: function(chart) {
						var data = chart.data;
						return helpers.isArray(data.datasets) ? data.datasets.map(function(dataset, i) {
							return {
								text: dataset.label,
								fillStyle: (!helpers.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0]),
								hidden: !chart.isDatasetVisible(i),
								lineCap: dataset.borderCapStyle,
								lineDash: dataset.borderDash,
								lineDashOffset: dataset.borderDashOffset,
								lineJoin: dataset.borderJoinStyle,
								lineWidth: dataset.borderWidth,
								strokeStyle: dataset.borderColor,
								pointStyle: dataset.pointStyle,
								
								// Below is extra data used for toggling the datasets
								datasetIndex: i
							};
						}, this) : [];
					}
				}
			},
			
			legendCallback: function(chart) {
				var text = [];
				text.push('<ul class="' + chart.id + '-legend">');
				for(var i = 0; i < chart.data.datasets.length; i++) {
					text.push('<li><span style="background-color:' + chart.data.datasets[i].backgroundColor + '"></span>');
					if(chart.data.datasets[i].label) {
						text.push(chart.data.datasets[i].label);
					}
					text.push('</li>');
				}
				text.push('</ul>');
				return text.join('');
			}
		});
		
		/**
		 * Helper function to get the box width based on the usePointStyle option
		 * @param labelopts {Object} the label options on the legend
		 * @param fontSize {Number} the label font size
		 * @return {Number} width of the color box area
		 */
		function getBoxWidth(labelOpts, fontSize) {
			return labelOpts.usePointStyle ?
				fontSize * Math.SQRT2 :
				labelOpts.boxWidth;
		}
		
		/**
		 * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!
		 */
		var Legend = Element.extend({
			
			initialize: function(config) {
				helpers.extend(this, config);
				
				// Contains hit boxes for each dataset (in dataset order)
				this.legendHitBoxes = [];
				
				// Are we in doughnut mode which has a different data type
				this.doughnutMode = false;
			},
			
			// These methods are ordered by lifecycle. Utilities then follow.
			// Any function defined here is inherited by all legend types.
			// Any function can be extended by the legend type
			
			beforeUpdate: noop,
			update: function(maxWidth, maxHeight, margins) {
				var me = this;
				
				// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)
				me.beforeUpdate();
				
				// Absorb the master measurements
				me.maxWidth = maxWidth;
				me.maxHeight = maxHeight;
				me.margins = margins;
				
				// Dimensions
				me.beforeSetDimensions();
				me.setDimensions();
				me.afterSetDimensions();
				// Labels
				me.beforeBuildLabels();
				me.buildLabels();
				me.afterBuildLabels();
				
				// Fit
				me.beforeFit();
				me.fit();
				me.afterFit();
				//
				me.afterUpdate();
				
				return me.minSize;
			},
			afterUpdate: noop,
			
			//
			
			beforeSetDimensions: noop,
			setDimensions: function() {
				var me = this;
				// Set the unconstrained dimension before label rotation
				if(me.isHorizontal()) {
					// Reset position before calculating rotation
					me.width = me.maxWidth;
					me.left = 0;
					me.right = me.width;
				} else {
					me.height = me.maxHeight;
					
					// Reset position before calculating rotation
					me.top = 0;
					me.bottom = me.height;
				}
				
				// Reset padding
				me.paddingLeft = 0;
				me.paddingTop = 0;
				me.paddingRight = 0;
				me.paddingBottom = 0;
				
				// Reset minSize
				me.minSize = {
					width: 0,
					height: 0
				};
			},
			afterSetDimensions: noop,
			
			//
			
			beforeBuildLabels: noop,
			buildLabels: function() {
				var me = this;
				var labelOpts = me.options.labels || {};
				var legendItems = helpers.callback(labelOpts.generateLabels, [me.chart], me) || [];
				
				if(labelOpts.filter) {
					legendItems = legendItems.filter(function(item) {
						return labelOpts.filter(item, me.chart.data);
					});
				}
				
				if(me.options.reverse) {
					legendItems.reverse();
				}
				
				me.legendItems = legendItems;
			},
			afterBuildLabels: noop,
			
			//
			
			beforeFit: noop,
			fit: function() {
				var me = this;
				var opts = me.options;
				var labelOpts = opts.labels;
				var display = opts.display;
				
				var ctx = me.ctx;
				
				var globalDefault = defaults.global;
				var valueOrDefault = helpers.valueOrDefault;
				var fontSize = valueOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize);
				var fontStyle = valueOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle);
				var fontFamily = valueOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily);
				var labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);
				
				// Reset hit boxes
				var hitboxes = me.legendHitBoxes = [];
				
				var minSize = me.minSize;
				var isHorizontal = me.isHorizontal();
				
				if(isHorizontal) {
					minSize.width = me.maxWidth; // fill all the width
					minSize.height = display ? 10 : 0;
				} else {
					minSize.width = display ? 10 : 0;
					minSize.height = me.maxHeight; // fill all the height
				}
				
				// Increase sizes here
				if(display) {
					ctx.font = labelFont;
					
					if(isHorizontal) {
						// Labels
						
						// Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one
						var lineWidths = me.lineWidths = [0];
						var totalHeight = me.legendItems.length ? fontSize + (labelOpts.padding) : 0;
						
						ctx.textAlign = 'left';
						ctx.textBaseline = 'top';
						
						helpers.each(me.legendItems, function(legendItem, i) {
							var boxWidth = getBoxWidth(labelOpts, fontSize);
							var width = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;
							
							if(lineWidths[lineWidths.length - 1] + width + labelOpts.padding >= me.width) {
								totalHeight += fontSize + (labelOpts.padding);
								lineWidths[lineWidths.length] = me.left;
							}
							
							// Store the hitbox width and height here. Final position will be updated in `draw`
							hitboxes[i] = {
								left: 0,
								top: 0,
								width: width,
								height: fontSize
							};
							
							lineWidths[lineWidths.length - 1] += width + labelOpts.padding;
						});
						
						minSize.height += totalHeight;
						
					} else {
						var vPadding = labelOpts.padding;
						var columnWidths = me.columnWidths = [];
						var totalWidth = labelOpts.padding;
						var currentColWidth = 0;
						var currentColHeight = 0;
						var itemHeight = fontSize + vPadding;
						
						helpers.each(me.legendItems, function(legendItem, i) {
							var boxWidth = getBoxWidth(labelOpts, fontSize);
							var itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;
							
							// If too tall, go to new column
							if(currentColHeight + itemHeight > minSize.height) {
								totalWidth += currentColWidth + labelOpts.padding;
								columnWidths.push(currentColWidth); // previous column width
								
								currentColWidth = 0;
								currentColHeight = 0;
							}
							
							// Get max width
							currentColWidth = Math.max(currentColWidth, itemWidth);
							currentColHeight += itemHeight;
							
							// Store the hitbox width and height here. Final position will be updated in `draw`
							hitboxes[i] = {
								left: 0,
								top: 0,
								width: itemWidth,
								height: fontSize
							};
						});
						
						totalWidth += currentColWidth;
						columnWidths.push(currentColWidth);
						minSize.width += totalWidth;
					}
				}
				
				me.width = minSize.width;
				me.height = minSize.height;
			},
			afterFit: noop,
			
			// Shared Methods
			isHorizontal: function() {
				return this.options.position === 'top' || this.options.position === 'bottom';
			},
			
			// Actually draw the legend on the canvas
			draw: function() {
				var me = this;
				var opts = me.options;
				var labelOpts = opts.labels;
				var globalDefault = defaults.global;
				var lineDefault = globalDefault.elements.line;
				var legendWidth = me.width;
				var lineWidths = me.lineWidths;
				
				if(opts.display) {
					var ctx = me.ctx;
					var valueOrDefault = helpers.valueOrDefault;
					var fontColor = valueOrDefault(labelOpts.fontColor, globalDefault.defaultFontColor);
					var fontSize = valueOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize);
					var fontStyle = valueOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle);
					var fontFamily = valueOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily);
					var labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);
					var cursor;
					
					// Canvas setup
					ctx.textAlign = 'left';
					ctx.textBaseline = 'middle';
					ctx.lineWidth = 0.5;
					ctx.strokeStyle = fontColor; // for strikethrough effect
					ctx.fillStyle = fontColor; // render in correct colour
					ctx.font = labelFont;
					
					var boxWidth = getBoxWidth(labelOpts, fontSize);
					var hitboxes = me.legendHitBoxes;
					
					// current position
					var drawLegendBox = function(x, y, legendItem) {
						if(isNaN(boxWidth) || boxWidth <= 0) {
							return;
						}
						
						// Set the ctx for the box
						ctx.save();
						
						ctx.fillStyle = valueOrDefault(legendItem.fillStyle, globalDefault.defaultColor);
						ctx.lineCap = valueOrDefault(legendItem.lineCap, lineDefault.borderCapStyle);
						ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, lineDefault.borderDashOffset);
						ctx.lineJoin = valueOrDefault(legendItem.lineJoin, lineDefault.borderJoinStyle);
						ctx.lineWidth = valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth);
						ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, globalDefault.defaultColor);
						var isLineWidthZero = (valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth) === 0);
						
						if(ctx.setLineDash) {
							// IE 9 and 10 do not support line dash
							ctx.setLineDash(valueOrDefault(legendItem.lineDash, lineDefault.borderDash));
						}
						
						if(opts.labels && opts.labels.usePointStyle) {
							// Recalculate x and y for drawPoint() because its expecting
							// x and y to be center of figure (instead of top left)
							var radius = fontSize * Math.SQRT2 / 2;
							var offSet = radius / Math.SQRT2;
							var centerX = x + offSet;
							var centerY = y + offSet;
							
							// Draw pointStyle as legend symbol
							helpers.canvas.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);
						} else {
							// Draw box as legend symbol
							if(!isLineWidthZero) {
								ctx.strokeRect(x, y, boxWidth, fontSize);
							}
							ctx.fillRect(x, y, boxWidth, fontSize);
						}
						
						ctx.restore();
					};
					var fillText = function(x, y, legendItem, textWidth) {
						var halfFontSize = fontSize / 2;
						var xLeft = boxWidth + halfFontSize + x;
						var yMiddle = y + halfFontSize;
						
						ctx.fillText(legendItem.text, xLeft, yMiddle);
						
						if(legendItem.hidden) {
							// Strikethrough the text if hidden
							ctx.beginPath();
							ctx.lineWidth = 2;
							ctx.moveTo(xLeft, yMiddle);
							ctx.lineTo(xLeft + textWidth, yMiddle);
							ctx.stroke();
						}
					};
					
					// Horizontal
					var isHorizontal = me.isHorizontal();
					if(isHorizontal) {
						cursor = {
							x: me.left + ((legendWidth - lineWidths[0]) / 2),
							y: me.top + labelOpts.padding,
							line: 0
						};
					} else {
						cursor = {
							x: me.left + labelOpts.padding,
							y: me.top + labelOpts.padding,
							line: 0
						};
					}
					
					var itemHeight = fontSize + labelOpts.padding;
					helpers.each(me.legendItems, function(legendItem, i) {
						var textWidth = ctx.measureText(legendItem.text).width;
						var width = boxWidth + (fontSize / 2) + textWidth;
						var x = cursor.x;
						var y = cursor.y;
						
						if(isHorizontal) {
							if(x + width >= legendWidth) {
								y = cursor.y += itemHeight;
								cursor.line++;
								x = cursor.x = me.left + ((legendWidth - lineWidths[cursor.line]) / 2);
							}
						} else if(y + itemHeight > me.bottom) {
							x = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;
							y = cursor.y = me.top + labelOpts.padding;
							cursor.line++;
						}
						
						drawLegendBox(x, y, legendItem);
						
						hitboxes[i].left = x;
						hitboxes[i].top = y;
						
						// Fill the actual label
						fillText(x, y, legendItem, textWidth);
						
						if(isHorizontal) {
							cursor.x += width + (labelOpts.padding);
						} else {
							cursor.y += itemHeight;
						}
						
					});
				}
			},
			
			/**
			 * Handle an event
			 * @private
			 * @param {IEvent} event - The event to handle
			 * @return {Boolean} true if a change occured
			 */
			handleEvent: function(e) {
				var me = this;
				var opts = me.options;
				var type = e.type === 'mouseup' ? 'click' : e.type;
				var changed = false;
				
				if(type === 'mousemove') {
					if(!opts.onHover) {
						return;
					}
				} else if(type === 'click') {
					if(!opts.onClick) {
						return;
					}
				} else {
					return;
				}
				
				// Chart event already has relative position in it
				var x = e.x;
				var y = e.y;
				
				if(x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {
					// See if we are touching one of the dataset boxes
					var lh = me.legendHitBoxes;
					for(var i = 0; i < lh.length; ++i) {
						var hitBox = lh[i];
						
						if(x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {
							// Touching an element
							if(type === 'click') {
								// use e.native for backwards compatibility
								opts.onClick.call(me, e.native, me.legendItems[i]);
								changed = true;
								break;
							} else if(type === 'mousemove') {
								// use e.native for backwards compatibility
								opts.onHover.call(me, e.native, me.legendItems[i]);
								changed = true;
								break;
							}
						}
					}
				}
				
				return changed;
			}
		});
		
		function createNewLegendAndAttach(chart, legendOpts) {
			var legend = new Legend({
				ctx: chart.ctx,
				options: legendOpts,
				chart: chart
			});
			
			layouts.configure(chart, legend, legendOpts);
			layouts.addBox(chart, legend);
			chart.legend = legend;
		}
		
		module.exports = {
			id: 'legend',
			
			/**
			 * Backward compatibility: since 2.1.5, the legend is registered as a plugin, making
			 * Chart.Legend obsolete. To avoid a breaking change, we export the Legend as part of
			 * the plugin, which one will be re-exposed in the chart.js file.
			 * https://github.com/chartjs/Chart.js/pull/2640
			 * @private
			 */
			_element: Legend,
			
			beforeInit: function(chart) {
				var legendOpts = chart.options.legend;
				
				if(legendOpts) {
					createNewLegendAndAttach(chart, legendOpts);
				}
			},
			
			beforeUpdate: function(chart) {
				var legendOpts = chart.options.legend;
				var legend = chart.legend;
				
				if(legendOpts) {
					helpers.mergeIf(legendOpts, defaults.global.legend);
					
					if(legend) {
						layouts.configure(chart, legend, legendOpts);
						legend.options = legendOpts;
					} else {
						createNewLegendAndAttach(chart, legendOpts);
					}
				} else if(legend) {
					layouts.removeBox(chart, legend);
					delete chart.legend;
				}
			},
			
			afterEvent: function(chart, e) {
				var legend = chart.legend;
				if(legend) {
					legend.handleEvent(e);
				}
			}
		};
		
		
		/***/
	}),
	
	/***/ "./node_modules/chart.js/src/plugins/plugin.title.js":
	/*!***********************************************************!*\
  !*** ./node_modules/chart.js/src/plugins/plugin.title.js ***!
  \***********************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		var defaults = __webpack_require__(/*! ../core/core.defaults */ "./node_modules/chart.js/src/core/core.defaults.js");
		var Element = __webpack_require__(/*! ../core/core.element */ "./node_modules/chart.js/src/core/core.element.js");
		var helpers = __webpack_require__(/*! ../helpers/index */ "./node_modules/chart.js/src/helpers/index.js");
		var layouts = __webpack_require__(/*! ../core/core.layouts */ "./node_modules/chart.js/src/core/core.layouts.js");
		
		var noop = helpers.noop;
		
		defaults._set('global', {
			title: {
				display: false,
				fontStyle: 'bold',
				fullWidth: true,
				lineHeight: 1.2,
				padding: 10,
				position: 'top',
				text: '',
				weight: 2000         // by default greater than legend (1000) to be above
			}
		});
		
		/**
		 * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!
		 */
		var Title = Element.extend({
			initialize: function(config) {
				var me = this;
				helpers.extend(me, config);
				
				// Contains hit boxes for each dataset (in dataset order)
				me.legendHitBoxes = [];
			},
			
			// These methods are ordered by lifecycle. Utilities then follow.
			
			beforeUpdate: noop,
			update: function(maxWidth, maxHeight, margins) {
				var me = this;
				
				// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)
				me.beforeUpdate();
				
				// Absorb the master measurements
				me.maxWidth = maxWidth;
				me.maxHeight = maxHeight;
				me.margins = margins;
				
				// Dimensions
				me.beforeSetDimensions();
				me.setDimensions();
				me.afterSetDimensions();
				// Labels
				me.beforeBuildLabels();
				me.buildLabels();
				me.afterBuildLabels();
				
				// Fit
				me.beforeFit();
				me.fit();
				me.afterFit();
				//
				me.afterUpdate();
				
				return me.minSize;
				
			},
			afterUpdate: noop,
			
			//
			
			beforeSetDimensions: noop,
			setDimensions: function() {
				var me = this;
				// Set the unconstrained dimension before label rotation
				if(me.isHorizontal()) {
					// Reset position before calculating rotation
					me.width = me.maxWidth;
					me.left = 0;
					me.right = me.width;
				} else {
					me.height = me.maxHeight;
					
					// Reset position before calculating rotation
					me.top = 0;
					me.bottom = me.height;
				}
				
				// Reset padding
				me.paddingLeft = 0;
				me.paddingTop = 0;
				me.paddingRight = 0;
				me.paddingBottom = 0;
				
				// Reset minSize
				me.minSize = {
					width: 0,
					height: 0
				};
			},
			afterSetDimensions: noop,
			
			//
			
			beforeBuildLabels: noop,
			buildLabels: noop,
			afterBuildLabels: noop,
			
			//
			
			beforeFit: noop,
			fit: function() {
				var me = this;
				var valueOrDefault = helpers.valueOrDefault;
				var opts = me.options;
				var display = opts.display;
				var fontSize = valueOrDefault(opts.fontSize, defaults.global.defaultFontSize);
				var minSize = me.minSize;
				var lineCount = helpers.isArray(opts.text) ? opts.text.length : 1;
				var lineHeight = helpers.options.toLineHeight(opts.lineHeight, fontSize);
				var textSize = display ? (lineCount * lineHeight) + (opts.padding * 2) : 0;
				
				if(me.isHorizontal()) {
					minSize.width = me.maxWidth; // fill all the width
					minSize.height = textSize;
				} else {
					minSize.width = textSize;
					minSize.height = me.maxHeight; // fill all the height
				}
				
				me.width = minSize.width;
				me.height = minSize.height;
				
			},
			afterFit: noop,
			
			// Shared Methods
			isHorizontal: function() {
				var pos = this.options.position;
				return pos === 'top' || pos === 'bottom';
			},
			
			// Actually draw the title block on the canvas
			draw: function() {
				var me = this;
				var ctx = me.ctx;
				var valueOrDefault = helpers.valueOrDefault;
				var opts = me.options;
				var globalDefaults = defaults.global;
				
				if(opts.display) {
					var fontSize = valueOrDefault(opts.fontSize, globalDefaults.defaultFontSize);
					var fontStyle = valueOrDefault(opts.fontStyle, globalDefaults.defaultFontStyle);
					var fontFamily = valueOrDefault(opts.fontFamily, globalDefaults.defaultFontFamily);
					var titleFont = helpers.fontString(fontSize, fontStyle, fontFamily);
					var lineHeight = helpers.options.toLineHeight(opts.lineHeight, fontSize);
					var offset = lineHeight / 2 + opts.padding;
					var rotation = 0;
					var top = me.top;
					var left = me.left;
					var bottom = me.bottom;
					var right = me.right;
					var maxWidth, titleX, titleY;
					
					ctx.fillStyle = valueOrDefault(opts.fontColor, globalDefaults.defaultFontColor); // render in correct colour
					ctx.font = titleFont;
					
					// Horizontal
					if(me.isHorizontal()) {
						titleX = left + ((right - left) / 2); // midpoint of the width
						titleY = top + offset;
						maxWidth = right - left;
					} else {
						titleX = opts.position === 'left' ? left + offset : right - offset;
						titleY = top + ((bottom - top) / 2);
						maxWidth = bottom - top;
						rotation = Math.PI * (opts.position === 'left' ? -0.5 : 0.5);
					}
					
					ctx.save();
					ctx.translate(titleX, titleY);
					ctx.rotate(rotation);
					ctx.textAlign = 'center';
					ctx.textBaseline = 'middle';
					
					var text = opts.text;
					if(helpers.isArray(text)) {
						var y = 0;
						for(var i = 0; i < text.length; ++i) {
							ctx.fillText(text[i], 0, y, maxWidth);
							y += lineHeight;
						}
					} else {
						ctx.fillText(text, 0, 0, maxWidth);
					}
					
					ctx.restore();
				}
			}
		});
		
		function createNewTitleBlockAndAttach(chart, titleOpts) {
			var title = new Title({
				ctx: chart.ctx,
				options: titleOpts,
				chart: chart
			});
			
			layouts.configure(chart, title, titleOpts);
			layouts.addBox(chart, title);
			chart.titleBlock = title;
		}
		
		module.exports = {
			id: 'title',
			
			/**
			 * Backward compatibility: since 2.1.5, the title is registered as a plugin, making
			 * Chart.Title obsolete. To avoid a breaking change, we export the Title as part of
			 * the plugin, which one will be re-exposed in the chart.js file.
			 * https://github.com/chartjs/Chart.js/pull/2640
			 * @private
			 */
			_element: Title,
			
			beforeInit: function(chart) {
				var titleOpts = chart.options.title;
				
				if(titleOpts) {
					createNewTitleBlockAndAttach(chart, titleOpts);
				}
			},
			
			beforeUpdate: function(chart) {
				var titleOpts = chart.options.title;
				var titleBlock = chart.titleBlock;
				
				if(titleOpts) {
					helpers.mergeIf(titleOpts, defaults.global.title);
					
					if(titleBlock) {
						layouts.configure(chart, titleBlock, titleOpts);
						titleBlock.options = titleOpts;
					} else {
						createNewTitleBlockAndAttach(chart, titleOpts);
					}
				} else if(titleBlock) {
					layouts.removeBox(chart, titleBlock);
					delete chart.titleBlock;
				}
			}
		};
		
		
		/***/
	}),
	
	/***/ "./node_modules/chart.js/src/scales/scale.category.js":
	/*!************************************************************!*\
  !*** ./node_modules/chart.js/src/scales/scale.category.js ***!
  \************************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		var Scale = __webpack_require__(/*! ../core/core.scale */ "./node_modules/chart.js/src/core/core.scale.js");
		var scaleService = __webpack_require__(/*! ../core/core.scaleService */ "./node_modules/chart.js/src/core/core.scaleService.js");
		
		module.exports = function() {
			
			// Default config for a category scale
			var defaultConfig = {
				position: 'bottom'
			};
			
			var DatasetScale = Scale.extend({
				/**
				 * Internal function to get the correct labels. If data.xLabels or data.yLabels are defined, use those
				 * else fall back to data.labels
				 * @private
				 */
				getLabels: function() {
					var data = this.chart.data;
					return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels;
				},
				
				determineDataLimits: function() {
					var me = this;
					var labels = me.getLabels();
					me.minIndex = 0;
					me.maxIndex = labels.length - 1;
					var findIndex;
					
					if(me.options.ticks.min !== undefined) {
						// user specified min value
						findIndex = labels.indexOf(me.options.ticks.min);
						me.minIndex = findIndex !== -1 ? findIndex : me.minIndex;
					}
					
					if(me.options.ticks.max !== undefined) {
						// user specified max value
						findIndex = labels.indexOf(me.options.ticks.max);
						me.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;
					}
					
					me.min = labels[me.minIndex];
					me.max = labels[me.maxIndex];
				},
				
				buildTicks: function() {
					var me = this;
					var labels = me.getLabels();
					// If we are viewing some subset of labels, slice the original array
					me.ticks = (me.minIndex === 0 && me.maxIndex === labels.length - 1) ? labels : labels.slice(me.minIndex, me.maxIndex + 1);
				},
				
				getLabelForIndex: function(index, datasetIndex) {
					var me = this;
					var data = me.chart.data;
					var isHorizontal = me.isHorizontal();
					
					if(data.yLabels && !isHorizontal) {
						return me.getRightValue(data.datasets[datasetIndex].data[index]);
					}
					return me.ticks[index - me.minIndex];
				},
				
				// Used to get data value locations.  Value can either be an index or a numerical value
				getPixelForValue: function(value, index) {
					var me = this;
					var offset = me.options.offset;
					// 1 is added because we need the length but we have the indexes
					var offsetAmt = Math.max((me.maxIndex + 1 - me.minIndex - (offset ? 0 : 1)), 1);
					
					// If value is a data object, then index is the index in the data array,
					// not the index of the scale. We need to change that.
					var valueCategory;
					if(value !== undefined && value !== null) {
						valueCategory = me.isHorizontal() ? value.x : value.y;
					}
					if(valueCategory !== undefined || (value !== undefined && isNaN(index))) {
						var labels = me.getLabels();
						value = valueCategory || value;
						var idx = labels.indexOf(value);
						index = idx !== -1 ? idx : index;
					}
					
					if(me.isHorizontal()) {
						var valueWidth = me.width / offsetAmt;
						var widthOffset = (valueWidth * (index - me.minIndex));
						
						if(offset) {
							widthOffset += (valueWidth / 2);
						}
						
						return me.left + Math.round(widthOffset);
					}
					var valueHeight = me.height / offsetAmt;
					var heightOffset = (valueHeight * (index - me.minIndex));
					
					if(offset) {
						heightOffset += (valueHeight / 2);
					}
					
					return me.top + Math.round(heightOffset);
				},
				getPixelForTick: function(index) {
					return this.getPixelForValue(this.ticks[index], index + this.minIndex, null);
				},
				getValueForPixel: function(pixel) {
					var me = this;
					var offset = me.options.offset;
					var value;
					var offsetAmt = Math.max((me._ticks.length - (offset ? 0 : 1)), 1);
					var horz = me.isHorizontal();
					var valueDimension = (horz ? me.width : me.height) / offsetAmt;
					
					pixel -= horz ? me.left : me.top;
					
					if(offset) {
						pixel -= (valueDimension / 2);
					}
					
					if(pixel <= 0) {
						value = 0;
					} else {
						value = Math.round(pixel / valueDimension);
					}
					
					return value + me.minIndex;
				},
				getBasePixel: function() {
					return this.bottom;
				}
			});
			
			scaleService.registerScaleType('category', DatasetScale, defaultConfig);
		};
		
		
		/***/
	}),
	
	/***/ "./node_modules/chart.js/src/scales/scale.linear.js":
	/*!**********************************************************!*\
  !*** ./node_modules/chart.js/src/scales/scale.linear.js ***!
  \**********************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		var defaults = __webpack_require__(/*! ../core/core.defaults */ "./node_modules/chart.js/src/core/core.defaults.js");
		var helpers = __webpack_require__(/*! ../helpers/index */ "./node_modules/chart.js/src/helpers/index.js");
		var scaleService = __webpack_require__(/*! ../core/core.scaleService */ "./node_modules/chart.js/src/core/core.scaleService.js");
		var Ticks = __webpack_require__(/*! ../core/core.ticks */ "./node_modules/chart.js/src/core/core.ticks.js");
		
		module.exports = function(Chart) {
			
			var defaultConfig = {
				position: 'left',
				ticks: {
					callback: Ticks.formatters.linear
				}
			};
			
			var LinearScale = Chart.LinearScaleBase.extend({
				
				determineDataLimits: function() {
					var me = this;
					var opts = me.options;
					var chart = me.chart;
					var data = chart.data;
					var datasets = data.datasets;
					var isHorizontal = me.isHorizontal();
					var DEFAULT_MIN = 0;
					var DEFAULT_MAX = 1;
					
					function IDMatches(meta) {
						return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
					}
					
					// First Calculate the range
					me.min = null;
					me.max = null;
					
					var hasStacks = opts.stacked;
					if(hasStacks === undefined) {
						helpers.each(datasets, function(dataset, datasetIndex) {
							if(hasStacks) {
								return;
							}
							
							var meta = chart.getDatasetMeta(datasetIndex);
							if(chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&
								meta.stack !== undefined) {
								hasStacks = true;
							}
						});
					}
					
					if(opts.stacked || hasStacks) {
						var valuesPerStack = {};
						
						helpers.each(datasets, function(dataset, datasetIndex) {
							var meta = chart.getDatasetMeta(datasetIndex);
							var key = [
								meta.type,
								// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
								((opts.stacked === undefined && meta.stack === undefined) ? datasetIndex : ''),
								meta.stack
							].join('.');
							
							if(valuesPerStack[key] === undefined) {
								valuesPerStack[key] = {
									positiveValues: [],
									negativeValues: []
								};
							}
							
							// Store these per type
							var positiveValues = valuesPerStack[key].positiveValues;
							var negativeValues = valuesPerStack[key].negativeValues;
							
							if(chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
								helpers.each(dataset.data, function(rawValue, index) {
									var value = +me.getRightValue(rawValue);
									if(isNaN(value) || meta.data[index].hidden) {
										return;
									}
									
									positiveValues[index] = positiveValues[index] || 0;
									negativeValues[index] = negativeValues[index] || 0;
									
									if(opts.relativePoints) {
										positiveValues[index] = 100;
									} else if(value < 0) {
										negativeValues[index] += value;
									} else {
										positiveValues[index] += value;
									}
								});
							}
						});
						
						helpers.each(valuesPerStack, function(valuesForType) {
							var values = valuesForType.positiveValues.concat(valuesForType.negativeValues);
							var minVal = helpers.min(values);
							var maxVal = helpers.max(values);
							me.min = me.min === null ? minVal : Math.min(me.min, minVal);
							me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);
						});
						
					} else {
						helpers.each(datasets, function(dataset, datasetIndex) {
							var meta = chart.getDatasetMeta(datasetIndex);
							if(chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
								helpers.each(dataset.data, function(rawValue, index) {
									var value = +me.getRightValue(rawValue);
									if(isNaN(value) || meta.data[index].hidden) {
										return;
									}
									
									if(me.min === null) {
										me.min = value;
									} else if(value < me.min) {
										me.min = value;
									}
									
									if(me.max === null) {
										me.max = value;
									} else if(value > me.max) {
										me.max = value;
									}
								});
							}
						});
					}
					
					me.min = isFinite(me.min) && !isNaN(me.min) ? me.min : DEFAULT_MIN;
					me.max = isFinite(me.max) && !isNaN(me.max) ? me.max : DEFAULT_MAX;
					
					// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero
					this.handleTickRangeOptions();
				},
				getTickLimit: function() {
					var maxTicks;
					var me = this;
					var tickOpts = me.options.ticks;
					
					if(me.isHorizontal()) {
						maxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.width / 50));
					} else {
						// The factor of 2 used to scale the font size has been experimentally determined.
						var tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, defaults.global.defaultFontSize);
						maxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.height / (2 * tickFontSize)));
					}
					
					return maxTicks;
				},
				// Called after the ticks are built. We need
				handleDirectionalChanges: function() {
					if(!this.isHorizontal()) {
						// We are in a vertical orientation. The top value is the highest. So reverse the array
						this.ticks.reverse();
					}
				},
				getLabelForIndex: function(index, datasetIndex) {
					return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
				},
				// Utils
				getPixelForValue: function(value) {
					// This must be called after fit has been run so that
					// this.left, this.top, this.right, and this.bottom have been defined
					var me = this;
					var start = me.start;
					
					var rightValue = +me.getRightValue(value);
					var pixel;
					var range = me.end - start;
					
					if(me.isHorizontal()) {
						pixel = me.left + (me.width / range * (rightValue - start));
					} else {
						pixel = me.bottom - (me.height / range * (rightValue - start));
					}
					return pixel;
				},
				getValueForPixel: function(pixel) {
					var me = this;
					var isHorizontal = me.isHorizontal();
					var innerDimension = isHorizontal ? me.width : me.height;
					var offset = (isHorizontal ? pixel - me.left : me.bottom - pixel) / innerDimension;
					return me.start + ((me.end - me.start) * offset);
				},
				getPixelForTick: function(index) {
					return this.getPixelForValue(this.ticksAsNumbers[index]);
				}
			});
			
			scaleService.registerScaleType('linear', LinearScale, defaultConfig);
		};
		
		
		/***/
	}),
	
	/***/ "./node_modules/chart.js/src/scales/scale.linearbase.js":
	/*!**************************************************************!*\
  !*** ./node_modules/chart.js/src/scales/scale.linearbase.js ***!
  \**************************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		var helpers = __webpack_require__(/*! ../helpers/index */ "./node_modules/chart.js/src/helpers/index.js");
		var Scale = __webpack_require__(/*! ../core/core.scale */ "./node_modules/chart.js/src/core/core.scale.js");
		
		/**
		 * Generate a set of linear ticks
		 * @param generationOptions the options used to generate the ticks
		 * @param dataRange the range of the data
		 * @returns {Array<Number>} array of tick values
		 */
		function generateTicks(generationOptions, dataRange) {
			var ticks = [];
			// To get a "nice" value for the tick spacing, we will use the appropriately named
			// "nice number" algorithm. See http://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks
			// for details.
			
			var factor;
			var precision;
			var spacing;
			
			if(generationOptions.stepSize && generationOptions.stepSize > 0) {
				spacing = generationOptions.stepSize;
			} else {
				var niceRange = helpers.niceNum(dataRange.max - dataRange.min, false);
				spacing = helpers.niceNum(niceRange / (generationOptions.maxTicks - 1), true);
				
				precision = generationOptions.precision;
				if(precision !== undefined) {
					// If the user specified a precision, round to that number of decimal places
					factor = Math.pow(10, precision);
					spacing = Math.ceil(spacing * factor) / factor;
				}
			}
			var niceMin = Math.floor(dataRange.min / spacing) * spacing;
			var niceMax = Math.ceil(dataRange.max / spacing) * spacing;
			
			// If min, max and stepSize is set and they make an evenly spaced scale use it.
			if(!helpers.isNullOrUndef(generationOptions.min) && !helpers.isNullOrUndef(generationOptions.max) && generationOptions.stepSize) {
				// If very close to our whole number, use it.
				if(helpers.almostWhole((generationOptions.max - generationOptions.min) / generationOptions.stepSize, spacing / 1000)) {
					niceMin = generationOptions.min;
					niceMax = generationOptions.max;
				}
			}
			
			var numSpaces = (niceMax - niceMin) / spacing;
			// If very close to our rounded value, use it.
			if(helpers.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {
				numSpaces = Math.round(numSpaces);
			} else {
				numSpaces = Math.ceil(numSpaces);
			}
			
			precision = 1;
			if(spacing < 1) {
				precision = Math.pow(10, 1 - Math.floor(helpers.log10(spacing)));
				niceMin = Math.round(niceMin * precision) / precision;
				niceMax = Math.round(niceMax * precision) / precision;
			}
			ticks.push(generationOptions.min !== undefined ? generationOptions.min : niceMin);
			for(var j = 1; j < numSpaces; ++j) {
				ticks.push(Math.round((niceMin + j * spacing) * precision) / precision);
			}
			ticks.push(generationOptions.max !== undefined ? generationOptions.max : niceMax);
			
			return ticks;
		}
		
		module.exports = function(Chart) {
			
			var noop = helpers.noop;
			
			Chart.LinearScaleBase = Scale.extend({
				getRightValue: function(value) {
					if(typeof value === 'string') {
						return +value;
					}
					return Scale.prototype.getRightValue.call(this, value);
				},
				
				handleTickRangeOptions: function() {
					var me = this;
					var opts = me.options;
					var tickOpts = opts.ticks;
					
					// If we are forcing it to begin at 0, but 0 will already be rendered on the chart,
					// do nothing since that would make the chart weird. If the user really wants a weird chart
					// axis, they can manually override it
					if(tickOpts.beginAtZero) {
						var minSign = helpers.sign(me.min);
						var maxSign = helpers.sign(me.max);
						
						if(minSign < 0 && maxSign < 0) {
							// move the top up to 0
							me.max = 0;
						} else if(minSign > 0 && maxSign > 0) {
							// move the bottom down to 0
							me.min = 0;
						}
					}
					
					var setMin = tickOpts.min !== undefined || tickOpts.suggestedMin !== undefined;
					var setMax = tickOpts.max !== undefined || tickOpts.suggestedMax !== undefined;
					
					if(tickOpts.min !== undefined) {
						me.min = tickOpts.min;
					} else if(tickOpts.suggestedMin !== undefined) {
						if(me.min === null) {
							me.min = tickOpts.suggestedMin;
						} else {
							me.min = Math.min(me.min, tickOpts.suggestedMin);
						}
					}
					
					if(tickOpts.max !== undefined) {
						me.max = tickOpts.max;
					} else if(tickOpts.suggestedMax !== undefined) {
						if(me.max === null) {
							me.max = tickOpts.suggestedMax;
						} else {
							me.max = Math.max(me.max, tickOpts.suggestedMax);
						}
					}
					
					if(setMin !== setMax) {
						// We set the min or the max but not both.
						// So ensure that our range is good
						// Inverted or 0 length range can happen when
						// ticks.min is set, and no datasets are visible
						if(me.min >= me.max) {
							if(setMin) {
								me.max = me.min + 1;
							} else {
								me.min = me.max - 1;
							}
						}
					}
					
					if(me.min === me.max) {
						me.max++;
						
						if(!tickOpts.beginAtZero) {
							me.min--;
						}
					}
				},
				getTickLimit: noop,
				handleDirectionalChanges: noop,
				
				buildTicks: function() {
					var me = this;
					var opts = me.options;
					var tickOpts = opts.ticks;
					
					// Figure out what the max number of ticks we can support it is based on the size of
					// the axis area. For now, we say that the minimum tick spacing in pixels must be 50
					// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on
					// the graph. Make sure we always have at least 2 ticks
					var maxTicks = me.getTickLimit();
					maxTicks = Math.max(2, maxTicks);
					
					var numericGeneratorOptions = {
						maxTicks: maxTicks,
						min: tickOpts.min,
						max: tickOpts.max,
						precision: tickOpts.precision,
						stepSize: helpers.valueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)
					};
					var ticks = me.ticks = generateTicks(numericGeneratorOptions, me);
					
					me.handleDirectionalChanges();
					
					// At this point, we need to update our max and min given the tick values since we have expanded the
					// range of the scale
					me.max = helpers.max(ticks);
					me.min = helpers.min(ticks);
					
					if(tickOpts.reverse) {
						ticks.reverse();
						
						me.start = me.max;
						me.end = me.min;
					} else {
						me.start = me.min;
						me.end = me.max;
					}
				},
				convertTicksToLabels: function() {
					var me = this;
					me.ticksAsNumbers = me.ticks.slice();
					me.zeroLineIndex = me.ticks.indexOf(0);
					
					Scale.prototype.convertTicksToLabels.call(me);
				}
			});
		};
		
		
		/***/
	}),
	
	/***/ "./node_modules/chart.js/src/scales/scale.logarithmic.js":
	/*!***************************************************************!*\
  !*** ./node_modules/chart.js/src/scales/scale.logarithmic.js ***!
  \***************************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		var helpers = __webpack_require__(/*! ../helpers/index */ "./node_modules/chart.js/src/helpers/index.js");
		var Scale = __webpack_require__(/*! ../core/core.scale */ "./node_modules/chart.js/src/core/core.scale.js");
		var scaleService = __webpack_require__(/*! ../core/core.scaleService */ "./node_modules/chart.js/src/core/core.scaleService.js");
		var Ticks = __webpack_require__(/*! ../core/core.ticks */ "./node_modules/chart.js/src/core/core.ticks.js");
		
		/**
		 * Generate a set of logarithmic ticks
		 * @param generationOptions the options used to generate the ticks
		 * @param dataRange the range of the data
		 * @returns {Array<Number>} array of tick values
		 */
		function generateTicks(generationOptions, dataRange) {
			var ticks = [];
			var valueOrDefault = helpers.valueOrDefault;
			
			// Figure out what the max number of ticks we can support it is based on the size of
			// the axis area. For now, we say that the minimum tick spacing in pixels must be 50
			// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on
			// the graph
			var tickVal = valueOrDefault(generationOptions.min, Math.pow(10, Math.floor(helpers.log10(dataRange.min))));
			
			var endExp = Math.floor(helpers.log10(dataRange.max));
			var endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
			var exp, significand;
			
			if(tickVal === 0) {
				exp = Math.floor(helpers.log10(dataRange.minNotZero));
				significand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));
				
				ticks.push(tickVal);
				tickVal = significand * Math.pow(10, exp);
			} else {
				exp = Math.floor(helpers.log10(tickVal));
				significand = Math.floor(tickVal / Math.pow(10, exp));
			}
			var precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
			
			do {
				ticks.push(tickVal);
				
				++significand;
				if(significand === 10) {
					significand = 1;
					++exp;
					precision = exp >= 0 ? 1 : precision;
				}
				
				tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;
			} while(exp < endExp || (exp === endExp && significand < endSignificand));
			
			var lastTick = valueOrDefault(generationOptions.max, tickVal);
			ticks.push(lastTick);
			
			return ticks;
		}
		
		
		module.exports = function(Chart) {
			
			var defaultConfig = {
				position: 'left',
				
				// label settings
				ticks: {
					callback: Ticks.formatters.logarithmic
				}
			};
			
			var LogarithmicScale = Scale.extend({
				determineDataLimits: function() {
					var me = this;
					var opts = me.options;
					var chart = me.chart;
					var data = chart.data;
					var datasets = data.datasets;
					var isHorizontal = me.isHorizontal();
					
					function IDMatches(meta) {
						return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
					}
					
					// Calculate Range
					me.min = null;
					me.max = null;
					me.minNotZero = null;
					
					var hasStacks = opts.stacked;
					if(hasStacks === undefined) {
						helpers.each(datasets, function(dataset, datasetIndex) {
							if(hasStacks) {
								return;
							}
							
							var meta = chart.getDatasetMeta(datasetIndex);
							if(chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&
								meta.stack !== undefined) {
								hasStacks = true;
							}
						});
					}
					
					if(opts.stacked || hasStacks) {
						var valuesPerStack = {};
						
						helpers.each(datasets, function(dataset, datasetIndex) {
							var meta = chart.getDatasetMeta(datasetIndex);
							var key = [
								meta.type,
								// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
								((opts.stacked === undefined && meta.stack === undefined) ? datasetIndex : ''),
								meta.stack
							].join('.');
							
							if(chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
								if(valuesPerStack[key] === undefined) {
									valuesPerStack[key] = [];
								}
								
								helpers.each(dataset.data, function(rawValue, index) {
									var values = valuesPerStack[key];
									var value = +me.getRightValue(rawValue);
									// invalid, hidden and negative values are ignored
									if(isNaN(value) || meta.data[index].hidden || value < 0) {
										return;
									}
									values[index] = values[index] || 0;
									values[index] += value;
								});
							}
						});
						
						helpers.each(valuesPerStack, function(valuesForType) {
							if(valuesForType.length > 0) {
								var minVal = helpers.min(valuesForType);
								var maxVal = helpers.max(valuesForType);
								me.min = me.min === null ? minVal : Math.min(me.min, minVal);
								me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);
							}
						});
						
					} else {
						helpers.each(datasets, function(dataset, datasetIndex) {
							var meta = chart.getDatasetMeta(datasetIndex);
							if(chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
								helpers.each(dataset.data, function(rawValue, index) {
									var value = +me.getRightValue(rawValue);
									// invalid, hidden and negative values are ignored
									if(isNaN(value) || meta.data[index].hidden || value < 0) {
										return;
									}
									
									if(me.min === null) {
										me.min = value;
									} else if(value < me.min) {
										me.min = value;
									}
									
									if(me.max === null) {
										me.max = value;
									} else if(value > me.max) {
										me.max = value;
									}
									
									if(value !== 0 && (me.minNotZero === null || value < me.minNotZero)) {
										me.minNotZero = value;
									}
								});
							}
						});
					}
					
					// Common base implementation to handle ticks.min, ticks.max
					this.handleTickRangeOptions();
				},
				handleTickRangeOptions: function() {
					var me = this;
					var opts = me.options;
					var tickOpts = opts.ticks;
					var valueOrDefault = helpers.valueOrDefault;
					var DEFAULT_MIN = 1;
					var DEFAULT_MAX = 10;
					
					me.min = valueOrDefault(tickOpts.min, me.min);
					me.max = valueOrDefault(tickOpts.max, me.max);
					
					if(me.min === me.max) {
						if(me.min !== 0 && me.min !== null) {
							me.min = Math.pow(10, Math.floor(helpers.log10(me.min)) - 1);
							me.max = Math.pow(10, Math.floor(helpers.log10(me.max)) + 1);
						} else {
							me.min = DEFAULT_MIN;
							me.max = DEFAULT_MAX;
						}
					}
					if(me.min === null) {
						me.min = Math.pow(10, Math.floor(helpers.log10(me.max)) - 1);
					}
					if(me.max === null) {
						me.max = me.min !== 0
							? Math.pow(10, Math.floor(helpers.log10(me.min)) + 1)
							: DEFAULT_MAX;
					}
					if(me.minNotZero === null) {
						if(me.min > 0) {
							me.minNotZero = me.min;
						} else if(me.max < 1) {
							me.minNotZero = Math.pow(10, Math.floor(helpers.log10(me.max)));
						} else {
							me.minNotZero = DEFAULT_MIN;
						}
					}
				},
				buildTicks: function() {
					var me = this;
					var opts = me.options;
					var tickOpts = opts.ticks;
					var reverse = !me.isHorizontal();
					
					var generationOptions = {
						min: tickOpts.min,
						max: tickOpts.max
					};
					var ticks = me.ticks = generateTicks(generationOptions, me);
					
					// At this point, we need to update our max and min given the tick values since we have expanded the
					// range of the scale
					me.max = helpers.max(ticks);
					me.min = helpers.min(ticks);
					
					if(tickOpts.reverse) {
						reverse = !reverse;
						me.start = me.max;
						me.end = me.min;
					} else {
						me.start = me.min;
						me.end = me.max;
					}
					if(reverse) {
						ticks.reverse();
					}
				},
				convertTicksToLabels: function() {
					this.tickValues = this.ticks.slice();
					
					Scale.prototype.convertTicksToLabels.call(this);
				},
				// Get the correct tooltip label
				getLabelForIndex: function(index, datasetIndex) {
					return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
				},
				getPixelForTick: function(index) {
					return this.getPixelForValue(this.tickValues[index]);
				},
				/**
				 * Returns the value of the first tick.
				 * @param {Number} value - The minimum not zero value.
				 * @return {Number} The first tick value.
				 * @private
				 */
				_getFirstTickValue: function(value) {
					var exp = Math.floor(helpers.log10(value));
					var significand = Math.floor(value / Math.pow(10, exp));
					
					return significand * Math.pow(10, exp);
				},
				getPixelForValue: function(value) {
					var me = this;
					var reverse = me.options.ticks.reverse;
					var log10 = helpers.log10;
					var firstTickValue = me._getFirstTickValue(me.minNotZero);
					var offset = 0;
					var innerDimension, pixel, start, end, sign;
					
					value = +me.getRightValue(value);
					if(reverse) {
						start = me.end;
						end = me.start;
						sign = -1;
					} else {
						start = me.start;
						end = me.end;
						sign = 1;
					}
					if(me.isHorizontal()) {
						innerDimension = me.width;
						pixel = reverse ? me.right : me.left;
					} else {
						innerDimension = me.height;
						sign *= -1; // invert, since the upper-left corner of the canvas is at pixel (0, 0)
						pixel = reverse ? me.top : me.bottom;
					}
					if(value !== start) {
						if(start === 0) { // include zero tick
							offset = helpers.getValueOrDefault(
								me.options.ticks.fontSize,
								Chart.defaults.global.defaultFontSize
							);
							innerDimension -= offset;
							start = firstTickValue;
						}
						if(value !== 0) {
							offset += innerDimension / (log10(end) - log10(start)) * (log10(value) - log10(start));
						}
						pixel += sign * offset;
					}
					return pixel;
				},
				getValueForPixel: function(pixel) {
					var me = this;
					var reverse = me.options.ticks.reverse;
					var log10 = helpers.log10;
					var firstTickValue = me._getFirstTickValue(me.minNotZero);
					var innerDimension, start, end, value;
					
					if(reverse) {
						start = me.end;
						end = me.start;
					} else {
						start = me.start;
						end = me.end;
					}
					if(me.isHorizontal()) {
						innerDimension = me.width;
						value = reverse ? me.right - pixel : pixel - me.left;
					} else {
						innerDimension = me.height;
						value = reverse ? pixel - me.top : me.bottom - pixel;
					}
					if(value !== start) {
						if(start === 0) { // include zero tick
							var offset = helpers.getValueOrDefault(
								me.options.ticks.fontSize,
								Chart.defaults.global.defaultFontSize
							);
							value -= offset;
							innerDimension -= offset;
							start = firstTickValue;
						}
						value *= log10(end) - log10(start);
						value /= innerDimension;
						value = Math.pow(10, log10(start) + value);
					}
					return value;
				}
			});
			
			scaleService.registerScaleType('logarithmic', LogarithmicScale, defaultConfig);
		};
		
		
		/***/
	}),
	
	/***/ "./node_modules/chart.js/src/scales/scale.radialLinear.js":
	/*!****************************************************************!*\
  !*** ./node_modules/chart.js/src/scales/scale.radialLinear.js ***!
  \****************************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		var defaults = __webpack_require__(/*! ../core/core.defaults */ "./node_modules/chart.js/src/core/core.defaults.js");
		var helpers = __webpack_require__(/*! ../helpers/index */ "./node_modules/chart.js/src/helpers/index.js");
		var scaleService = __webpack_require__(/*! ../core/core.scaleService */ "./node_modules/chart.js/src/core/core.scaleService.js");
		var Ticks = __webpack_require__(/*! ../core/core.ticks */ "./node_modules/chart.js/src/core/core.ticks.js");
		
		module.exports = function(Chart) {
			
			var globalDefaults = defaults.global;
			
			var defaultConfig = {
				display: true,
				
				// Boolean - Whether to animate scaling the chart from the centre
				animate: true,
				position: 'chartArea',
				
				angleLines: {
					display: true,
					color: 'rgba(0, 0, 0, 0.1)',
					lineWidth: 1
				},
				
				gridLines: {
					circular: false
				},
				
				// label settings
				ticks: {
					// Boolean - Show a backdrop to the scale label
					showLabelBackdrop: true,
					
					// String - The colour of the label backdrop
					backdropColor: 'rgba(255,255,255,0.75)',
					
					// Number - The backdrop padding above & below the label in pixels
					backdropPaddingY: 2,
					
					// Number - The backdrop padding to the side of the label in pixels
					backdropPaddingX: 2,
					
					callback: Ticks.formatters.linear
				},
				
				pointLabels: {
					// Boolean - if true, show point labels
					display: true,
					
					// Number - Point label font size in pixels
					fontSize: 10,
					
					// Function - Used to convert point labels
					callback: function(label) {
						return label;
					}
				}
			};
			
			function getValueCount(scale) {
				var opts = scale.options;
				return opts.angleLines.display || opts.pointLabels.display ? scale.chart.data.labels.length : 0;
			}
			
			function getPointLabelFontOptions(scale) {
				var pointLabelOptions = scale.options.pointLabels;
				var fontSize = helpers.valueOrDefault(pointLabelOptions.fontSize, globalDefaults.defaultFontSize);
				var fontStyle = helpers.valueOrDefault(pointLabelOptions.fontStyle, globalDefaults.defaultFontStyle);
				var fontFamily = helpers.valueOrDefault(pointLabelOptions.fontFamily, globalDefaults.defaultFontFamily);
				var font = helpers.fontString(fontSize, fontStyle, fontFamily);
				
				return {
					size: fontSize,
					style: fontStyle,
					family: fontFamily,
					font: font
				};
			}
			
			function measureLabelSize(ctx, fontSize, label) {
				if(helpers.isArray(label)) {
					return {
						w: helpers.longestText(ctx, ctx.font, label),
						h: (label.length * fontSize) + ((label.length - 1) * 1.5 * fontSize)
					};
				}
				
				return {
					w: ctx.measureText(label).width,
					h: fontSize
				};
			}
			
			function determineLimits(angle, pos, size, min, max) {
				if(angle === min || angle === max) {
					return {
						start: pos - (size / 2),
						end: pos + (size / 2)
					};
				} else if(angle < min || angle > max) {
					return {
						start: pos - size - 5,
						end: pos
					};
				}
				
				return {
					start: pos,
					end: pos + size + 5
				};
			}
			
			/**
			 * Helper function to fit a radial linear scale with point labels
			 */
			function fitWithPointLabels(scale) {
				/*
		 * Right, this is really confusing and there is a lot of maths going on here
		 * The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9
		 *
		 * Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif
		 *
		 * Solution:
		 *
		 * We assume the radius of the polygon is half the size of the canvas at first
		 * at each index we check if the text overlaps.
		 *
		 * Where it does, we store that angle and that index.
		 *
		 * After finding the largest index and angle we calculate how much we need to remove
		 * from the shape radius to move the point inwards by that x.
		 *
		 * We average the left and right distances to get the maximum shape radius that can fit in the box
		 * along with labels.
		 *
		 * Once we have that, we can find the centre point for the chart, by taking the x text protrusion
		 * on each side, removing that from the size, halving it and adding the left x protrusion width.
		 *
		 * This will mean we have a shape fitted to the canvas, as large as it can be with the labels
		 * and position it in the most space efficient manner
		 *
		 * https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif
		 */
				
				var plFont = getPointLabelFontOptions(scale);
				
				// Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.
				// Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points
				var largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);
				var furthestLimits = {
					r: scale.width,
					l: 0,
					t: scale.height,
					b: 0
				};
				var furthestAngles = {};
				var i, textSize, pointPosition;
				
				scale.ctx.font = plFont.font;
				scale._pointLabelSizes = [];
				
				var valueCount = getValueCount(scale);
				for(i = 0; i < valueCount; i++) {
					pointPosition = scale.getPointPosition(i, largestPossibleRadius);
					textSize = measureLabelSize(scale.ctx, plFont.size, scale.pointLabels[i] || '');
					scale._pointLabelSizes[i] = textSize;
					
					// Add quarter circle to make degree 0 mean top of circle
					var angleRadians = scale.getIndexAngle(i);
					var angle = helpers.toDegrees(angleRadians) % 360;
					var hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
					var vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
					
					if(hLimits.start < furthestLimits.l) {
						furthestLimits.l = hLimits.start;
						furthestAngles.l = angleRadians;
					}
					
					if(hLimits.end > furthestLimits.r) {
						furthestLimits.r = hLimits.end;
						furthestAngles.r = angleRadians;
					}
					
					if(vLimits.start < furthestLimits.t) {
						furthestLimits.t = vLimits.start;
						furthestAngles.t = angleRadians;
					}
					
					if(vLimits.end > furthestLimits.b) {
						furthestLimits.b = vLimits.end;
						furthestAngles.b = angleRadians;
					}
				}
				
				scale.setReductions(largestPossibleRadius, furthestLimits, furthestAngles);
			}
			
			/**
			 * Helper function to fit a radial linear scale with no point labels
			 */
			function fit(scale) {
				var largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);
				scale.drawingArea = Math.round(largestPossibleRadius);
				scale.setCenterPoint(0, 0, 0, 0);
			}
			
			function getTextAlignForAngle(angle) {
				if(angle === 0 || angle === 180) {
					return 'center';
				} else if(angle < 180) {
					return 'left';
				}
				
				return 'right';
			}
			
			function fillText(ctx, text, position, fontSize) {
				if(helpers.isArray(text)) {
					var y = position.y;
					var spacing = 1.5 * fontSize;
					
					for(var i = 0; i < text.length; ++i) {
						ctx.fillText(text[i], position.x, y);
						y += spacing;
					}
				} else {
					ctx.fillText(text, position.x, position.y);
				}
			}
			
			function adjustPointPositionForLabelHeight(angle, textSize, position) {
				if(angle === 90 || angle === 270) {
					position.y -= (textSize.h / 2);
				} else if(angle > 270 || angle < 90) {
					position.y -= textSize.h;
				}
			}
			
			function drawPointLabels(scale) {
				var ctx = scale.ctx;
				var opts = scale.options;
				var angleLineOpts = opts.angleLines;
				var pointLabelOpts = opts.pointLabels;
				
				ctx.lineWidth = angleLineOpts.lineWidth;
				ctx.strokeStyle = angleLineOpts.color;
				
				var outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max);
				
				// Point Label Font
				var plFont = getPointLabelFontOptions(scale);
				
				ctx.textBaseline = 'top';
				
				for(var i = getValueCount(scale) - 1; i >= 0; i--) {
					if(angleLineOpts.display) {
						var outerPosition = scale.getPointPosition(i, outerDistance);
						ctx.beginPath();
						ctx.moveTo(scale.xCenter, scale.yCenter);
						ctx.lineTo(outerPosition.x, outerPosition.y);
						ctx.stroke();
						ctx.closePath();
					}
					
					if(pointLabelOpts.display) {
						// Extra 3px out for some label spacing
						var pointLabelPosition = scale.getPointPosition(i, outerDistance + 5);
						
						// Keep this in loop since we may support array properties here
						var pointLabelFontColor = helpers.valueAtIndexOrDefault(pointLabelOpts.fontColor, i, globalDefaults.defaultFontColor);
						ctx.font = plFont.font;
						ctx.fillStyle = pointLabelFontColor;
						
						var angleRadians = scale.getIndexAngle(i);
						var angle = helpers.toDegrees(angleRadians);
						ctx.textAlign = getTextAlignForAngle(angle);
						adjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);
						fillText(ctx, scale.pointLabels[i] || '', pointLabelPosition, plFont.size);
					}
				}
			}
			
			function drawRadiusLine(scale, gridLineOpts, radius, index) {
				var ctx = scale.ctx;
				ctx.strokeStyle = helpers.valueAtIndexOrDefault(gridLineOpts.color, index - 1);
				ctx.lineWidth = helpers.valueAtIndexOrDefault(gridLineOpts.lineWidth, index - 1);
				
				if(scale.options.gridLines.circular) {
					// Draw circular arcs between the points
					ctx.beginPath();
					ctx.arc(scale.xCenter, scale.yCenter, radius, 0, Math.PI * 2);
					ctx.closePath();
					ctx.stroke();
				} else {
					// Draw straight lines connecting each index
					var valueCount = getValueCount(scale);
					
					if(valueCount === 0) {
						return;
					}
					
					ctx.beginPath();
					var pointPosition = scale.getPointPosition(0, radius);
					ctx.moveTo(pointPosition.x, pointPosition.y);
					
					for(var i = 1; i < valueCount; i++) {
						pointPosition = scale.getPointPosition(i, radius);
						ctx.lineTo(pointPosition.x, pointPosition.y);
					}
					
					ctx.closePath();
					ctx.stroke();
				}
			}
			
			function numberOrZero(param) {
				return helpers.isNumber(param) ? param : 0;
			}
			
			var LinearRadialScale = Chart.LinearScaleBase.extend({
				setDimensions: function() {
					var me = this;
					var opts = me.options;
					var tickOpts = opts.ticks;
					// Set the unconstrained dimension before label rotation
					me.width = me.maxWidth;
					me.height = me.maxHeight;
					me.xCenter = Math.round(me.width / 2);
					me.yCenter = Math.round(me.height / 2);
					
					var minSize = helpers.min([me.height, me.width]);
					var tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
					me.drawingArea = opts.display ? (minSize / 2) - (tickFontSize / 2 + tickOpts.backdropPaddingY) : (minSize / 2);
				},
				determineDataLimits: function() {
					var me = this;
					var chart = me.chart;
					var min = Number.POSITIVE_INFINITY;
					var max = Number.NEGATIVE_INFINITY;
					
					helpers.each(chart.data.datasets, function(dataset, datasetIndex) {
						if(chart.isDatasetVisible(datasetIndex)) {
							var meta = chart.getDatasetMeta(datasetIndex);
							
							helpers.each(dataset.data, function(rawValue, index) {
								var value = +me.getRightValue(rawValue);
								if(isNaN(value) || meta.data[index].hidden) {
									return;
								}
								
								min = Math.min(value, min);
								max = Math.max(value, max);
							});
						}
					});
					
					me.min = (min === Number.POSITIVE_INFINITY ? 0 : min);
					me.max = (max === Number.NEGATIVE_INFINITY ? 0 : max);
					
					// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero
					me.handleTickRangeOptions();
				},
				getTickLimit: function() {
					var tickOpts = this.options.ticks;
					var tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
					return Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(this.drawingArea / (1.5 * tickFontSize)));
				},
				convertTicksToLabels: function() {
					var me = this;
					
					Chart.LinearScaleBase.prototype.convertTicksToLabels.call(me);
					
					// Point labels
					me.pointLabels = me.chart.data.labels.map(me.options.pointLabels.callback, me);
				},
				getLabelForIndex: function(index, datasetIndex) {
					return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
				},
				fit: function() {
					if(this.options.pointLabels.display) {
						fitWithPointLabels(this);
					} else {
						fit(this);
					}
				},
				/**
				 * Set radius reductions and determine new radius and center point
				 * @private
				 */
				setReductions: function(largestPossibleRadius, furthestLimits, furthestAngles) {
					var me = this;
					var radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);
					var radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);
					var radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);
					var radiusReductionBottom = -Math.max(furthestLimits.b - me.height, 0) / Math.cos(furthestAngles.b);
					
					radiusReductionLeft = numberOrZero(radiusReductionLeft);
					radiusReductionRight = numberOrZero(radiusReductionRight);
					radiusReductionTop = numberOrZero(radiusReductionTop);
					radiusReductionBottom = numberOrZero(radiusReductionBottom);
					
					me.drawingArea = Math.min(
						Math.round(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2),
						Math.round(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));
					me.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);
				},
				setCenterPoint: function(leftMovement, rightMovement, topMovement, bottomMovement) {
					var me = this;
					var maxRight = me.width - rightMovement - me.drawingArea;
					var maxLeft = leftMovement + me.drawingArea;
					var maxTop = topMovement + me.drawingArea;
					var maxBottom = me.height - bottomMovement - me.drawingArea;
					
					me.xCenter = Math.round(((maxLeft + maxRight) / 2) + me.left);
					me.yCenter = Math.round(((maxTop + maxBottom) / 2) + me.top);
				},
				
				getIndexAngle: function(index) {
					var angleMultiplier = (Math.PI * 2) / getValueCount(this);
					var startAngle = this.chart.options && this.chart.options.startAngle ?
						this.chart.options.startAngle :
						0;
					
					var startAngleRadians = startAngle * Math.PI * 2 / 360;
					
					// Start from the top instead of right, so remove a quarter of the circle
					return index * angleMultiplier + startAngleRadians;
				},
				getDistanceFromCenterForValue: function(value) {
					var me = this;
					
					if(value === null) {
						return 0; // null always in center
					}
					
					// Take into account half font size + the yPadding of the top value
					var scalingFactor = me.drawingArea / (me.max - me.min);
					if(me.options.ticks.reverse) {
						return (me.max - value) * scalingFactor;
					}
					return (value - me.min) * scalingFactor;
				},
				getPointPosition: function(index, distanceFromCenter) {
					var me = this;
					var thisAngle = me.getIndexAngle(index) - (Math.PI / 2);
					return {
						x: Math.round(Math.cos(thisAngle) * distanceFromCenter) + me.xCenter,
						y: Math.round(Math.sin(thisAngle) * distanceFromCenter) + me.yCenter
					};
				},
				getPointPositionForValue: function(index, value) {
					return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
				},
				
				getBasePosition: function() {
					var me = this;
					var min = me.min;
					var max = me.max;
					
					return me.getPointPositionForValue(0,
						me.beginAtZero ? 0 :
							min < 0 && max < 0 ? max :
								min > 0 && max > 0 ? min :
									0);
				},
				
				draw: function() {
					var me = this;
					var opts = me.options;
					var gridLineOpts = opts.gridLines;
					var tickOpts = opts.ticks;
					var valueOrDefault = helpers.valueOrDefault;
					
					if(opts.display) {
						var ctx = me.ctx;
						var startAngle = this.getIndexAngle(0);
						
						// Tick Font
						var tickFontSize = valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
						var tickFontStyle = valueOrDefault(tickOpts.fontStyle, globalDefaults.defaultFontStyle);
						var tickFontFamily = valueOrDefault(tickOpts.fontFamily, globalDefaults.defaultFontFamily);
						var tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);
						
						helpers.each(me.ticks, function(label, index) {
							// Don't draw a centre value (if it is minimum)
							if(index > 0 || tickOpts.reverse) {
								var yCenterOffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);
								
								// Draw circular lines around the scale
								if(gridLineOpts.display && index !== 0) {
									drawRadiusLine(me, gridLineOpts, yCenterOffset, index);
								}
								
								if(tickOpts.display) {
									var tickFontColor = valueOrDefault(tickOpts.fontColor, globalDefaults.defaultFontColor);
									ctx.font = tickLabelFont;
									
									ctx.save();
									ctx.translate(me.xCenter, me.yCenter);
									ctx.rotate(startAngle);
									
									if(tickOpts.showLabelBackdrop) {
										var labelWidth = ctx.measureText(label).width;
										ctx.fillStyle = tickOpts.backdropColor;
										ctx.fillRect(
											-labelWidth / 2 - tickOpts.backdropPaddingX,
											-yCenterOffset - tickFontSize / 2 - tickOpts.backdropPaddingY,
											labelWidth + tickOpts.backdropPaddingX * 2,
											tickFontSize + tickOpts.backdropPaddingY * 2
										);
									}
									
									ctx.textAlign = 'center';
									ctx.textBaseline = 'middle';
									ctx.fillStyle = tickFontColor;
									ctx.fillText(label, 0, -yCenterOffset);
									ctx.restore();
								}
							}
						});
						
						if(opts.angleLines.display || opts.pointLabels.display) {
							drawPointLabels(me);
						}
					}
				}
			});
			
			scaleService.registerScaleType('radialLinear', LinearRadialScale, defaultConfig);
		};
		
		
		/***/
	}),
	
	/***/ "./node_modules/chart.js/src/scales/scale.time.js":
	/*!********************************************************!*\
  !*** ./node_modules/chart.js/src/scales/scale.time.js ***!
  \********************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		/* global window: false */
		
		
		var moment = __webpack_require__(/*! moment */ "./node_modules/moment/moment.js");
		moment = typeof moment === 'function' ? moment : window.moment;
		
		var defaults = __webpack_require__(/*! ../core/core.defaults */ "./node_modules/chart.js/src/core/core.defaults.js");
		var helpers = __webpack_require__(/*! ../helpers/index */ "./node_modules/chart.js/src/helpers/index.js");
		var Scale = __webpack_require__(/*! ../core/core.scale */ "./node_modules/chart.js/src/core/core.scale.js");
		var scaleService = __webpack_require__(/*! ../core/core.scaleService */ "./node_modules/chart.js/src/core/core.scaleService.js");

// Integer constants are from the ES6 spec.
		var MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
		var MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
		
		var INTERVALS = {
			millisecond: {
				common: true,
				size: 1,
				steps: [1, 2, 5, 10, 20, 50, 100, 250, 500]
			},
			second: {
				common: true,
				size: 1000,
				steps: [1, 2, 5, 10, 15, 30]
			},
			minute: {
				common: true,
				size: 60000,
				steps: [1, 2, 5, 10, 15, 30]
			},
			hour: {
				common: true,
				size: 3600000,
				steps: [1, 2, 3, 6, 12]
			},
			day: {
				common: true,
				size: 86400000,
				steps: [1, 2, 5]
			},
			week: {
				common: false,
				size: 604800000,
				steps: [1, 2, 3, 4]
			},
			month: {
				common: true,
				size: 2.628e9,
				steps: [1, 2, 3]
			},
			quarter: {
				common: false,
				size: 7.884e9,
				steps: [1, 2, 3, 4]
			},
			year: {
				common: true,
				size: 3.154e10
			}
		};
		
		var UNITS = Object.keys(INTERVALS);
		
		function sorter(a, b) {
			return a - b;
		}
		
		function arrayUnique(items) {
			var hash = {};
			var out = [];
			var i, ilen, item;
			
			for(i = 0, ilen = items.length; i < ilen; ++i) {
				item = items[i];
				if(!hash[item]) {
					hash[item] = true;
					out.push(item);
				}
			}
			
			return out;
		}
		
		/**
		 * Returns an array of {time, pos} objects used to interpolate a specific `time` or position
		 * (`pos`) on the scale, by searching entries before and after the requested value. `pos` is
		 * a decimal between 0 and 1: 0 being the start of the scale (left or top) and 1 the other
		 * extremity (left + width or top + height). Note that it would be more optimized to directly
		 * store pre-computed pixels, but the scale dimensions are not guaranteed at the time we need
		 * to create the lookup table. The table ALWAYS contains at least two items: min and max.
		 *
		 * @param {Number[]} timestamps - timestamps sorted from lowest to highest.
		 * @param {String} distribution - If 'linear', timestamps will be spread linearly along the min
		 * and max range, so basically, the table will contains only two items: {min, 0} and {max, 1}.
		 * If 'series', timestamps will be positioned at the same distance from each other. In this
		 * case, only timestamps that break the time linearity are registered, meaning that in the
		 * best case, all timestamps are linear, the table contains only min and max.
		 */
		function buildLookupTable(timestamps, min, max, distribution) {
			if(distribution === 'linear' || !timestamps.length) {
				return [
					{time: min, pos: 0},
					{time: max, pos: 1}
				];
			}
			
			var table = [];
			var items = [min];
			var i, ilen, prev, curr, next;
			
			for(i = 0, ilen = timestamps.length; i < ilen; ++i) {
				curr = timestamps[i];
				if(curr > min && curr < max) {
					items.push(curr);
				}
			}
			
			items.push(max);
			
			for(i = 0, ilen = items.length; i < ilen; ++i) {
				next = items[i + 1];
				prev = items[i - 1];
				curr = items[i];
				
				// only add points that breaks the scale linearity
				if(prev === undefined || next === undefined || Math.round((next + prev) / 2) !== curr) {
					table.push({time: curr, pos: i / (ilen - 1)});
				}
			}
			
			return table;
		}

// @see adapted from http://www.anujgakhar.com/2014/03/01/binary-search-in-javascript/
		function lookup(table, key, value) {
			var lo = 0;
			var hi = table.length - 1;
			var mid, i0, i1;
			
			while(lo >= 0 && lo <= hi) {
				mid = (lo + hi) >> 1;
				i0 = table[mid - 1] || null;
				i1 = table[mid];
				
				if(!i0) {
					// given value is outside table (before first item)
					return {lo: null, hi: i1};
				} else if(i1[key] < value) {
					lo = mid + 1;
				} else if(i0[key] > value) {
					hi = mid - 1;
				} else {
					return {lo: i0, hi: i1};
				}
			}
			
			// given value is outside table (after last item)
			return {lo: i1, hi: null};
		}
		
		/**
		 * Linearly interpolates the given source `value` using the table items `skey` values and
		 * returns the associated `tkey` value. For example, interpolate(table, 'time', 42, 'pos')
		 * returns the position for a timestamp equal to 42. If value is out of bounds, values at
		 * index [0, 1] or [n - 1, n] are used for the interpolation.
		 */
		function interpolate(table, skey, sval, tkey) {
			var range = lookup(table, skey, sval);
			
			// Note: the lookup table ALWAYS contains at least 2 items (min and max)
			var prev = !range.lo ? table[0] : !range.hi ? table[table.length - 2] : range.lo;
			var next = !range.lo ? table[1] : !range.hi ? table[table.length - 1] : range.hi;
			
			var span = next[skey] - prev[skey];
			var ratio = span ? (sval - prev[skey]) / span : 0;
			var offset = (next[tkey] - prev[tkey]) * ratio;
			
			return prev[tkey] + offset;
		}
		
		/**
		 * Convert the given value to a moment object using the given time options.
		 * @see http://momentjs.com/docs/#/parsing/
		 */
		function momentify(value, options) {
			var parser = options.parser;
			var format = options.parser || options.format;
			
			if(typeof parser === 'function') {
				return parser(value);
			}
			
			if(typeof value === 'string' && typeof format === 'string') {
				return moment(value, format);
			}
			
			if(!(value instanceof moment)) {
				value = moment(value);
			}
			
			if(value.isValid()) {
				return value;
			}
			
			// Labels are in an incompatible moment format and no `parser` has been provided.
			// The user might still use the deprecated `format` option to convert his inputs.
			if(typeof format === 'function') {
				return format(value);
			}
			
			return value;
		}
		
		function parse(input, scale) {
			if(helpers.isNullOrUndef(input)) {
				return null;
			}
			
			var options = scale.options.time;
			var value = momentify(scale.getRightValue(input), options);
			if(!value.isValid()) {
				return null;
			}
			
			if(options.round) {
				value.startOf(options.round);
			}
			
			return value.valueOf();
		}
		
		/**
		 * Returns the number of unit to skip to be able to display up to `capacity` number of ticks
		 * in `unit` for the given `min` / `max` range and respecting the interval steps constraints.
		 */
		function determineStepSize(min, max, unit, capacity) {
			var range = max - min;
			var interval = INTERVALS[unit];
			var milliseconds = interval.size;
			var steps = interval.steps;
			var i, ilen, factor;
			
			if(!steps) {
				return Math.ceil(range / (capacity * milliseconds));
			}
			
			for(i = 0, ilen = steps.length; i < ilen; ++i) {
				factor = steps[i];
				if(Math.ceil(range / (milliseconds * factor)) <= capacity) {
					break;
				}
			}
			
			return factor;
		}
		
		/**
		 * Figures out what unit results in an appropriate number of auto-generated ticks
		 */
		function determineUnitForAutoTicks(minUnit, min, max, capacity) {
			var ilen = UNITS.length;
			var i, interval, factor;
			
			for(i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
				interval = INTERVALS[UNITS[i]];
				factor = interval.steps ? interval.steps[interval.steps.length - 1] : MAX_INTEGER;
				
				if(interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
					return UNITS[i];
				}
			}
			
			return UNITS[ilen - 1];
		}
		
		/**
		 * Figures out what unit to format a set of ticks with
		 */
		function determineUnitForFormatting(ticks, minUnit, min, max) {
			var duration = moment.duration(moment(max).diff(moment(min)));
			var ilen = UNITS.length;
			var i, unit;
			
			for(i = ilen - 1; i >= UNITS.indexOf(minUnit); i--) {
				unit = UNITS[i];
				if(INTERVALS[unit].common && duration.as(unit) >= ticks.length) {
					return unit;
				}
			}
			
			return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
		}
		
		function determineMajorUnit(unit) {
			for(var i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
				if(INTERVALS[UNITS[i]].common) {
					return UNITS[i];
				}
			}
		}
		
		/**
		 * Generates a maximum of `capacity` timestamps between min and max, rounded to the
		 * `minor` unit, aligned on the `major` unit and using the given scale time `options`.
		 * Important: this method can return ticks outside the min and max range, it's the
		 * responsibility of the calling code to clamp values if needed.
		 */
		function generate(min, max, capacity, options) {
			var timeOpts = options.time;
			var minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);
			var major = determineMajorUnit(minor);
			var stepSize = helpers.valueOrDefault(timeOpts.stepSize, timeOpts.unitStepSize);
			var weekday = minor === 'week' ? timeOpts.isoWeekday : false;
			var majorTicksEnabled = options.ticks.major.enabled;
			var interval = INTERVALS[minor];
			var first = moment(min);
			var last = moment(max);
			var ticks = [];
			var time;
			
			if(!stepSize) {
				stepSize = determineStepSize(min, max, minor, capacity);
			}
			
			// For 'week' unit, handle the first day of week option
			if(weekday) {
				first = first.isoWeekday(weekday);
				last = last.isoWeekday(weekday);
			}
			
			// Align first/last ticks on unit
			first = first.startOf(weekday ? 'day' : minor);
			last = last.startOf(weekday ? 'day' : minor);
			
			// Make sure that the last tick include max
			if(last < max) {
				last.add(1, minor);
			}
			
			time = moment(first);
			
			if(majorTicksEnabled && major && !weekday && !timeOpts.round) {
				// Align the first tick on the previous `minor` unit aligned on the `major` unit:
				// we first aligned time on the previous `major` unit then add the number of full
				// stepSize there is between first and the previous major time.
				time.startOf(major);
				time.add(~~((first - time) / (interval.size * stepSize)) * stepSize, minor);
			}
			
			for(; time < last; time.add(stepSize, minor)) {
				ticks.push(+time);
			}
			
			ticks.push(+time);
			
			return ticks;
		}
		
		/**
		 * Returns the right and left offsets from edges in the form of {left, right}.
		 * Offsets are added when the `offset` option is true.
		 */
		function computeOffsets(table, ticks, min, max, options) {
			var left = 0;
			var right = 0;
			var upper, lower;
			
			if(options.offset && ticks.length) {
				if(!options.time.min) {
					upper = ticks.length > 1 ? ticks[1] : max;
					lower = ticks[0];
					left = (
						interpolate(table, 'time', upper, 'pos') -
						interpolate(table, 'time', lower, 'pos')
					) / 2;
				}
				if(!options.time.max) {
					upper = ticks[ticks.length - 1];
					lower = ticks.length > 1 ? ticks[ticks.length - 2] : min;
					right = (
						interpolate(table, 'time', upper, 'pos') -
						interpolate(table, 'time', lower, 'pos')
					) / 2;
				}
			}
			
			return {left: left, right: right};
		}
		
		function ticksFromTimestamps(values, majorUnit) {
			var ticks = [];
			var i, ilen, value, major;
			
			for(i = 0, ilen = values.length; i < ilen; ++i) {
				value = values[i];
				major = majorUnit ? value === +moment(value).startOf(majorUnit) : false;
				
				ticks.push({
					value: value,
					major: major
				});
			}
			
			return ticks;
		}
		
		function determineLabelFormat(data, timeOpts) {
			var i, momentDate, hasTime;
			var ilen = data.length;
			
			// find the label with the most parts (milliseconds, minutes, etc.)
			// format all labels with the same level of detail as the most specific label
			for(i = 0; i < ilen; i++) {
				momentDate = momentify(data[i], timeOpts);
				if(momentDate.millisecond() !== 0) {
					return 'MMM D, YYYY h:mm:ss.SSS a';
				}
				if(momentDate.second() !== 0 || momentDate.minute() !== 0 || momentDate.hour() !== 0) {
					hasTime = true;
				}
			}
			if(hasTime) {
				return 'MMM D, YYYY h:mm:ss a';
			}
			return 'MMM D, YYYY';
		}
		
		module.exports = function() {
			
			var defaultConfig = {
				position: 'bottom',
				
				/**
				 * Data distribution along the scale:
				 * - 'linear': data are spread according to their time (distances can vary),
				 * - 'series': data are spread at the same distance from each other.
				 * @see https://github.com/chartjs/Chart.js/pull/4507
				 * @since 2.7.0
				 */
				distribution: 'linear',
				
				/**
				 * Scale boundary strategy (bypassed by min/max time options)
				 * - `data`: make sure data are fully visible, ticks outside are removed
				 * - `ticks`: make sure ticks are fully visible, data outside are truncated
				 * @see https://github.com/chartjs/Chart.js/pull/4556
				 * @since 2.7.0
				 */
				bounds: 'data',
				
				time: {
					parser: false, // false == a pattern string from http://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment
					format: false, // DEPRECATED false == date objects, moment object, callback or a pattern string from http://momentjs.com/docs/#/parsing/string-format/
					unit: false, // false == automatic or override with week, month, year, etc.
					round: false, // none, or override with week, month, year, etc.
					displayFormat: false, // DEPRECATED
					isoWeekday: false, // override week start day - see http://momentjs.com/docs/#/get-set/iso-weekday/
					minUnit: 'millisecond',
					
					// defaults to unit's corresponding unitFormat below or override using pattern string from http://momentjs.com/docs/#/displaying/format/
					displayFormats: {
						millisecond: 'h:mm:ss.SSS a', // 11:20:01.123 AM,
						second: 'h:mm:ss a', // 11:20:01 AM
						minute: 'h:mm a', // 11:20 AM
						hour: 'hA', // 5PM
						day: 'MMM D', // Sep 4
						week: 'll', // Week 46, or maybe "[W]WW - YYYY" ?
						month: 'MMM YYYY', // Sept 2015
						quarter: '[Q]Q - YYYY', // Q3
						year: 'YYYY' // 2015
					},
				},
				ticks: {
					autoSkip: false,
					
					/**
					 * Ticks generation input values:
					 * - 'auto': generates "optimal" ticks based on scale size and time options.
					 * - 'data': generates ticks from data (including labels from data {t|x|y} objects).
					 * - 'labels': generates ticks from user given `data.labels` values ONLY.
					 * @see https://github.com/chartjs/Chart.js/pull/4507
					 * @since 2.7.0
					 */
					source: 'auto',
					
					major: {
						enabled: false
					}
				}
			};
			
			var TimeScale = Scale.extend({
				initialize: function() {
					if(!moment) {
						throw new Error('Chart.js - Moment.js could not be found! You must include it before Chart.js to use the time scale. Download at https://momentjs.com');
					}
					
					this.mergeTicksOptions();
					
					Scale.prototype.initialize.call(this);
				},
				
				update: function() {
					var me = this;
					var options = me.options;
					
					// DEPRECATIONS: output a message only one time per update
					if(options.time && options.time.format) {
						console.warn('options.time.format is deprecated and replaced by options.time.parser.');
					}
					
					return Scale.prototype.update.apply(me, arguments);
				},
				
				/**
				 * Allows data to be referenced via 't' attribute
				 */
				getRightValue: function(rawValue) {
					if(rawValue && rawValue.t !== undefined) {
						rawValue = rawValue.t;
					}
					return Scale.prototype.getRightValue.call(this, rawValue);
				},
				
				determineDataLimits: function() {
					var me = this;
					var chart = me.chart;
					var timeOpts = me.options.time;
					var unit = timeOpts.unit || 'day';
					var min = MAX_INTEGER;
					var max = MIN_INTEGER;
					var timestamps = [];
					var datasets = [];
					var labels = [];
					var i, j, ilen, jlen, data, timestamp;
					
					// Convert labels to timestamps
					for(i = 0, ilen = chart.data.labels.length; i < ilen; ++i) {
						labels.push(parse(chart.data.labels[i], me));
					}
					
					// Convert data to timestamps
					for(i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
						if(chart.isDatasetVisible(i)) {
							data = chart.data.datasets[i].data;
							
							// Let's consider that all data have the same format.
							if(helpers.isObject(data[0])) {
								datasets[i] = [];
								
								for(j = 0, jlen = data.length; j < jlen; ++j) {
									timestamp = parse(data[j], me);
									timestamps.push(timestamp);
									datasets[i][j] = timestamp;
								}
							} else {
								timestamps.push.apply(timestamps, labels);
								datasets[i] = labels.slice(0);
							}
						} else {
							datasets[i] = [];
						}
					}
					
					if(labels.length) {
						// Sort labels **after** data have been converted
						labels = arrayUnique(labels).sort(sorter);
						min = Math.min(min, labels[0]);
						max = Math.max(max, labels[labels.length - 1]);
					}
					
					if(timestamps.length) {
						timestamps = arrayUnique(timestamps).sort(sorter);
						min = Math.min(min, timestamps[0]);
						max = Math.max(max, timestamps[timestamps.length - 1]);
					}
					
					min = parse(timeOpts.min, me) || min;
					max = parse(timeOpts.max, me) || max;
					
					// In case there is no valid min/max, set limits based on unit time option
					min = min === MAX_INTEGER ? +moment().startOf(unit) : min;
					max = max === MIN_INTEGER ? +moment().endOf(unit) + 1 : max;
					
					// Make sure that max is strictly higher than min (required by the lookup table)
					me.min = Math.min(min, max);
					me.max = Math.max(min + 1, max);
					
					// PRIVATE
					me._horizontal = me.isHorizontal();
					me._table = [];
					me._timestamps = {
						data: timestamps,
						datasets: datasets,
						labels: labels
					};
				},
				
				buildTicks: function() {
					var me = this;
					var min = me.min;
					var max = me.max;
					var options = me.options;
					var timeOpts = options.time;
					var timestamps = [];
					var ticks = [];
					var i, ilen, timestamp;
					
					switch(options.ticks.source) {
						case 'data':
							timestamps = me._timestamps.data;
							break;
						case 'labels':
							timestamps = me._timestamps.labels;
							break;
						case 'auto':
						default:
							timestamps = generate(min, max, me.getLabelCapacity(min), options);
					}
					
					if(options.bounds === 'ticks' && timestamps.length) {
						min = timestamps[0];
						max = timestamps[timestamps.length - 1];
					}
					
					// Enforce limits with user min/max options
					min = parse(timeOpts.min, me) || min;
					max = parse(timeOpts.max, me) || max;
					
					// Remove ticks outside the min/max range
					for(i = 0, ilen = timestamps.length; i < ilen; ++i) {
						timestamp = timestamps[i];
						if(timestamp >= min && timestamp <= max) {
							ticks.push(timestamp);
						}
					}
					
					me.min = min;
					me.max = max;
					
					// PRIVATE
					me._unit = timeOpts.unit || determineUnitForFormatting(ticks, timeOpts.minUnit, me.min, me.max);
					me._majorUnit = determineMajorUnit(me._unit);
					me._table = buildLookupTable(me._timestamps.data, min, max, options.distribution);
					me._offsets = computeOffsets(me._table, ticks, min, max, options);
					me._labelFormat = determineLabelFormat(me._timestamps.data, timeOpts);
					
					return ticksFromTimestamps(ticks, me._majorUnit);
				},
				
				getLabelForIndex: function(index, datasetIndex) {
					var me = this;
					var data = me.chart.data;
					var timeOpts = me.options.time;
					var label = data.labels && index < data.labels.length ? data.labels[index] : '';
					var value = data.datasets[datasetIndex].data[index];
					
					if(helpers.isObject(value)) {
						label = me.getRightValue(value);
					}
					if(timeOpts.tooltipFormat) {
						return momentify(label, timeOpts).format(timeOpts.tooltipFormat);
					}
					if(typeof label === 'string') {
						return label;
					}
					
					return momentify(label, timeOpts).format(me._labelFormat);
				},
				
				/**
				 * Function to format an individual tick mark
				 * @private
				 */
				tickFormatFunction: function(tick, index, ticks, formatOverride) {
					var me = this;
					var options = me.options;
					var time = tick.valueOf();
					var formats = options.time.displayFormats;
					var minorFormat = formats[me._unit];
					var majorUnit = me._majorUnit;
					var majorFormat = formats[majorUnit];
					var majorTime = tick.clone().startOf(majorUnit).valueOf();
					var majorTickOpts = options.ticks.major;
					var major = majorTickOpts.enabled && majorUnit && majorFormat && time === majorTime;
					var label = tick.format(formatOverride ? formatOverride : major ? majorFormat : minorFormat);
					var tickOpts = major ? majorTickOpts : options.ticks.minor;
					var formatter = helpers.valueOrDefault(tickOpts.callback, tickOpts.userCallback);
					
					return formatter ? formatter(label, index, ticks) : label;
				},
				
				convertTicksToLabels: function(ticks) {
					var labels = [];
					var i, ilen;
					
					for(i = 0, ilen = ticks.length; i < ilen; ++i) {
						labels.push(this.tickFormatFunction(moment(ticks[i].value), i, ticks));
					}
					
					return labels;
				},
				
				/**
				 * @private
				 */
				getPixelForOffset: function(time) {
					var me = this;
					var size = me._horizontal ? me.width : me.height;
					var start = me._horizontal ? me.left : me.top;
					var pos = interpolate(me._table, 'time', time, 'pos');
					
					return start + size * (me._offsets.left + pos) / (me._offsets.left + 1 + me._offsets.right);
				},
				
				getPixelForValue: function(value, index, datasetIndex) {
					var me = this;
					var time = null;
					
					if(index !== undefined && datasetIndex !== undefined) {
						time = me._timestamps.datasets[datasetIndex][index];
					}
					
					if(time === null) {
						time = parse(value, me);
					}
					
					if(time !== null) {
						return me.getPixelForOffset(time);
					}
				},
				
				getPixelForTick: function(index) {
					var ticks = this.getTicks();
					return index >= 0 && index < ticks.length ?
						this.getPixelForOffset(ticks[index].value) :
						null;
				},
				
				getValueForPixel: function(pixel) {
					var me = this;
					var size = me._horizontal ? me.width : me.height;
					var start = me._horizontal ? me.left : me.top;
					var pos = (size ? (pixel - start) / size : 0) * (me._offsets.left + 1 + me._offsets.left) - me._offsets.right;
					var time = interpolate(me._table, 'pos', pos, 'time');
					
					return moment(time);
				},
				
				/**
				 * Crude approximation of what the label width might be
				 * @private
				 */
				getLabelWidth: function(label) {
					var me = this;
					var ticksOpts = me.options.ticks;
					var tickLabelWidth = me.ctx.measureText(label).width;
					var angle = helpers.toRadians(ticksOpts.maxRotation);
					var cosRotation = Math.cos(angle);
					var sinRotation = Math.sin(angle);
					var tickFontSize = helpers.valueOrDefault(ticksOpts.fontSize, defaults.global.defaultFontSize);
					
					return (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation);
				},
				
				/**
				 * @private
				 */
				getLabelCapacity: function(exampleTime) {
					var me = this;
					
					var formatOverride = me.options.time.displayFormats.millisecond;	// Pick the longest format for guestimation
					
					var exampleLabel = me.tickFormatFunction(moment(exampleTime), 0, [], formatOverride);
					var tickLabelWidth = me.getLabelWidth(exampleLabel);
					var innerWidth = me.isHorizontal() ? me.width : me.height;
					
					var capacity = Math.floor(innerWidth / tickLabelWidth);
					return capacity > 0 ? capacity : 1;
				}
			});
			
			scaleService.registerScaleType('time', TimeScale, defaultConfig);
		};
		
		
		/***/
	}),
	
	/***/ "./node_modules/chartjs-color-string/color-string.js":
	/*!***********************************************************!*\
  !*** ./node_modules/chartjs-color-string/color-string.js ***!
  \***********************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		/* MIT license */
		var colorNames = __webpack_require__(/*! color-name */ "./node_modules/color-name/index.js");
		
		module.exports = {
			getRgba: getRgba,
			getHsla: getHsla,
			getRgb: getRgb,
			getHsl: getHsl,
			getHwb: getHwb,
			getAlpha: getAlpha,
			
			hexString: hexString,
			rgbString: rgbString,
			rgbaString: rgbaString,
			percentString: percentString,
			percentaString: percentaString,
			hslString: hslString,
			hslaString: hslaString,
			hwbString: hwbString,
			keyword: keyword
		}
		
		function getRgba(string) {
			if(!string) {
				return;
			}
			var abbr = /^#([a-fA-F0-9]{3})$/i,
				hex = /^#([a-fA-F0-9]{6})$/i,
				rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
				per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
				keyword = /(\w+)/;
			
			var rgb = [0, 0, 0],
				a = 1,
				match = string.match(abbr);
			if(match) {
				match = match[1];
				for(var i = 0; i < rgb.length; i++) {
					rgb[i] = parseInt(match[i] + match[i], 16);
				}
			} else if(match = string.match(hex)) {
				match = match[1];
				for(var i = 0; i < rgb.length; i++) {
					rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);
				}
			} else if(match = string.match(rgba)) {
				for(var i = 0; i < rgb.length; i++) {
					rgb[i] = parseInt(match[i + 1]);
				}
				a = parseFloat(match[4]);
			} else if(match = string.match(per)) {
				for(var i = 0; i < rgb.length; i++) {
					rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
				}
				a = parseFloat(match[4]);
			} else if(match = string.match(keyword)) {
				if(match[1] == "transparent") {
					return [0, 0, 0, 0];
				}
				rgb = colorNames[match[1]];
				if(!rgb) {
					return;
				}
			}
			
			for(var i = 0; i < rgb.length; i++) {
				rgb[i] = scale(rgb[i], 0, 255);
			}
			if(!a && a != 0) {
				a = 1;
			} else {
				a = scale(a, 0, 1);
			}
			rgb[3] = a;
			return rgb;
		}
		
		function getHsla(string) {
			if(!string) {
				return;
			}
			var hsl = /^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
			var match = string.match(hsl);
			if(match) {
				var alpha = parseFloat(match[4]);
				var h = scale(parseInt(match[1]), 0, 360),
					s = scale(parseFloat(match[2]), 0, 100),
					l = scale(parseFloat(match[3]), 0, 100),
					a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
				return [h, s, l, a];
			}
		}
		
		function getHwb(string) {
			if(!string) {
				return;
			}
			var hwb = /^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
			var match = string.match(hwb);
			if(match) {
				var alpha = parseFloat(match[4]);
				var h = scale(parseInt(match[1]), 0, 360),
					w = scale(parseFloat(match[2]), 0, 100),
					b = scale(parseFloat(match[3]), 0, 100),
					a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
				return [h, w, b, a];
			}
		}
		
		function getRgb(string) {
			var rgba = getRgba(string);
			return rgba && rgba.slice(0, 3);
		}
		
		function getHsl(string) {
			var hsla = getHsla(string);
			return hsla && hsla.slice(0, 3);
		}
		
		function getAlpha(string) {
			var vals = getRgba(string);
			if(vals) {
				return vals[3];
			} else if(vals = getHsla(string)) {
				return vals[3];
			} else if(vals = getHwb(string)) {
				return vals[3];
			}
		}

// generators
		function hexString(rgb) {
			return "#" + hexDouble(rgb[0]) + hexDouble(rgb[1])
				+ hexDouble(rgb[2]);
		}
		
		function rgbString(rgba, alpha) {
			if(alpha < 1 || (rgba[3] && rgba[3] < 1)) {
				return rgbaString(rgba, alpha);
			}
			return "rgb(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ")";
		}
		
		function rgbaString(rgba, alpha) {
			if(alpha === undefined) {
				alpha = (rgba[3] !== undefined ? rgba[3] : 1);
			}
			return "rgba(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2]
				+ ", " + alpha + ")";
		}
		
		function percentString(rgba, alpha) {
			if(alpha < 1 || (rgba[3] && rgba[3] < 1)) {
				return percentaString(rgba, alpha);
			}
			var r = Math.round(rgba[0] / 255 * 100),
				g = Math.round(rgba[1] / 255 * 100),
				b = Math.round(rgba[2] / 255 * 100);
			
			return "rgb(" + r + "%, " + g + "%, " + b + "%)";
		}
		
		function percentaString(rgba, alpha) {
			var r = Math.round(rgba[0] / 255 * 100),
				g = Math.round(rgba[1] / 255 * 100),
				b = Math.round(rgba[2] / 255 * 100);
			return "rgba(" + r + "%, " + g + "%, " + b + "%, " + (alpha || rgba[3] || 1) + ")";
		}
		
		function hslString(hsla, alpha) {
			if(alpha < 1 || (hsla[3] && hsla[3] < 1)) {
				return hslaString(hsla, alpha);
			}
			return "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)";
		}
		
		function hslaString(hsla, alpha) {
			if(alpha === undefined) {
				alpha = (hsla[3] !== undefined ? hsla[3] : 1);
			}
			return "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, "
				+ alpha + ")";
		}

// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
// (hwb have alpha optional & 1 is default value)
		function hwbString(hwb, alpha) {
			if(alpha === undefined) {
				alpha = (hwb[3] !== undefined ? hwb[3] : 1);
			}
			return "hwb(" + hwb[0] + ", " + hwb[1] + "%, " + hwb[2] + "%"
				+ (alpha !== undefined && alpha !== 1 ? ", " + alpha : "") + ")";
		}
		
		function keyword(rgb) {
			return reverseNames[rgb.slice(0, 3)];
		}

// helpers
		function scale(num, min, max) {
			return Math.min(Math.max(min, num), max);
		}
		
		function hexDouble(num) {
			var str = num.toString(16).toUpperCase();
			return (str.length < 2) ? "0" + str : str;
		}


//create a list of reverse color names
		var reverseNames = {};
		for(var name in colorNames) {
			reverseNames[colorNames[name]] = name;
		}
		
		
		/***/
	}),
	
	/***/ "./node_modules/chartjs-color/index.js":
	/*!*********************************************!*\
  !*** ./node_modules/chartjs-color/index.js ***!
  \*********************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		/* MIT license */
		var convert = __webpack_require__(/*! color-convert */ "./node_modules/chartjs-color/node_modules/color-convert/index.js");
		var string = __webpack_require__(/*! chartjs-color-string */ "./node_modules/chartjs-color-string/color-string.js");
		
		var Color = function(obj) {
			if(obj instanceof Color) {
				return obj;
			}
			if(!(this instanceof Color)) {
				return new Color(obj);
			}
			
			this.valid = false;
			this.values = {
				rgb: [0, 0, 0],
				hsl: [0, 0, 0],
				hsv: [0, 0, 0],
				hwb: [0, 0, 0],
				cmyk: [0, 0, 0, 0],
				alpha: 1
			};
			
			// parse Color() argument
			var vals;
			if(typeof obj === 'string') {
				vals = string.getRgba(obj);
				if(vals) {
					this.setValues('rgb', vals);
				} else if(vals = string.getHsla(obj)) {
					this.setValues('hsl', vals);
				} else if(vals = string.getHwb(obj)) {
					this.setValues('hwb', vals);
				}
			} else if(typeof obj === 'object') {
				vals = obj;
				if(vals.r !== undefined || vals.red !== undefined) {
					this.setValues('rgb', vals);
				} else if(vals.l !== undefined || vals.lightness !== undefined) {
					this.setValues('hsl', vals);
				} else if(vals.v !== undefined || vals.value !== undefined) {
					this.setValues('hsv', vals);
				} else if(vals.w !== undefined || vals.whiteness !== undefined) {
					this.setValues('hwb', vals);
				} else if(vals.c !== undefined || vals.cyan !== undefined) {
					this.setValues('cmyk', vals);
				}
			}
		};
		
		Color.prototype = {
			isValid: function() {
				return this.valid;
			},
			rgb: function() {
				return this.setSpace('rgb', arguments);
			},
			hsl: function() {
				return this.setSpace('hsl', arguments);
			},
			hsv: function() {
				return this.setSpace('hsv', arguments);
			},
			hwb: function() {
				return this.setSpace('hwb', arguments);
			},
			cmyk: function() {
				return this.setSpace('cmyk', arguments);
			},
			
			rgbArray: function() {
				return this.values.rgb;
			},
			hslArray: function() {
				return this.values.hsl;
			},
			hsvArray: function() {
				return this.values.hsv;
			},
			hwbArray: function() {
				var values = this.values;
				if(values.alpha !== 1) {
					return values.hwb.concat([values.alpha]);
				}
				return values.hwb;
			},
			cmykArray: function() {
				return this.values.cmyk;
			},
			rgbaArray: function() {
				var values = this.values;
				return values.rgb.concat([values.alpha]);
			},
			hslaArray: function() {
				var values = this.values;
				return values.hsl.concat([values.alpha]);
			},
			alpha: function(val) {
				if(val === undefined) {
					return this.values.alpha;
				}
				this.setValues('alpha', val);
				return this;
			},
			
			red: function(val) {
				return this.setChannel('rgb', 0, val);
			},
			green: function(val) {
				return this.setChannel('rgb', 1, val);
			},
			blue: function(val) {
				return this.setChannel('rgb', 2, val);
			},
			hue: function(val) {
				if(val) {
					val %= 360;
					val = val < 0 ? 360 + val : val;
				}
				return this.setChannel('hsl', 0, val);
			},
			saturation: function(val) {
				return this.setChannel('hsl', 1, val);
			},
			lightness: function(val) {
				return this.setChannel('hsl', 2, val);
			},
			saturationv: function(val) {
				return this.setChannel('hsv', 1, val);
			},
			whiteness: function(val) {
				return this.setChannel('hwb', 1, val);
			},
			blackness: function(val) {
				return this.setChannel('hwb', 2, val);
			},
			value: function(val) {
				return this.setChannel('hsv', 2, val);
			},
			cyan: function(val) {
				return this.setChannel('cmyk', 0, val);
			},
			magenta: function(val) {
				return this.setChannel('cmyk', 1, val);
			},
			yellow: function(val) {
				return this.setChannel('cmyk', 2, val);
			},
			black: function(val) {
				return this.setChannel('cmyk', 3, val);
			},
			
			hexString: function() {
				return string.hexString(this.values.rgb);
			},
			rgbString: function() {
				return string.rgbString(this.values.rgb, this.values.alpha);
			},
			rgbaString: function() {
				return string.rgbaString(this.values.rgb, this.values.alpha);
			},
			percentString: function() {
				return string.percentString(this.values.rgb, this.values.alpha);
			},
			hslString: function() {
				return string.hslString(this.values.hsl, this.values.alpha);
			},
			hslaString: function() {
				return string.hslaString(this.values.hsl, this.values.alpha);
			},
			hwbString: function() {
				return string.hwbString(this.values.hwb, this.values.alpha);
			},
			keyword: function() {
				return string.keyword(this.values.rgb, this.values.alpha);
			},
			
			rgbNumber: function() {
				var rgb = this.values.rgb;
				return (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];
			},
			
			luminosity: function() {
				// http://www.w3.org/TR/WCAG20/#relativeluminancedef
				var rgb = this.values.rgb;
				var lum = [];
				for(var i = 0; i < rgb.length; i++) {
					var chan = rgb[i] / 255;
					lum[i] = (chan <= 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);
				}
				return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
			},
			
			contrast: function(color2) {
				// http://www.w3.org/TR/WCAG20/#contrast-ratiodef
				var lum1 = this.luminosity();
				var lum2 = color2.luminosity();
				if(lum1 > lum2) {
					return (lum1 + 0.05) / (lum2 + 0.05);
				}
				return (lum2 + 0.05) / (lum1 + 0.05);
			},
			
			level: function(color2) {
				var contrastRatio = this.contrast(color2);
				if(contrastRatio >= 7.1) {
					return 'AAA';
				}
				
				return (contrastRatio >= 4.5) ? 'AA' : '';
			},
			
			dark: function() {
				// YIQ equation from http://24ways.org/2010/calculating-color-contrast
				var rgb = this.values.rgb;
				var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
				return yiq < 128;
			},
			
			light: function() {
				return !this.dark();
			},
			
			negate: function() {
				var rgb = [];
				for(var i = 0; i < 3; i++) {
					rgb[i] = 255 - this.values.rgb[i];
				}
				this.setValues('rgb', rgb);
				return this;
			},
			
			lighten: function(ratio) {
				var hsl = this.values.hsl;
				hsl[2] += hsl[2] * ratio;
				this.setValues('hsl', hsl);
				return this;
			},
			
			darken: function(ratio) {
				var hsl = this.values.hsl;
				hsl[2] -= hsl[2] * ratio;
				this.setValues('hsl', hsl);
				return this;
			},
			
			saturate: function(ratio) {
				var hsl = this.values.hsl;
				hsl[1] += hsl[1] * ratio;
				this.setValues('hsl', hsl);
				return this;
			},
			
			desaturate: function(ratio) {
				var hsl = this.values.hsl;
				hsl[1] -= hsl[1] * ratio;
				this.setValues('hsl', hsl);
				return this;
			},
			
			whiten: function(ratio) {
				var hwb = this.values.hwb;
				hwb[1] += hwb[1] * ratio;
				this.setValues('hwb', hwb);
				return this;
			},
			
			blacken: function(ratio) {
				var hwb = this.values.hwb;
				hwb[2] += hwb[2] * ratio;
				this.setValues('hwb', hwb);
				return this;
			},
			
			greyscale: function() {
				var rgb = this.values.rgb;
				// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale
				var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
				this.setValues('rgb', [val, val, val]);
				return this;
			},
			
			clearer: function(ratio) {
				var alpha = this.values.alpha;
				this.setValues('alpha', alpha - (alpha * ratio));
				return this;
			},
			
			opaquer: function(ratio) {
				var alpha = this.values.alpha;
				this.setValues('alpha', alpha + (alpha * ratio));
				return this;
			},
			
			rotate: function(degrees) {
				var hsl = this.values.hsl;
				var hue = (hsl[0] + degrees) % 360;
				hsl[0] = hue < 0 ? 360 + hue : hue;
				this.setValues('hsl', hsl);
				return this;
			},
			
			/**
			 * Ported from sass implementation in C
			 * https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
			 */
			mix: function(mixinColor, weight) {
				var color1 = this;
				var color2 = mixinColor;
				var p = weight === undefined ? 0.5 : weight;
				
				var w = 2 * p - 1;
				var a = color1.alpha() - color2.alpha();
				
				var w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
				var w2 = 1 - w1;
				
				return this
					.rgb(
						w1 * color1.red() + w2 * color2.red(),
						w1 * color1.green() + w2 * color2.green(),
						w1 * color1.blue() + w2 * color2.blue()
					)
					.alpha(color1.alpha() * p + color2.alpha() * (1 - p));
			},
			
			toJSON: function() {
				return this.rgb();
			},
			
			clone: function() {
				// NOTE(SB): using node-clone creates a dependency to Buffer when using browserify,
				// making the final build way to big to embed in Chart.js. So let's do it manually,
				// assuming that values to clone are 1 dimension arrays containing only numbers,
				// except 'alpha' which is a number.
				var result = new Color();
				var source = this.values;
				var target = result.values;
				var value, type;
				
				for(var prop in source) {
					if(source.hasOwnProperty(prop)) {
						value = source[prop];
						type = ({}).toString.call(value);
						if(type === '[object Array]') {
							target[prop] = value.slice(0);
						} else if(type === '[object Number]') {
							target[prop] = value;
						} else {
							console.error('unexpected color value:', value);
						}
					}
				}
				
				return result;
			}
		};
		
		Color.prototype.spaces = {
			rgb: ['red', 'green', 'blue'],
			hsl: ['hue', 'saturation', 'lightness'],
			hsv: ['hue', 'saturation', 'value'],
			hwb: ['hue', 'whiteness', 'blackness'],
			cmyk: ['cyan', 'magenta', 'yellow', 'black']
		};
		
		Color.prototype.maxes = {
			rgb: [255, 255, 255],
			hsl: [360, 100, 100],
			hsv: [360, 100, 100],
			hwb: [360, 100, 100],
			cmyk: [100, 100, 100, 100]
		};
		
		Color.prototype.getValues = function(space) {
			var values = this.values;
			var vals = {};
			
			for(var i = 0; i < space.length; i++) {
				vals[space.charAt(i)] = values[space][i];
			}
			
			if(values.alpha !== 1) {
				vals.a = values.alpha;
			}
			
			// {r: 255, g: 255, b: 255, a: 0.4}
			return vals;
		};
		
		Color.prototype.setValues = function(space, vals) {
			var values = this.values;
			var spaces = this.spaces;
			var maxes = this.maxes;
			var alpha = 1;
			var i;
			
			this.valid = true;
			
			if(space === 'alpha') {
				alpha = vals;
			} else if(vals.length) {
				// [10, 10, 10]
				values[space] = vals.slice(0, space.length);
				alpha = vals[space.length];
			} else if(vals[space.charAt(0)] !== undefined) {
				// {r: 10, g: 10, b: 10}
				for(i = 0; i < space.length; i++) {
					values[space][i] = vals[space.charAt(i)];
				}
				
				alpha = vals.a;
			} else if(vals[spaces[space][0]] !== undefined) {
				// {red: 10, green: 10, blue: 10}
				var chans = spaces[space];
				
				for(i = 0; i < space.length; i++) {
					values[space][i] = vals[chans[i]];
				}
				
				alpha = vals.alpha;
			}
			
			values.alpha = Math.max(0, Math.min(1, (alpha === undefined ? values.alpha : alpha)));
			
			if(space === 'alpha') {
				return false;
			}
			
			var capped;
			
			// cap values of the space prior converting all values
			for(i = 0; i < space.length; i++) {
				capped = Math.max(0, Math.min(maxes[space][i], values[space][i]));
				values[space][i] = Math.round(capped);
			}
			
			// convert to all the other color spaces
			for(var sname in spaces) {
				if(sname !== space) {
					values[sname] = convert[space][sname](values[space]);
				}
			}
			
			return true;
		};
		
		Color.prototype.setSpace = function(space, args) {
			var vals = args[0];
			
			if(vals === undefined) {
				// color.rgb()
				return this.getValues(space);
			}
			
			// color.rgb(10, 10, 10)
			if(typeof vals === 'number') {
				vals = Array.prototype.slice.call(args);
			}
			
			this.setValues(space, vals);
			return this;
		};
		
		Color.prototype.setChannel = function(space, index, val) {
			var svalues = this.values[space];
			if(val === undefined) {
				// color.red()
				return svalues[index];
			} else if(val === svalues[index]) {
				// color.red(color.red())
				return this;
			}
			
			// color.red(100)
			svalues[index] = val;
			this.setValues(space, svalues);
			
			return this;
		};
		
		if(typeof window !== 'undefined') {
			window.Color = Color;
		}
		
		module.exports = Color;
		
		
		/***/
	}),
	
	/***/ "./node_modules/chartjs-color/node_modules/color-convert/conversions.js":
	/*!******************************************************************************!*\
  !*** ./node_modules/chartjs-color/node_modules/color-convert/conversions.js ***!
  \******************************************************************************/
	/*! no static exports found */
	/***/ (function(module, exports) {
		
		/* MIT license */
		
		module.exports = {
			rgb2hsl: rgb2hsl,
			rgb2hsv: rgb2hsv,
			rgb2hwb: rgb2hwb,
			rgb2cmyk: rgb2cmyk,
			rgb2keyword: rgb2keyword,
			rgb2xyz: rgb2xyz,
			rgb2lab: rgb2lab,
			rgb2lch: rgb2lch,
			
			hsl2rgb: hsl2rgb,
			hsl2hsv: hsl2hsv,
			hsl2hwb: hsl2hwb,
			hsl2cmyk: hsl2cmyk,
			hsl2keyword: hsl2keyword,
			
			hsv2rgb: hsv2rgb,
			hsv2hsl: hsv2hsl,
			hsv2hwb: hsv2hwb,
			hsv2cmyk: hsv2cmyk,
			hsv2keyword: hsv2keyword,
			
			hwb2rgb: hwb2rgb,
			hwb2hsl: hwb2hsl,
			hwb2hsv: hwb2hsv,
			hwb2cmyk: hwb2cmyk,
			hwb2keyword: hwb2keyword,
			
			cmyk2rgb: cmyk2rgb,
			cmyk2hsl: cmyk2hsl,
			cmyk2hsv: cmyk2hsv,
			cmyk2hwb: cmyk2hwb,
			cmyk2keyword: cmyk2keyword,
			
			keyword2rgb: keyword2rgb,
			keyword2hsl: keyword2hsl,
			keyword2hsv: keyword2hsv,
			keyword2hwb: keyword2hwb,
			keyword2cmyk: keyword2cmyk,
			keyword2lab: keyword2lab,
			keyword2xyz: keyword2xyz,
			
			xyz2rgb: xyz2rgb,
			xyz2lab: xyz2lab,
			xyz2lch: xyz2lch,
			
			lab2xyz: lab2xyz,
			lab2rgb: lab2rgb,
			lab2lch: lab2lch,
			
			lch2lab: lch2lab,
			lch2xyz: lch2xyz,
			lch2rgb: lch2rgb
		}
		
		
		function rgb2hsl(rgb) {
			var r = rgb[0] / 255,
				g = rgb[1] / 255,
				b = rgb[2] / 255,
				min = Math.min(r, g, b),
				max = Math.max(r, g, b),
				delta = max - min,
				h, s, l;
			
			if(max == min)
				h = 0;
			else if(r == max)
				h = (g - b) / delta;
			else if(g == max)
				h = 2 + (b - r) / delta;
			else if(b == max)
				h = 4 + (r - g) / delta;
			
			h = Math.min(h * 60, 360);
			
			if(h < 0)
				h += 360;
			
			l = (min + max) / 2;
			
			if(max == min)
				s = 0;
			else if(l <= 0.5)
				s = delta / (max + min);
			else
				s = delta / (2 - max - min);
			
			return [h, s * 100, l * 100];
		}
		
		function rgb2hsv(rgb) {
			var r = rgb[0],
				g = rgb[1],
				b = rgb[2],
				min = Math.min(r, g, b),
				max = Math.max(r, g, b),
				delta = max - min,
				h, s, v;
			
			if(max == 0)
				s = 0;
			else
				s = (delta / max * 1000) / 10;
			
			if(max == min)
				h = 0;
			else if(r == max)
				h = (g - b) / delta;
			else if(g == max)
				h = 2 + (b - r) / delta;
			else if(b == max)
				h = 4 + (r - g) / delta;
			
			h = Math.min(h * 60, 360);
			
			if(h < 0)
				h += 360;
			
			v = ((max / 255) * 1000) / 10;
			
			return [h, s, v];
		}
		
		function rgb2hwb(rgb) {
			var r = rgb[0],
				g = rgb[1],
				b = rgb[2],
				h = rgb2hsl(rgb)[0],
				w = 1 / 255 * Math.min(r, Math.min(g, b)),
				b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
			
			return [h, w * 100, b * 100];
		}
		
		function rgb2cmyk(rgb) {
			var r = rgb[0] / 255,
				g = rgb[1] / 255,
				b = rgb[2] / 255,
				c, m, y, k;
			
			k = Math.min(1 - r, 1 - g, 1 - b);
			c = (1 - r - k) / (1 - k) || 0;
			m = (1 - g - k) / (1 - k) || 0;
			y = (1 - b - k) / (1 - k) || 0;
			return [c * 100, m * 100, y * 100, k * 100];
		}
		
		function rgb2keyword(rgb) {
			return reverseKeywords[JSON.stringify(rgb)];
		}
		
		function rgb2xyz(rgb) {
			var r = rgb[0] / 255,
				g = rgb[1] / 255,
				b = rgb[2] / 255;
			
			// assume sRGB
			r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
			g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
			b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);
			
			var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
			var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
			var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);
			
			return [x * 100, y * 100, z * 100];
		}
		
		function rgb2lab(rgb) {
			var xyz = rgb2xyz(rgb),
				x = xyz[0],
				y = xyz[1],
				z = xyz[2],
				l, a, b;
			
			x /= 95.047;
			y /= 100;
			z /= 108.883;
			
			x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
			y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
			z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);
			
			l = (116 * y) - 16;
			a = 500 * (x - y);
			b = 200 * (y - z);
			
			return [l, a, b];
		}
		
		function rgb2lch(args) {
			return lab2lch(rgb2lab(args));
		}
		
		function hsl2rgb(hsl) {
			var h = hsl[0] / 360,
				s = hsl[1] / 100,
				l = hsl[2] / 100,
				t1, t2, t3, rgb, val;
			
			if(s == 0) {
				val = l * 255;
				return [val, val, val];
			}
			
			if(l < 0.5)
				t2 = l * (1 + s);
			else
				t2 = l + s - l * s;
			t1 = 2 * l - t2;
			
			rgb = [0, 0, 0];
			for(var i = 0; i < 3; i++) {
				t3 = h + 1 / 3 * -(i - 1);
				t3 < 0 && t3++;
				t3 > 1 && t3--;
				
				if(6 * t3 < 1)
					val = t1 + (t2 - t1) * 6 * t3;
				else if(2 * t3 < 1)
					val = t2;
				else if(3 * t3 < 2)
					val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
				else
					val = t1;
				
				rgb[i] = val * 255;
			}
			
			return rgb;
		}
		
		function hsl2hsv(hsl) {
			var h = hsl[0],
				s = hsl[1] / 100,
				l = hsl[2] / 100,
				sv, v;
			
			if(l === 0) {
				// no need to do calc on black
				// also avoids divide by 0 error
				return [0, 0, 0];
			}
			
			l *= 2;
			s *= (l <= 1) ? l : 2 - l;
			v = (l + s) / 2;
			sv = (2 * s) / (l + s);
			return [h, sv * 100, v * 100];
		}
		
		function hsl2hwb(args) {
			return rgb2hwb(hsl2rgb(args));
		}
		
		function hsl2cmyk(args) {
			return rgb2cmyk(hsl2rgb(args));
		}
		
		function hsl2keyword(args) {
			return rgb2keyword(hsl2rgb(args));
		}
		
		
		function hsv2rgb(hsv) {
			var h = hsv[0] / 60,
				s = hsv[1] / 100,
				v = hsv[2] / 100,
				hi = Math.floor(h) % 6;
			
			var f = h - Math.floor(h),
				p = 255 * v * (1 - s),
				q = 255 * v * (1 - (s * f)),
				t = 255 * v * (1 - (s * (1 - f))),
				v = 255 * v;
			
			switch(hi) {
				case 0:
					return [v, t, p];
				case 1:
					return [q, v, p];
				case 2:
					return [p, v, t];
				case 3:
					return [p, q, v];
				case 4:
					return [t, p, v];
				case 5:
					return [v, p, q];
			}
		}
		
		function hsv2hsl(hsv) {
			var h = hsv[0],
				s = hsv[1] / 100,
				v = hsv[2] / 100,
				sl, l;
			
			l = (2 - s) * v;
			sl = s * v;
			sl /= (l <= 1) ? l : 2 - l;
			sl = sl || 0;
			l /= 2;
			return [h, sl * 100, l * 100];
		}
		
		function hsv2hwb(args) {
			return rgb2hwb(hsv2rgb(args))
		}
		
		function hsv2cmyk(args) {
			return rgb2cmyk(hsv2rgb(args));
		}
		
		function hsv2keyword(args) {
			return rgb2keyword(hsv2rgb(args));
		}

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
		function hwb2rgb(hwb) {
			var h = hwb[0] / 360,
				wh = hwb[1] / 100,
				bl = hwb[2] / 100,
				ratio = wh + bl,
				i, v, f, n;
			
			// wh + bl cant be > 1
			if(ratio > 1) {
				wh /= ratio;
				bl /= ratio;
			}
			
			i = Math.floor(6 * h);
			v = 1 - bl;
			f = 6 * h - i;
			if((i & 0x01) != 0) {
				f = 1 - f;
			}
			n = wh + f * (v - wh);  // linear interpolation
			
			switch(i) {
				default:
				case 6:
				case 0:
					r = v;
					g = n;
					b = wh;
					break;
				case 1:
					r = n;
					g = v;
					b = wh;
					break;
				case 2:
					r = wh;
					g = v;
					b = n;
					break;
				case 3:
					r = wh;
					g = n;
					b = v;
					break;
				case 4:
					r = n;
					g = wh;
					b = v;
					break;
				case 5:
					r = v;
					g = wh;
					b = n;
					break;
			}
			
			return [r * 255, g * 255, b * 255];
		}
		
		function hwb2hsl(args) {
			return rgb2hsl(hwb2rgb(args));
		}
		
		function hwb2hsv(args) {
			return rgb2hsv(hwb2rgb(args));
		}
		
		function hwb2cmyk(args) {
			return rgb2cmyk(hwb2rgb(args));
		}
		
		function hwb2keyword(args) {
			return rgb2keyword(hwb2rgb(args));
		}
		
		function cmyk2rgb(cmyk) {
			var c = cmyk[0] / 100,
				m = cmyk[1] / 100,
				y = cmyk[2] / 100,
				k = cmyk[3] / 100,
				r, g, b;
			
			r = 1 - Math.min(1, c * (1 - k) + k);
			g = 1 - Math.min(1, m * (1 - k) + k);
			b = 1 - Math.min(1, y * (1 - k) + k);
			return [r * 255, g * 255, b * 255];
		}
		
		function cmyk2hsl(args) {
			return rgb2hsl(cmyk2rgb(args));
		}
		
		function cmyk2hsv(args) {
			return rgb2hsv(cmyk2rgb(args));
		}
		
		function cmyk2hwb(args) {
			return rgb2hwb(cmyk2rgb(args));
		}
		
		function cmyk2keyword(args) {
			return rgb2keyword(cmyk2rgb(args));
		}
		
		
		function xyz2rgb(xyz) {
			var x = xyz[0] / 100,
				y = xyz[1] / 100,
				z = xyz[2] / 100,
				r, g, b;
			
			r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
			g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
			b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);
			
			// assume sRGB
			r = r > 0.0031308 ? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
				: r = (r * 12.92);
			
			g = g > 0.0031308 ? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
				: g = (g * 12.92);
			
			b = b > 0.0031308 ? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
				: b = (b * 12.92);
			
			r = Math.min(Math.max(0, r), 1);
			g = Math.min(Math.max(0, g), 1);
			b = Math.min(Math.max(0, b), 1);
			
			return [r * 255, g * 255, b * 255];
		}
		
		function xyz2lab(xyz) {
			var x = xyz[0],
				y = xyz[1],
				z = xyz[2],
				l, a, b;
			
			x /= 95.047;
			y /= 100;
			z /= 108.883;
			
			x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
			y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
			z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);
			
			l = (116 * y) - 16;
			a = 500 * (x - y);
			b = 200 * (y - z);
			
			return [l, a, b];
		}
		
		function xyz2lch(args) {
			return lab2lch(xyz2lab(args));
		}
		
		function lab2xyz(lab) {
			var l = lab[0],
				a = lab[1],
				b = lab[2],
				x, y, z, y2;
			
			if(l <= 8) {
				y = (l * 100) / 903.3;
				y2 = (7.787 * (y / 100)) + (16 / 116);
			} else {
				y = 100 * Math.pow((l + 16) / 116, 3);
				y2 = Math.pow(y / 100, 1 / 3);
			}
			
			x = x / 95.047 <= 0.008856 ? x = (95.047 * ((a / 500) + y2 - (16 / 116))) / 7.787 : 95.047 * Math.pow((a / 500) + y2, 3);
			
			z = z / 108.883 <= 0.008859 ? z = (108.883 * (y2 - (b / 200) - (16 / 116))) / 7.787 : 108.883 * Math.pow(y2 - (b / 200), 3);
			
			return [x, y, z];
		}
		
		function lab2lch(lab) {
			var l = lab[0],
				a = lab[1],
				b = lab[2],
				hr, h, c;
			
			hr = Math.atan2(b, a);
			h = hr * 360 / 2 / Math.PI;
			if(h < 0) {
				h += 360;
			}
			c = Math.sqrt(a * a + b * b);
			return [l, c, h];
		}
		
		function lab2rgb(args) {
			return xyz2rgb(lab2xyz(args));
		}
		
		function lch2lab(lch) {
			var l = lch[0],
				c = lch[1],
				h = lch[2],
				a, b, hr;
			
			hr = h / 360 * 2 * Math.PI;
			a = c * Math.cos(hr);
			b = c * Math.sin(hr);
			return [l, a, b];
		}
		
		function lch2xyz(args) {
			return lab2xyz(lch2lab(args));
		}
		
		function lch2rgb(args) {
			return lab2rgb(lch2lab(args));
		}
		
		function keyword2rgb(keyword) {
			return cssKeywords[keyword];
		}
		
		function keyword2hsl(args) {
			return rgb2hsl(keyword2rgb(args));
		}
		
		function keyword2hsv(args) {
			return rgb2hsv(keyword2rgb(args));
		}
		
		function keyword2hwb(args) {
			return rgb2hwb(keyword2rgb(args));
		}
		
		function keyword2cmyk(args) {
			return rgb2cmyk(keyword2rgb(args));
		}
		
		function keyword2lab(args) {
			return rgb2lab(keyword2rgb(args));
		}
		
		function keyword2xyz(args) {
			return rgb2xyz(keyword2rgb(args));
		}
		
		var cssKeywords = {
			aliceblue: [240, 248, 255],
			antiquewhite: [250, 235, 215],
			aqua: [0, 255, 255],
			aquamarine: [127, 255, 212],
			azure: [240, 255, 255],
			beige: [245, 245, 220],
			bisque: [255, 228, 196],
			black: [0, 0, 0],
			blanchedalmond: [255, 235, 205],
			blue: [0, 0, 255],
			blueviolet: [138, 43, 226],
			brown: [165, 42, 42],
			burlywood: [222, 184, 135],
			cadetblue: [95, 158, 160],
			chartreuse: [127, 255, 0],
			chocolate: [210, 105, 30],
			coral: [255, 127, 80],
			cornflowerblue: [100, 149, 237],
			cornsilk: [255, 248, 220],
			crimson: [220, 20, 60],
			cyan: [0, 255, 255],
			darkblue: [0, 0, 139],
			darkcyan: [0, 139, 139],
			darkgoldenrod: [184, 134, 11],
			darkgray: [169, 169, 169],
			darkgreen: [0, 100, 0],
			darkgrey: [169, 169, 169],
			darkkhaki: [189, 183, 107],
			darkmagenta: [139, 0, 139],
			darkolivegreen: [85, 107, 47],
			darkorange: [255, 140, 0],
			darkorchid: [153, 50, 204],
			darkred: [139, 0, 0],
			darksalmon: [233, 150, 122],
			darkseagreen: [143, 188, 143],
			darkslateblue: [72, 61, 139],
			darkslategray: [47, 79, 79],
			darkslategrey: [47, 79, 79],
			darkturquoise: [0, 206, 209],
			darkviolet: [148, 0, 211],
			deeppink: [255, 20, 147],
			deepskyblue: [0, 191, 255],
			dimgray: [105, 105, 105],
			dimgrey: [105, 105, 105],
			dodgerblue: [30, 144, 255],
			firebrick: [178, 34, 34],
			floralwhite: [255, 250, 240],
			forestgreen: [34, 139, 34],
			fuchsia: [255, 0, 255],
			gainsboro: [220, 220, 220],
			ghostwhite: [248, 248, 255],
			gold: [255, 215, 0],
			goldenrod: [218, 165, 32],
			gray: [128, 128, 128],
			green: [0, 128, 0],
			greenyellow: [173, 255, 47],
			grey: [128, 128, 128],
			honeydew: [240, 255, 240],
			hotpink: [255, 105, 180],
			indianred: [205, 92, 92],
			indigo: [75, 0, 130],
			ivory: [255, 255, 240],
			khaki: [240, 230, 140],
			lavender: [230, 230, 250],
			lavenderblush: [255, 240, 245],
			lawngreen: [124, 252, 0],
			lemonchiffon: [255, 250, 205],
			lightblue: [173, 216, 230],
			lightcoral: [240, 128, 128],
			lightcyan: [224, 255, 255],
			lightgoldenrodyellow: [250, 250, 210],
			lightgray: [211, 211, 211],
			lightgreen: [144, 238, 144],
			lightgrey: [211, 211, 211],
			lightpink: [255, 182, 193],
			lightsalmon: [255, 160, 122],
			lightseagreen: [32, 178, 170],
			lightskyblue: [135, 206, 250],
			lightslategray: [119, 136, 153],
			lightslategrey: [119, 136, 153],
			lightsteelblue: [176, 196, 222],
			lightyellow: [255, 255, 224],
			lime: [0, 255, 0],
			limegreen: [50, 205, 50],
			linen: [250, 240, 230],
			magenta: [255, 0, 255],
			maroon: [128, 0, 0],
			mediumaquamarine: [102, 205, 170],
			mediumblue: [0, 0, 205],
			mediumorchid: [186, 85, 211],
			mediumpurple: [147, 112, 219],
			mediumseagreen: [60, 179, 113],
			mediumslateblue: [123, 104, 238],
			mediumspringgreen: [0, 250, 154],
			mediumturquoise: [72, 209, 204],
			mediumvioletred: [199, 21, 133],
			midnightblue: [25, 25, 112],
			mintcream: [245, 255, 250],
			mistyrose: [255, 228, 225],
			moccasin: [255, 228, 181],
			navajowhite: [255, 222, 173],
			navy: [0, 0, 128],
			oldlace: [253, 245, 230],
			olive: [128, 128, 0],
			olivedrab: [107, 142, 35],
			orange: [255, 165, 0],
			orangered: [255, 69, 0],
			orchid: [218, 112, 214],
			palegoldenrod: [238, 232, 170],
			palegreen: [152, 251, 152],
			paleturquoise: [175, 238, 238],
			palevioletred: [219, 112, 147],
			papayawhip: [255, 239, 213],
			peachpuff: [255, 218, 185],
			peru: [205, 133, 63],
			pink: [255, 192, 203],
			plum: [221, 160, 221],
			powderblue: [176, 224, 230],
			purple: [128, 0, 128],
			rebeccapurple: [102, 51, 153],
			red: [255, 0, 0],
			rosybrown: [188, 143, 143],
			royalblue: [65, 105, 225],
			saddlebrown: [139, 69, 19],
			salmon: [250, 128, 114],
			sandybrown: [244, 164, 96],
			seagreen: [46, 139, 87],
			seashell: [255, 245, 238],
			sienna: [160, 82, 45],
			silver: [192, 192, 192],
			skyblue: [135, 206, 235],
			slateblue: [106, 90, 205],
			slategray: [112, 128, 144],
			slategrey: [112, 128, 144],
			snow: [255, 250, 250],
			springgreen: [0, 255, 127],
			steelblue: [70, 130, 180],
			tan: [210, 180, 140],
			teal: [0, 128, 128],
			thistle: [216, 191, 216],
			tomato: [255, 99, 71],
			turquoise: [64, 224, 208],
			violet: [238, 130, 238],
			wheat: [245, 222, 179],
			white: [255, 255, 255],
			whitesmoke: [245, 245, 245],
			yellow: [255, 255, 0],
			yellowgreen: [154, 205, 50]
		};
		
		var reverseKeywords = {};
		for(var key in cssKeywords) {
			reverseKeywords[JSON.stringify(cssKeywords[key])] = key;
		}
		
		
		/***/
	}),
	
	/***/ "./node_modules/chartjs-color/node_modules/color-convert/index.js":
	/*!************************************************************************!*\
  !*** ./node_modules/chartjs-color/node_modules/color-convert/index.js ***!
  \************************************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		var conversions = __webpack_require__(/*! ./conversions */ "./node_modules/chartjs-color/node_modules/color-convert/conversions.js");
		
		var convert = function() {
			return new Converter();
		}
		
		for(var func in conversions) {
			// export Raw versions
			convert[func + "Raw"] = (function(func) {
				// accept array or plain args
				return function(arg) {
					if(typeof arg == "number")
						arg = Array.prototype.slice.call(arguments);
					return conversions[func](arg);
				}
			})(func);
			
			var pair = /(\w+)2(\w+)/.exec(func),
				from = pair[1],
				to = pair[2];
			
			// export rgb2hsl and ["rgb"]["hsl"]
			convert[from] = convert[from] || {};
			
			convert[from][to] = convert[func] = (function(func) {
				return function(arg) {
					if(typeof arg == "number")
						arg = Array.prototype.slice.call(arguments);
					
					var val = conversions[func](arg);
					if(typeof val == "string" || val === undefined)
						return val; // keyword
					
					for(var i = 0; i < val.length; i++)
						val[i] = Math.round(val[i]);
					return val;
				}
			})(func);
		}
		
		
		/* Converter does lazy conversion and caching */
		var Converter = function() {
			this.convs = {};
		};
		
		/* Either get the values for a space or
  set the values for a space, depending on args */
		Converter.prototype.routeSpace = function(space, args) {
			var values = args[0];
			if(values === undefined) {
				// color.rgb()
				return this.getValues(space);
			}
			// color.rgb(10, 10, 10)
			if(typeof values == "number") {
				values = Array.prototype.slice.call(args);
			}
			
			return this.setValues(space, values);
		};
		
		/* Set the values for a space, invalidating cache */
		Converter.prototype.setValues = function(space, values) {
			this.space = space;
			this.convs = {};
			this.convs[space] = values;
			return this;
		};
		
		/* Get the values for a space. If there's already
  a conversion for the space, fetch it, otherwise
  compute it */
		Converter.prototype.getValues = function(space) {
			var vals = this.convs[space];
			if(!vals) {
				var fspace = this.space,
					from = this.convs[fspace];
				vals = convert[fspace][space](from);
				
				this.convs[space] = vals;
			}
			return vals;
		};
		
		["rgb", "hsl", "hsv", "cmyk", "keyword"].forEach(function(space) {
			Converter.prototype[space] = function(vals) {
				return this.routeSpace(space, arguments);
			}
		});
		
		module.exports = convert;
		
		/***/
	}),
	
	/***/ "./node_modules/color-name/index.js":
	/*!******************************************!*\
  !*** ./node_modules/color-name/index.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		module.exports = {
			"aliceblue": [240, 248, 255],
			"antiquewhite": [250, 235, 215],
			"aqua": [0, 255, 255],
			"aquamarine": [127, 255, 212],
			"azure": [240, 255, 255],
			"beige": [245, 245, 220],
			"bisque": [255, 228, 196],
			"black": [0, 0, 0],
			"blanchedalmond": [255, 235, 205],
			"blue": [0, 0, 255],
			"blueviolet": [138, 43, 226],
			"brown": [165, 42, 42],
			"burlywood": [222, 184, 135],
			"cadetblue": [95, 158, 160],
			"chartreuse": [127, 255, 0],
			"chocolate": [210, 105, 30],
			"coral": [255, 127, 80],
			"cornflowerblue": [100, 149, 237],
			"cornsilk": [255, 248, 220],
			"crimson": [220, 20, 60],
			"cyan": [0, 255, 255],
			"darkblue": [0, 0, 139],
			"darkcyan": [0, 139, 139],
			"darkgoldenrod": [184, 134, 11],
			"darkgray": [169, 169, 169],
			"darkgreen": [0, 100, 0],
			"darkgrey": [169, 169, 169],
			"darkkhaki": [189, 183, 107],
			"darkmagenta": [139, 0, 139],
			"darkolivegreen": [85, 107, 47],
			"darkorange": [255, 140, 0],
			"darkorchid": [153, 50, 204],
			"darkred": [139, 0, 0],
			"darksalmon": [233, 150, 122],
			"darkseagreen": [143, 188, 143],
			"darkslateblue": [72, 61, 139],
			"darkslategray": [47, 79, 79],
			"darkslategrey": [47, 79, 79],
			"darkturquoise": [0, 206, 209],
			"darkviolet": [148, 0, 211],
			"deeppink": [255, 20, 147],
			"deepskyblue": [0, 191, 255],
			"dimgray": [105, 105, 105],
			"dimgrey": [105, 105, 105],
			"dodgerblue": [30, 144, 255],
			"firebrick": [178, 34, 34],
			"floralwhite": [255, 250, 240],
			"forestgreen": [34, 139, 34],
			"fuchsia": [255, 0, 255],
			"gainsboro": [220, 220, 220],
			"ghostwhite": [248, 248, 255],
			"gold": [255, 215, 0],
			"goldenrod": [218, 165, 32],
			"gray": [128, 128, 128],
			"green": [0, 128, 0],
			"greenyellow": [173, 255, 47],
			"grey": [128, 128, 128],
			"honeydew": [240, 255, 240],
			"hotpink": [255, 105, 180],
			"indianred": [205, 92, 92],
			"indigo": [75, 0, 130],
			"ivory": [255, 255, 240],
			"khaki": [240, 230, 140],
			"lavender": [230, 230, 250],
			"lavenderblush": [255, 240, 245],
			"lawngreen": [124, 252, 0],
			"lemonchiffon": [255, 250, 205],
			"lightblue": [173, 216, 230],
			"lightcoral": [240, 128, 128],
			"lightcyan": [224, 255, 255],
			"lightgoldenrodyellow": [250, 250, 210],
			"lightgray": [211, 211, 211],
			"lightgreen": [144, 238, 144],
			"lightgrey": [211, 211, 211],
			"lightpink": [255, 182, 193],
			"lightsalmon": [255, 160, 122],
			"lightseagreen": [32, 178, 170],
			"lightskyblue": [135, 206, 250],
			"lightslategray": [119, 136, 153],
			"lightslategrey": [119, 136, 153],
			"lightsteelblue": [176, 196, 222],
			"lightyellow": [255, 255, 224],
			"lime": [0, 255, 0],
			"limegreen": [50, 205, 50],
			"linen": [250, 240, 230],
			"magenta": [255, 0, 255],
			"maroon": [128, 0, 0],
			"mediumaquamarine": [102, 205, 170],
			"mediumblue": [0, 0, 205],
			"mediumorchid": [186, 85, 211],
			"mediumpurple": [147, 112, 219],
			"mediumseagreen": [60, 179, 113],
			"mediumslateblue": [123, 104, 238],
			"mediumspringgreen": [0, 250, 154],
			"mediumturquoise": [72, 209, 204],
			"mediumvioletred": [199, 21, 133],
			"midnightblue": [25, 25, 112],
			"mintcream": [245, 255, 250],
			"mistyrose": [255, 228, 225],
			"moccasin": [255, 228, 181],
			"navajowhite": [255, 222, 173],
			"navy": [0, 0, 128],
			"oldlace": [253, 245, 230],
			"olive": [128, 128, 0],
			"olivedrab": [107, 142, 35],
			"orange": [255, 165, 0],
			"orangered": [255, 69, 0],
			"orchid": [218, 112, 214],
			"palegoldenrod": [238, 232, 170],
			"palegreen": [152, 251, 152],
			"paleturquoise": [175, 238, 238],
			"palevioletred": [219, 112, 147],
			"papayawhip": [255, 239, 213],
			"peachpuff": [255, 218, 185],
			"peru": [205, 133, 63],
			"pink": [255, 192, 203],
			"plum": [221, 160, 221],
			"powderblue": [176, 224, 230],
			"purple": [128, 0, 128],
			"rebeccapurple": [102, 51, 153],
			"red": [255, 0, 0],
			"rosybrown": [188, 143, 143],
			"royalblue": [65, 105, 225],
			"saddlebrown": [139, 69, 19],
			"salmon": [250, 128, 114],
			"sandybrown": [244, 164, 96],
			"seagreen": [46, 139, 87],
			"seashell": [255, 245, 238],
			"sienna": [160, 82, 45],
			"silver": [192, 192, 192],
			"skyblue": [135, 206, 235],
			"slateblue": [106, 90, 205],
			"slategray": [112, 128, 144],
			"slategrey": [112, 128, 144],
			"snow": [255, 250, 250],
			"springgreen": [0, 255, 127],
			"steelblue": [70, 130, 180],
			"tan": [210, 180, 140],
			"teal": [0, 128, 128],
			"thistle": [216, 191, 216],
			"tomato": [255, 99, 71],
			"turquoise": [64, 224, 208],
			"violet": [238, 130, 238],
			"wheat": [245, 222, 179],
			"white": [255, 255, 255],
			"whitesmoke": [245, 245, 245],
			"yellow": [255, 255, 0],
			"yellowgreen": [154, 205, 50]
		};
		
		
		/***/
	}),
	
	/***/ "./node_modules/datatables.net/js/jquery.dataTables.js":
	/*!*************************************************************!*\
  !*** ./node_modules/datatables.net/js/jquery.dataTables.js ***!
  \*************************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! DataTables 1.10.19
 * 2008-2018 SpryMedia Ltd - datatables.net/license
 */
		
		/**
		 * @summary     DataTables
		 * @description Paginate, search and order HTML tables
		 * @version     1.10.19
		 * @file        jquery.dataTables.js
		 * @author      SpryMedia Ltd
		 * @contact     www.datatables.net
		 * @copyright   Copyright 2008-2018 SpryMedia Ltd.
		 *
		 * This source file is free software, available under the following license:
		 *   MIT license - http://datatables.net/license
		 *
		 * This source file is distributed in the hope that it will be useful, but
		 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
		 * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.
		 *
		 * For details please refer to: http://www.datatables.net
		 */
		
		/*jslint evil: true, undef: true, browser: true */
		/*globals $,require,jQuery,define,_selector_run,_selector_opts,_selector_first,_selector_row_indexes,_ext,_Api,_api_register,_api_registerPlural,_re_new_lines,_re_html,_re_formatted_numeric,_re_escape_regex,_empty,_intVal,_numToDecimal,_isNumber,_isHtml,_htmlNumeric,_pluck,_pluck_order,_range,_stripHtml,_unique,_fnBuildAjax,_fnAjaxUpdate,_fnAjaxParameters,_fnAjaxUpdateDraw,_fnAjaxDataSrc,_fnAddColumn,_fnColumnOptions,_fnAdjustColumnSizing,_fnVisibleToColumnIndex,_fnColumnIndexToVisible,_fnVisbleColumns,_fnGetColumns,_fnColumnTypes,_fnApplyColumnDefs,_fnHungarianMap,_fnCamelToHungarian,_fnLanguageCompat,_fnBrowserDetect,_fnAddData,_fnAddTr,_fnNodeToDataIndex,_fnNodeToColumnIndex,_fnGetCellData,_fnSetCellData,_fnSplitObjNotation,_fnGetObjectDataFn,_fnSetObjectDataFn,_fnGetDataMaster,_fnClearTable,_fnDeleteIndex,_fnInvalidate,_fnGetRowElements,_fnCreateTr,_fnBuildHead,_fnDrawHead,_fnDraw,_fnReDraw,_fnAddOptionsHtml,_fnDetectHeader,_fnGetUniqueThs,_fnFeatureHtmlFilter,_fnFilterComplete,_fnFilterCustom,_fnFilterColumn,_fnFilter,_fnFilterCreateSearch,_fnEscapeRegex,_fnFilterData,_fnFeatureHtmlInfo,_fnUpdateInfo,_fnInfoMacros,_fnInitialise,_fnInitComplete,_fnLengthChange,_fnFeatureHtmlLength,_fnFeatureHtmlPaginate,_fnPageChange,_fnFeatureHtmlProcessing,_fnProcessingDisplay,_fnFeatureHtmlTable,_fnScrollDraw,_fnApplyToChildren,_fnCalculateColumnWidths,_fnThrottle,_fnConvertToWidth,_fnGetWidestNode,_fnGetMaxLenString,_fnStringToCss,_fnSortFlatten,_fnSort,_fnSortAria,_fnSortListener,_fnSortAttachListener,_fnSortingClasses,_fnSortData,_fnSaveState,_fnLoadState,_fnSettingsFromNode,_fnLog,_fnMap,_fnBindAction,_fnCallbackReg,_fnCallbackFire,_fnLengthOverflow,_fnRenderer,_fnDataSource,_fnRowAttributes*/
		
		(function(factory) {
			"use strict";
			
			if(true) {
				// AMD
				!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function($) {
					return factory($, window, document);
				}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
			} else {
			}
		}
		(function($, window, document, undefined) {
			"use strict";
			
			/**
			 * DataTables is a plug-in for the jQuery Javascript library. It is a highly
			 * flexible tool, based upon the foundations of progressive enhancement,
			 * which will add advanced interaction controls to any HTML table. For a
			 * full list of features please refer to
			 * [DataTables.net](href="http://datatables.net).
			 *
			 * Note that the `DataTable` object is not a global variable but is aliased
			 * to `jQuery.fn.DataTable` and `jQuery.fn.dataTable` through which it may
			 * be  accessed.
			 *
			 *  @class
			 *  @param {object} [init={}] Configuration object for DataTables. Options
			 *    are defined by {@link DataTable.defaults}
			 *  @requires jQuery 1.7+
			 *
			 *  @example
			 *    // Basic initialisation
			 *    $(document).ready( function {
			 *      $('#example').dataTable();
			 *    } );
			 *
			 *  @example
			 *    // Initialisation with configuration options - in this case, disable
			 *    // pagination and sorting.
			 *    $(document).ready( function {
			 *      $('#example').dataTable( {
			 *        "paginate": false,
			 *        "sort": false
			 *      } );
			 *    } );
			 */
			var DataTable = function(options) {
				/**
				 * Perform a jQuery selector action on the table's TR elements (from the tbody) and
				 * return the resulting jQuery object.
				 *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
				 *  @param {object} [oOpts] Optional parameters for modifying the rows to be included
				 *  @param {string} [oOpts.filter=none] Select TR elements that meet the current filter
				 *    criterion ("applied") or all TR elements (i.e. no filter).
				 *  @param {string} [oOpts.order=current] Order of the TR elements in the processed array.
				 *    Can be either 'current', whereby the current sorting of the table is used, or
				 *    'original' whereby the original order the data was read into the table is used.
				 *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
				 *    ("current") or not ("all"). If 'current' is given, then order is assumed to be
				 *    'current' and filter is 'applied', regardless of what they might be given as.
				 *  @returns {object} jQuery object, filtered by the given selector.
				 *  @dtopt API
				 *  @deprecated Since v1.10
				 *
				 *  @example
				 *    $(document).ready(function() {
				 *      var oTable = $('#example').dataTable();
				 *
				 *      // Highlight every second row
				 *      oTable.$('tr:odd').css('backgroundColor', 'blue');
				 *    } );
				 *
				 *  @example
				 *    $(document).ready(function() {
				 *      var oTable = $('#example').dataTable();
				 *
				 *      // Filter to rows with 'Webkit' in them, add a background colour and then
				 *      // remove the filter, thus highlighting the 'Webkit' rows only.
				 *      oTable.fnFilter('Webkit');
				 *      oTable.$('tr', {"search": "applied"}).css('backgroundColor', 'blue');
				 *      oTable.fnFilter('');
				 *    } );
				 */
				this.$ = function(sSelector, oOpts) {
					return this.api(true).$(sSelector, oOpts);
				};
				
				
				/**
				 * Almost identical to $ in operation, but in this case returns the data for the matched
				 * rows - as such, the jQuery selector used should match TR row nodes or TD/TH cell nodes
				 * rather than any descendants, so the data can be obtained for the row/cell. If matching
				 * rows are found, the data returned is the original data array/object that was used to
				 * create the row (or a generated array if from a DOM source).
				 *
				 * This method is often useful in-combination with $ where both functions are given the
				 * same parameters and the array indexes will match identically.
				 *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
				 *  @param {object} [oOpts] Optional parameters for modifying the rows to be included
				 *  @param {string} [oOpts.filter=none] Select elements that meet the current filter
				 *    criterion ("applied") or all elements (i.e. no filter).
				 *  @param {string} [oOpts.order=current] Order of the data in the processed array.
				 *    Can be either 'current', whereby the current sorting of the table is used, or
				 *    'original' whereby the original order the data was read into the table is used.
				 *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
				 *    ("current") or not ("all"). If 'current' is given, then order is assumed to be
				 *    'current' and filter is 'applied', regardless of what they might be given as.
				 *  @returns {array} Data for the matched elements. If any elements, as a result of the
				 *    selector, were not TR, TD or TH elements in the DataTable, they will have a null
				 *    entry in the array.
				 *  @dtopt API
				 *  @deprecated Since v1.10
				 *
				 *  @example
				 *    $(document).ready(function() {
				 *      var oTable = $('#example').dataTable();
				 *
				 *      // Get the data from the first row in the table
				 *      var data = oTable._('tr:first');
				 *
				 *      // Do something useful with the data
				 *      alert( "First cell is: "+data[0] );
				 *    } );
				 *
				 *  @example
				 *    $(document).ready(function() {
				 *      var oTable = $('#example').dataTable();
				 *
				 *      // Filter to 'Webkit' and get all data for
				 *      oTable.fnFilter('Webkit');
				 *      var data = oTable._('tr', {"search": "applied"});
				 *
				 *      // Do something with the data
				 *      alert( data.length+" rows matched the search" );
				 *    } );
				 */
				this._ = function(sSelector, oOpts) {
					return this.api(true).rows(sSelector, oOpts).data();
				};
				
				
				/**
				 * Create a DataTables Api instance, with the currently selected tables for
				 * the Api's context.
				 * @param {boolean} [traditional=false] Set the API instance's context to be
				 *   only the table referred to by the `DataTable.ext.iApiIndex` option, as was
				 *   used in the API presented by DataTables 1.9- (i.e. the traditional mode),
				 *   or if all tables captured in the jQuery object should be used.
				 * @return {DataTables.Api}
				 */
				this.api = function(traditional) {
					return traditional ?
						new _Api(
							_fnSettingsFromNode(this[_ext.iApiIndex])
						) :
						new _Api(this);
				};
				
				
				/**
				 * Add a single new row or multiple rows of data to the table. Please note
				 * that this is suitable for client-side processing only - if you are using
				 * server-side processing (i.e. "bServerSide": true), then to add data, you
				 * must add it to the data source, i.e. the server-side, through an Ajax call.
				 *  @param {array|object} data The data to be added to the table. This can be:
				 *    <ul>
				 *      <li>1D array of data - add a single row with the data provided</li>
				 *      <li>2D array of arrays - add multiple rows in a single call</li>
				 *      <li>object - data object when using <i>mData</i></li>
				 *      <li>array of objects - multiple data objects when using <i>mData</i></li>
				 *    </ul>
				 *  @param {bool} [redraw=true] redraw the table or not
				 *  @returns {array} An array of integers, representing the list of indexes in
				 *    <i>aoData</i> ({@link DataTable.models.oSettings}) that have been added to
				 *    the table.
				 *  @dtopt API
				 *  @deprecated Since v1.10
				 *
				 *  @example
				 *    // Global var for counter
				 *    var giCount = 2;
				 *
				 *    $(document).ready(function() {
				 *      $('#example').dataTable();
				 *    } );
				 *
				 *    function fnClickAddRow() {
				 *      $('#example').dataTable().fnAddData( [
				 *        giCount+".1",
				 *        giCount+".2",
				 *        giCount+".3",
				 *        giCount+".4" ]
				 *      );
				 *
				 *      giCount++;
				 *    }
				 */
				this.fnAddData = function(data, redraw) {
					var api = this.api(true);
					
					/* Check if we want to add multiple rows or not */
					var rows = $.isArray(data) && ($.isArray(data[0]) || $.isPlainObject(data[0])) ?
						api.rows.add(data) :
						api.row.add(data);
					
					if(redraw === undefined || redraw) {
						api.draw();
					}
					
					return rows.flatten().toArray();
				};
				
				
				/**
				 * This function will make DataTables recalculate the column sizes, based on the data
				 * contained in the table and the sizes applied to the columns (in the DOM, CSS or
				 * through the sWidth parameter). This can be useful when the width of the table's
				 * parent element changes (for example a window resize).
				 *  @param {boolean} [bRedraw=true] Redraw the table or not, you will typically want to
				 *  @dtopt API
				 *  @deprecated Since v1.10
				 *
				 *  @example
				 *    $(document).ready(function() {
				 *      var oTable = $('#example').dataTable( {
				 *        "sScrollY": "200px",
				 *        "bPaginate": false
				 *      } );
				 *
				 *      $(window).on('resize', function () {
				 *        oTable.fnAdjustColumnSizing();
				 *      } );
				 *    } );
				 */
				this.fnAdjustColumnSizing = function(bRedraw) {
					var api = this.api(true).columns.adjust();
					var settings = api.settings()[0];
					var scroll = settings.oScroll;
					
					if(bRedraw === undefined || bRedraw) {
						api.draw(false);
					} else if(scroll.sX !== "" || scroll.sY !== "") {
						/* If not redrawing, but scrolling, we want to apply the new column sizes anyway */
						_fnScrollDraw(settings);
					}
				};
				
				
				/**
				 * Quickly and simply clear a table
				 *  @param {bool} [bRedraw=true] redraw the table or not
				 *  @dtopt API
				 *  @deprecated Since v1.10
				 *
				 *  @example
				 *    $(document).ready(function() {
				 *      var oTable = $('#example').dataTable();
				 *
				 *      // Immediately 'nuke' the current rows (perhaps waiting for an Ajax callback...)
				 *      oTable.fnClearTable();
				 *    } );
				 */
				this.fnClearTable = function(bRedraw) {
					var api = this.api(true).clear();
					
					if(bRedraw === undefined || bRedraw) {
						api.draw();
					}
				};
				
				
				/**
				 * The exact opposite of 'opening' a row, this function will close any rows which
				 * are currently 'open'.
				 *  @param {node} nTr the table row to 'close'
				 *  @returns {int} 0 on success, or 1 if failed (can't find the row)
				 *  @dtopt API
				 *  @deprecated Since v1.10
				 *
				 *  @example
				 *    $(document).ready(function() {
				 *      var oTable;
				 *
				 *      // 'open' an information row when a row is clicked on
				 *      $('#example tbody tr').click( function () {
				 *        if ( oTable.fnIsOpen(this) ) {
				 *          oTable.fnClose( this );
				 *        } else {
				 *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
				 *        }
				 *      } );
				 *
				 *      oTable = $('#example').dataTable();
				 *    } );
				 */
				this.fnClose = function(nTr) {
					this.api(true).row(nTr).child.hide();
				};
				
				
				/**
				 * Remove a row for the table
				 *  @param {mixed} target The index of the row from aoData to be deleted, or
				 *    the TR element you want to delete
				 *  @param {function|null} [callBack] Callback function
				 *  @param {bool} [redraw=true] Redraw the table or not
				 *  @returns {array} The row that was deleted
				 *  @dtopt API
				 *  @deprecated Since v1.10
				 *
				 *  @example
				 *    $(document).ready(function() {
				 *      var oTable = $('#example').dataTable();
				 *
				 *      // Immediately remove the first row
				 *      oTable.fnDeleteRow( 0 );
				 *    } );
				 */
				this.fnDeleteRow = function(target, callback, redraw) {
					var api = this.api(true);
					var rows = api.rows(target);
					var settings = rows.settings()[0];
					var data = settings.aoData[rows[0][0]];
					
					rows.remove();
					
					if(callback) {
						callback.call(this, settings, data);
					}
					
					if(redraw === undefined || redraw) {
						api.draw();
					}
					
					return data;
				};
				
				
				/**
				 * Restore the table to it's original state in the DOM by removing all of DataTables
				 * enhancements, alterations to the DOM structure of the table and event listeners.
				 *  @param {boolean} [remove=false] Completely remove the table from the DOM
				 *  @dtopt API
				 *  @deprecated Since v1.10
				 *
				 *  @example
				 *    $(document).ready(function() {
				 *      // This example is fairly pointless in reality, but shows how fnDestroy can be used
				 *      var oTable = $('#example').dataTable();
				 *      oTable.fnDestroy();
				 *    } );
				 */
				this.fnDestroy = function(remove) {
					this.api(true).destroy(remove);
				};
				
				
				/**
				 * Redraw the table
				 *  @param {bool} [complete=true] Re-filter and resort (if enabled) the table before the draw.
				 *  @dtopt API
				 *  @deprecated Since v1.10
				 *
				 *  @example
				 *    $(document).ready(function() {
				 *      var oTable = $('#example').dataTable();
				 *
				 *      // Re-draw the table - you wouldn't want to do it here, but it's an example :-)
				 *      oTable.fnDraw();
				 *    } );
				 */
				this.fnDraw = function(complete) {
					// Note that this isn't an exact match to the old call to _fnDraw - it takes
					// into account the new data, but can hold position.
					this.api(true).draw(complete);
				};
				
				
				/**
				 * Filter the input based on data
				 *  @param {string} sInput String to filter the table on
				 *  @param {int|null} [iColumn] Column to limit filtering to
				 *  @param {bool} [bRegex=false] Treat as regular expression or not
				 *  @param {bool} [bSmart=true] Perform smart filtering or not
				 *  @param {bool} [bShowGlobal=true] Show the input global filter in it's input box(es)
				 *  @param {bool} [bCaseInsensitive=true] Do case-insensitive matching (true) or not (false)
				 *  @dtopt API
				 *  @deprecated Since v1.10
				 *
				 *  @example
				 *    $(document).ready(function() {
				 *      var oTable = $('#example').dataTable();
				 *
				 *      // Sometime later - filter...
				 *      oTable.fnFilter( 'test string' );
				 *    } );
				 */
				this.fnFilter = function(sInput, iColumn, bRegex, bSmart, bShowGlobal, bCaseInsensitive) {
					var api = this.api(true);
					
					if(iColumn === null || iColumn === undefined) {
						api.search(sInput, bRegex, bSmart, bCaseInsensitive);
					} else {
						api.column(iColumn).search(sInput, bRegex, bSmart, bCaseInsensitive);
					}
					
					api.draw();
				};
				
				
				/**
				 * Get the data for the whole table, an individual row or an individual cell based on the
				 * provided parameters.
				 *  @param {int|node} [src] A TR row node, TD/TH cell node or an integer. If given as
				 *    a TR node then the data source for the whole row will be returned. If given as a
				 *    TD/TH cell node then iCol will be automatically calculated and the data for the
				 *    cell returned. If given as an integer, then this is treated as the aoData internal
				 *    data index for the row (see fnGetPosition) and the data for that row used.
				 *  @param {int} [col] Optional column index that you want the data of.
				 *  @returns {array|object|string} If mRow is undefined, then the data for all rows is
				 *    returned. If mRow is defined, just data for that row, and is iCol is
				 *    defined, only data for the designated cell is returned.
				 *  @dtopt API
				 *  @deprecated Since v1.10
				 *
				 *  @example
				 *    // Row data
				 *    $(document).ready(function() {
				 *      oTable = $('#example').dataTable();
				 *
				 *      oTable.$('tr').click( function () {
				 *        var data = oTable.fnGetData( this );
				 *        // ... do something with the array / object of data for the row
				 *      } );
				 *    } );
				 *
				 *  @example
				 *    // Individual cell data
				 *    $(document).ready(function() {
				 *      oTable = $('#example').dataTable();
				 *
				 *      oTable.$('td').click( function () {
				 *        var sData = oTable.fnGetData( this );
				 *        alert( 'The cell clicked on had the value of '+sData );
				 *      } );
				 *    } );
				 */
				this.fnGetData = function(src, col) {
					var api = this.api(true);
					
					if(src !== undefined) {
						var type = src.nodeName ? src.nodeName.toLowerCase() : '';
						
						return col !== undefined || type == 'td' || type == 'th' ?
							api.cell(src, col).data() :
							api.row(src).data() || null;
					}
					
					return api.data().toArray();
				};
				
				
				/**
				 * Get an array of the TR nodes that are used in the table's body. Note that you will
				 * typically want to use the '$' API method in preference to this as it is more
				 * flexible.
				 *  @param {int} [iRow] Optional row index for the TR element you want
				 *  @returns {array|node} If iRow is undefined, returns an array of all TR elements
				 *    in the table's body, or iRow is defined, just the TR element requested.
				 *  @dtopt API
				 *  @deprecated Since v1.10
				 *
				 *  @example
				 *    $(document).ready(function() {
				 *      var oTable = $('#example').dataTable();
				 *
				 *      // Get the nodes from the table
				 *      var nNodes = oTable.fnGetNodes( );
				 *    } );
				 */
				this.fnGetNodes = function(iRow) {
					var api = this.api(true);
					
					return iRow !== undefined ?
						api.row(iRow).node() :
						api.rows().nodes().flatten().toArray();
				};
				
				
				/**
				 * Get the array indexes of a particular cell from it's DOM element
				 * and column index including hidden columns
				 *  @param {node} node this can either be a TR, TD or TH in the table's body
				 *  @returns {int} If nNode is given as a TR, then a single index is returned, or
				 *    if given as a cell, an array of [row index, column index (visible),
				 *    column index (all)] is given.
				 *  @dtopt API
				 *  @deprecated Since v1.10
				 *
				 *  @example
				 *    $(document).ready(function() {
				 *      $('#example tbody td').click( function () {
				 *        // Get the position of the current data from the node
				 *        var aPos = oTable.fnGetPosition( this );
				 *
				 *        // Get the data array for this row
				 *        var aData = oTable.fnGetData( aPos[0] );
				 *
				 *        // Update the data array and return the value
				 *        aData[ aPos[1] ] = 'clicked';
				 *        this.innerHTML = 'clicked';
				 *      } );
				 *
				 *      // Init DataTables
				 *      oTable = $('#example').dataTable();
				 *    } );
				 */
				this.fnGetPosition = function(node) {
					var api = this.api(true);
					var nodeName = node.nodeName.toUpperCase();
					
					if(nodeName == 'TR') {
						return api.row(node).index();
					} else if(nodeName == 'TD' || nodeName == 'TH') {
						var cell = api.cell(node).index();
						
						return [
							cell.row,
							cell.columnVisible,
							cell.column
						];
					}
					return null;
				};
				
				
				/**
				 * Check to see if a row is 'open' or not.
				 *  @param {node} nTr the table row to check
				 *  @returns {boolean} true if the row is currently open, false otherwise
				 *  @dtopt API
				 *  @deprecated Since v1.10
				 *
				 *  @example
				 *    $(document).ready(function() {
				 *      var oTable;
				 *
				 *      // 'open' an information row when a row is clicked on
				 *      $('#example tbody tr').click( function () {
				 *        if ( oTable.fnIsOpen(this) ) {
				 *          oTable.fnClose( this );
				 *        } else {
				 *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
				 *        }
				 *      } );
				 *
				 *      oTable = $('#example').dataTable();
				 *    } );
				 */
				this.fnIsOpen = function(nTr) {
					return this.api(true).row(nTr).child.isShown();
				};
				
				
				/**
				 * This function will place a new row directly after a row which is currently
				 * on display on the page, with the HTML contents that is passed into the
				 * function. This can be used, for example, to ask for confirmation that a
				 * particular record should be deleted.
				 *  @param {node} nTr The table row to 'open'
				 *  @param {string|node|jQuery} mHtml The HTML to put into the row
				 *  @param {string} sClass Class to give the new TD cell
				 *  @returns {node} The row opened. Note that if the table row passed in as the
				 *    first parameter, is not found in the table, this method will silently
				 *    return.
				 *  @dtopt API
				 *  @deprecated Since v1.10
				 *
				 *  @example
				 *    $(document).ready(function() {
				 *      var oTable;
				 *
				 *      // 'open' an information row when a row is clicked on
				 *      $('#example tbody tr').click( function () {
				 *        if ( oTable.fnIsOpen(this) ) {
				 *          oTable.fnClose( this );
				 *        } else {
				 *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
				 *        }
				 *      } );
				 *
				 *      oTable = $('#example').dataTable();
				 *    } );
				 */
				this.fnOpen = function(nTr, mHtml, sClass) {
					return this.api(true)
						.row(nTr)
						.child(mHtml, sClass)
						.show()
						.child()[0];
				};
				
				
				/**
				 * Change the pagination - provides the internal logic for pagination in a simple API
				 * function. With this function you can have a DataTables table go to the next,
				 * previous, first or last pages.
				 *  @param {string|int} mAction Paging action to take: "first", "previous", "next" or "last"
				 *    or page number to jump to (integer), note that page 0 is the first page.
				 *  @param {bool} [bRedraw=true] Redraw the table or not
				 *  @dtopt API
				 *  @deprecated Since v1.10
				 *
				 *  @example
				 *    $(document).ready(function() {
				 *      var oTable = $('#example').dataTable();
				 *      oTable.fnPageChange( 'next' );
				 *    } );
				 */
				this.fnPageChange = function(mAction, bRedraw) {
					var api = this.api(true).page(mAction);
					
					if(bRedraw === undefined || bRedraw) {
						api.draw(false);
					}
				};
				
				
				/**
				 * Show a particular column
				 *  @param {int} iCol The column whose display should be changed
				 *  @param {bool} bShow Show (true) or hide (false) the column
				 *  @param {bool} [bRedraw=true] Redraw the table or not
				 *  @dtopt API
				 *  @deprecated Since v1.10
				 *
				 *  @example
				 *    $(document).ready(function() {
				 *      var oTable = $('#example').dataTable();
				 *
				 *      // Hide the second column after initialisation
				 *      oTable.fnSetColumnVis( 1, false );
				 *    } );
				 */
				this.fnSetColumnVis = function(iCol, bShow, bRedraw) {
					var api = this.api(true).column(iCol).visible(bShow);
					
					if(bRedraw === undefined || bRedraw) {
						api.columns.adjust().draw();
					}
				};
				
				
				/**
				 * Get the settings for a particular table for external manipulation
				 *  @returns {object} DataTables settings object. See
				 *    {@link DataTable.models.oSettings}
				 *  @dtopt API
				 *  @deprecated Since v1.10
				 *
				 *  @example
				 *    $(document).ready(function() {
				 *      var oTable = $('#example').dataTable();
				 *      var oSettings = oTable.fnSettings();
				 *
				 *      // Show an example parameter from the settings
				 *      alert( oSettings._iDisplayStart );
				 *    } );
				 */
				this.fnSettings = function() {
					return _fnSettingsFromNode(this[_ext.iApiIndex]);
				};
				
				
				/**
				 * Sort the table by a particular column
				 *  @param {int} iCol the data index to sort on. Note that this will not match the
				 *    'display index' if you have hidden data entries
				 *  @dtopt API
				 *  @deprecated Since v1.10
				 *
				 *  @example
				 *    $(document).ready(function() {
				 *      var oTable = $('#example').dataTable();
				 *
				 *      // Sort immediately with columns 0 and 1
				 *      oTable.fnSort( [ [0,'asc'], [1,'asc'] ] );
				 *    } );
				 */
				this.fnSort = function(aaSort) {
					this.api(true).order(aaSort).draw();
				};
				
				
				/**
				 * Attach a sort listener to an element for a given column
				 *  @param {node} nNode the element to attach the sort listener to
				 *  @param {int} iColumn the column that a click on this node will sort on
				 *  @param {function} [fnCallback] callback function when sort is run
				 *  @dtopt API
				 *  @deprecated Since v1.10
				 *
				 *  @example
				 *    $(document).ready(function() {
				 *      var oTable = $('#example').dataTable();
				 *
				 *      // Sort on column 1, when 'sorter' is clicked on
				 *      oTable.fnSortListener( document.getElementById('sorter'), 1 );
				 *    } );
				 */
				this.fnSortListener = function(nNode, iColumn, fnCallback) {
					this.api(true).order.listener(nNode, iColumn, fnCallback);
				};
				
				
				/**
				 * Update a table cell or row - this method will accept either a single value to
				 * update the cell with, an array of values with one element for each column or
				 * an object in the same format as the original data source. The function is
				 * self-referencing in order to make the multi column updates easier.
				 *  @param {object|array|string} mData Data to update the cell/row with
				 *  @param {node|int} mRow TR element you want to update or the aoData index
				 *  @param {int} [iColumn] The column to update, give as null or undefined to
				 *    update a whole row.
				 *  @param {bool} [bRedraw=true] Redraw the table or not
				 *  @param {bool} [bAction=true] Perform pre-draw actions or not
				 *  @returns {int} 0 on success, 1 on error
				 *  @dtopt API
				 *  @deprecated Since v1.10
				 *
				 *  @example
				 *    $(document).ready(function() {
				 *      var oTable = $('#example').dataTable();
				 *      oTable.fnUpdate( 'Example update', 0, 0 ); // Single cell
				 *      oTable.fnUpdate( ['a', 'b', 'c', 'd', 'e'], $('tbody tr')[0] ); // Row
				 *    } );
				 */
				this.fnUpdate = function(mData, mRow, iColumn, bRedraw, bAction) {
					var api = this.api(true);
					
					if(iColumn === undefined || iColumn === null) {
						api.row(mRow).data(mData);
					} else {
						api.cell(mRow, iColumn).data(mData);
					}
					
					if(bAction === undefined || bAction) {
						api.columns.adjust();
					}
					
					if(bRedraw === undefined || bRedraw) {
						api.draw();
					}
					return 0;
				};
				
				
				/**
				 * Provide a common method for plug-ins to check the version of DataTables being used, in order
				 * to ensure compatibility.
				 *  @param {string} sVersion Version string to check for, in the format "X.Y.Z". Note that the
				 *    formats "X" and "X.Y" are also acceptable.
				 *  @returns {boolean} true if this version of DataTables is greater or equal to the required
				 *    version, or false if this version of DataTales is not suitable
				 *  @method
				 *  @dtopt API
				 *  @deprecated Since v1.10
				 *
				 *  @example
				 *    $(document).ready(function() {
				 *      var oTable = $('#example').dataTable();
				 *      alert( oTable.fnVersionCheck( '1.9.0' ) );
				 *    } );
				 */
				this.fnVersionCheck = _ext.fnVersionCheck;
				
				
				var _that = this;
				var emptyInit = options === undefined;
				var len = this.length;
				
				if(emptyInit) {
					options = {};
				}
				
				this.oApi = this.internal = _ext.internal;
				
				// Extend with old style plug-in API methods
				for(var fn in DataTable.ext.internal) {
					if(fn) {
						this[fn] = _fnExternApiFunc(fn);
					}
				}
				
				this.each(function() {
					// For each initialisation we want to give it a clean initialisation
					// object that can be bashed around
					var o = {};
					var oInit = len > 1 ? // optimisation for single table case
						_fnExtend(o, options, true) :
						options;
					
					/*global oInit,_that,emptyInit*/
					var i = 0, iLen, j, jLen, k, kLen;
					var sId = this.getAttribute('id');
					var bInitHandedOff = false;
					var defaults = DataTable.defaults;
					var $this = $(this);
					
					
					/* Sanity check */
					if(this.nodeName.toLowerCase() != 'table') {
						_fnLog(null, 0, 'Non-table node initialisation (' + this.nodeName + ')', 2);
						return;
					}
					
					/* Backwards compatibility for the defaults */
					_fnCompatOpts(defaults);
					_fnCompatCols(defaults.column);
					
					/* Convert the camel-case defaults to Hungarian */
					_fnCamelToHungarian(defaults, defaults, true);
					_fnCamelToHungarian(defaults.column, defaults.column, true);
					
					/* Setting up the initialisation object */
					_fnCamelToHungarian(defaults, $.extend(oInit, $this.data()));
					
					
					/* Check to see if we are re-initialising a table */
					var allSettings = DataTable.settings;
					for(i = 0, iLen = allSettings.length; i < iLen; i++) {
						var s = allSettings[i];
						
						/* Base check on table node */
						if(
							s.nTable == this ||
							(s.nTHead && s.nTHead.parentNode == this) ||
							(s.nTFoot && s.nTFoot.parentNode == this)
						) {
							var bRetrieve = oInit.bRetrieve !== undefined ? oInit.bRetrieve : defaults.bRetrieve;
							var bDestroy = oInit.bDestroy !== undefined ? oInit.bDestroy : defaults.bDestroy;
							
							if(emptyInit || bRetrieve) {
								return s.oInstance;
							} else if(bDestroy) {
								s.oInstance.fnDestroy();
								break;
							} else {
								_fnLog(s, 0, 'Cannot reinitialise DataTable', 3);
								return;
							}
						}
						
						/* If the element we are initialising has the same ID as a table which was previously
				 * initialised, but the table nodes don't match (from before) then we destroy the old
				 * instance by simply deleting it. This is under the assumption that the table has been
				 * destroyed by other methods. Anyone using non-id selectors will need to do this manually
				 */
						if(s.sTableId == this.id) {
							allSettings.splice(i, 1);
							break;
						}
					}
					
					/* Ensure the table has an ID - required for accessibility */
					if(sId === null || sId === "") {
						sId = "DataTables_Table_" + (DataTable.ext._unique++);
						this.id = sId;
					}
					
					/* Create the settings object for this table and set some of the default parameters */
					var oSettings = $.extend(true, {}, DataTable.models.oSettings, {
						"sDestroyWidth": $this[0].style.width,
						"sInstance": sId,
						"sTableId": sId
					});
					oSettings.nTable = this;
					oSettings.oApi = _that.internal;
					oSettings.oInit = oInit;
					
					allSettings.push(oSettings);
					
					// Need to add the instance after the instance after the settings object has been added
					// to the settings array, so we can self reference the table instance if more than one
					oSettings.oInstance = (_that.length === 1) ? _that : $this.dataTable();
					
					// Backwards compatibility, before we apply all the defaults
					_fnCompatOpts(oInit);
					_fnLanguageCompat(oInit.oLanguage);
					
					// If the length menu is given, but the init display length is not, use the length menu
					if(oInit.aLengthMenu && !oInit.iDisplayLength) {
						oInit.iDisplayLength = $.isArray(oInit.aLengthMenu[0]) ?
							oInit.aLengthMenu[0][0] : oInit.aLengthMenu[0];
					}
					
					// Apply the defaults and init options to make a single init object will all
					// options defined from defaults and instance options.
					oInit = _fnExtend($.extend(true, {}, defaults), oInit);
					
					
					// Map the initialisation options onto the settings object
					_fnMap(oSettings.oFeatures, oInit, [
						"bPaginate",
						"bLengthChange",
						"bFilter",
						"bSort",
						"bSortMulti",
						"bInfo",
						"bProcessing",
						"bAutoWidth",
						"bSortClasses",
						"bServerSide",
						"bDeferRender"
					]);
					_fnMap(oSettings, oInit, [
						"asStripeClasses",
						"ajax",
						"fnServerData",
						"fnFormatNumber",
						"sServerMethod",
						"aaSorting",
						"aaSortingFixed",
						"aLengthMenu",
						"sPaginationType",
						"sAjaxSource",
						"sAjaxDataProp",
						"iStateDuration",
						"sDom",
						"bSortCellsTop",
						"iTabIndex",
						"fnStateLoadCallback",
						"fnStateSaveCallback",
						"renderer",
						"searchDelay",
						"rowId",
						["iCookieDuration", "iStateDuration"], // backwards compat
						["oSearch", "oPreviousSearch"],
						["aoSearchCols", "aoPreSearchCols"],
						["iDisplayLength", "_iDisplayLength"]
					]);
					_fnMap(oSettings.oScroll, oInit, [
						["sScrollX", "sX"],
						["sScrollXInner", "sXInner"],
						["sScrollY", "sY"],
						["bScrollCollapse", "bCollapse"]
					]);
					_fnMap(oSettings.oLanguage, oInit, "fnInfoCallback");
					
					/* Callback functions which are array driven */
					_fnCallbackReg(oSettings, 'aoDrawCallback', oInit.fnDrawCallback, 'user');
					_fnCallbackReg(oSettings, 'aoServerParams', oInit.fnServerParams, 'user');
					_fnCallbackReg(oSettings, 'aoStateSaveParams', oInit.fnStateSaveParams, 'user');
					_fnCallbackReg(oSettings, 'aoStateLoadParams', oInit.fnStateLoadParams, 'user');
					_fnCallbackReg(oSettings, 'aoStateLoaded', oInit.fnStateLoaded, 'user');
					_fnCallbackReg(oSettings, 'aoRowCallback', oInit.fnRowCallback, 'user');
					_fnCallbackReg(oSettings, 'aoRowCreatedCallback', oInit.fnCreatedRow, 'user');
					_fnCallbackReg(oSettings, 'aoHeaderCallback', oInit.fnHeaderCallback, 'user');
					_fnCallbackReg(oSettings, 'aoFooterCallback', oInit.fnFooterCallback, 'user');
					_fnCallbackReg(oSettings, 'aoInitComplete', oInit.fnInitComplete, 'user');
					_fnCallbackReg(oSettings, 'aoPreDrawCallback', oInit.fnPreDrawCallback, 'user');
					
					oSettings.rowIdFn = _fnGetObjectDataFn(oInit.rowId);
					
					/* Browser support detection */
					_fnBrowserDetect(oSettings);
					
					var oClasses = oSettings.oClasses;
					
					$.extend(oClasses, DataTable.ext.classes, oInit.oClasses);
					$this.addClass(oClasses.sTable);
					
					
					if(oSettings.iInitDisplayStart === undefined) {
						/* Display start point, taking into account the save saving */
						oSettings.iInitDisplayStart = oInit.iDisplayStart;
						oSettings._iDisplayStart = oInit.iDisplayStart;
					}
					
					if(oInit.iDeferLoading !== null) {
						oSettings.bDeferLoading = true;
						var tmp = $.isArray(oInit.iDeferLoading);
						oSettings._iRecordsDisplay = tmp ? oInit.iDeferLoading[0] : oInit.iDeferLoading;
						oSettings._iRecordsTotal = tmp ? oInit.iDeferLoading[1] : oInit.iDeferLoading;
					}
					
					/* Language definitions */
					var oLanguage = oSettings.oLanguage;
					$.extend(true, oLanguage, oInit.oLanguage);
					
					if(oLanguage.sUrl) {
						/* Get the language definitions from a file - because this Ajax call makes the language
				 * get async to the remainder of this function we use bInitHandedOff to indicate that
				 * _fnInitialise will be fired by the returned Ajax handler, rather than the constructor
				 */
						$.ajax({
							dataType: 'json',
							url: oLanguage.sUrl,
							success: function(json) {
								_fnLanguageCompat(json);
								_fnCamelToHungarian(defaults.oLanguage, json);
								$.extend(true, oLanguage, json);
								_fnInitialise(oSettings);
							},
							error: function() {
								// Error occurred loading language file, continue on as best we can
								_fnInitialise(oSettings);
							}
						});
						bInitHandedOff = true;
					}
					
					/*
			 * Stripes
			 */
					if(oInit.asStripeClasses === null) {
						oSettings.asStripeClasses = [
							oClasses.sStripeOdd,
							oClasses.sStripeEven
						];
					}
					
					/* Remove row stripe classes if they are already on the table row */
					var stripeClasses = oSettings.asStripeClasses;
					var rowOne = $this.children('tbody').find('tr').eq(0);
					if($.inArray(true, $.map(stripeClasses, function(el, i) {
						return rowOne.hasClass(el);
					})) !== -1) {
						$('tbody tr', this).removeClass(stripeClasses.join(' '));
						oSettings.asDestroyStripes = stripeClasses.slice();
					}
					
					/*
			 * Columns
			 * See if we should load columns automatically or use defined ones
			 */
					var anThs = [];
					var aoColumnsInit;
					var nThead = this.getElementsByTagName('thead');
					if(nThead.length !== 0) {
						_fnDetectHeader(oSettings.aoHeader, nThead[0]);
						anThs = _fnGetUniqueThs(oSettings);
					}
					
					/* If not given a column array, generate one with nulls */
					if(oInit.aoColumns === null) {
						aoColumnsInit = [];
						for(i = 0, iLen = anThs.length; i < iLen; i++) {
							aoColumnsInit.push(null);
						}
					} else {
						aoColumnsInit = oInit.aoColumns;
					}
					
					/* Add the columns */
					for(i = 0, iLen = aoColumnsInit.length; i < iLen; i++) {
						_fnAddColumn(oSettings, anThs ? anThs[i] : null);
					}
					
					/* Apply the column definitions */
					_fnApplyColumnDefs(oSettings, oInit.aoColumnDefs, aoColumnsInit, function(iCol, oDef) {
						_fnColumnOptions(oSettings, iCol, oDef);
					});
					
					/* HTML5 attribute detection - build an mData object automatically if the
			 * attributes are found
			 */
					if(rowOne.length) {
						var a = function(cell, name) {
							return cell.getAttribute('data-' + name) !== null ? name : null;
						};
						
						$(rowOne[0]).children('th, td').each(function(i, cell) {
							var col = oSettings.aoColumns[i];
							
							if(col.mData === i) {
								var sort = a(cell, 'sort') || a(cell, 'order');
								var filter = a(cell, 'filter') || a(cell, 'search');
								
								if(sort !== null || filter !== null) {
									col.mData = {
										_: i + '.display',
										sort: sort !== null ? i + '.@data-' + sort : undefined,
										type: sort !== null ? i + '.@data-' + sort : undefined,
										filter: filter !== null ? i + '.@data-' + filter : undefined
									};
									
									_fnColumnOptions(oSettings, i);
								}
							}
						});
					}
					
					var features = oSettings.oFeatures;
					var loadedInit = function() {
						/*
				 * Sorting
				 * @todo For modularisation (1.11) this needs to do into a sort start up handler
				 */
						
						// If aaSorting is not defined, then we use the first indicator in asSorting
						// in case that has been altered, so the default sort reflects that option
						if(oInit.aaSorting === undefined) {
							var sorting = oSettings.aaSorting;
							for(i = 0, iLen = sorting.length; i < iLen; i++) {
								sorting[i][1] = oSettings.aoColumns[i].asSorting[0];
							}
						}
						
						/* Do a first pass on the sorting classes (allows any size changes to be taken into
				 * account, and also will apply sorting disabled classes if disabled
				 */
						_fnSortingClasses(oSettings);
						
						if(features.bSort) {
							_fnCallbackReg(oSettings, 'aoDrawCallback', function() {
								if(oSettings.bSorted) {
									var aSort = _fnSortFlatten(oSettings);
									var sortedColumns = {};
									
									$.each(aSort, function(i, val) {
										sortedColumns[val.src] = val.dir;
									});
									
									_fnCallbackFire(oSettings, null, 'order', [oSettings, aSort, sortedColumns]);
									_fnSortAria(oSettings);
								}
							});
						}
						
						_fnCallbackReg(oSettings, 'aoDrawCallback', function() {
							if(oSettings.bSorted || _fnDataSource(oSettings) === 'ssp' || features.bDeferRender) {
								_fnSortingClasses(oSettings);
							}
						}, 'sc');
						
						
						/*
				 * Final init
				 * Cache the header, body and footer as required, creating them if needed
				 */
						
						// Work around for Webkit bug 83867 - store the caption-side before removing from doc
						var captions = $this.children('caption').each(function() {
							this._captionSide = $(this).css('caption-side');
						});
						
						var thead = $this.children('thead');
						if(thead.length === 0) {
							thead = $('<thead/>').appendTo($this);
						}
						oSettings.nTHead = thead[0];
						
						var tbody = $this.children('tbody');
						if(tbody.length === 0) {
							tbody = $('<tbody/>').appendTo($this);
						}
						oSettings.nTBody = tbody[0];
						
						var tfoot = $this.children('tfoot');
						if(tfoot.length === 0 && captions.length > 0 && (oSettings.oScroll.sX !== "" || oSettings.oScroll.sY !== "")) {
							// If we are a scrolling table, and no footer has been given, then we need to create
							// a tfoot element for the caption element to be appended to
							tfoot = $('<tfoot/>').appendTo($this);
						}
						
						if(tfoot.length === 0 || tfoot.children().length === 0) {
							$this.addClass(oClasses.sNoFooter);
						} else if(tfoot.length > 0) {
							oSettings.nTFoot = tfoot[0];
							_fnDetectHeader(oSettings.aoFooter, oSettings.nTFoot);
						}
						
						/* Check if there is data passing into the constructor */
						if(oInit.aaData) {
							for(i = 0; i < oInit.aaData.length; i++) {
								_fnAddData(oSettings, oInit.aaData[i]);
							}
						} else if(oSettings.bDeferLoading || _fnDataSource(oSettings) == 'dom') {
							/* Grab the data from the page - only do this when deferred loading or no Ajax
					 * source since there is no point in reading the DOM data if we are then going
					 * to replace it with Ajax data
					 */
							_fnAddTr(oSettings, $(oSettings.nTBody).children('tr'));
						}
						
						/* Copy the data index array */
						oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
						
						/* Initialisation complete - table can be drawn */
						oSettings.bInitialised = true;
						
						/* Check if we need to initialise the table (it might not have been handed off to the
				 * language processor)
				 */
						if(bInitHandedOff === false) {
							_fnInitialise(oSettings);
						}
					};
					
					/* Must be done after everything which can be overridden by the state saving! */
					if(oInit.bStateSave) {
						features.bStateSave = true;
						_fnCallbackReg(oSettings, 'aoDrawCallback', _fnSaveState, 'state_save');
						_fnLoadState(oSettings, oInit, loadedInit);
					} else {
						loadedInit();
					}
					
				});
				_that = null;
				return this;
			};
			
			
			/*
	 * It is useful to have variables which are scoped locally so only the
	 * DataTables functions can access them and they don't leak into global space.
	 * At the same time these functions are often useful over multiple files in the
	 * core and API, so we list, or at least document, all variables which are used
	 * by DataTables as private variables here. This also ensures that there is no
	 * clashing of variable names and that they can easily referenced for reuse.
	 */
			
			
			// Defined else where
			//  _selector_run
			//  _selector_opts
			//  _selector_first
			//  _selector_row_indexes
			
			var _ext; // DataTable.ext
			var _Api; // DataTable.Api
			var _api_register; // DataTable.Api.register
			var _api_registerPlural; // DataTable.Api.registerPlural
			
			var _re_dic = {};
			var _re_new_lines = /[\r\n]/g;
			var _re_html = /<.*?>/g;
			
			// This is not strict ISO8601 - Date.parse() is quite lax, although
			// implementations differ between browsers.
			var _re_date = /^\d{2,4}[\.\/\-]\d{1,2}[\.\/\-]\d{1,2}([T ]{1}\d{1,2}[:\.]\d{2}([\.:]\d{2})?)?$/;
			
			// Escape regular expression special characters
			var _re_escape_regex = new RegExp('(\\' + ['/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\', '$', '^', '-'].join('|\\') + ')', 'g');
			
			// http://en.wikipedia.org/wiki/Foreign_exchange_market
			// - \u20BD - Russian ruble.
			// - \u20a9 - South Korean Won
			// - \u20BA - Turkish Lira
			// - \u20B9 - Indian Rupee
			// - R - Brazil (R$) and South Africa
			// - fr - Swiss Franc
			// - kr - Swedish krona, Norwegian krone and Danish krone
			// - \u2009 is thin space and \u202F is narrow no-break space, both used in many
			// -  - Bitcoin
			// -  - Ethereum
			//   standards as thousands separators.
			var _re_formatted_numeric = /[',$%\u2009\u202F\u20BD\u20a9\u20BArfk]/gi;
			
			
			var _empty = function(d) {
				return !d || d === true || d === '-' ? true : false;
			};
			
			
			var _intVal = function(s) {
				var integer = parseInt(s, 10);
				return !isNaN(integer) && isFinite(s) ? integer : null;
			};
			
			// Convert from a formatted number with characters other than `.` as the
			// decimal place, to a Javascript number
			var _numToDecimal = function(num, decimalPoint) {
				// Cache created regular expressions for speed as this function is called often
				if(!_re_dic[decimalPoint]) {
					_re_dic[decimalPoint] = new RegExp(_fnEscapeRegex(decimalPoint), 'g');
				}
				return typeof num === 'string' && decimalPoint !== '.' ?
					num.replace(/\./g, '').replace(_re_dic[decimalPoint], '.') :
					num;
			};
			
			
			var _isNumber = function(d, decimalPoint, formatted) {
				var strType = typeof d === 'string';
				
				// If empty return immediately so there must be a number if it is a
				// formatted string (this stops the string "k", or "kr", etc being detected
				// as a formatted number for currency
				if(_empty(d)) {
					return true;
				}
				
				if(decimalPoint && strType) {
					d = _numToDecimal(d, decimalPoint);
				}
				
				if(formatted && strType) {
					d = d.replace(_re_formatted_numeric, '');
				}
				
				return !isNaN(parseFloat(d)) && isFinite(d);
			};
			
			
			// A string without HTML in it can be considered to be HTML still
			var _isHtml = function(d) {
				return _empty(d) || typeof d === 'string';
			};
			
			
			var _htmlNumeric = function(d, decimalPoint, formatted) {
				if(_empty(d)) {
					return true;
				}
				
				var html = _isHtml(d);
				return !html ?
					null :
					_isNumber(_stripHtml(d), decimalPoint, formatted) ?
						true :
						null;
			};
			
			
			var _pluck = function(a, prop, prop2) {
				var out = [];
				var i = 0, ien = a.length;
				
				// Could have the test in the loop for slightly smaller code, but speed
				// is essential here
				if(prop2 !== undefined) {
					for(; i < ien; i++) {
						if(a[i] && a[i][prop]) {
							out.push(a[i][prop][prop2]);
						}
					}
				} else {
					for(; i < ien; i++) {
						if(a[i]) {
							out.push(a[i][prop]);
						}
					}
				}
				
				return out;
			};
			
			
			// Basically the same as _pluck, but rather than looping over `a` we use `order`
			// as the indexes to pick from `a`
			var _pluck_order = function(a, order, prop, prop2) {
				var out = [];
				var i = 0, ien = order.length;
				
				// Could have the test in the loop for slightly smaller code, but speed
				// is essential here
				if(prop2 !== undefined) {
					for(; i < ien; i++) {
						if(a[order[i]][prop]) {
							out.push(a[order[i]][prop][prop2]);
						}
					}
				} else {
					for(; i < ien; i++) {
						out.push(a[order[i]][prop]);
					}
				}
				
				return out;
			};
			
			
			var _range = function(len, start) {
				var out = [];
				var end;
				
				if(start === undefined) {
					start = 0;
					end = len;
				} else {
					end = start;
					start = len;
				}
				
				for(var i = start; i < end; i++) {
					out.push(i);
				}
				
				return out;
			};
			
			
			var _removeEmpty = function(a) {
				var out = [];
				
				for(var i = 0, ien = a.length; i < ien; i++) {
					if(a[i]) { // careful - will remove all falsy values!
						out.push(a[i]);
					}
				}
				
				return out;
			};
			
			
			var _stripHtml = function(d) {
				return d.replace(_re_html, '');
			};
			
			
			/**
			 * Determine if all values in the array are unique. This means we can short
			 * cut the _unique method at the cost of a single loop. A sorted array is used
			 * to easily check the values.
			 *
			 * @param  {array} src Source array
			 * @return {boolean} true if all unique, false otherwise
			 * @ignore
			 */
			var _areAllUnique = function(src) {
				if(src.length < 2) {
					return true;
				}
				
				var sorted = src.slice().sort();
				var last = sorted[0];
				
				for(var i = 1, ien = sorted.length; i < ien; i++) {
					if(sorted[i] === last) {
						return false;
					}
					
					last = sorted[i];
				}
				
				return true;
			};
			
			
			/**
			 * Find the unique elements in a source array.
			 *
			 * @param  {array} src Source array
			 * @return {array} Array of unique items
			 * @ignore
			 */
			var _unique = function(src) {
				if(_areAllUnique(src)) {
					return src.slice();
				}
				
				// A faster unique method is to use object keys to identify used values,
				// but this doesn't work with arrays or objects, which we must also
				// consider. See jsperf.com/compare-array-unique-versions/4 for more
				// information.
				var
					out = [],
					val,
					i, ien = src.length,
					j, k = 0;
				
				again: for(i = 0; i < ien; i++) {
					val = src[i];
					
					for(j = 0; j < k; j++) {
						if(out[j] === val) {
							continue again;
						}
					}
					
					out.push(val);
					k++;
				}
				
				return out;
			};
			
			
			/**
			 * DataTables utility methods
			 *
			 * This namespace provides helper methods that DataTables uses internally to
			 * create a DataTable, but which are not exclusively used only for DataTables.
			 * These methods can be used by extension authors to save the duplication of
			 * code.
			 *
			 *  @namespace
			 */
			DataTable.util = {
				/**
				 * Throttle the calls to a function. Arguments and context are maintained
				 * for the throttled function.
				 *
				 * @param {function} fn Function to be called
				 * @param {integer} freq Call frequency in mS
				 * @return {function} Wrapped function
				 */
				throttle: function(fn, freq) {
					var
						frequency = freq !== undefined ? freq : 200,
						last,
						timer;
					
					return function() {
						var
							that = this,
							now = +new Date(),
							args = arguments;
						
						if(last && now < last + frequency) {
							clearTimeout(timer);
							
							timer = setTimeout(function() {
								last = undefined;
								fn.apply(that, args);
							}, frequency);
						} else {
							last = now;
							fn.apply(that, args);
						}
					};
				},
				
				
				/**
				 * Escape a string such that it can be used in a regular expression
				 *
				 *  @param {string} val string to escape
				 *  @returns {string} escaped string
				 */
				escapeRegex: function(val) {
					return val.replace(_re_escape_regex, '\\$1');
				}
			};
			
			
			/**
			 * Create a mapping object that allows camel case parameters to be looked up
			 * for their Hungarian counterparts. The mapping is stored in a private
			 * parameter called `_hungarianMap` which can be accessed on the source object.
			 *  @param {object} o
			 *  @memberof DataTable#oApi
			 */
			function _fnHungarianMap(o) {
				var
					hungarian = 'a aa ai ao as b fn i m o s ',
					match,
					newKey,
					map = {};
				
				$.each(o, function(key, val) {
					match = key.match(/^([^A-Z]+?)([A-Z])/);
					
					if(match && hungarian.indexOf(match[1] + ' ') !== -1) {
						newKey = key.replace(match[0], match[2].toLowerCase());
						map[newKey] = key;
						
						if(match[1] === 'o') {
							_fnHungarianMap(o[key]);
						}
					}
				});
				
				o._hungarianMap = map;
			}
			
			
			/**
			 * Convert from camel case parameters to Hungarian, based on a Hungarian map
			 * created by _fnHungarianMap.
			 *  @param {object} src The model object which holds all parameters that can be
			 *    mapped.
			 *  @param {object} user The object to convert from camel case to Hungarian.
			 *  @param {boolean} force When set to `true`, properties which already have a
			 *    Hungarian value in the `user` object will be overwritten. Otherwise they
			 *    won't be.
			 *  @memberof DataTable#oApi
			 */
			function _fnCamelToHungarian(src, user, force) {
				if(!src._hungarianMap) {
					_fnHungarianMap(src);
				}
				
				var hungarianKey;
				
				$.each(user, function(key, val) {
					hungarianKey = src._hungarianMap[key];
					
					if(hungarianKey !== undefined && (force || user[hungarianKey] === undefined)) {
						// For objects, we need to buzz down into the object to copy parameters
						if(hungarianKey.charAt(0) === 'o') {
							// Copy the camelCase options over to the hungarian
							if(!user[hungarianKey]) {
								user[hungarianKey] = {};
							}
							$.extend(true, user[hungarianKey], user[key]);
							
							_fnCamelToHungarian(src[hungarianKey], user[hungarianKey], force);
						} else {
							user[hungarianKey] = user[key];
						}
					}
				});
			}
			
			
			/**
			 * Language compatibility - when certain options are given, and others aren't, we
			 * need to duplicate the values over, in order to provide backwards compatibility
			 * with older language files.
			 *  @param {object} oSettings dataTables settings object
			 *  @memberof DataTable#oApi
			 */
			function _fnLanguageCompat(lang) {
				// Note the use of the Hungarian notation for the parameters in this method as
				// this is called after the mapping of camelCase to Hungarian
				var defaults = DataTable.defaults.oLanguage;
				
				// Default mapping
				var defaultDecimal = defaults.sDecimal;
				if(defaultDecimal) {
					_addNumericSort(defaultDecimal);
				}
				
				if(lang) {
					var zeroRecords = lang.sZeroRecords;
					
					// Backwards compatibility - if there is no sEmptyTable given, then use the same as
					// sZeroRecords - assuming that is given.
					if(!lang.sEmptyTable && zeroRecords &&
						defaults.sEmptyTable === "No data available in table") {
						_fnMap(lang, lang, 'sZeroRecords', 'sEmptyTable');
					}
					
					// Likewise with loading records
					if(!lang.sLoadingRecords && zeroRecords &&
						defaults.sLoadingRecords === "Loading...") {
						_fnMap(lang, lang, 'sZeroRecords', 'sLoadingRecords');
					}
					
					// Old parameter name of the thousands separator mapped onto the new
					if(lang.sInfoThousands) {
						lang.sThousands = lang.sInfoThousands;
					}
					
					var decimal = lang.sDecimal;
					if(decimal && defaultDecimal !== decimal) {
						_addNumericSort(decimal);
					}
				}
			}
			
			
			/**
			 * Map one parameter onto another
			 *  @param {object} o Object to map
			 *  @param {*} knew The new parameter name
			 *  @param {*} old The old parameter name
			 */
			var _fnCompatMap = function(o, knew, old) {
				if(o[knew] !== undefined) {
					o[old] = o[knew];
				}
			};
			
			
			/**
			 * Provide backwards compatibility for the main DT options. Note that the new
			 * options are mapped onto the old parameters, so this is an external interface
			 * change only.
			 *  @param {object} init Object to map
			 */
			function _fnCompatOpts(init) {
				_fnCompatMap(init, 'ordering', 'bSort');
				_fnCompatMap(init, 'orderMulti', 'bSortMulti');
				_fnCompatMap(init, 'orderClasses', 'bSortClasses');
				_fnCompatMap(init, 'orderCellsTop', 'bSortCellsTop');
				_fnCompatMap(init, 'order', 'aaSorting');
				_fnCompatMap(init, 'orderFixed', 'aaSortingFixed');
				_fnCompatMap(init, 'paging', 'bPaginate');
				_fnCompatMap(init, 'pagingType', 'sPaginationType');
				_fnCompatMap(init, 'pageLength', 'iDisplayLength');
				_fnCompatMap(init, 'searching', 'bFilter');
				
				// Boolean initialisation of x-scrolling
				if(typeof init.sScrollX === 'boolean') {
					init.sScrollX = init.sScrollX ? '100%' : '';
				}
				if(typeof init.scrollX === 'boolean') {
					init.scrollX = init.scrollX ? '100%' : '';
				}
				
				// Column search objects are in an array, so it needs to be converted
				// element by element
				var searchCols = init.aoSearchCols;
				
				if(searchCols) {
					for(var i = 0, ien = searchCols.length; i < ien; i++) {
						if(searchCols[i]) {
							_fnCamelToHungarian(DataTable.models.oSearch, searchCols[i]);
						}
					}
				}
			}
			
			
			/**
			 * Provide backwards compatibility for column options. Note that the new options
			 * are mapped onto the old parameters, so this is an external interface change
			 * only.
			 *  @param {object} init Object to map
			 */
			function _fnCompatCols(init) {
				_fnCompatMap(init, 'orderable', 'bSortable');
				_fnCompatMap(init, 'orderData', 'aDataSort');
				_fnCompatMap(init, 'orderSequence', 'asSorting');
				_fnCompatMap(init, 'orderDataType', 'sortDataType');
				
				// orderData can be given as an integer
				var dataSort = init.aDataSort;
				if(typeof dataSort === 'number' && !$.isArray(dataSort)) {
					init.aDataSort = [dataSort];
				}
			}
			
			
			/**
			 * Browser feature detection for capabilities, quirks
			 *  @param {object} settings dataTables settings object
			 *  @memberof DataTable#oApi
			 */
			function _fnBrowserDetect(settings) {
				// We don't need to do this every time DataTables is constructed, the values
				// calculated are specific to the browser and OS configuration which we
				// don't expect to change between initialisations
				if(!DataTable.__browser) {
					var browser = {};
					DataTable.__browser = browser;
					
					// Scrolling feature / quirks detection
					var n = $('<div/>')
						.css({
							position: 'fixed',
							top: 0,
							left: $(window).scrollLeft() * -1, // allow for scrolling
							height: 1,
							width: 1,
							overflow: 'hidden'
						})
						.append(
							$('<div/>')
								.css({
									position: 'absolute',
									top: 1,
									left: 1,
									width: 100,
									overflow: 'scroll'
								})
								.append(
									$('<div/>')
										.css({
											width: '100%',
											height: 10
										})
								)
						)
						.appendTo('body');
					
					var outer = n.children();
					var inner = outer.children();
					
					// Numbers below, in order, are:
					// inner.offsetWidth, inner.clientWidth, outer.offsetWidth, outer.clientWidth
					//
					// IE6 XP:                           100 100 100  83
					// IE7 Vista:                        100 100 100  83
					// IE 8+ Windows:                     83  83 100  83
					// Evergreen Windows:                 83  83 100  83
					// Evergreen Mac with scrollbars:     85  85 100  85
					// Evergreen Mac without scrollbars: 100 100 100 100
					
					// Get scrollbar width
					browser.barWidth = outer[0].offsetWidth - outer[0].clientWidth;
					
					// IE6/7 will oversize a width 100% element inside a scrolling element, to
					// include the width of the scrollbar, while other browsers ensure the inner
					// element is contained without forcing scrolling
					browser.bScrollOversize = inner[0].offsetWidth === 100 && outer[0].clientWidth !== 100;
					
					// In rtl text layout, some browsers (most, but not all) will place the
					// scrollbar on the left, rather than the right.
					browser.bScrollbarLeft = Math.round(inner.offset().left) !== 1;
					
					// IE8- don't provide height and width for getBoundingClientRect
					browser.bBounding = n[0].getBoundingClientRect().width ? true : false;
					
					n.remove();
				}
				
				$.extend(settings.oBrowser, DataTable.__browser);
				settings.oScroll.iBarWidth = DataTable.__browser.barWidth;
			}
			
			
			/**
			 * Array.prototype reduce[Right] method, used for browsers which don't support
			 * JS 1.6. Done this way to reduce code size, since we iterate either way
			 *  @param {object} settings dataTables settings object
			 *  @memberof DataTable#oApi
			 */
			function _fnReduce(that, fn, init, start, end, inc) {
				var
					i = start,
					value,
					isSet = false;
				
				if(init !== undefined) {
					value = init;
					isSet = true;
				}
				
				while(i !== end) {
					if(!that.hasOwnProperty(i)) {
						continue;
					}
					
					value = isSet ?
						fn(value, that[i], i, that) :
						that[i];
					
					isSet = true;
					i += inc;
				}
				
				return value;
			}
			
			/**
			 * Add a column to the list used for the table with default values
			 *  @param {object} oSettings dataTables settings object
			 *  @param {node} nTh The th element for this column
			 *  @memberof DataTable#oApi
			 */
			function _fnAddColumn(oSettings, nTh) {
				// Add column to aoColumns array
				var oDefaults = DataTable.defaults.column;
				var iCol = oSettings.aoColumns.length;
				var oCol = $.extend({}, DataTable.models.oColumn, oDefaults, {
					"nTh": nTh ? nTh : document.createElement('th'),
					"sTitle": oDefaults.sTitle ? oDefaults.sTitle : nTh ? nTh.innerHTML : '',
					"aDataSort": oDefaults.aDataSort ? oDefaults.aDataSort : [iCol],
					"mData": oDefaults.mData ? oDefaults.mData : iCol,
					idx: iCol
				});
				oSettings.aoColumns.push(oCol);
				
				// Add search object for column specific search. Note that the `searchCols[ iCol ]`
				// passed into extend can be undefined. This allows the user to give a default
				// with only some of the parameters defined, and also not give a default
				var searchCols = oSettings.aoPreSearchCols;
				searchCols[iCol] = $.extend({}, DataTable.models.oSearch, searchCols[iCol]);
				
				// Use the default column options function to initialise classes etc
				_fnColumnOptions(oSettings, iCol, $(nTh).data());
			}
			
			
			/**
			 * Apply options for a column
			 *  @param {object} oSettings dataTables settings object
			 *  @param {int} iCol column index to consider
			 *  @param {object} oOptions object with sType, bVisible and bSearchable etc
			 *  @memberof DataTable#oApi
			 */
			function _fnColumnOptions(oSettings, iCol, oOptions) {
				var oCol = oSettings.aoColumns[iCol];
				var oClasses = oSettings.oClasses;
				var th = $(oCol.nTh);
				
				// Try to get width information from the DOM. We can't get it from CSS
				// as we'd need to parse the CSS stylesheet. `width` option can override
				if(!oCol.sWidthOrig) {
					// Width attribute
					oCol.sWidthOrig = th.attr('width') || null;
					
					// Style attribute
					var t = (th.attr('style') || '').match(/width:\s*(\d+[pxem%]+)/);
					if(t) {
						oCol.sWidthOrig = t[1];
					}
				}
				
				/* User specified column options */
				if(oOptions !== undefined && oOptions !== null) {
					// Backwards compatibility
					_fnCompatCols(oOptions);
					
					// Map camel case parameters to their Hungarian counterparts
					_fnCamelToHungarian(DataTable.defaults.column, oOptions);
					
					/* Backwards compatibility for mDataProp */
					if(oOptions.mDataProp !== undefined && !oOptions.mData) {
						oOptions.mData = oOptions.mDataProp;
					}
					
					if(oOptions.sType) {
						oCol._sManualType = oOptions.sType;
					}
					
					// `class` is a reserved word in Javascript, so we need to provide
					// the ability to use a valid name for the camel case input
					if(oOptions.className && !oOptions.sClass) {
						oOptions.sClass = oOptions.className;
					}
					if(oOptions.sClass) {
						th.addClass(oOptions.sClass);
					}
					
					$.extend(oCol, oOptions);
					_fnMap(oCol, oOptions, "sWidth", "sWidthOrig");
					
					/* iDataSort to be applied (backwards compatibility), but aDataSort will take
			 * priority if defined
			 */
					if(oOptions.iDataSort !== undefined) {
						oCol.aDataSort = [oOptions.iDataSort];
					}
					_fnMap(oCol, oOptions, "aDataSort");
				}
				
				/* Cache the data get and set functions for speed */
				var mDataSrc = oCol.mData;
				var mData = _fnGetObjectDataFn(mDataSrc);
				var mRender = oCol.mRender ? _fnGetObjectDataFn(oCol.mRender) : null;
				
				var attrTest = function(src) {
					return typeof src === 'string' && src.indexOf('@') !== -1;
				};
				oCol._bAttrSrc = $.isPlainObject(mDataSrc) && (
					attrTest(mDataSrc.sort) || attrTest(mDataSrc.type) || attrTest(mDataSrc.filter)
				);
				oCol._setter = null;
				
				oCol.fnGetData = function(rowData, type, meta) {
					var innerData = mData(rowData, type, undefined, meta);
					
					return mRender && type ?
						mRender(innerData, type, rowData, meta) :
						innerData;
				};
				oCol.fnSetData = function(rowData, val, meta) {
					return _fnSetObjectDataFn(mDataSrc)(rowData, val, meta);
				};
				
				// Indicate if DataTables should read DOM data as an object or array
				// Used in _fnGetRowElements
				if(typeof mDataSrc !== 'number') {
					oSettings._rowReadObject = true;
				}
				
				/* Feature sorting overrides column specific when off */
				if(!oSettings.oFeatures.bSort) {
					oCol.bSortable = false;
					th.addClass(oClasses.sSortableNone); // Have to add class here as order event isn't called
				}
				
				/* Check that the class assignment is correct for sorting */
				var bAsc = $.inArray('asc', oCol.asSorting) !== -1;
				var bDesc = $.inArray('desc', oCol.asSorting) !== -1;
				if(!oCol.bSortable || (!bAsc && !bDesc)) {
					oCol.sSortingClass = oClasses.sSortableNone;
					oCol.sSortingClassJUI = "";
				} else if(bAsc && !bDesc) {
					oCol.sSortingClass = oClasses.sSortableAsc;
					oCol.sSortingClassJUI = oClasses.sSortJUIAscAllowed;
				} else if(!bAsc && bDesc) {
					oCol.sSortingClass = oClasses.sSortableDesc;
					oCol.sSortingClassJUI = oClasses.sSortJUIDescAllowed;
				} else {
					oCol.sSortingClass = oClasses.sSortable;
					oCol.sSortingClassJUI = oClasses.sSortJUI;
				}
			}
			
			
			/**
			 * Adjust the table column widths for new data. Note: you would probably want to
			 * do a redraw after calling this function!
			 *  @param {object} settings dataTables settings object
			 *  @memberof DataTable#oApi
			 */
			function _fnAdjustColumnSizing(settings) {
				/* Not interested in doing column width calculation if auto-width is disabled */
				if(settings.oFeatures.bAutoWidth !== false) {
					var columns = settings.aoColumns;
					
					_fnCalculateColumnWidths(settings);
					for(var i = 0, iLen = columns.length; i < iLen; i++) {
						columns[i].nTh.style.width = columns[i].sWidth;
					}
				}
				
				var scroll = settings.oScroll;
				if(scroll.sY !== '' || scroll.sX !== '') {
					_fnScrollDraw(settings);
				}
				
				_fnCallbackFire(settings, null, 'column-sizing', [settings]);
			}
			
			
			/**
			 * Covert the index of a visible column to the index in the data array (take account
			 * of hidden columns)
			 *  @param {object} oSettings dataTables settings object
			 *  @param {int} iMatch Visible column index to lookup
			 *  @returns {int} i the data index
			 *  @memberof DataTable#oApi
			 */
			function _fnVisibleToColumnIndex(oSettings, iMatch) {
				var aiVis = _fnGetColumns(oSettings, 'bVisible');
				
				return typeof aiVis[iMatch] === 'number' ?
					aiVis[iMatch] :
					null;
			}
			
			
			/**
			 * Covert the index of an index in the data array and convert it to the visible
			 *   column index (take account of hidden columns)
			 *  @param {int} iMatch Column index to lookup
			 *  @param {object} oSettings dataTables settings object
			 *  @returns {int} i the data index
			 *  @memberof DataTable#oApi
			 */
			function _fnColumnIndexToVisible(oSettings, iMatch) {
				var aiVis = _fnGetColumns(oSettings, 'bVisible');
				var iPos = $.inArray(iMatch, aiVis);
				
				return iPos !== -1 ? iPos : null;
			}
			
			
			/**
			 * Get the number of visible columns
			 *  @param {object} oSettings dataTables settings object
			 *  @returns {int} i the number of visible columns
			 *  @memberof DataTable#oApi
			 */
			function _fnVisbleColumns(oSettings) {
				var vis = 0;
				
				// No reduce in IE8, use a loop for now
				$.each(oSettings.aoColumns, function(i, col) {
					if(col.bVisible && $(col.nTh).css('display') !== 'none') {
						vis++;
					}
				});
				
				return vis;
			}
			
			
			/**
			 * Get an array of column indexes that match a given property
			 *  @param {object} oSettings dataTables settings object
			 *  @param {string} sParam Parameter in aoColumns to look for - typically
			 *    bVisible or bSearchable
			 *  @returns {array} Array of indexes with matched properties
			 *  @memberof DataTable#oApi
			 */
			function _fnGetColumns(oSettings, sParam) {
				var a = [];
				
				$.map(oSettings.aoColumns, function(val, i) {
					if(val[sParam]) {
						a.push(i);
					}
				});
				
				return a;
			}
			
			
			/**
			 * Calculate the 'type' of a column
			 *  @param {object} settings dataTables settings object
			 *  @memberof DataTable#oApi
			 */
			function _fnColumnTypes(settings) {
				var columns = settings.aoColumns;
				var data = settings.aoData;
				var types = DataTable.ext.type.detect;
				var i, ien, j, jen, k, ken;
				var col, cell, detectedType, cache;
				
				// For each column, spin over the
				for(i = 0, ien = columns.length; i < ien; i++) {
					col = columns[i];
					cache = [];
					
					if(!col.sType && col._sManualType) {
						col.sType = col._sManualType;
					} else if(!col.sType) {
						for(j = 0, jen = types.length; j < jen; j++) {
							for(k = 0, ken = data.length; k < ken; k++) {
								// Use a cache array so we only need to get the type data
								// from the formatter once (when using multiple detectors)
								if(cache[k] === undefined) {
									cache[k] = _fnGetCellData(settings, k, i, 'type');
								}
								
								detectedType = types[j](cache[k], settings);
								
								// If null, then this type can't apply to this column, so
								// rather than testing all cells, break out. There is an
								// exception for the last type which is `html`. We need to
								// scan all rows since it is possible to mix string and HTML
								// types
								if(!detectedType && j !== types.length - 1) {
									break;
								}
								
								// Only a single match is needed for html type since it is
								// bottom of the pile and very similar to string
								if(detectedType === 'html') {
									break;
								}
							}
							
							// Type is valid for all data points in the column - use this
							// type
							if(detectedType) {
								col.sType = detectedType;
								break;
							}
						}
						
						// Fall back - if no type was detected, always use string
						if(!col.sType) {
							col.sType = 'string';
						}
					}
				}
			}
			
			
			/**
			 * Take the column definitions and static columns arrays and calculate how
			 * they relate to column indexes. The callback function will then apply the
			 * definition found for a column to a suitable configuration object.
			 *  @param {object} oSettings dataTables settings object
			 *  @param {array} aoColDefs The aoColumnDefs array that is to be applied
			 *  @param {array} aoCols The aoColumns array that defines columns individually
			 *  @param {function} fn Callback function - takes two parameters, the calculated
			 *    column index and the definition for that column.
			 *  @memberof DataTable#oApi
			 */
			function _fnApplyColumnDefs(oSettings, aoColDefs, aoCols, fn) {
				var i, iLen, j, jLen, k, kLen, def;
				var columns = oSettings.aoColumns;
				
				// Column definitions with aTargets
				if(aoColDefs) {
					/* Loop over the definitions array - loop in reverse so first instance has priority */
					for(i = aoColDefs.length - 1; i >= 0; i--) {
						def = aoColDefs[i];
						
						/* Each definition can target multiple columns, as it is an array */
						var aTargets = def.targets !== undefined ?
							def.targets :
							def.aTargets;
						
						if(!$.isArray(aTargets)) {
							aTargets = [aTargets];
						}
						
						for(j = 0, jLen = aTargets.length; j < jLen; j++) {
							if(typeof aTargets[j] === 'number' && aTargets[j] >= 0) {
								/* Add columns that we don't yet know about */
								while(columns.length <= aTargets[j]) {
									_fnAddColumn(oSettings);
								}
								
								/* Integer, basic index */
								fn(aTargets[j], def);
							} else if(typeof aTargets[j] === 'number' && aTargets[j] < 0) {
								/* Negative integer, right to left column counting */
								fn(columns.length + aTargets[j], def);
							} else if(typeof aTargets[j] === 'string') {
								/* Class name matching on TH element */
								for(k = 0, kLen = columns.length; k < kLen; k++) {
									if(aTargets[j] == "_all" ||
										$(columns[k].nTh).hasClass(aTargets[j])) {
										fn(k, def);
									}
								}
							}
						}
					}
				}
				
				// Statically defined columns array
				if(aoCols) {
					for(i = 0, iLen = aoCols.length; i < iLen; i++) {
						fn(i, aoCols[i]);
					}
				}
			}
			
			/**
			 * Add a data array to the table, creating DOM node etc. This is the parallel to
			 * _fnGatherData, but for adding rows from a Javascript source, rather than a
			 * DOM source.
			 *  @param {object} oSettings dataTables settings object
			 *  @param {array} aData data array to be added
			 *  @param {node} [nTr] TR element to add to the table - optional. If not given,
			 *    DataTables will create a row automatically
			 *  @param {array} [anTds] Array of TD|TH elements for the row - must be given
			 *    if nTr is.
			 *  @returns {int} >=0 if successful (index of new aoData entry), -1 if failed
			 *  @memberof DataTable#oApi
			 */
			function _fnAddData(oSettings, aDataIn, nTr, anTds) {
				/* Create the object for storing information about this new row */
				var iRow = oSettings.aoData.length;
				var oData = $.extend(true, {}, DataTable.models.oRow, {
					src: nTr ? 'dom' : 'data',
					idx: iRow
				});
				
				oData._aData = aDataIn;
				oSettings.aoData.push(oData);
				
				/* Create the cells */
				var nTd, sThisType;
				var columns = oSettings.aoColumns;
				
				// Invalidate the column types as the new data needs to be revalidated
				for(var i = 0, iLen = columns.length; i < iLen; i++) {
					columns[i].sType = null;
				}
				
				/* Add to the display array */
				oSettings.aiDisplayMaster.push(iRow);
				
				var id = oSettings.rowIdFn(aDataIn);
				if(id !== undefined) {
					oSettings.aIds[id] = oData;
				}
				
				/* Create the DOM information, or register it if already present */
				if(nTr || !oSettings.oFeatures.bDeferRender) {
					_fnCreateTr(oSettings, iRow, nTr, anTds);
				}
				
				return iRow;
			}
			
			
			/**
			 * Add one or more TR elements to the table. Generally we'd expect to
			 * use this for reading data from a DOM sourced table, but it could be
			 * used for an TR element. Note that if a TR is given, it is used (i.e.
			 * it is not cloned).
			 *  @param {object} settings dataTables settings object
			 *  @param {array|node|jQuery} trs The TR element(s) to add to the table
			 *  @returns {array} Array of indexes for the added rows
			 *  @memberof DataTable#oApi
			 */
			function _fnAddTr(settings, trs) {
				var row;
				
				// Allow an individual node to be passed in
				if(!(trs instanceof $)) {
					trs = $(trs);
				}
				
				return trs.map(function(i, el) {
					row = _fnGetRowElements(settings, el);
					return _fnAddData(settings, row.data, el, row.cells);
				});
			}
			
			
			/**
			 * Take a TR element and convert it to an index in aoData
			 *  @param {object} oSettings dataTables settings object
			 *  @param {node} n the TR element to find
			 *  @returns {int} index if the node is found, null if not
			 *  @memberof DataTable#oApi
			 */
			function _fnNodeToDataIndex(oSettings, n) {
				return (n._DT_RowIndex !== undefined) ? n._DT_RowIndex : null;
			}
			
			
			/**
			 * Take a TD element and convert it into a column data index (not the visible index)
			 *  @param {object} oSettings dataTables settings object
			 *  @param {int} iRow The row number the TD/TH can be found in
			 *  @param {node} n The TD/TH element to find
			 *  @returns {int} index if the node is found, -1 if not
			 *  @memberof DataTable#oApi
			 */
			function _fnNodeToColumnIndex(oSettings, iRow, n) {
				return $.inArray(n, oSettings.aoData[iRow].anCells);
			}
			
			
			/**
			 * Get the data for a given cell from the internal cache, taking into account data mapping
			 *  @param {object} settings dataTables settings object
			 *  @param {int} rowIdx aoData row id
			 *  @param {int} colIdx Column index
			 *  @param {string} type data get type ('display', 'type' 'filter' 'sort')
			 *  @returns {*} Cell data
			 *  @memberof DataTable#oApi
			 */
			function _fnGetCellData(settings, rowIdx, colIdx, type) {
				var draw = settings.iDraw;
				var col = settings.aoColumns[colIdx];
				var rowData = settings.aoData[rowIdx]._aData;
				var defaultContent = col.sDefaultContent;
				var cellData = col.fnGetData(rowData, type, {
					settings: settings,
					row: rowIdx,
					col: colIdx
				});
				
				if(cellData === undefined) {
					if(settings.iDrawError != draw && defaultContent === null) {
						_fnLog(settings, 0, "Requested unknown parameter " +
							(typeof col.mData == 'function' ? '{function}' : "'" + col.mData + "'") +
							" for row " + rowIdx + ", column " + colIdx, 4);
						settings.iDrawError = draw;
					}
					return defaultContent;
				}
				
				// When the data source is null and a specific data type is requested (i.e.
				// not the original data), we can use default column data
				if((cellData === rowData || cellData === null) && defaultContent !== null && type !== undefined) {
					cellData = defaultContent;
				} else if(typeof cellData === 'function') {
					// If the data source is a function, then we run it and use the return,
					// executing in the scope of the data object (for instances)
					return cellData.call(rowData);
				}
				
				if(cellData === null && type == 'display') {
					return '';
				}
				return cellData;
			}
			
			
			/**
			 * Set the value for a specific cell, into the internal data cache
			 *  @param {object} settings dataTables settings object
			 *  @param {int} rowIdx aoData row id
			 *  @param {int} colIdx Column index
			 *  @param {*} val Value to set
			 *  @memberof DataTable#oApi
			 */
			function _fnSetCellData(settings, rowIdx, colIdx, val) {
				var col = settings.aoColumns[colIdx];
				var rowData = settings.aoData[rowIdx]._aData;
				
				col.fnSetData(rowData, val, {
					settings: settings,
					row: rowIdx,
					col: colIdx
				});
			}
			
			
			// Private variable that is used to match action syntax in the data property object
			var __reArray = /\[.*?\]$/;
			var __reFn = /\(\)$/;
			
			/**
			 * Split string on periods, taking into account escaped periods
			 * @param  {string} str String to split
			 * @return {array} Split string
			 */
			function _fnSplitObjNotation(str) {
				return $.map(str.match(/(\\.|[^\.])+/g) || [''], function(s) {
					return s.replace(/\\\./g, '.');
				});
			}
			
			
			/**
			 * Return a function that can be used to get data from a source object, taking
			 * into account the ability to use nested objects as a source
			 *  @param {string|int|function} mSource The data source for the object
			 *  @returns {function} Data get function
			 *  @memberof DataTable#oApi
			 */
			function _fnGetObjectDataFn(mSource) {
				if($.isPlainObject(mSource)) {
					/* Build an object of get functions, and wrap them in a single call */
					var o = {};
					$.each(mSource, function(key, val) {
						if(val) {
							o[key] = _fnGetObjectDataFn(val);
						}
					});
					
					return function(data, type, row, meta) {
						var t = o[type] || o._;
						return t !== undefined ?
							t(data, type, row, meta) :
							data;
					};
				} else if(mSource === null) {
					/* Give an empty string for rendering / sorting etc */
					return function(data) { // type, row and meta also passed, but not used
						return data;
					};
				} else if(typeof mSource === 'function') {
					return function(data, type, row, meta) {
						return mSource(data, type, row, meta);
					};
				} else if(typeof mSource === 'string' && (mSource.indexOf('.') !== -1 ||
					mSource.indexOf('[') !== -1 || mSource.indexOf('(') !== -1)) {
					/* If there is a . in the source string then the data source is in a
			 * nested object so we loop over the data for each level to get the next
			 * level down. On each loop we test for undefined, and if found immediately
			 * return. This allows entire objects to be missing and sDefaultContent to
			 * be used if defined, rather than throwing an error
			 */
					var fetchData = function(data, type, src) {
						var arrayNotation, funcNotation, out, innerSrc;
						
						if(src !== "") {
							var a = _fnSplitObjNotation(src);
							
							for(var i = 0, iLen = a.length; i < iLen; i++) {
								// Check if we are dealing with special notation
								arrayNotation = a[i].match(__reArray);
								funcNotation = a[i].match(__reFn);
								
								if(arrayNotation) {
									// Array notation
									a[i] = a[i].replace(__reArray, '');
									
									// Condition allows simply [] to be passed in
									if(a[i] !== "") {
										data = data[a[i]];
									}
									out = [];
									
									// Get the remainder of the nested object to get
									a.splice(0, i + 1);
									innerSrc = a.join('.');
									
									// Traverse each entry in the array getting the properties requested
									if($.isArray(data)) {
										for(var j = 0, jLen = data.length; j < jLen; j++) {
											out.push(fetchData(data[j], type, innerSrc));
										}
									}
									
									// If a string is given in between the array notation indicators, that
									// is used to join the strings together, otherwise an array is returned
									var join = arrayNotation[0].substring(1, arrayNotation[0].length - 1);
									data = (join === "") ? out : out.join(join);
									
									// The inner call to fetchData has already traversed through the remainder
									// of the source requested, so we exit from the loop
									break;
								} else if(funcNotation) {
									// Function call
									a[i] = a[i].replace(__reFn, '');
									data = data[a[i]]();
									continue;
								}
								
								if(data === null || data[a[i]] === undefined) {
									return undefined;
								}
								data = data[a[i]];
							}
						}
						
						return data;
					};
					
					return function(data, type) { // row and meta also passed, but not used
						return fetchData(data, type, mSource);
					};
				} else {
					/* Array or flat object mapping */
					return function(data, type) { // row and meta also passed, but not used
						return data[mSource];
					};
				}
			}
			
			
			/**
			 * Return a function that can be used to set data from a source object, taking
			 * into account the ability to use nested objects as a source
			 *  @param {string|int|function} mSource The data source for the object
			 *  @returns {function} Data set function
			 *  @memberof DataTable#oApi
			 */
			function _fnSetObjectDataFn(mSource) {
				if($.isPlainObject(mSource)) {
					/* Unlike get, only the underscore (global) option is used for for
			 * setting data since we don't know the type here. This is why an object
			 * option is not documented for `mData` (which is read/write), but it is
			 * for `mRender` which is read only.
			 */
					return _fnSetObjectDataFn(mSource._);
				} else if(mSource === null) {
					/* Nothing to do when the data source is null */
					return function() {
					};
				} else if(typeof mSource === 'function') {
					return function(data, val, meta) {
						mSource(data, 'set', val, meta);
					};
				} else if(typeof mSource === 'string' && (mSource.indexOf('.') !== -1 ||
					mSource.indexOf('[') !== -1 || mSource.indexOf('(') !== -1)) {
					/* Like the get, we need to get data from a nested object */
					var setData = function(data, val, src) {
						var a = _fnSplitObjNotation(src), b;
						var aLast = a[a.length - 1];
						var arrayNotation, funcNotation, o, innerSrc;
						
						for(var i = 0, iLen = a.length - 1; i < iLen; i++) {
							// Check if we are dealing with an array notation request
							arrayNotation = a[i].match(__reArray);
							funcNotation = a[i].match(__reFn);
							
							if(arrayNotation) {
								a[i] = a[i].replace(__reArray, '');
								data[a[i]] = [];
								
								// Get the remainder of the nested object to set so we can recurse
								b = a.slice();
								b.splice(0, i + 1);
								innerSrc = b.join('.');
								
								// Traverse each entry in the array setting the properties requested
								if($.isArray(val)) {
									for(var j = 0, jLen = val.length; j < jLen; j++) {
										o = {};
										setData(o, val[j], innerSrc);
										data[a[i]].push(o);
									}
								} else {
									// We've been asked to save data to an array, but it
									// isn't array data to be saved. Best that can be done
									// is to just save the value.
									data[a[i]] = val;
								}
								
								// The inner call to setData has already traversed through the remainder
								// of the source and has set the data, thus we can exit here
								return;
							} else if(funcNotation) {
								// Function call
								a[i] = a[i].replace(__reFn, '');
								data = data[a[i]](val);
							}
							
							// If the nested object doesn't currently exist - since we are
							// trying to set the value - create it
							if(data[a[i]] === null || data[a[i]] === undefined) {
								data[a[i]] = {};
							}
							data = data[a[i]];
						}
						
						// Last item in the input - i.e, the actual set
						if(aLast.match(__reFn)) {
							// Function call
							data = data[aLast.replace(__reFn, '')](val);
						} else {
							// If array notation is used, we just want to strip it and use the property name
							// and assign the value. If it isn't used, then we get the result we want anyway
							data[aLast.replace(__reArray, '')] = val;
						}
					};
					
					return function(data, val) { // meta is also passed in, but not used
						return setData(data, val, mSource);
					};
				} else {
					/* Array or flat object mapping */
					return function(data, val) { // meta is also passed in, but not used
						data[mSource] = val;
					};
				}
			}
			
			
			/**
			 * Return an array with the full table data
			 *  @param {object} oSettings dataTables settings object
			 *  @returns array {array} aData Master data array
			 *  @memberof DataTable#oApi
			 */
			function _fnGetDataMaster(settings) {
				return _pluck(settings.aoData, '_aData');
			}
			
			
			/**
			 * Nuke the table
			 *  @param {object} oSettings dataTables settings object
			 *  @memberof DataTable#oApi
			 */
			function _fnClearTable(settings) {
				settings.aoData.length = 0;
				settings.aiDisplayMaster.length = 0;
				settings.aiDisplay.length = 0;
				settings.aIds = {};
			}
			
			
			/**
			 * Take an array of integers (index array) and remove a target integer (value - not
			 * the key!)
			 *  @param {array} a Index array to target
			 *  @param {int} iTarget value to find
			 *  @memberof DataTable#oApi
			 */
			function _fnDeleteIndex(a, iTarget, splice) {
				var iTargetIndex = -1;
				
				for(var i = 0, iLen = a.length; i < iLen; i++) {
					if(a[i] == iTarget) {
						iTargetIndex = i;
					} else if(a[i] > iTarget) {
						a[i]--;
					}
				}
				
				if(iTargetIndex != -1 && splice === undefined) {
					a.splice(iTargetIndex, 1);
				}
			}
			
			
			/**
			 * Mark cached data as invalid such that a re-read of the data will occur when
			 * the cached data is next requested. Also update from the data source object.
			 *
			 * @param {object} settings DataTables settings object
			 * @param {int}    rowIdx   Row index to invalidate
			 * @param {string} [src]    Source to invalidate from: undefined, 'auto', 'dom'
			 *     or 'data'
			 * @param {int}    [colIdx] Column index to invalidate. If undefined the whole
			 *     row will be invalidated
			 * @memberof DataTable#oApi
			 *
			 * @todo For the modularisation of v1.11 this will need to become a callback, so
			 *   the sort and filter methods can subscribe to it. That will required
			 *   initialisation options for sorting, which is why it is not already baked in
			 */
			function _fnInvalidate(settings, rowIdx, src, colIdx) {
				var row = settings.aoData[rowIdx];
				var i, ien;
				var cellWrite = function(cell, col) {
					// This is very frustrating, but in IE if you just write directly
					// to innerHTML, and elements that are overwritten are GC'ed,
					// even if there is a reference to them elsewhere
					while(cell.childNodes.length) {
						cell.removeChild(cell.firstChild);
					}
					
					cell.innerHTML = _fnGetCellData(settings, rowIdx, col, 'display');
				};
				
				// Are we reading last data from DOM or the data object?
				if(src === 'dom' || ((!src || src === 'auto') && row.src === 'dom')) {
					// Read the data from the DOM
					row._aData = _fnGetRowElements(
						settings, row, colIdx, colIdx === undefined ? undefined : row._aData
					)
						.data;
				} else {
					// Reading from data object, update the DOM
					var cells = row.anCells;
					
					if(cells) {
						if(colIdx !== undefined) {
							cellWrite(cells[colIdx], colIdx);
						} else {
							for(i = 0, ien = cells.length; i < ien; i++) {
								cellWrite(cells[i], i);
							}
						}
					}
				}
				
				// For both row and cell invalidation, the cached data for sorting and
				// filtering is nulled out
				row._aSortData = null;
				row._aFilterData = null;
				
				// Invalidate the type for a specific column (if given) or all columns since
				// the data might have changed
				var cols = settings.aoColumns;
				if(colIdx !== undefined) {
					cols[colIdx].sType = null;
				} else {
					for(i = 0, ien = cols.length; i < ien; i++) {
						cols[i].sType = null;
					}
					
					// Update DataTables special `DT_*` attributes for the row
					_fnRowAttributes(settings, row);
				}
			}
			
			
			/**
			 * Build a data source object from an HTML row, reading the contents of the
			 * cells that are in the row.
			 *
			 * @param {object} settings DataTables settings object
			 * @param {node|object} TR element from which to read data or existing row
			 *   object from which to re-read the data from the cells
			 * @param {int} [colIdx] Optional column index
			 * @param {array|object} [d] Data source object. If `colIdx` is given then this
			 *   parameter should also be given and will be used to write the data into.
			 *   Only the column in question will be written
			 * @returns {object} Object with two parameters: `data` the data read, in
			 *   document order, and `cells` and array of nodes (they can be useful to the
			 *   caller, so rather than needing a second traversal to get them, just return
			 *   them from here).
			 * @memberof DataTable#oApi
			 */
			function _fnGetRowElements(settings, row, colIdx, d) {
				var
					tds = [],
					td = row.firstChild,
					name, col, o, i = 0, contents,
					columns = settings.aoColumns,
					objectRead = settings._rowReadObject;
				
				// Allow the data object to be passed in, or construct
				d = d !== undefined ?
					d :
					objectRead ?
						{} :
						[];
				
				var attr = function(str, td) {
					if(typeof str === 'string') {
						var idx = str.indexOf('@');
						
						if(idx !== -1) {
							var attr = str.substring(idx + 1);
							var setter = _fnSetObjectDataFn(str);
							setter(d, td.getAttribute(attr));
						}
					}
				};
				
				// Read data from a cell and store into the data object
				var cellProcess = function(cell) {
					if(colIdx === undefined || colIdx === i) {
						col = columns[i];
						contents = $.trim(cell.innerHTML);
						
						if(col && col._bAttrSrc) {
							var setter = _fnSetObjectDataFn(col.mData._);
							setter(d, contents);
							
							attr(col.mData.sort, cell);
							attr(col.mData.type, cell);
							attr(col.mData.filter, cell);
						} else {
							// Depending on the `data` option for the columns the data can
							// be read to either an object or an array.
							if(objectRead) {
								if(!col._setter) {
									// Cache the setter function
									col._setter = _fnSetObjectDataFn(col.mData);
								}
								col._setter(d, contents);
							} else {
								d[i] = contents;
							}
						}
					}
					
					i++;
				};
				
				if(td) {
					// `tr` element was passed in
					while(td) {
						name = td.nodeName.toUpperCase();
						
						if(name == "TD" || name == "TH") {
							cellProcess(td);
							tds.push(td);
						}
						
						td = td.nextSibling;
					}
				} else {
					// Existing row object passed in
					tds = row.anCells;
					
					for(var j = 0, jen = tds.length; j < jen; j++) {
						cellProcess(tds[j]);
					}
				}
				
				// Read the ID from the DOM if present
				var rowNode = row.firstChild ? row : row.nTr;
				
				if(rowNode) {
					var id = rowNode.getAttribute('id');
					
					if(id) {
						_fnSetObjectDataFn(settings.rowId)(d, id);
					}
				}
				
				return {
					data: d,
					cells: tds
				};
			}
			
			/**
			 * Create a new TR element (and it's TD children) for a row
			 *  @param {object} oSettings dataTables settings object
			 *  @param {int} iRow Row to consider
			 *  @param {node} [nTrIn] TR element to add to the table - optional. If not given,
			 *    DataTables will create a row automatically
			 *  @param {array} [anTds] Array of TD|TH elements for the row - must be given
			 *    if nTr is.
			 *  @memberof DataTable#oApi
			 */
			function _fnCreateTr(oSettings, iRow, nTrIn, anTds) {
				var
					row = oSettings.aoData[iRow],
					rowData = row._aData,
					cells = [],
					nTr, nTd, oCol,
					i, iLen;
				
				if(row.nTr === null) {
					nTr = nTrIn || document.createElement('tr');
					
					row.nTr = nTr;
					row.anCells = cells;
					
					/* Use a private property on the node to allow reserve mapping from the node
			 * to the aoData array for fast look up
			 */
					nTr._DT_RowIndex = iRow;
					
					/* Special parameters can be given by the data source to be used on the row */
					_fnRowAttributes(oSettings, row);
					
					/* Process each column */
					for(i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
						oCol = oSettings.aoColumns[i];
						
						nTd = nTrIn ? anTds[i] : document.createElement(oCol.sCellType);
						nTd._DT_CellIndex = {
							row: iRow,
							column: i
						};
						
						cells.push(nTd);
						
						// Need to create the HTML if new, or if a rendering function is defined
						if((!nTrIn || oCol.mRender || oCol.mData !== i) &&
							(!$.isPlainObject(oCol.mData) || oCol.mData._ !== i + '.display')
						) {
							nTd.innerHTML = _fnGetCellData(oSettings, iRow, i, 'display');
						}
						
						/* Add user defined class */
						if(oCol.sClass) {
							nTd.className += ' ' + oCol.sClass;
						}
						
						// Visibility - add or remove as required
						if(oCol.bVisible && !nTrIn) {
							nTr.appendChild(nTd);
						} else if(!oCol.bVisible && nTrIn) {
							nTd.parentNode.removeChild(nTd);
						}
						
						if(oCol.fnCreatedCell) {
							oCol.fnCreatedCell.call(oSettings.oInstance,
								nTd, _fnGetCellData(oSettings, iRow, i), rowData, iRow, i
							);
						}
					}
					
					_fnCallbackFire(oSettings, 'aoRowCreatedCallback', null, [nTr, rowData, iRow, cells]);
				}
				
				// Remove once webkit bug 131819 and Chromium bug 365619 have been resolved
				// and deployed
				row.nTr.setAttribute('role', 'row');
			}
			
			
			/**
			 * Add attributes to a row based on the special `DT_*` parameters in a data
			 * source object.
			 *  @param {object} settings DataTables settings object
			 *  @param {object} DataTables row object for the row to be modified
			 *  @memberof DataTable#oApi
			 */
			function _fnRowAttributes(settings, row) {
				var tr = row.nTr;
				var data = row._aData;
				
				if(tr) {
					var id = settings.rowIdFn(data);
					
					if(id) {
						tr.id = id;
					}
					
					if(data.DT_RowClass) {
						// Remove any classes added by DT_RowClass before
						var a = data.DT_RowClass.split(' ');
						row.__rowc = row.__rowc ?
							_unique(row.__rowc.concat(a)) :
							a;
						
						$(tr)
							.removeClass(row.__rowc.join(' '))
							.addClass(data.DT_RowClass);
					}
					
					if(data.DT_RowAttr) {
						$(tr).attr(data.DT_RowAttr);
					}
					
					if(data.DT_RowData) {
						$(tr).data(data.DT_RowData);
					}
				}
			}
			
			
			/**
			 * Create the HTML header for the table
			 *  @param {object} oSettings dataTables settings object
			 *  @memberof DataTable#oApi
			 */
			function _fnBuildHead(oSettings) {
				var i, ien, cell, row, column;
				var thead = oSettings.nTHead;
				var tfoot = oSettings.nTFoot;
				var createHeader = $('th, td', thead).length === 0;
				var classes = oSettings.oClasses;
				var columns = oSettings.aoColumns;
				
				if(createHeader) {
					row = $('<tr/>').appendTo(thead);
				}
				
				for(i = 0, ien = columns.length; i < ien; i++) {
					column = columns[i];
					cell = $(column.nTh).addClass(column.sClass);
					
					if(createHeader) {
						cell.appendTo(row);
					}
					
					// 1.11 move into sorting
					if(oSettings.oFeatures.bSort) {
						cell.addClass(column.sSortingClass);
						
						if(column.bSortable !== false) {
							cell
								.attr('tabindex', oSettings.iTabIndex)
								.attr('aria-controls', oSettings.sTableId);
							
							_fnSortAttachListener(oSettings, column.nTh, i);
						}
					}
					
					if(column.sTitle != cell[0].innerHTML) {
						cell.html(column.sTitle);
					}
					
					_fnRenderer(oSettings, 'header')(
						oSettings, cell, column, classes
					);
				}
				
				if(createHeader) {
					_fnDetectHeader(oSettings.aoHeader, thead);
				}
				
				/* ARIA role for the rows */
				$(thead).find('>tr').attr('role', 'row');
				
				/* Deal with the footer - add classes if required */
				$(thead).find('>tr>th, >tr>td').addClass(classes.sHeaderTH);
				$(tfoot).find('>tr>th, >tr>td').addClass(classes.sFooterTH);
				
				// Cache the footer cells. Note that we only take the cells from the first
				// row in the footer. If there is more than one row the user wants to
				// interact with, they need to use the table().foot() method. Note also this
				// allows cells to be used for multiple columns using colspan
				if(tfoot !== null) {
					var cells = oSettings.aoFooter[0];
					
					for(i = 0, ien = cells.length; i < ien; i++) {
						column = columns[i];
						column.nTf = cells[i].cell;
						
						if(column.sClass) {
							$(column.nTf).addClass(column.sClass);
						}
					}
				}
			}
			
			
			/**
			 * Draw the header (or footer) element based on the column visibility states. The
			 * methodology here is to use the layout array from _fnDetectHeader, modified for
			 * the instantaneous column visibility, to construct the new layout. The grid is
			 * traversed over cell at a time in a rows x columns grid fashion, although each
			 * cell insert can cover multiple elements in the grid - which is tracks using the
			 * aApplied array. Cell inserts in the grid will only occur where there isn't
			 * already a cell in that position.
			 *  @param {object} oSettings dataTables settings object
			 *  @param array {objects} aoSource Layout array from _fnDetectHeader
			 *  @param {boolean} [bIncludeHidden=false] If true then include the hidden columns in the calc,
			 *  @memberof DataTable#oApi
			 */
			function _fnDrawHead(oSettings, aoSource, bIncludeHidden) {
				var i, iLen, j, jLen, k, kLen, n, nLocalTr;
				var aoLocal = [];
				var aApplied = [];
				var iColumns = oSettings.aoColumns.length;
				var iRowspan, iColspan;
				
				if(!aoSource) {
					return;
				}
				
				if(bIncludeHidden === undefined) {
					bIncludeHidden = false;
				}
				
				/* Make a copy of the master layout array, but without the visible columns in it */
				for(i = 0, iLen = aoSource.length; i < iLen; i++) {
					aoLocal[i] = aoSource[i].slice();
					aoLocal[i].nTr = aoSource[i].nTr;
					
					/* Remove any columns which are currently hidden */
					for(j = iColumns - 1; j >= 0; j--) {
						if(!oSettings.aoColumns[j].bVisible && !bIncludeHidden) {
							aoLocal[i].splice(j, 1);
						}
					}
					
					/* Prep the applied array - it needs an element for each row */
					aApplied.push([]);
				}
				
				for(i = 0, iLen = aoLocal.length; i < iLen; i++) {
					nLocalTr = aoLocal[i].nTr;
					
					/* All cells are going to be replaced, so empty out the row */
					if(nLocalTr) {
						while((n = nLocalTr.firstChild)) {
							nLocalTr.removeChild(n);
						}
					}
					
					for(j = 0, jLen = aoLocal[i].length; j < jLen; j++) {
						iRowspan = 1;
						iColspan = 1;
						
						/* Check to see if there is already a cell (row/colspan) covering our target
				 * insert point. If there is, then there is nothing to do.
				 */
						if(aApplied[i][j] === undefined) {
							nLocalTr.appendChild(aoLocal[i][j].cell);
							aApplied[i][j] = 1;
							
							/* Expand the cell to cover as many rows as needed */
							while(aoLocal[i + iRowspan] !== undefined &&
							aoLocal[i][j].cell == aoLocal[i + iRowspan][j].cell) {
								aApplied[i + iRowspan][j] = 1;
								iRowspan++;
							}
							
							/* Expand the cell to cover as many columns as needed */
							while(aoLocal[i][j + iColspan] !== undefined &&
							aoLocal[i][j].cell == aoLocal[i][j + iColspan].cell) {
								/* Must update the applied array over the rows for the columns */
								for(k = 0; k < iRowspan; k++) {
									aApplied[i + k][j + iColspan] = 1;
								}
								iColspan++;
							}
							
							/* Do the actual expansion in the DOM */
							$(aoLocal[i][j].cell)
								.attr('rowspan', iRowspan)
								.attr('colspan', iColspan);
						}
					}
				}
			}
			
			
			/**
			 * Insert the required TR nodes into the table for display
			 *  @param {object} oSettings dataTables settings object
			 *  @memberof DataTable#oApi
			 */
			function _fnDraw(oSettings) {
				/* Provide a pre-callback function which can be used to cancel the draw is false is returned */
				var aPreDraw = _fnCallbackFire(oSettings, 'aoPreDrawCallback', 'preDraw', [oSettings]);
				if($.inArray(false, aPreDraw) !== -1) {
					_fnProcessingDisplay(oSettings, false);
					return;
				}
				
				var i, iLen, n;
				var anRows = [];
				var iRowCount = 0;
				var asStripeClasses = oSettings.asStripeClasses;
				var iStripes = asStripeClasses.length;
				var iOpenRows = oSettings.aoOpenRows.length;
				var oLang = oSettings.oLanguage;
				var iInitDisplayStart = oSettings.iInitDisplayStart;
				var bServerSide = _fnDataSource(oSettings) == 'ssp';
				var aiDisplay = oSettings.aiDisplay;
				
				oSettings.bDrawing = true;
				
				/* Check and see if we have an initial draw position from state saving */
				if(iInitDisplayStart !== undefined && iInitDisplayStart !== -1) {
					oSettings._iDisplayStart = bServerSide ?
						iInitDisplayStart :
						iInitDisplayStart >= oSettings.fnRecordsDisplay() ?
							0 :
							iInitDisplayStart;
					
					oSettings.iInitDisplayStart = -1;
				}
				
				var iDisplayStart = oSettings._iDisplayStart;
				var iDisplayEnd = oSettings.fnDisplayEnd();
				
				/* Server-side processing draw intercept */
				if(oSettings.bDeferLoading) {
					oSettings.bDeferLoading = false;
					oSettings.iDraw++;
					_fnProcessingDisplay(oSettings, false);
				} else if(!bServerSide) {
					oSettings.iDraw++;
				} else if(!oSettings.bDestroying && !_fnAjaxUpdate(oSettings)) {
					return;
				}
				
				if(aiDisplay.length !== 0) {
					var iStart = bServerSide ? 0 : iDisplayStart;
					var iEnd = bServerSide ? oSettings.aoData.length : iDisplayEnd;
					
					for(var j = iStart; j < iEnd; j++) {
						var iDataIndex = aiDisplay[j];
						var aoData = oSettings.aoData[iDataIndex];
						if(aoData.nTr === null) {
							_fnCreateTr(oSettings, iDataIndex);
						}
						
						var nRow = aoData.nTr;
						
						/* Remove the old striping classes and then add the new one */
						if(iStripes !== 0) {
							var sStripe = asStripeClasses[iRowCount % iStripes];
							if(aoData._sRowStripe != sStripe) {
								$(nRow).removeClass(aoData._sRowStripe).addClass(sStripe);
								aoData._sRowStripe = sStripe;
							}
						}
						
						// Row callback functions - might want to manipulate the row
						// iRowCount and j are not currently documented. Are they at all
						// useful?
						_fnCallbackFire(oSettings, 'aoRowCallback', null,
							[nRow, aoData._aData, iRowCount, j, iDataIndex]);
						
						anRows.push(nRow);
						iRowCount++;
					}
				} else {
					/* Table is empty - create a row with an empty message in it */
					var sZero = oLang.sZeroRecords;
					if(oSettings.iDraw == 1 && _fnDataSource(oSettings) == 'ajax') {
						sZero = oLang.sLoadingRecords;
					} else if(oLang.sEmptyTable && oSettings.fnRecordsTotal() === 0) {
						sZero = oLang.sEmptyTable;
					}
					
					anRows[0] = $('<tr/>', {'class': iStripes ? asStripeClasses[0] : ''})
						.append($('<td />', {
							'valign': 'top',
							'colSpan': _fnVisbleColumns(oSettings),
							'class': oSettings.oClasses.sRowEmpty
						}).html(sZero))[0];
				}
				
				/* Header and footer callbacks */
				_fnCallbackFire(oSettings, 'aoHeaderCallback', 'header', [$(oSettings.nTHead).children('tr')[0],
					_fnGetDataMaster(oSettings), iDisplayStart, iDisplayEnd, aiDisplay]);
				
				_fnCallbackFire(oSettings, 'aoFooterCallback', 'footer', [$(oSettings.nTFoot).children('tr')[0],
					_fnGetDataMaster(oSettings), iDisplayStart, iDisplayEnd, aiDisplay]);
				
				var body = $(oSettings.nTBody);
				
				body.children().detach();
				body.append($(anRows));
				
				/* Call all required callback functions for the end of a draw */
				_fnCallbackFire(oSettings, 'aoDrawCallback', 'draw', [oSettings]);
				
				/* Draw is complete, sorting and filtering must be as well */
				oSettings.bSorted = false;
				oSettings.bFiltered = false;
				oSettings.bDrawing = false;
			}
			
			
			/**
			 * Redraw the table - taking account of the various features which are enabled
			 *  @param {object} oSettings dataTables settings object
			 *  @param {boolean} [holdPosition] Keep the current paging position. By default
			 *    the paging is reset to the first page
			 *  @memberof DataTable#oApi
			 */
			function _fnReDraw(settings, holdPosition) {
				var
					features = settings.oFeatures,
					sort = features.bSort,
					filter = features.bFilter;
				
				if(sort) {
					_fnSort(settings);
				}
				
				if(filter) {
					_fnFilterComplete(settings, settings.oPreviousSearch);
				} else {
					// No filtering, so we want to just use the display master
					settings.aiDisplay = settings.aiDisplayMaster.slice();
				}
				
				if(holdPosition !== true) {
					settings._iDisplayStart = 0;
				}
				
				// Let any modules know about the draw hold position state (used by
				// scrolling internally)
				settings._drawHold = holdPosition;
				
				_fnDraw(settings);
				
				settings._drawHold = false;
			}
			
			
			/**
			 * Add the options to the page HTML for the table
			 *  @param {object} oSettings dataTables settings object
			 *  @memberof DataTable#oApi
			 */
			function _fnAddOptionsHtml(oSettings) {
				var classes = oSettings.oClasses;
				var table = $(oSettings.nTable);
				var holding = $('<div/>').insertBefore(table); // Holding element for speed
				var features = oSettings.oFeatures;
				
				// All DataTables are wrapped in a div
				var insert = $('<div/>', {
					id: oSettings.sTableId + '_wrapper',
					'class': classes.sWrapper + (oSettings.nTFoot ? '' : ' ' + classes.sNoFooter)
				});
				
				oSettings.nHolding = holding[0];
				oSettings.nTableWrapper = insert[0];
				oSettings.nTableReinsertBefore = oSettings.nTable.nextSibling;
				
				/* Loop over the user set positioning and place the elements as needed */
				var aDom = oSettings.sDom.split('');
				var featureNode, cOption, nNewNode, cNext, sAttr, j;
				for(var i = 0; i < aDom.length; i++) {
					featureNode = null;
					cOption = aDom[i];
					
					if(cOption == '<') {
						/* New container div */
						nNewNode = $('<div/>')[0];
						
						/* Check to see if we should append an id and/or a class name to the container */
						cNext = aDom[i + 1];
						if(cNext == "'" || cNext == '"') {
							sAttr = "";
							j = 2;
							while(aDom[i + j] != cNext) {
								sAttr += aDom[i + j];
								j++;
							}
							
							/* Replace jQuery UI constants @todo depreciated */
							if(sAttr == "H") {
								sAttr = classes.sJUIHeader;
							} else if(sAttr == "F") {
								sAttr = classes.sJUIFooter;
							}
							
							/* The attribute can be in the format of "#id.class", "#id" or "class" This logic
					 * breaks the string into parts and applies them as needed
					 */
							if(sAttr.indexOf('.') != -1) {
								var aSplit = sAttr.split('.');
								nNewNode.id = aSplit[0].substr(1, aSplit[0].length - 1);
								nNewNode.className = aSplit[1];
							} else if(sAttr.charAt(0) == "#") {
								nNewNode.id = sAttr.substr(1, sAttr.length - 1);
							} else {
								nNewNode.className = sAttr;
							}
							
							i += j; /* Move along the position array */
						}
						
						insert.append(nNewNode);
						insert = $(nNewNode);
					} else if(cOption == '>') {
						/* End container div */
						insert = insert.parent();
					}
					// @todo Move options into their own plugins?
					else if(cOption == 'l' && features.bPaginate && features.bLengthChange) {
						/* Length */
						featureNode = _fnFeatureHtmlLength(oSettings);
					} else if(cOption == 'f' && features.bFilter) {
						/* Filter */
						featureNode = _fnFeatureHtmlFilter(oSettings);
					} else if(cOption == 'r' && features.bProcessing) {
						/* pRocessing */
						featureNode = _fnFeatureHtmlProcessing(oSettings);
					} else if(cOption == 't') {
						/* Table */
						featureNode = _fnFeatureHtmlTable(oSettings);
					} else if(cOption == 'i' && features.bInfo) {
						/* Info */
						featureNode = _fnFeatureHtmlInfo(oSettings);
					} else if(cOption == 'p' && features.bPaginate) {
						/* Pagination */
						featureNode = _fnFeatureHtmlPaginate(oSettings);
					} else if(DataTable.ext.feature.length !== 0) {
						/* Plug-in features */
						var aoFeatures = DataTable.ext.feature;
						for(var k = 0, kLen = aoFeatures.length; k < kLen; k++) {
							if(cOption == aoFeatures[k].cFeature) {
								featureNode = aoFeatures[k].fnInit(oSettings);
								break;
							}
						}
					}
					
					/* Add to the 2D features array */
					if(featureNode) {
						var aanFeatures = oSettings.aanFeatures;
						
						if(!aanFeatures[cOption]) {
							aanFeatures[cOption] = [];
						}
						
						aanFeatures[cOption].push(featureNode);
						insert.append(featureNode);
					}
				}
				
				/* Built our DOM structure - replace the holding div with what we want */
				holding.replaceWith(insert);
				oSettings.nHolding = null;
			}
			
			
			/**
			 * Use the DOM source to create up an array of header cells. The idea here is to
			 * create a layout grid (array) of rows x columns, which contains a reference
			 * to the cell that that point in the grid (regardless of col/rowspan), such that
			 * any column / row could be removed and the new grid constructed
			 *  @param array {object} aLayout Array to store the calculated layout in
			 *  @param {node} nThead The header/footer element for the table
			 *  @memberof DataTable#oApi
			 */
			function _fnDetectHeader(aLayout, nThead) {
				var nTrs = $(nThead).children('tr');
				var nTr, nCell;
				var i, k, l, iLen, jLen, iColShifted, iColumn, iColspan, iRowspan;
				var bUnique;
				var fnShiftCol = function(a, i, j) {
					var k = a[i];
					while(k[j]) {
						j++;
					}
					return j;
				};
				
				aLayout.splice(0, aLayout.length);
				
				/* We know how many rows there are in the layout - so prep it */
				for(i = 0, iLen = nTrs.length; i < iLen; i++) {
					aLayout.push([]);
				}
				
				/* Calculate a layout array */
				for(i = 0, iLen = nTrs.length; i < iLen; i++) {
					nTr = nTrs[i];
					iColumn = 0;
					
					/* For every cell in the row... */
					nCell = nTr.firstChild;
					while(nCell) {
						if(nCell.nodeName.toUpperCase() == "TD" ||
							nCell.nodeName.toUpperCase() == "TH") {
							/* Get the col and rowspan attributes from the DOM and sanitise them */
							iColspan = nCell.getAttribute('colspan') * 1;
							iRowspan = nCell.getAttribute('rowspan') * 1;
							iColspan = (!iColspan || iColspan === 0 || iColspan === 1) ? 1 : iColspan;
							iRowspan = (!iRowspan || iRowspan === 0 || iRowspan === 1) ? 1 : iRowspan;
							
							/* There might be colspan cells already in this row, so shift our target
					 * accordingly
					 */
							iColShifted = fnShiftCol(aLayout, i, iColumn);
							
							/* Cache calculation for unique columns */
							bUnique = iColspan === 1 ? true : false;
							
							/* If there is col / rowspan, copy the information into the layout grid */
							for(l = 0; l < iColspan; l++) {
								for(k = 0; k < iRowspan; k++) {
									aLayout[i + k][iColShifted + l] = {
										"cell": nCell,
										"unique": bUnique
									};
									aLayout[i + k].nTr = nTr;
								}
							}
						}
						nCell = nCell.nextSibling;
					}
				}
			}
			
			
			/**
			 * Get an array of unique th elements, one for each column
			 *  @param {object} oSettings dataTables settings object
			 *  @param {node} nHeader automatically detect the layout from this node - optional
			 *  @param {array} aLayout thead/tfoot layout from _fnDetectHeader - optional
			 *  @returns array {node} aReturn list of unique th's
			 *  @memberof DataTable#oApi
			 */
			function _fnGetUniqueThs(oSettings, nHeader, aLayout) {
				var aReturn = [];
				if(!aLayout) {
					aLayout = oSettings.aoHeader;
					if(nHeader) {
						aLayout = [];
						_fnDetectHeader(aLayout, nHeader);
					}
				}
				
				for(var i = 0, iLen = aLayout.length; i < iLen; i++) {
					for(var j = 0, jLen = aLayout[i].length; j < jLen; j++) {
						if(aLayout[i][j].unique &&
							(!aReturn[j] || !oSettings.bSortCellsTop)) {
							aReturn[j] = aLayout[i][j].cell;
						}
					}
				}
				
				return aReturn;
			}
			
			/**
			 * Create an Ajax call based on the table's settings, taking into account that
			 * parameters can have multiple forms, and backwards compatibility.
			 *
			 * @param {object} oSettings dataTables settings object
			 * @param {array} data Data to send to the server, required by
			 *     DataTables - may be augmented by developer callbacks
			 * @param {function} fn Callback function to run when data is obtained
			 */
			function _fnBuildAjax(oSettings, data, fn) {
				// Compatibility with 1.9-, allow fnServerData and event to manipulate
				_fnCallbackFire(oSettings, 'aoServerParams', 'serverParams', [data]);
				
				// Convert to object based for 1.10+ if using the old array scheme which can
				// come from server-side processing or serverParams
				if(data && $.isArray(data)) {
					var tmp = {};
					var rbracket = /(.*?)\[\]$/;
					
					$.each(data, function(key, val) {
						var match = val.name.match(rbracket);
						
						if(match) {
							// Support for arrays
							var name = match[0];
							
							if(!tmp[name]) {
								tmp[name] = [];
							}
							tmp[name].push(val.value);
						} else {
							tmp[val.name] = val.value;
						}
					});
					data = tmp;
				}
				
				var ajaxData;
				var ajax = oSettings.ajax;
				var instance = oSettings.oInstance;
				var callback = function(json) {
					_fnCallbackFire(oSettings, null, 'xhr', [oSettings, json, oSettings.jqXHR]);
					fn(json);
				};
				
				if($.isPlainObject(ajax) && ajax.data) {
					ajaxData = ajax.data;
					
					var newData = typeof ajaxData === 'function' ?
						ajaxData(data, oSettings) :  // fn can manipulate data or return
						ajaxData;                      // an object object or array to merge
					
					// If the function returned something, use that alone
					data = typeof ajaxData === 'function' && newData ?
						newData :
						$.extend(true, data, newData);
					
					// Remove the data property as we've resolved it already and don't want
					// jQuery to do it again (it is restored at the end of the function)
					delete ajax.data;
				}
				
				var baseAjax = {
					"data": data,
					"success": function(json) {
						var error = json.error || json.sError;
						if(error) {
							_fnLog(oSettings, 0, error);
						}
						
						oSettings.json = json;
						callback(json);
					},
					"dataType": "json",
					"cache": false,
					"type": oSettings.sServerMethod,
					"error": function(xhr, error, thrown) {
						var ret = _fnCallbackFire(oSettings, null, 'xhr', [oSettings, null, oSettings.jqXHR]);
						
						if($.inArray(true, ret) === -1) {
							if(error == "parsererror") {
								_fnLog(oSettings, 0, 'Invalid JSON response', 1);
							} else if(xhr.readyState === 4) {
								_fnLog(oSettings, 0, 'Ajax error', 7);
							}
						}
						
						_fnProcessingDisplay(oSettings, false);
					}
				};
				
				// Store the data submitted for the API
				oSettings.oAjaxData = data;
				
				// Allow plug-ins and external processes to modify the data
				_fnCallbackFire(oSettings, null, 'preXhr', [oSettings, data]);
				
				if(oSettings.fnServerData) {
					// DataTables 1.9- compatibility
					oSettings.fnServerData.call(instance,
						oSettings.sAjaxSource,
						$.map(data, function(val, key) { // Need to convert back to 1.9 trad format
							return {name: key, value: val};
						}),
						callback,
						oSettings
					);
				} else if(oSettings.sAjaxSource || typeof ajax === 'string') {
					// DataTables 1.9- compatibility
					oSettings.jqXHR = $.ajax($.extend(baseAjax, {
						url: ajax || oSettings.sAjaxSource
					}));
				} else if(typeof ajax === 'function') {
					// Is a function - let the caller define what needs to be done
					oSettings.jqXHR = ajax.call(instance, data, callback, oSettings);
				} else {
					// Object to extend the base settings
					oSettings.jqXHR = $.ajax($.extend(baseAjax, ajax));
					
					// Restore for next time around
					ajax.data = ajaxData;
				}
			}
			
			
			/**
			 * Update the table using an Ajax call
			 *  @param {object} settings dataTables settings object
			 *  @returns {boolean} Block the table drawing or not
			 *  @memberof DataTable#oApi
			 */
			function _fnAjaxUpdate(settings) {
				if(settings.bAjaxDataGet) {
					settings.iDraw++;
					_fnProcessingDisplay(settings, true);
					
					_fnBuildAjax(
						settings,
						_fnAjaxParameters(settings),
						function(json) {
							_fnAjaxUpdateDraw(settings, json);
						}
					);
					
					return false;
				}
				return true;
			}
			
			
			/**
			 * Build up the parameters in an object needed for a server-side processing
			 * request. Note that this is basically done twice, is different ways - a modern
			 * method which is used by default in DataTables 1.10 which uses objects and
			 * arrays, or the 1.9- method with is name / value pairs. 1.9 method is used if
			 * the sAjaxSource option is used in the initialisation, or the legacyAjax
			 * option is set.
			 *  @param {object} oSettings dataTables settings object
			 *  @returns {bool} block the table drawing or not
			 *  @memberof DataTable#oApi
			 */
			function _fnAjaxParameters(settings) {
				var
					columns = settings.aoColumns,
					columnCount = columns.length,
					features = settings.oFeatures,
					preSearch = settings.oPreviousSearch,
					preColSearch = settings.aoPreSearchCols,
					i, data = [], dataProp, column, columnSearch,
					sort = _fnSortFlatten(settings),
					displayStart = settings._iDisplayStart,
					displayLength = features.bPaginate !== false ?
						settings._iDisplayLength :
						-1;
				
				var param = function(name, value) {
					data.push({'name': name, 'value': value});
				};
				
				// DataTables 1.9- compatible method
				param('sEcho', settings.iDraw);
				param('iColumns', columnCount);
				param('sColumns', _pluck(columns, 'sName').join(','));
				param('iDisplayStart', displayStart);
				param('iDisplayLength', displayLength);
				
				// DataTables 1.10+ method
				var d = {
					draw: settings.iDraw,
					columns: [],
					order: [],
					start: displayStart,
					length: displayLength,
					search: {
						value: preSearch.sSearch,
						regex: preSearch.bRegex
					}
				};
				
				for(i = 0; i < columnCount; i++) {
					column = columns[i];
					columnSearch = preColSearch[i];
					dataProp = typeof column.mData == "function" ? 'function' : column.mData;
					
					d.columns.push({
						data: dataProp,
						name: column.sName,
						searchable: column.bSearchable,
						orderable: column.bSortable,
						search: {
							value: columnSearch.sSearch,
							regex: columnSearch.bRegex
						}
					});
					
					param("mDataProp_" + i, dataProp);
					
					if(features.bFilter) {
						param('sSearch_' + i, columnSearch.sSearch);
						param('bRegex_' + i, columnSearch.bRegex);
						param('bSearchable_' + i, column.bSearchable);
					}
					
					if(features.bSort) {
						param('bSortable_' + i, column.bSortable);
					}
				}
				
				if(features.bFilter) {
					param('sSearch', preSearch.sSearch);
					param('bRegex', preSearch.bRegex);
				}
				
				if(features.bSort) {
					$.each(sort, function(i, val) {
						d.order.push({column: val.col, dir: val.dir});
						
						param('iSortCol_' + i, val.col);
						param('sSortDir_' + i, val.dir);
					});
					
					param('iSortingCols', sort.length);
				}
				
				// If the legacy.ajax parameter is null, then we automatically decide which
				// form to use, based on sAjaxSource
				var legacy = DataTable.ext.legacy.ajax;
				if(legacy === null) {
					return settings.sAjaxSource ? data : d;
				}
				
				// Otherwise, if legacy has been specified then we use that to decide on the
				// form
				return legacy ? data : d;
			}
			
			
			/**
			 * Data the data from the server (nuking the old) and redraw the table
			 *  @param {object} oSettings dataTables settings object
			 *  @param {object} json json data return from the server.
			 *  @param {string} json.sEcho Tracking flag for DataTables to match requests
			 *  @param {int} json.iTotalRecords Number of records in the data set, not accounting for filtering
			 *  @param {int} json.iTotalDisplayRecords Number of records in the data set, accounting for filtering
			 *  @param {array} json.aaData The data to display on this page
			 *  @param {string} [json.sColumns] Column ordering (sName, comma separated)
			 *  @memberof DataTable#oApi
			 */
			function _fnAjaxUpdateDraw(settings, json) {
				// v1.10 uses camelCase variables, while 1.9 uses Hungarian notation.
				// Support both
				var compat = function(old, modern) {
					return json[old] !== undefined ? json[old] : json[modern];
				};
				
				var data = _fnAjaxDataSrc(settings, json);
				var draw = compat('sEcho', 'draw');
				var recordsTotal = compat('iTotalRecords', 'recordsTotal');
				var recordsFiltered = compat('iTotalDisplayRecords', 'recordsFiltered');
				
				if(draw) {
					// Protect against out of sequence returns
					if(draw * 1 < settings.iDraw) {
						return;
					}
					settings.iDraw = draw * 1;
				}
				
				_fnClearTable(settings);
				settings._iRecordsTotal = parseInt(recordsTotal, 10);
				settings._iRecordsDisplay = parseInt(recordsFiltered, 10);
				
				for(var i = 0, ien = data.length; i < ien; i++) {
					_fnAddData(settings, data[i]);
				}
				settings.aiDisplay = settings.aiDisplayMaster.slice();
				
				settings.bAjaxDataGet = false;
				_fnDraw(settings);
				
				if(!settings._bInitComplete) {
					_fnInitComplete(settings, json);
				}
				
				settings.bAjaxDataGet = true;
				_fnProcessingDisplay(settings, false);
			}
			
			
			/**
			 * Get the data from the JSON data source to use for drawing a table. Using
			 * `_fnGetObjectDataFn` allows the data to be sourced from a property of the
			 * source object, or from a processing function.
			 *  @param {object} oSettings dataTables settings object
			 *  @param  {object} json Data source object / array from the server
			 *  @return {array} Array of data to use
			 */
			function _fnAjaxDataSrc(oSettings, json) {
				var dataSrc = $.isPlainObject(oSettings.ajax) && oSettings.ajax.dataSrc !== undefined ?
					oSettings.ajax.dataSrc :
					oSettings.sAjaxDataProp; // Compatibility with 1.9-.
				
				// Compatibility with 1.9-. In order to read from aaData, check if the
				// default has been changed, if not, check for aaData
				if(dataSrc === 'data') {
					return json.aaData || json[dataSrc];
				}
				
				return dataSrc !== "" ?
					_fnGetObjectDataFn(dataSrc)(json) :
					json;
			}
			
			/**
			 * Generate the node required for filtering text
			 *  @returns {node} Filter control element
			 *  @param {object} oSettings dataTables settings object
			 *  @memberof DataTable#oApi
			 */
			function _fnFeatureHtmlFilter(settings) {
				var classes = settings.oClasses;
				var tableId = settings.sTableId;
				var language = settings.oLanguage;
				var previousSearch = settings.oPreviousSearch;
				var features = settings.aanFeatures;
				var input = '<input type="search" class="' + classes.sFilterInput + '"/>';
				
				var str = language.sSearch;
				str = str.match(/_INPUT_/) ?
					str.replace('_INPUT_', input) :
					str + input;
				
				var filter = $('<div/>', {
					'id': !features.f ? tableId + '_filter' : null,
					'class': classes.sFilter
				})
					.append($('<label/>').append(str));
				
				var searchFn = function() {
					/* Update all other filter input elements for the new display */
					var n = features.f;
					var val = !this.value ? "" : this.value; // mental IE8 fix :-(
					
					/* Now do the filter */
					if(val != previousSearch.sSearch) {
						_fnFilterComplete(settings, {
							"sSearch": val,
							"bRegex": previousSearch.bRegex,
							"bSmart": previousSearch.bSmart,
							"bCaseInsensitive": previousSearch.bCaseInsensitive
						});
						
						// Need to redraw, without resorting
						settings._iDisplayStart = 0;
						_fnDraw(settings);
					}
				};
				
				var searchDelay = settings.searchDelay !== null ?
					settings.searchDelay :
					_fnDataSource(settings) === 'ssp' ?
						400 :
						0;
				
				var jqFilter = $('input', filter)
					.val(previousSearch.sSearch)
					.attr('placeholder', language.sSearchPlaceholder)
					.on(
						'keyup.DT search.DT input.DT paste.DT cut.DT',
						searchDelay ?
							_fnThrottle(searchFn, searchDelay) :
							searchFn
					)
					.on('keypress.DT', function(e) {
						/* Prevent form submission */
						if(e.keyCode == 13) {
							return false;
						}
					})
					.attr('aria-controls', tableId);
				
				// Update the input elements whenever the table is filtered
				$(settings.nTable).on('search.dt.DT', function(ev, s) {
					if(settings === s) {
						// IE9 throws an 'unknown error' if document.activeElement is used
						// inside an iframe or frame...
						try {
							if(jqFilter[0] !== document.activeElement) {
								jqFilter.val(previousSearch.sSearch);
							}
						} catch(e) {
						}
					}
				});
				
				return filter[0];
			}
			
			
			/**
			 * Filter the table using both the global filter and column based filtering
			 *  @param {object} oSettings dataTables settings object
			 *  @param {object} oSearch search information
			 *  @param {int} [iForce] force a research of the master array (1) or not (undefined or 0)
			 *  @memberof DataTable#oApi
			 */
			function _fnFilterComplete(oSettings, oInput, iForce) {
				var oPrevSearch = oSettings.oPreviousSearch;
				var aoPrevSearch = oSettings.aoPreSearchCols;
				var fnSaveFilter = function(oFilter) {
					/* Save the filtering values */
					oPrevSearch.sSearch = oFilter.sSearch;
					oPrevSearch.bRegex = oFilter.bRegex;
					oPrevSearch.bSmart = oFilter.bSmart;
					oPrevSearch.bCaseInsensitive = oFilter.bCaseInsensitive;
				};
				var fnRegex = function(o) {
					// Backwards compatibility with the bEscapeRegex option
					return o.bEscapeRegex !== undefined ? !o.bEscapeRegex : o.bRegex;
				};
				
				// Resolve any column types that are unknown due to addition or invalidation
				// @todo As per sort - can this be moved into an event handler?
				_fnColumnTypes(oSettings);
				
				/* In server-side processing all filtering is done by the server, so no point hanging around here */
				if(_fnDataSource(oSettings) != 'ssp') {
					/* Global filter */
					_fnFilter(oSettings, oInput.sSearch, iForce, fnRegex(oInput), oInput.bSmart, oInput.bCaseInsensitive);
					fnSaveFilter(oInput);
					
					/* Now do the individual column filter */
					for(var i = 0; i < aoPrevSearch.length; i++) {
						_fnFilterColumn(oSettings, aoPrevSearch[i].sSearch, i, fnRegex(aoPrevSearch[i]),
							aoPrevSearch[i].bSmart, aoPrevSearch[i].bCaseInsensitive);
					}
					
					/* Custom filtering */
					_fnFilterCustom(oSettings);
				} else {
					fnSaveFilter(oInput);
				}
				
				/* Tell the draw function we have been filtering */
				oSettings.bFiltered = true;
				_fnCallbackFire(oSettings, null, 'search', [oSettings]);
			}
			
			
			/**
			 * Apply custom filtering functions
			 *  @param {object} oSettings dataTables settings object
			 *  @memberof DataTable#oApi
			 */
			function _fnFilterCustom(settings) {
				var filters = DataTable.ext.search;
				var displayRows = settings.aiDisplay;
				var row, rowIdx;
				
				for(var i = 0, ien = filters.length; i < ien; i++) {
					var rows = [];
					
					// Loop over each row and see if it should be included
					for(var j = 0, jen = displayRows.length; j < jen; j++) {
						rowIdx = displayRows[j];
						row = settings.aoData[rowIdx];
						
						if(filters[i](settings, row._aFilterData, rowIdx, row._aData, j)) {
							rows.push(rowIdx);
						}
					}
					
					// So the array reference doesn't break set the results into the
					// existing array
					displayRows.length = 0;
					$.merge(displayRows, rows);
				}
			}
			
			
			/**
			 * Filter the table on a per-column basis
			 *  @param {object} oSettings dataTables settings object
			 *  @param {string} sInput string to filter on
			 *  @param {int} iColumn column to filter
			 *  @param {bool} bRegex treat search string as a regular expression or not
			 *  @param {bool} bSmart use smart filtering or not
			 *  @param {bool} bCaseInsensitive Do case insenstive matching or not
			 *  @memberof DataTable#oApi
			 */
			function _fnFilterColumn(settings, searchStr, colIdx, regex, smart, caseInsensitive) {
				if(searchStr === '') {
					return;
				}
				
				var data;
				var out = [];
				var display = settings.aiDisplay;
				var rpSearch = _fnFilterCreateSearch(searchStr, regex, smart, caseInsensitive);
				
				for(var i = 0; i < display.length; i++) {
					data = settings.aoData[display[i]]._aFilterData[colIdx];
					
					if(rpSearch.test(data)) {
						out.push(display[i]);
					}
				}
				
				settings.aiDisplay = out;
			}
			
			
			/**
			 * Filter the data table based on user input and draw the table
			 *  @param {object} settings dataTables settings object
			 *  @param {string} input string to filter on
			 *  @param {int} force optional - force a research of the master array (1) or not (undefined or 0)
			 *  @param {bool} regex treat as a regular expression or not
			 *  @param {bool} smart perform smart filtering or not
			 *  @param {bool} caseInsensitive Do case insenstive matching or not
			 *  @memberof DataTable#oApi
			 */
			function _fnFilter(settings, input, force, regex, smart, caseInsensitive) {
				var rpSearch = _fnFilterCreateSearch(input, regex, smart, caseInsensitive);
				var prevSearch = settings.oPreviousSearch.sSearch;
				var displayMaster = settings.aiDisplayMaster;
				var display, invalidated, i;
				var filtered = [];
				
				// Need to take account of custom filtering functions - always filter
				if(DataTable.ext.search.length !== 0) {
					force = true;
				}
				
				// Check if any of the rows were invalidated
				invalidated = _fnFilterData(settings);
				
				// If the input is blank - we just want the full data set
				if(input.length <= 0) {
					settings.aiDisplay = displayMaster.slice();
				} else {
					// New search - start from the master array
					if(invalidated ||
						force ||
						prevSearch.length > input.length ||
						input.indexOf(prevSearch) !== 0 ||
						settings.bSorted // On resort, the display master needs to be
					                     // re-filtered since indexes will have changed
					) {
						settings.aiDisplay = displayMaster.slice();
					}
					
					// Search the display array
					display = settings.aiDisplay;
					
					for(i = 0; i < display.length; i++) {
						if(rpSearch.test(settings.aoData[display[i]]._sFilterRow)) {
							filtered.push(display[i]);
						}
					}
					
					settings.aiDisplay = filtered;
				}
			}
			
			
			/**
			 * Build a regular expression object suitable for searching a table
			 *  @param {string} sSearch string to search for
			 *  @param {bool} bRegex treat as a regular expression or not
			 *  @param {bool} bSmart perform smart filtering or not
			 *  @param {bool} bCaseInsensitive Do case insensitive matching or not
			 *  @returns {RegExp} constructed object
			 *  @memberof DataTable#oApi
			 */
			function _fnFilterCreateSearch(search, regex, smart, caseInsensitive) {
				search = regex ?
					search :
					_fnEscapeRegex(search);
				
				if(smart) {
					/* For smart filtering we want to allow the search to work regardless of
			 * word order. We also want double quoted text to be preserved, so word
			 * order is important - a la google. So this is what we want to
			 * generate:
			 *
			 * ^(?=.*?\bone\b)(?=.*?\btwo three\b)(?=.*?\bfour\b).*$
			 */
					var a = $.map(search.match(/"[^"]+"|[^ ]+/g) || [''], function(word) {
						if(word.charAt(0) === '"') {
							var m = word.match(/^"(.*)"$/);
							word = m ? m[1] : word;
						}
						
						return word.replace('"', '');
					});
					
					search = '^(?=.*?' + a.join(')(?=.*?') + ').*$';
				}
				
				return new RegExp(search, caseInsensitive ? 'i' : '');
			}
			
			
			/**
			 * Escape a string such that it can be used in a regular expression
			 *  @param {string} sVal string to escape
			 *  @returns {string} escaped string
			 *  @memberof DataTable#oApi
			 */
			var _fnEscapeRegex = DataTable.util.escapeRegex;
			
			var __filter_div = $('<div>')[0];
			var __filter_div_textContent = __filter_div.textContent !== undefined;
			
			// Update the filtering data for each row if needed (by invalidation or first run)
			function _fnFilterData(settings) {
				var columns = settings.aoColumns;
				var column;
				var i, j, ien, jen, filterData, cellData, row;
				var fomatters = DataTable.ext.type.search;
				var wasInvalidated = false;
				
				for(i = 0, ien = settings.aoData.length; i < ien; i++) {
					row = settings.aoData[i];
					
					if(!row._aFilterData) {
						filterData = [];
						
						for(j = 0, jen = columns.length; j < jen; j++) {
							column = columns[j];
							
							if(column.bSearchable) {
								cellData = _fnGetCellData(settings, i, j, 'filter');
								
								if(fomatters[column.sType]) {
									cellData = fomatters[column.sType](cellData);
								}
								
								// Search in DataTables 1.10 is string based. In 1.11 this
								// should be altered to also allow strict type checking.
								if(cellData === null) {
									cellData = '';
								}
								
								if(typeof cellData !== 'string' && cellData.toString) {
									cellData = cellData.toString();
								}
							} else {
								cellData = '';
							}
							
							// If it looks like there is an HTML entity in the string,
							// attempt to decode it so sorting works as expected. Note that
							// we could use a single line of jQuery to do this, but the DOM
							// method used here is much faster http://jsperf.com/html-decode
							if(cellData.indexOf && cellData.indexOf('&') !== -1) {
								__filter_div.innerHTML = cellData;
								cellData = __filter_div_textContent ?
									__filter_div.textContent :
									__filter_div.innerText;
							}
							
							if(cellData.replace) {
								cellData = cellData.replace(/[\r\n]/g, '');
							}
							
							filterData.push(cellData);
						}
						
						row._aFilterData = filterData;
						row._sFilterRow = filterData.join('  ');
						wasInvalidated = true;
					}
				}
				
				return wasInvalidated;
			}
			
			
			/**
			 * Convert from the internal Hungarian notation to camelCase for external
			 * interaction
			 *  @param {object} obj Object to convert
			 *  @returns {object} Inverted object
			 *  @memberof DataTable#oApi
			 */
			function _fnSearchToCamel(obj) {
				return {
					search: obj.sSearch,
					smart: obj.bSmart,
					regex: obj.bRegex,
					caseInsensitive: obj.bCaseInsensitive
				};
			}
			
			
			/**
			 * Convert from camelCase notation to the internal Hungarian. We could use the
			 * Hungarian convert function here, but this is cleaner
			 *  @param {object} obj Object to convert
			 *  @returns {object} Inverted object
			 *  @memberof DataTable#oApi
			 */
			function _fnSearchToHung(obj) {
				return {
					sSearch: obj.search,
					bSmart: obj.smart,
					bRegex: obj.regex,
					bCaseInsensitive: obj.caseInsensitive
				};
			}
			
			/**
			 * Generate the node required for the info display
			 *  @param {object} oSettings dataTables settings object
			 *  @returns {node} Information element
			 *  @memberof DataTable#oApi
			 */
			function _fnFeatureHtmlInfo(settings) {
				var
					tid = settings.sTableId,
					nodes = settings.aanFeatures.i,
					n = $('<div/>', {
						'class': settings.oClasses.sInfo,
						'id': !nodes ? tid + '_info' : null
					});
				
				if(!nodes) {
					// Update display on each draw
					settings.aoDrawCallback.push({
						"fn": _fnUpdateInfo,
						"sName": "information"
					});
					
					n
						.attr('role', 'status')
						.attr('aria-live', 'polite');
					
					// Table is described by our info div
					$(settings.nTable).attr('aria-describedby', tid + '_info');
				}
				
				return n[0];
			}
			
			
			/**
			 * Update the information elements in the display
			 *  @param {object} settings dataTables settings object
			 *  @memberof DataTable#oApi
			 */
			function _fnUpdateInfo(settings) {
				/* Show information about the table */
				var nodes = settings.aanFeatures.i;
				if(nodes.length === 0) {
					return;
				}
				
				var
					lang = settings.oLanguage,
					start = settings._iDisplayStart + 1,
					end = settings.fnDisplayEnd(),
					max = settings.fnRecordsTotal(),
					total = settings.fnRecordsDisplay(),
					out = total ?
						lang.sInfo :
						lang.sInfoEmpty;
				
				if(total !== max) {
					/* Record set after filtering */
					out += ' ' + lang.sInfoFiltered;
				}
				
				// Convert the macros
				out += lang.sInfoPostFix;
				out = _fnInfoMacros(settings, out);
				
				var callback = lang.fnInfoCallback;
				if(callback !== null) {
					out = callback.call(settings.oInstance,
						settings, start, end, max, total, out
					);
				}
				
				$(nodes).html(out);
			}
			
			
			function _fnInfoMacros(settings, str) {
				// When infinite scrolling, we are always starting at 1. _iDisplayStart is used only
				// internally
				var
					formatter = settings.fnFormatNumber,
					start = settings._iDisplayStart + 1,
					len = settings._iDisplayLength,
					vis = settings.fnRecordsDisplay(),
					all = len === -1;
				
				return str.replace(/_START_/g, formatter.call(settings, start)).replace(/_END_/g, formatter.call(settings, settings.fnDisplayEnd())).replace(/_MAX_/g, formatter.call(settings, settings.fnRecordsTotal())).replace(/_TOTAL_/g, formatter.call(settings, vis)).replace(/_PAGE_/g, formatter.call(settings, all ? 1 : Math.ceil(start / len))).replace(/_PAGES_/g, formatter.call(settings, all ? 1 : Math.ceil(vis / len)));
			}
			
			
			/**
			 * Draw the table for the first time, adding all required features
			 *  @param {object} settings dataTables settings object
			 *  @memberof DataTable#oApi
			 */
			function _fnInitialise(settings) {
				var i, iLen, iAjaxStart = settings.iInitDisplayStart;
				var columns = settings.aoColumns, column;
				var features = settings.oFeatures;
				var deferLoading = settings.bDeferLoading; // value modified by the draw
				
				/* Ensure that the table data is fully initialised */
				if(!settings.bInitialised) {
					setTimeout(function() {
						_fnInitialise(settings);
					}, 200);
					return;
				}
				
				/* Show the display HTML options */
				_fnAddOptionsHtml(settings);
				
				/* Build and draw the header / footer for the table */
				_fnBuildHead(settings);
				_fnDrawHead(settings, settings.aoHeader);
				_fnDrawHead(settings, settings.aoFooter);
				
				/* Okay to show that something is going on now */
				_fnProcessingDisplay(settings, true);
				
				/* Calculate sizes for columns */
				if(features.bAutoWidth) {
					_fnCalculateColumnWidths(settings);
				}
				
				for(i = 0, iLen = columns.length; i < iLen; i++) {
					column = columns[i];
					
					if(column.sWidth) {
						column.nTh.style.width = _fnStringToCss(column.sWidth);
					}
				}
				
				_fnCallbackFire(settings, null, 'preInit', [settings]);
				
				// If there is default sorting required - let's do it. The sort function
				// will do the drawing for us. Otherwise we draw the table regardless of the
				// Ajax source - this allows the table to look initialised for Ajax sourcing
				// data (show 'loading' message possibly)
				_fnReDraw(settings);
				
				// Server-side processing init complete is done by _fnAjaxUpdateDraw
				var dataSrc = _fnDataSource(settings);
				if(dataSrc != 'ssp' || deferLoading) {
					// if there is an ajax source load the data
					if(dataSrc == 'ajax') {
						_fnBuildAjax(settings, [], function(json) {
							var aData = _fnAjaxDataSrc(settings, json);
							
							// Got the data - add it to the table
							for(i = 0; i < aData.length; i++) {
								_fnAddData(settings, aData[i]);
							}
							
							// Reset the init display for cookie saving. We've already done
							// a filter, and therefore cleared it before. So we need to make
							// it appear 'fresh'
							settings.iInitDisplayStart = iAjaxStart;
							
							_fnReDraw(settings);
							
							_fnProcessingDisplay(settings, false);
							_fnInitComplete(settings, json);
						}, settings);
					} else {
						_fnProcessingDisplay(settings, false);
						_fnInitComplete(settings);
					}
				}
			}
			
			
			/**
			 * Draw the table for the first time, adding all required features
			 *  @param {object} oSettings dataTables settings object
			 *  @param {object} [json] JSON from the server that completed the table, if using Ajax source
			 *    with client-side processing (optional)
			 *  @memberof DataTable#oApi
			 */
			function _fnInitComplete(settings, json) {
				settings._bInitComplete = true;
				
				// When data was added after the initialisation (data or Ajax) we need to
				// calculate the column sizing
				if(json || settings.oInit.aaData) {
					_fnAdjustColumnSizing(settings);
				}
				
				_fnCallbackFire(settings, null, 'plugin-init', [settings, json]);
				_fnCallbackFire(settings, 'aoInitComplete', 'init', [settings, json]);
			}
			
			
			function _fnLengthChange(settings, val) {
				var len = parseInt(val, 10);
				settings._iDisplayLength = len;
				
				_fnLengthOverflow(settings);
				
				// Fire length change event
				_fnCallbackFire(settings, null, 'length', [settings, len]);
			}
			
			
			/**
			 * Generate the node required for user display length changing
			 *  @param {object} settings dataTables settings object
			 *  @returns {node} Display length feature node
			 *  @memberof DataTable#oApi
			 */
			function _fnFeatureHtmlLength(settings) {
				var
					classes = settings.oClasses,
					tableId = settings.sTableId,
					menu = settings.aLengthMenu,
					d2 = $.isArray(menu[0]),
					lengths = d2 ? menu[0] : menu,
					language = d2 ? menu[1] : menu;
				
				var select = $('<select/>', {
					'name': tableId + '_length',
					'aria-controls': tableId,
					'class': classes.sLengthSelect
				});
				
				for(var i = 0, ien = lengths.length; i < ien; i++) {
					select[0][i] = new Option(
						typeof language[i] === 'number' ?
							settings.fnFormatNumber(language[i]) :
							language[i],
						lengths[i]
					);
				}
				
				var div = $('<div><label/></div>').addClass(classes.sLength);
				if(!settings.aanFeatures.l) {
					div[0].id = tableId + '_length';
				}
				
				div.children().append(
					settings.oLanguage.sLengthMenu.replace('_MENU_', select[0].outerHTML)
				);
				
				// Can't use `select` variable as user might provide their own and the
				// reference is broken by the use of outerHTML
				$('select', div)
					.val(settings._iDisplayLength)
					.on('change.DT', function(e) {
						_fnLengthChange(settings, $(this).val());
						_fnDraw(settings);
					});
				
				// Update node value whenever anything changes the table's length
				$(settings.nTable).on('length.dt.DT', function(e, s, len) {
					if(settings === s) {
						$('select', div).val(len);
					}
				});
				
				return div[0];
			}
			
			
			/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Note that most of the paging logic is done in
	 * DataTable.ext.pager
	 */
			
			/**
			 * Generate the node required for default pagination
			 *  @param {object} oSettings dataTables settings object
			 *  @returns {node} Pagination feature node
			 *  @memberof DataTable#oApi
			 */
			function _fnFeatureHtmlPaginate(settings) {
				var
					type = settings.sPaginationType,
					plugin = DataTable.ext.pager[type],
					modern = typeof plugin === 'function',
					redraw = function(settings) {
						_fnDraw(settings);
					},
					node = $('<div/>').addClass(settings.oClasses.sPaging + type)[0],
					features = settings.aanFeatures;
				
				if(!modern) {
					plugin.fnInit(settings, node, redraw);
				}
				
				/* Add a draw callback for the pagination on first instance, to update the paging display */
				if(!features.p) {
					node.id = settings.sTableId + '_paginate';
					
					settings.aoDrawCallback.push({
						"fn": function(settings) {
							if(modern) {
								var
									start = settings._iDisplayStart,
									len = settings._iDisplayLength,
									visRecords = settings.fnRecordsDisplay(),
									all = len === -1,
									page = all ? 0 : Math.ceil(start / len),
									pages = all ? 1 : Math.ceil(visRecords / len),
									buttons = plugin(page, pages),
									i, ien;
								
								for(i = 0, ien = features.p.length; i < ien; i++) {
									_fnRenderer(settings, 'pageButton')(
										settings, features.p[i], i, buttons, page, pages
									);
								}
							} else {
								plugin.fnUpdate(settings, redraw);
							}
						},
						"sName": "pagination"
					});
				}
				
				return node;
			}
			
			
			/**
			 * Alter the display settings to change the page
			 *  @param {object} settings DataTables settings object
			 *  @param {string|int} action Paging action to take: "first", "previous",
			 *    "next" or "last" or page number to jump to (integer)
			 *  @param [bool] redraw Automatically draw the update or not
			 *  @returns {bool} true page has changed, false - no change
			 *  @memberof DataTable#oApi
			 */
			function _fnPageChange(settings, action, redraw) {
				var
					start = settings._iDisplayStart,
					len = settings._iDisplayLength,
					records = settings.fnRecordsDisplay();
				
				if(records === 0 || len === -1) {
					start = 0;
				} else if(typeof action === "number") {
					start = action * len;
					
					if(start > records) {
						start = 0;
					}
				} else if(action == "first") {
					start = 0;
				} else if(action == "previous") {
					start = len >= 0 ?
						start - len :
						0;
					
					if(start < 0) {
						start = 0;
					}
				} else if(action == "next") {
					if(start + len < records) {
						start += len;
					}
				} else if(action == "last") {
					start = Math.floor((records - 1) / len) * len;
				} else {
					_fnLog(settings, 0, "Unknown paging action: " + action, 5);
				}
				
				var changed = settings._iDisplayStart !== start;
				settings._iDisplayStart = start;
				
				if(changed) {
					_fnCallbackFire(settings, null, 'page', [settings]);
					
					if(redraw) {
						_fnDraw(settings);
					}
				}
				
				return changed;
			}
			
			
			/**
			 * Generate the node required for the processing node
			 *  @param {object} settings dataTables settings object
			 *  @returns {node} Processing element
			 *  @memberof DataTable#oApi
			 */
			function _fnFeatureHtmlProcessing(settings) {
				return $('<div/>', {
					'id': !settings.aanFeatures.r ? settings.sTableId + '_processing' : null,
					'class': settings.oClasses.sProcessing
				})
					.html(settings.oLanguage.sProcessing)
					.insertBefore(settings.nTable)[0];
			}
			
			
			/**
			 * Display or hide the processing indicator
			 *  @param {object} settings dataTables settings object
			 *  @param {bool} show Show the processing indicator (true) or not (false)
			 *  @memberof DataTable#oApi
			 */
			function _fnProcessingDisplay(settings, show) {
				if(settings.oFeatures.bProcessing) {
					$(settings.aanFeatures.r).css('display', show ? 'block' : 'none');
				}
				
				_fnCallbackFire(settings, null, 'processing', [settings, show]);
			}
			
			/**
			 * Add any control elements for the table - specifically scrolling
			 *  @param {object} settings dataTables settings object
			 *  @returns {node} Node to add to the DOM
			 *  @memberof DataTable#oApi
			 */
			function _fnFeatureHtmlTable(settings) {
				var table = $(settings.nTable);
				
				// Add the ARIA grid role to the table
				table.attr('role', 'grid');
				
				// Scrolling from here on in
				var scroll = settings.oScroll;
				
				if(scroll.sX === '' && scroll.sY === '') {
					return settings.nTable;
				}
				
				var scrollX = scroll.sX;
				var scrollY = scroll.sY;
				var classes = settings.oClasses;
				var caption = table.children('caption');
				var captionSide = caption.length ? caption[0]._captionSide : null;
				var headerClone = $(table[0].cloneNode(false));
				var footerClone = $(table[0].cloneNode(false));
				var footer = table.children('tfoot');
				var _div = '<div/>';
				var size = function(s) {
					return !s ? null : _fnStringToCss(s);
				};
				
				if(!footer.length) {
					footer = null;
				}
				
				/*
		 * The HTML structure that we want to generate in this function is:
		 *  div - scroller
		 *    div - scroll head
		 *      div - scroll head inner
		 *        table - scroll head table
		 *          thead - thead
		 *    div - scroll body
		 *      table - table (master table)
		 *        thead - thead clone for sizing
		 *        tbody - tbody
		 *    div - scroll foot
		 *      div - scroll foot inner
		 *        table - scroll foot table
		 *          tfoot - tfoot
		 */
				var scroller = $(_div, {'class': classes.sScrollWrapper})
					.append(
						$(_div, {'class': classes.sScrollHead})
							.css({
								overflow: 'hidden',
								position: 'relative',
								border: 0,
								width: scrollX ? size(scrollX) : '100%'
							})
							.append(
								$(_div, {'class': classes.sScrollHeadInner})
									.css({
										'box-sizing': 'content-box',
										width: scroll.sXInner || '100%'
									})
									.append(
										headerClone
											.removeAttr('id')
											.css('margin-left', 0)
											.append(captionSide === 'top' ? caption : null)
											.append(
												table.children('thead')
											)
									)
							)
					)
					.append(
						$(_div, {'class': classes.sScrollBody})
							.css({
								position: 'relative',
								overflow: 'auto',
								width: size(scrollX)
							})
							.append(table)
					);
				
				if(footer) {
					scroller.append(
						$(_div, {'class': classes.sScrollFoot})
							.css({
								overflow: 'hidden',
								border: 0,
								width: scrollX ? size(scrollX) : '100%'
							})
							.append(
								$(_div, {'class': classes.sScrollFootInner})
									.append(
										footerClone
											.removeAttr('id')
											.css('margin-left', 0)
											.append(captionSide === 'bottom' ? caption : null)
											.append(
												table.children('tfoot')
											)
									)
							)
					);
				}
				
				var children = scroller.children();
				var scrollHead = children[0];
				var scrollBody = children[1];
				var scrollFoot = footer ? children[2] : null;
				
				// When the body is scrolled, then we also want to scroll the headers
				if(scrollX) {
					$(scrollBody).on('scroll.DT', function(e) {
						var scrollLeft = this.scrollLeft;
						
						scrollHead.scrollLeft = scrollLeft;
						
						if(footer) {
							scrollFoot.scrollLeft = scrollLeft;
						}
					});
				}
				
				$(scrollBody).css(
					scrollY && scroll.bCollapse ? 'max-height' : 'height',
					scrollY
				);
				
				settings.nScrollHead = scrollHead;
				settings.nScrollBody = scrollBody;
				settings.nScrollFoot = scrollFoot;
				
				// On redraw - align columns
				settings.aoDrawCallback.push({
					"fn": _fnScrollDraw,
					"sName": "scrolling"
				});
				
				return scroller[0];
			}
			
			
			/**
			 * Update the header, footer and body tables for resizing - i.e. column
			 * alignment.
			 *
			 * Welcome to the most horrible function DataTables. The process that this
			 * function follows is basically:
			 *   1. Re-create the table inside the scrolling div
			 *   2. Take live measurements from the DOM
			 *   3. Apply the measurements to align the columns
			 *   4. Clean up
			 *
			 *  @param {object} settings dataTables settings object
			 *  @memberof DataTable#oApi
			 */
			function _fnScrollDraw(settings) {
				// Given that this is such a monster function, a lot of variables are use
				// to try and keep the minimised size as small as possible
				var
					scroll = settings.oScroll,
					scrollX = scroll.sX,
					scrollXInner = scroll.sXInner,
					scrollY = scroll.sY,
					barWidth = scroll.iBarWidth,
					divHeader = $(settings.nScrollHead),
					divHeaderStyle = divHeader[0].style,
					divHeaderInner = divHeader.children('div'),
					divHeaderInnerStyle = divHeaderInner[0].style,
					divHeaderTable = divHeaderInner.children('table'),
					divBodyEl = settings.nScrollBody,
					divBody = $(divBodyEl),
					divBodyStyle = divBodyEl.style,
					divFooter = $(settings.nScrollFoot),
					divFooterInner = divFooter.children('div'),
					divFooterTable = divFooterInner.children('table'),
					header = $(settings.nTHead),
					table = $(settings.nTable),
					tableEl = table[0],
					tableStyle = tableEl.style,
					footer = settings.nTFoot ? $(settings.nTFoot) : null,
					browser = settings.oBrowser,
					ie67 = browser.bScrollOversize,
					dtHeaderCells = _pluck(settings.aoColumns, 'nTh'),
					headerTrgEls, footerTrgEls,
					headerSrcEls, footerSrcEls,
					headerCopy, footerCopy,
					headerWidths = [], footerWidths = [],
					headerContent = [], footerContent = [],
					idx, correction, sanityWidth,
					zeroOut = function(nSizer) {
						var style = nSizer.style;
						style.paddingTop = "0";
						style.paddingBottom = "0";
						style.borderTopWidth = "0";
						style.borderBottomWidth = "0";
						style.height = 0;
					};
				
				// If the scrollbar visibility has changed from the last draw, we need to
				// adjust the column sizes as the table width will have changed to account
				// for the scrollbar
				var scrollBarVis = divBodyEl.scrollHeight > divBodyEl.clientHeight;
				
				if(settings.scrollBarVis !== scrollBarVis && settings.scrollBarVis !== undefined) {
					settings.scrollBarVis = scrollBarVis;
					_fnAdjustColumnSizing(settings);
					return; // adjust column sizing will call this function again
				} else {
					settings.scrollBarVis = scrollBarVis;
				}
				
				/*
		 * 1. Re-create the table inside the scrolling div
		 */
				
				// Remove the old minimised thead and tfoot elements in the inner table
				table.children('thead, tfoot').remove();
				
				if(footer) {
					footerCopy = footer.clone().prependTo(table);
					footerTrgEls = footer.find('tr'); // the original tfoot is in its own table and must be sized
					footerSrcEls = footerCopy.find('tr');
				}
				
				// Clone the current header and footer elements and then place it into the inner table
				headerCopy = header.clone().prependTo(table);
				headerTrgEls = header.find('tr'); // original header is in its own table
				headerSrcEls = headerCopy.find('tr');
				headerCopy.find('th, td').removeAttr('tabindex');
				
				
				/*
		 * 2. Take live measurements from the DOM - do not alter the DOM itself!
		 */
				
				// Remove old sizing and apply the calculated column widths
				// Get the unique column headers in the newly created (cloned) header. We want to apply the
				// calculated sizes to this header
				if(!scrollX) {
					divBodyStyle.width = '100%';
					divHeader[0].style.width = '100%';
				}
				
				$.each(_fnGetUniqueThs(settings, headerCopy), function(i, el) {
					idx = _fnVisibleToColumnIndex(settings, i);
					el.style.width = settings.aoColumns[idx].sWidth;
				});
				
				if(footer) {
					_fnApplyToChildren(function(n) {
						n.style.width = "";
					}, footerSrcEls);
				}
				
				// Size the table as a whole
				sanityWidth = table.outerWidth();
				if(scrollX === "") {
					// No x scrolling
					tableStyle.width = "100%";
					
					// IE7 will make the width of the table when 100% include the scrollbar
					// - which is shouldn't. When there is a scrollbar we need to take this
					// into account.
					if(ie67 && (table.find('tbody').height() > divBodyEl.offsetHeight ||
						divBody.css('overflow-y') == "scroll")
					) {
						tableStyle.width = _fnStringToCss(table.outerWidth() - barWidth);
					}
					
					// Recalculate the sanity width
					sanityWidth = table.outerWidth();
				} else if(scrollXInner !== "") {
					// legacy x scroll inner has been given - use it
					tableStyle.width = _fnStringToCss(scrollXInner);
					
					// Recalculate the sanity width
					sanityWidth = table.outerWidth();
				}
				
				// Hidden header should have zero height, so remove padding and borders. Then
				// set the width based on the real headers
				
				// Apply all styles in one pass
				_fnApplyToChildren(zeroOut, headerSrcEls);
				
				// Read all widths in next pass
				_fnApplyToChildren(function(nSizer) {
					headerContent.push(nSizer.innerHTML);
					headerWidths.push(_fnStringToCss($(nSizer).css('width')));
				}, headerSrcEls);
				
				// Apply all widths in final pass
				_fnApplyToChildren(function(nToSize, i) {
					// Only apply widths to the DataTables detected header cells - this
					// prevents complex headers from having contradictory sizes applied
					if($.inArray(nToSize, dtHeaderCells) !== -1) {
						nToSize.style.width = headerWidths[i];
					}
				}, headerTrgEls);
				
				$(headerSrcEls).height(0);
				
				/* Same again with the footer if we have one */
				if(footer) {
					_fnApplyToChildren(zeroOut, footerSrcEls);
					
					_fnApplyToChildren(function(nSizer) {
						footerContent.push(nSizer.innerHTML);
						footerWidths.push(_fnStringToCss($(nSizer).css('width')));
					}, footerSrcEls);
					
					_fnApplyToChildren(function(nToSize, i) {
						nToSize.style.width = footerWidths[i];
					}, footerTrgEls);
					
					$(footerSrcEls).height(0);
				}
				
				
				/*
		 * 3. Apply the measurements
		 */
				
				// "Hide" the header and footer that we used for the sizing. We need to keep
				// the content of the cell so that the width applied to the header and body
				// both match, but we want to hide it completely. We want to also fix their
				// width to what they currently are
				_fnApplyToChildren(function(nSizer, i) {
					nSizer.innerHTML = '<div class="dataTables_sizing">' + headerContent[i] + '</div>';
					nSizer.childNodes[0].style.height = "0";
					nSizer.childNodes[0].style.overflow = "hidden";
					nSizer.style.width = headerWidths[i];
				}, headerSrcEls);
				
				if(footer) {
					_fnApplyToChildren(function(nSizer, i) {
						nSizer.innerHTML = '<div class="dataTables_sizing">' + footerContent[i] + '</div>';
						nSizer.childNodes[0].style.height = "0";
						nSizer.childNodes[0].style.overflow = "hidden";
						nSizer.style.width = footerWidths[i];
					}, footerSrcEls);
				}
				
				// Sanity check that the table is of a sensible width. If not then we are going to get
				// misalignment - try to prevent this by not allowing the table to shrink below its min width
				if(table.outerWidth() < sanityWidth) {
					// The min width depends upon if we have a vertical scrollbar visible or not */
					correction = ((divBodyEl.scrollHeight > divBodyEl.offsetHeight ||
						divBody.css('overflow-y') == "scroll")) ?
						sanityWidth + barWidth :
						sanityWidth;
					
					// IE6/7 are a law unto themselves...
					if(ie67 && (divBodyEl.scrollHeight >
						divBodyEl.offsetHeight || divBody.css('overflow-y') == "scroll")
					) {
						tableStyle.width = _fnStringToCss(correction - barWidth);
					}
					
					// And give the user a warning that we've stopped the table getting too small
					if(scrollX === "" || scrollXInner !== "") {
						_fnLog(settings, 1, 'Possible column misalignment', 6);
					}
				} else {
					correction = '100%';
				}
				
				// Apply to the container elements
				divBodyStyle.width = _fnStringToCss(correction);
				divHeaderStyle.width = _fnStringToCss(correction);
				
				if(footer) {
					settings.nScrollFoot.style.width = _fnStringToCss(correction);
				}
				
				
				/*
		 * 4. Clean up
		 */
				if(!scrollY) {
					/* IE7< puts a vertical scrollbar in place (when it shouldn't be) due to subtracting
			 * the scrollbar height from the visible display, rather than adding it on. We need to
			 * set the height in order to sort this. Don't want to do it in any other browsers.
			 */
					if(ie67) {
						divBodyStyle.height = _fnStringToCss(tableEl.offsetHeight + barWidth);
					}
				}
				
				/* Finally set the width's of the header and footer tables */
				var iOuterWidth = table.outerWidth();
				divHeaderTable[0].style.width = _fnStringToCss(iOuterWidth);
				divHeaderInnerStyle.width = _fnStringToCss(iOuterWidth);
				
				// Figure out if there are scrollbar present - if so then we need a the header and footer to
				// provide a bit more space to allow "overflow" scrolling (i.e. past the scrollbar)
				var bScrolling = table.height() > divBodyEl.clientHeight || divBody.css('overflow-y') == "scroll";
				var padding = 'padding' + (browser.bScrollbarLeft ? 'Left' : 'Right');
				divHeaderInnerStyle[padding] = bScrolling ? barWidth + "px" : "0px";
				
				if(footer) {
					divFooterTable[0].style.width = _fnStringToCss(iOuterWidth);
					divFooterInner[0].style.width = _fnStringToCss(iOuterWidth);
					divFooterInner[0].style[padding] = bScrolling ? barWidth + "px" : "0px";
				}
				
				// Correct DOM ordering for colgroup - comes before the thead
				table.children('colgroup').insertBefore(table.children('thead'));
				
				/* Adjust the position of the header in case we loose the y-scrollbar */
				divBody.scroll();
				
				// If sorting or filtering has occurred, jump the scrolling back to the top
				// only if we aren't holding the position
				if((settings.bSorted || settings.bFiltered) && !settings._drawHold) {
					divBodyEl.scrollTop = 0;
				}
			}
			
			
			/**
			 * Apply a given function to the display child nodes of an element array (typically
			 * TD children of TR rows
			 *  @param {function} fn Method to apply to the objects
			 *  @param array {nodes} an1 List of elements to look through for display children
			 *  @param array {nodes} an2 Another list (identical structure to the first) - optional
			 *  @memberof DataTable#oApi
			 */
			function _fnApplyToChildren(fn, an1, an2) {
				var index = 0, i = 0, iLen = an1.length;
				var nNode1, nNode2;
				
				while(i < iLen) {
					nNode1 = an1[i].firstChild;
					nNode2 = an2 ? an2[i].firstChild : null;
					
					while(nNode1) {
						if(nNode1.nodeType === 1) {
							if(an2) {
								fn(nNode1, nNode2, index);
							} else {
								fn(nNode1, index);
							}
							
							index++;
						}
						
						nNode1 = nNode1.nextSibling;
						nNode2 = an2 ? nNode2.nextSibling : null;
					}
					
					i++;
				}
			}
			
			
			var __re_html_remove = /<.*?>/g;
			
			
			/**
			 * Calculate the width of columns for the table
			 *  @param {object} oSettings dataTables settings object
			 *  @memberof DataTable#oApi
			 */
			function _fnCalculateColumnWidths(oSettings) {
				var
					table = oSettings.nTable,
					columns = oSettings.aoColumns,
					scroll = oSettings.oScroll,
					scrollY = scroll.sY,
					scrollX = scroll.sX,
					scrollXInner = scroll.sXInner,
					columnCount = columns.length,
					visibleColumns = _fnGetColumns(oSettings, 'bVisible'),
					headerCells = $('th', oSettings.nTHead),
					tableWidthAttr = table.getAttribute('width'), // from DOM element
					tableContainer = table.parentNode,
					userInputs = false,
					i, column, columnIdx, width, outerWidth,
					browser = oSettings.oBrowser,
					ie67 = browser.bScrollOversize;
				
				var styleWidth = table.style.width;
				if(styleWidth && styleWidth.indexOf('%') !== -1) {
					tableWidthAttr = styleWidth;
				}
				
				/* Convert any user input sizes into pixel sizes */
				for(i = 0; i < visibleColumns.length; i++) {
					column = columns[visibleColumns[i]];
					
					if(column.sWidth !== null) {
						column.sWidth = _fnConvertToWidth(column.sWidthOrig, tableContainer);
						
						userInputs = true;
					}
				}
				
				/* If the number of columns in the DOM equals the number that we have to
		 * process in DataTables, then we can use the offsets that are created by
		 * the web- browser. No custom sizes can be set in order for this to happen,
		 * nor scrolling used
		 */
				if(ie67 || !userInputs && !scrollX && !scrollY &&
					columnCount == _fnVisbleColumns(oSettings) &&
					columnCount == headerCells.length
				) {
					for(i = 0; i < columnCount; i++) {
						var colIdx = _fnVisibleToColumnIndex(oSettings, i);
						
						if(colIdx !== null) {
							columns[colIdx].sWidth = _fnStringToCss(headerCells.eq(i).width());
						}
					}
				} else {
					// Otherwise construct a single row, worst case, table with the widest
					// node in the data, assign any user defined widths, then insert it into
					// the DOM and allow the browser to do all the hard work of calculating
					// table widths
					var tmpTable = $(table).clone() // don't use cloneNode - IE8 will remove events on the main table
						.css('visibility', 'hidden')
						.removeAttr('id');
					
					// Clean up the table body
					tmpTable.find('tbody tr').remove();
					var tr = $('<tr/>').appendTo(tmpTable.find('tbody'));
					
					// Clone the table header and footer - we can't use the header / footer
					// from the cloned table, since if scrolling is active, the table's
					// real header and footer are contained in different table tags
					tmpTable.find('thead, tfoot').remove();
					tmpTable
						.append($(oSettings.nTHead).clone())
						.append($(oSettings.nTFoot).clone());
					
					// Remove any assigned widths from the footer (from scrolling)
					tmpTable.find('tfoot th, tfoot td').css('width', '');
					
					// Apply custom sizing to the cloned header
					headerCells = _fnGetUniqueThs(oSettings, tmpTable.find('thead')[0]);
					
					for(i = 0; i < visibleColumns.length; i++) {
						column = columns[visibleColumns[i]];
						
						headerCells[i].style.width = column.sWidthOrig !== null && column.sWidthOrig !== '' ?
							_fnStringToCss(column.sWidthOrig) :
							'';
						
						// For scrollX we need to force the column width otherwise the
						// browser will collapse it. If this width is smaller than the
						// width the column requires, then it will have no effect
						if(column.sWidthOrig && scrollX) {
							$(headerCells[i]).append($('<div/>').css({
								width: column.sWidthOrig,
								margin: 0,
								padding: 0,
								border: 0,
								height: 1
							}));
						}
					}
					
					// Find the widest cell for each column and put it into the table
					if(oSettings.aoData.length) {
						for(i = 0; i < visibleColumns.length; i++) {
							columnIdx = visibleColumns[i];
							column = columns[columnIdx];
							
							$(_fnGetWidestNode(oSettings, columnIdx))
								.clone(false)
								.append(column.sContentPadding)
								.appendTo(tr);
						}
					}
					
					// Tidy the temporary table - remove name attributes so there aren't
					// duplicated in the dom (radio elements for example)
					$('[name]', tmpTable).removeAttr('name');
					
					// Table has been built, attach to the document so we can work with it.
					// A holding element is used, positioned at the top of the container
					// with minimal height, so it has no effect on if the container scrolls
					// or not. Otherwise it might trigger scrolling when it actually isn't
					// needed
					var holder = $('<div/>').css(scrollX || scrollY ?
						{
							position: 'absolute',
							top: 0,
							left: 0,
							height: 1,
							right: 0,
							overflow: 'hidden'
						} :
						{}
					)
						.append(tmpTable)
						.appendTo(tableContainer);
					
					// When scrolling (X or Y) we want to set the width of the table as
					// appropriate. However, when not scrolling leave the table width as it
					// is. This results in slightly different, but I think correct behaviour
					if(scrollX && scrollXInner) {
						tmpTable.width(scrollXInner);
					} else if(scrollX) {
						tmpTable.css('width', 'auto');
						tmpTable.removeAttr('width');
						
						// If there is no width attribute or style, then allow the table to
						// collapse
						if(tmpTable.width() < tableContainer.clientWidth && tableWidthAttr) {
							tmpTable.width(tableContainer.clientWidth);
						}
					} else if(scrollY) {
						tmpTable.width(tableContainer.clientWidth);
					} else if(tableWidthAttr) {
						tmpTable.width(tableWidthAttr);
					}
					
					// Get the width of each column in the constructed table - we need to
					// know the inner width (so it can be assigned to the other table's
					// cells) and the outer width so we can calculate the full width of the
					// table. This is safe since DataTables requires a unique cell for each
					// column, but if ever a header can span multiple columns, this will
					// need to be modified.
					var total = 0;
					for(i = 0; i < visibleColumns.length; i++) {
						var cell = $(headerCells[i]);
						var border = cell.outerWidth() - cell.width();
						
						// Use getBounding... where possible (not IE8-) because it can give
						// sub-pixel accuracy, which we then want to round up!
						var bounding = browser.bBounding ?
							Math.ceil(headerCells[i].getBoundingClientRect().width) :
							cell.outerWidth();
						
						// Total is tracked to remove any sub-pixel errors as the outerWidth
						// of the table might not equal the total given here (IE!).
						total += bounding;
						
						// Width for each column to use
						columns[visibleColumns[i]].sWidth = _fnStringToCss(bounding - border);
					}
					
					table.style.width = _fnStringToCss(total);
					
					// Finished with the table - ditch it
					holder.remove();
				}
				
				// If there is a width attr, we want to attach an event listener which
				// allows the table sizing to automatically adjust when the window is
				// resized. Use the width attr rather than CSS, since we can't know if the
				// CSS is a relative value or absolute - DOM read is always px.
				if(tableWidthAttr) {
					table.style.width = _fnStringToCss(tableWidthAttr);
				}
				
				if((tableWidthAttr || scrollX) && !oSettings._reszEvt) {
					var bindResize = function() {
						$(window).on('resize.DT-' + oSettings.sInstance, _fnThrottle(function() {
							_fnAdjustColumnSizing(oSettings);
						}));
					};
					
					// IE6/7 will crash if we bind a resize event handler on page load.
					// To be removed in 1.11 which drops IE6/7 support
					if(ie67) {
						setTimeout(bindResize, 1000);
					} else {
						bindResize();
					}
					
					oSettings._reszEvt = true;
				}
			}
			
			
			/**
			 * Throttle the calls to a function. Arguments and context are maintained for
			 * the throttled function
			 *  @param {function} fn Function to be called
			 *  @param {int} [freq=200] call frequency in mS
			 *  @returns {function} wrapped function
			 *  @memberof DataTable#oApi
			 */
			var _fnThrottle = DataTable.util.throttle;
			
			
			/**
			 * Convert a CSS unit width to pixels (e.g. 2em)
			 *  @param {string} width width to be converted
			 *  @param {node} parent parent to get the with for (required for relative widths) - optional
			 *  @returns {int} width in pixels
			 *  @memberof DataTable#oApi
			 */
			function _fnConvertToWidth(width, parent) {
				if(!width) {
					return 0;
				}
				
				var n = $('<div/>')
					.css('width', _fnStringToCss(width))
					.appendTo(parent || document.body);
				
				var val = n[0].offsetWidth;
				n.remove();
				
				return val;
			}
			
			
			/**
			 * Get the widest node
			 *  @param {object} settings dataTables settings object
			 *  @param {int} colIdx column of interest
			 *  @returns {node} widest table node
			 *  @memberof DataTable#oApi
			 */
			function _fnGetWidestNode(settings, colIdx) {
				var idx = _fnGetMaxLenString(settings, colIdx);
				if(idx < 0) {
					return null;
				}
				
				var data = settings.aoData[idx];
				return !data.nTr ? // Might not have been created when deferred rendering
					$('<td/>').html(_fnGetCellData(settings, idx, colIdx, 'display'))[0] :
					data.anCells[colIdx];
			}
			
			
			/**
			 * Get the maximum strlen for each data column
			 *  @param {object} settings dataTables settings object
			 *  @param {int} colIdx column of interest
			 *  @returns {string} max string length for each column
			 *  @memberof DataTable#oApi
			 */
			function _fnGetMaxLenString(settings, colIdx) {
				var s, max = -1, maxIdx = -1;
				
				for(var i = 0, ien = settings.aoData.length; i < ien; i++) {
					s = _fnGetCellData(settings, i, colIdx, 'display') + '';
					s = s.replace(__re_html_remove, '');
					s = s.replace(/&nbsp;/g, ' ');
					
					if(s.length > max) {
						max = s.length;
						maxIdx = i;
					}
				}
				
				return maxIdx;
			}
			
			
			/**
			 * Append a CSS unit (only if required) to a string
			 *  @param {string} value to css-ify
			 *  @returns {string} value with css unit
			 *  @memberof DataTable#oApi
			 */
			function _fnStringToCss(s) {
				if(s === null) {
					return '0px';
				}
				
				if(typeof s == 'number') {
					return s < 0 ?
						'0px' :
						s + 'px';
				}
				
				// Check it has a unit character already
				return s.match(/\d$/) ?
					s + 'px' :
					s;
			}
			
			
			function _fnSortFlatten(settings) {
				var
					i, iLen, k, kLen,
					aSort = [],
					aiOrig = [],
					aoColumns = settings.aoColumns,
					aDataSort, iCol, sType, srcCol,
					fixed = settings.aaSortingFixed,
					fixedObj = $.isPlainObject(fixed),
					nestedSort = [],
					add = function(a) {
						if(a.length && !$.isArray(a[0])) {
							// 1D array
							nestedSort.push(a);
						} else {
							// 2D array
							$.merge(nestedSort, a);
						}
					};
				
				// Build the sort array, with pre-fix and post-fix options if they have been
				// specified
				if($.isArray(fixed)) {
					add(fixed);
				}
				
				if(fixedObj && fixed.pre) {
					add(fixed.pre);
				}
				
				add(settings.aaSorting);
				
				if(fixedObj && fixed.post) {
					add(fixed.post);
				}
				
				for(i = 0; i < nestedSort.length; i++) {
					srcCol = nestedSort[i][0];
					aDataSort = aoColumns[srcCol].aDataSort;
					
					for(k = 0, kLen = aDataSort.length; k < kLen; k++) {
						iCol = aDataSort[k];
						sType = aoColumns[iCol].sType || 'string';
						
						if(nestedSort[i]._idx === undefined) {
							nestedSort[i]._idx = $.inArray(nestedSort[i][1], aoColumns[iCol].asSorting);
						}
						
						aSort.push({
							src: srcCol,
							col: iCol,
							dir: nestedSort[i][1],
							index: nestedSort[i]._idx,
							type: sType,
							formatter: DataTable.ext.type.order[sType + "-pre"]
						});
					}
				}
				
				return aSort;
			}
			
			/**
			 * Change the order of the table
			 *  @param {object} oSettings dataTables settings object
			 *  @memberof DataTable#oApi
			 *  @todo This really needs split up!
			 */
			function _fnSort(oSettings) {
				var
					i, ien, iLen, j, jLen, k, kLen,
					sDataType, nTh,
					aiOrig = [],
					oExtSort = DataTable.ext.type.order,
					aoData = oSettings.aoData,
					aoColumns = oSettings.aoColumns,
					aDataSort, data, iCol, sType, oSort,
					formatters = 0,
					sortCol,
					displayMaster = oSettings.aiDisplayMaster,
					aSort;
				
				// Resolve any column types that are unknown due to addition or invalidation
				// @todo Can this be moved into a 'data-ready' handler which is called when
				//   data is going to be used in the table?
				_fnColumnTypes(oSettings);
				
				aSort = _fnSortFlatten(oSettings);
				
				for(i = 0, ien = aSort.length; i < ien; i++) {
					sortCol = aSort[i];
					
					// Track if we can use the fast sort algorithm
					if(sortCol.formatter) {
						formatters++;
					}
					
					// Load the data needed for the sort, for each cell
					_fnSortData(oSettings, sortCol.col);
				}
				
				/* No sorting required if server-side or no sorting array */
				if(_fnDataSource(oSettings) != 'ssp' && aSort.length !== 0) {
					// Create a value - key array of the current row positions such that we can use their
					// current position during the sort, if values match, in order to perform stable sorting
					for(i = 0, iLen = displayMaster.length; i < iLen; i++) {
						aiOrig[displayMaster[i]] = i;
					}
					
					/* Do the sort - here we want multi-column sorting based on a given data source (column)
			 * and sorting function (from oSort) in a certain direction. It's reasonably complex to
			 * follow on it's own, but this is what we want (example two column sorting):
			 *  fnLocalSorting = function(a,b){
			 *    var iTest;
			 *    iTest = oSort['string-asc']('data11', 'data12');
			 *      if (iTest !== 0)
			 *        return iTest;
			 *    iTest = oSort['numeric-desc']('data21', 'data22');
			 *    if (iTest !== 0)
			 *      return iTest;
			 *    return oSort['numeric-asc']( aiOrig[a], aiOrig[b] );
			 *  }
			 * Basically we have a test for each sorting column, if the data in that column is equal,
			 * test the next column. If all columns match, then we use a numeric sort on the row
			 * positions in the original data array to provide a stable sort.
			 *
			 * Note - I know it seems excessive to have two sorting methods, but the first is around
			 * 15% faster, so the second is only maintained for backwards compatibility with sorting
			 * methods which do not have a pre-sort formatting function.
			 */
					if(formatters === aSort.length) {
						// All sort types have formatting functions
						displayMaster.sort(function(a, b) {
							var
								x, y, k, test, sort,
								len = aSort.length,
								dataA = aoData[a]._aSortData,
								dataB = aoData[b]._aSortData;
							
							for(k = 0; k < len; k++) {
								sort = aSort[k];
								
								x = dataA[sort.col];
								y = dataB[sort.col];
								
								test = x < y ? -1 : x > y ? 1 : 0;
								if(test !== 0) {
									return sort.dir === 'asc' ? test : -test;
								}
							}
							
							x = aiOrig[a];
							y = aiOrig[b];
							return x < y ? -1 : x > y ? 1 : 0;
						});
					} else {
						// Depreciated - remove in 1.11 (providing a plug-in option)
						// Not all sort types have formatting methods, so we have to call their sorting
						// methods.
						displayMaster.sort(function(a, b) {
							var
								x, y, k, l, test, sort, fn,
								len = aSort.length,
								dataA = aoData[a]._aSortData,
								dataB = aoData[b]._aSortData;
							
							for(k = 0; k < len; k++) {
								sort = aSort[k];
								
								x = dataA[sort.col];
								y = dataB[sort.col];
								
								fn = oExtSort[sort.type + "-" + sort.dir] || oExtSort["string-" + sort.dir];
								test = fn(x, y);
								if(test !== 0) {
									return test;
								}
							}
							
							x = aiOrig[a];
							y = aiOrig[b];
							return x < y ? -1 : x > y ? 1 : 0;
						});
					}
				}
				
				/* Tell the draw function that we have sorted the data */
				oSettings.bSorted = true;
			}
			
			
			function _fnSortAria(settings) {
				var label;
				var nextSort;
				var columns = settings.aoColumns;
				var aSort = _fnSortFlatten(settings);
				var oAria = settings.oLanguage.oAria;
				
				// ARIA attributes - need to loop all columns, to update all (removing old
				// attributes as needed)
				for(var i = 0, iLen = columns.length; i < iLen; i++) {
					var col = columns[i];
					var asSorting = col.asSorting;
					var sTitle = col.sTitle.replace(/<.*?>/g, "");
					var th = col.nTh;
					
					// IE7 is throwing an error when setting these properties with jQuery's
					// attr() and removeAttr() methods...
					th.removeAttribute('aria-sort');
					
					/* In ARIA only the first sorting column can be marked as sorting - no multi-sort option */
					if(col.bSortable) {
						if(aSort.length > 0 && aSort[0].col == i) {
							th.setAttribute('aria-sort', aSort[0].dir == "asc" ? "ascending" : "descending");
							nextSort = asSorting[aSort[0].index + 1] || asSorting[0];
						} else {
							nextSort = asSorting[0];
						}
						
						label = sTitle + (nextSort === "asc" ?
								oAria.sSortAscending :
								oAria.sSortDescending
						);
					} else {
						label = sTitle;
					}
					
					th.setAttribute('aria-label', label);
				}
			}
			
			
			/**
			 * Function to run on user sort request
			 *  @param {object} settings dataTables settings object
			 *  @param {node} attachTo node to attach the handler to
			 *  @param {int} colIdx column sorting index
			 *  @param {boolean} [append=false] Append the requested sort to the existing
			 *    sort if true (i.e. multi-column sort)
			 *  @param {function} [callback] callback function
			 *  @memberof DataTable#oApi
			 */
			function _fnSortListener(settings, colIdx, append, callback) {
				var col = settings.aoColumns[colIdx];
				var sorting = settings.aaSorting;
				var asSorting = col.asSorting;
				var nextSortIdx;
				var next = function(a, overflow) {
					var idx = a._idx;
					if(idx === undefined) {
						idx = $.inArray(a[1], asSorting);
					}
					
					return idx + 1 < asSorting.length ?
						idx + 1 :
						overflow ?
							null :
							0;
				};
				
				// Convert to 2D array if needed
				if(typeof sorting[0] === 'number') {
					sorting = settings.aaSorting = [sorting];
				}
				
				// If appending the sort then we are multi-column sorting
				if(append && settings.oFeatures.bSortMulti) {
					// Are we already doing some kind of sort on this column?
					var sortIdx = $.inArray(colIdx, _pluck(sorting, '0'));
					
					if(sortIdx !== -1) {
						// Yes, modify the sort
						nextSortIdx = next(sorting[sortIdx], true);
						
						if(nextSortIdx === null && sorting.length === 1) {
							nextSortIdx = 0; // can't remove sorting completely
						}
						
						if(nextSortIdx === null) {
							sorting.splice(sortIdx, 1);
						} else {
							sorting[sortIdx][1] = asSorting[nextSortIdx];
							sorting[sortIdx]._idx = nextSortIdx;
						}
					} else {
						// No sort on this column yet
						sorting.push([colIdx, asSorting[0], 0]);
						sorting[sorting.length - 1]._idx = 0;
					}
				} else if(sorting.length && sorting[0][0] == colIdx) {
					// Single column - already sorting on this column, modify the sort
					nextSortIdx = next(sorting[0]);
					
					sorting.length = 1;
					sorting[0][1] = asSorting[nextSortIdx];
					sorting[0]._idx = nextSortIdx;
				} else {
					// Single column - sort only on this column
					sorting.length = 0;
					sorting.push([colIdx, asSorting[0]]);
					sorting[0]._idx = 0;
				}
				
				// Run the sort by calling a full redraw
				_fnReDraw(settings);
				
				// callback used for async user interaction
				if(typeof callback == 'function') {
					callback(settings);
				}
			}
			
			
			/**
			 * Attach a sort handler (click) to a node
			 *  @param {object} settings dataTables settings object
			 *  @param {node} attachTo node to attach the handler to
			 *  @param {int} colIdx column sorting index
			 *  @param {function} [callback] callback function
			 *  @memberof DataTable#oApi
			 */
			function _fnSortAttachListener(settings, attachTo, colIdx, callback) {
				var col = settings.aoColumns[colIdx];
				
				_fnBindAction(attachTo, {}, function(e) {
					/* If the column is not sortable - don't to anything */
					if(col.bSortable === false) {
						return;
					}
					
					// If processing is enabled use a timeout to allow the processing
					// display to be shown - otherwise to it synchronously
					if(settings.oFeatures.bProcessing) {
						_fnProcessingDisplay(settings, true);
						
						setTimeout(function() {
							_fnSortListener(settings, colIdx, e.shiftKey, callback);
							
							// In server-side processing, the draw callback will remove the
							// processing display
							if(_fnDataSource(settings) !== 'ssp') {
								_fnProcessingDisplay(settings, false);
							}
						}, 0);
					} else {
						_fnSortListener(settings, colIdx, e.shiftKey, callback);
					}
				});
			}
			
			
			/**
			 * Set the sorting classes on table's body, Note: it is safe to call this function
			 * when bSort and bSortClasses are false
			 *  @param {object} oSettings dataTables settings object
			 *  @memberof DataTable#oApi
			 */
			function _fnSortingClasses(settings) {
				var oldSort = settings.aLastSort;
				var sortClass = settings.oClasses.sSortColumn;
				var sort = _fnSortFlatten(settings);
				var features = settings.oFeatures;
				var i, ien, colIdx;
				
				if(features.bSort && features.bSortClasses) {
					// Remove old sorting classes
					for(i = 0, ien = oldSort.length; i < ien; i++) {
						colIdx = oldSort[i].src;
						
						// Remove column sorting
						$(_pluck(settings.aoData, 'anCells', colIdx))
							.removeClass(sortClass + (i < 2 ? i + 1 : 3));
					}
					
					// Add new column sorting
					for(i = 0, ien = sort.length; i < ien; i++) {
						colIdx = sort[i].src;
						
						$(_pluck(settings.aoData, 'anCells', colIdx))
							.addClass(sortClass + (i < 2 ? i + 1 : 3));
					}
				}
				
				settings.aLastSort = sort;
			}
			
			
			// Get the data to sort a column, be it from cache, fresh (populating the
			// cache), or from a sort formatter
			function _fnSortData(settings, idx) {
				// Custom sorting function - provided by the sort data type
				var column = settings.aoColumns[idx];
				var customSort = DataTable.ext.order[column.sSortDataType];
				var customData;
				
				if(customSort) {
					customData = customSort.call(settings.oInstance, settings, idx,
						_fnColumnIndexToVisible(settings, idx)
					);
				}
				
				// Use / populate cache
				var row, cellData;
				var formatter = DataTable.ext.type.order[column.sType + "-pre"];
				
				for(var i = 0, ien = settings.aoData.length; i < ien; i++) {
					row = settings.aoData[i];
					
					if(!row._aSortData) {
						row._aSortData = [];
					}
					
					if(!row._aSortData[idx] || customSort) {
						cellData = customSort ?
							customData[i] : // If there was a custom sort function, use data from there
							_fnGetCellData(settings, i, idx, 'sort');
						
						row._aSortData[idx] = formatter ?
							formatter(cellData) :
							cellData;
					}
				}
			}
			
			
			/**
			 * Save the state of a table
			 *  @param {object} oSettings dataTables settings object
			 *  @memberof DataTable#oApi
			 */
			function _fnSaveState(settings) {
				if(!settings.oFeatures.bStateSave || settings.bDestroying) {
					return;
				}
				
				/* Store the interesting variables */
				var state = {
					time: +new Date(),
					start: settings._iDisplayStart,
					length: settings._iDisplayLength,
					order: $.extend(true, [], settings.aaSorting),
					search: _fnSearchToCamel(settings.oPreviousSearch),
					columns: $.map(settings.aoColumns, function(col, i) {
						return {
							visible: col.bVisible,
							search: _fnSearchToCamel(settings.aoPreSearchCols[i])
						};
					})
				};
				
				_fnCallbackFire(settings, "aoStateSaveParams", 'stateSaveParams', [settings, state]);
				
				settings.oSavedState = state;
				settings.fnStateSaveCallback.call(settings.oInstance, settings, state);
			}
			
			
			/**
			 * Attempt to load a saved table state
			 *  @param {object} oSettings dataTables settings object
			 *  @param {object} oInit DataTables init object so we can override settings
			 *  @param {function} callback Callback to execute when the state has been loaded
			 *  @memberof DataTable#oApi
			 */
			function _fnLoadState(settings, oInit, callback) {
				var i, ien;
				var columns = settings.aoColumns;
				var loaded = function(s) {
					if(!s || !s.time) {
						callback();
						return;
					}
					
					// Allow custom and plug-in manipulation functions to alter the saved data set and
					// cancelling of loading by returning false
					var abStateLoad = _fnCallbackFire(settings, 'aoStateLoadParams', 'stateLoadParams', [settings, s]);
					if($.inArray(false, abStateLoad) !== -1) {
						callback();
						return;
					}
					
					// Reject old data
					var duration = settings.iStateDuration;
					if(duration > 0 && s.time < +new Date() - (duration * 1000)) {
						callback();
						return;
					}
					
					// Number of columns have changed - all bets are off, no restore of settings
					if(s.columns && columns.length !== s.columns.length) {
						callback();
						return;
					}
					
					// Store the saved state so it might be accessed at any time
					settings.oLoadedState = $.extend(true, {}, s);
					
					// Restore key features - todo - for 1.11 this needs to be done by
					// subscribed events
					if(s.start !== undefined) {
						settings._iDisplayStart = s.start;
						settings.iInitDisplayStart = s.start;
					}
					if(s.length !== undefined) {
						settings._iDisplayLength = s.length;
					}
					
					// Order
					if(s.order !== undefined) {
						settings.aaSorting = [];
						$.each(s.order, function(i, col) {
							settings.aaSorting.push(col[0] >= columns.length ?
								[0, col[1]] :
								col
							);
						});
					}
					
					// Search
					if(s.search !== undefined) {
						$.extend(settings.oPreviousSearch, _fnSearchToHung(s.search));
					}
					
					// Columns
					//
					if(s.columns) {
						for(i = 0, ien = s.columns.length; i < ien; i++) {
							var col = s.columns[i];
							
							// Visibility
							if(col.visible !== undefined) {
								columns[i].bVisible = col.visible;
							}
							
							// Search
							if(col.search !== undefined) {
								$.extend(settings.aoPreSearchCols[i], _fnSearchToHung(col.search));
							}
						}
					}
					
					_fnCallbackFire(settings, 'aoStateLoaded', 'stateLoaded', [settings, s]);
					callback();
				};
				
				if(!settings.oFeatures.bStateSave) {
					callback();
					return;
				}
				
				var state = settings.fnStateLoadCallback.call(settings.oInstance, settings, loaded);
				
				if(state !== undefined) {
					loaded(state);
				}
				// otherwise, wait for the loaded callback to be executed
			}
			
			
			/**
			 * Return the settings object for a particular table
			 *  @param {node} table table we are using as a dataTable
			 *  @returns {object} Settings object - or null if not found
			 *  @memberof DataTable#oApi
			 */
			function _fnSettingsFromNode(table) {
				var settings = DataTable.settings;
				var idx = $.inArray(table, _pluck(settings, 'nTable'));
				
				return idx !== -1 ?
					settings[idx] :
					null;
			}
			
			
			/**
			 * Log an error message
			 *  @param {object} settings dataTables settings object
			 *  @param {int} level log error messages, or display them to the user
			 *  @param {string} msg error message
			 *  @param {int} tn Technical note id to get more information about the error.
			 *  @memberof DataTable#oApi
			 */
			function _fnLog(settings, level, msg, tn) {
				msg = 'DataTables warning: ' +
					(settings ? 'table id=' + settings.sTableId + ' - ' : '') + msg;
				
				if(tn) {
					msg += '. For more information about this error, please see ' +
						'http://datatables.net/tn/' + tn;
				}
				
				if(!level) {
					// Backwards compatibility pre 1.10
					var ext = DataTable.ext;
					var type = ext.sErrMode || ext.errMode;
					
					if(settings) {
						_fnCallbackFire(settings, null, 'error', [settings, tn, msg]);
					}
					
					if(type == 'alert') {
						alert(msg);
					} else if(type == 'throw') {
						throw new Error(msg);
					} else if(typeof type == 'function') {
						type(settings, tn, msg);
					}
				} else if(window.console && console.log) {
					console.log(msg);
				}
			}
			
			
			/**
			 * See if a property is defined on one object, if so assign it to the other object
			 *  @param {object} ret target object
			 *  @param {object} src source object
			 *  @param {string} name property
			 *  @param {string} [mappedName] name to map too - optional, name used if not given
			 *  @memberof DataTable#oApi
			 */
			function _fnMap(ret, src, name, mappedName) {
				if($.isArray(name)) {
					$.each(name, function(i, val) {
						if($.isArray(val)) {
							_fnMap(ret, src, val[0], val[1]);
						} else {
							_fnMap(ret, src, val);
						}
					});
					
					return;
				}
				
				if(mappedName === undefined) {
					mappedName = name;
				}
				
				if(src[name] !== undefined) {
					ret[mappedName] = src[name];
				}
			}
			
			
			/**
			 * Extend objects - very similar to jQuery.extend, but deep copy objects, and
			 * shallow copy arrays. The reason we need to do this, is that we don't want to
			 * deep copy array init values (such as aaSorting) since the dev wouldn't be
			 * able to override them, but we do want to deep copy arrays.
			 *  @param {object} out Object to extend
			 *  @param {object} extender Object from which the properties will be applied to
			 *      out
			 *  @param {boolean} breakRefs If true, then arrays will be sliced to take an
			 *      independent copy with the exception of the `data` or `aaData` parameters
			 *      if they are present. This is so you can pass in a collection to
			 *      DataTables and have that used as your data source without breaking the
			 *      references
			 *  @returns {object} out Reference, just for convenience - out === the return.
			 *  @memberof DataTable#oApi
			 *  @todo This doesn't take account of arrays inside the deep copied objects.
			 */
			function _fnExtend(out, extender, breakRefs) {
				var val;
				
				for(var prop in extender) {
					if(extender.hasOwnProperty(prop)) {
						val = extender[prop];
						
						if($.isPlainObject(val)) {
							if(!$.isPlainObject(out[prop])) {
								out[prop] = {};
							}
							$.extend(true, out[prop], val);
						} else if(breakRefs && prop !== 'data' && prop !== 'aaData' && $.isArray(val)) {
							out[prop] = val.slice();
						} else {
							out[prop] = val;
						}
					}
				}
				
				return out;
			}
			
			
			/**
			 * Bind an event handers to allow a click or return key to activate the callback.
			 * This is good for accessibility since a return on the keyboard will have the
			 * same effect as a click, if the element has focus.
			 *  @param {element} n Element to bind the action to
			 *  @param {object} oData Data object to pass to the triggered function
			 *  @param {function} fn Callback function for when the event is triggered
			 *  @memberof DataTable#oApi
			 */
			function _fnBindAction(n, oData, fn) {
				$(n)
					.on('click.DT', oData, function(e) {
						$(n).blur(); // Remove focus outline for mouse users
						fn(e);
					})
					.on('keypress.DT', oData, function(e) {
						if(e.which === 13) {
							e.preventDefault();
							fn(e);
						}
					})
					.on('selectstart.DT', function() {
						/* Take the brutal approach to cancelling text selection */
						return false;
					});
			}
			
			
			/**
			 * Register a callback function. Easily allows a callback function to be added to
			 * an array store of callback functions that can then all be called together.
			 *  @param {object} oSettings dataTables settings object
			 *  @param {string} sStore Name of the array storage for the callbacks in oSettings
			 *  @param {function} fn Function to be called back
			 *  @param {string} sName Identifying name for the callback (i.e. a label)
			 *  @memberof DataTable#oApi
			 */
			function _fnCallbackReg(oSettings, sStore, fn, sName) {
				if(fn) {
					oSettings[sStore].push({
						"fn": fn,
						"sName": sName
					});
				}
			}
			
			
			/**
			 * Fire callback functions and trigger events. Note that the loop over the
			 * callback array store is done backwards! Further note that you do not want to
			 * fire off triggers in time sensitive applications (for example cell creation)
			 * as its slow.
			 *  @param {object} settings dataTables settings object
			 *  @param {string} callbackArr Name of the array storage for the callbacks in
			 *      oSettings
			 *  @param {string} eventName Name of the jQuery custom event to trigger. If
			 *      null no trigger is fired
			 *  @param {array} args Array of arguments to pass to the callback function /
			 *      trigger
			 *  @memberof DataTable#oApi
			 */
			function _fnCallbackFire(settings, callbackArr, eventName, args) {
				var ret = [];
				
				if(callbackArr) {
					ret = $.map(settings[callbackArr].slice().reverse(), function(val, i) {
						return val.fn.apply(settings.oInstance, args);
					});
				}
				
				if(eventName !== null) {
					var e = $.Event(eventName + '.dt');
					
					$(settings.nTable).trigger(e, args);
					
					ret.push(e.result);
				}
				
				return ret;
			}
			
			
			function _fnLengthOverflow(settings) {
				var
					start = settings._iDisplayStart,
					end = settings.fnDisplayEnd(),
					len = settings._iDisplayLength;
				
				/* If we have space to show extra rows (backing up from the end point - then do so */
				if(start >= end) {
					start = end - len;
				}
				
				// Keep the start record on the current page
				start -= (start % len);
				
				if(len === -1 || start < 0) {
					start = 0;
				}
				
				settings._iDisplayStart = start;
			}
			
			
			function _fnRenderer(settings, type) {
				var renderer = settings.renderer;
				var host = DataTable.ext.renderer[type];
				
				if($.isPlainObject(renderer) && renderer[type]) {
					// Specific renderer for this type. If available use it, otherwise use
					// the default.
					return host[renderer[type]] || host._;
				} else if(typeof renderer === 'string') {
					// Common renderer - if there is one available for this type use it,
					// otherwise use the default
					return host[renderer] || host._;
				}
				
				// Use the default
				return host._;
			}
			
			
			/**
			 * Detect the data source being used for the table. Used to simplify the code
			 * a little (ajax) and to make it compress a little smaller.
			 *
			 *  @param {object} settings dataTables settings object
			 *  @returns {string} Data source
			 *  @memberof DataTable#oApi
			 */
			function _fnDataSource(settings) {
				if(settings.oFeatures.bServerSide) {
					return 'ssp';
				} else if(settings.ajax || settings.sAjaxSource) {
					return 'ajax';
				}
				return 'dom';
			}
			
			
			/**
			 * Computed structure of the DataTables API, defined by the options passed to
			 * `DataTable.Api.register()` when building the API.
			 *
			 * The structure is built in order to speed creation and extension of the Api
			 * objects since the extensions are effectively pre-parsed.
			 *
			 * The array is an array of objects with the following structure, where this
			 * base array represents the Api prototype base:
			 *
			 *     [
			 *       {
			 *         name:      'data'                -- string   - Property name
			 *         val:       function () {},       -- function - Api method (or undefined if just an object
			 *         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result
			 *         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property
			 *       },
			 *       {
			 *         name:     'row'
			 *         val:       {},
			 *         methodExt: [ ... ],
			 *         propExt:   [
			 *           {
			 *             name:      'data'
			 *             val:       function () {},
			 *             methodExt: [ ... ],
			 *             propExt:   [ ... ]
			 *           },
			 *           ...
			 *         ]
			 *       }
			 *     ]
			 *
			 * @type {Array}
			 * @ignore
			 */
			var __apiStruct = [];
			
			
			/**
			 * `Array.prototype` reference.
			 *
			 * @type object
			 * @ignore
			 */
			var __arrayProto = Array.prototype;
			
			
			/**
			 * Abstraction for `context` parameter of the `Api` constructor to allow it to
			 * take several different forms for ease of use.
			 *
			 * Each of the input parameter types will be converted to a DataTables settings
			 * object where possible.
			 *
			 * @param  {string|node|jQuery|object} mixed DataTable identifier. Can be one
			 *   of:
			 *
			 *   * `string` - jQuery selector. Any DataTables' matching the given selector
			 *     with be found and used.
			 *   * `node` - `TABLE` node which has already been formed into a DataTable.
			 *   * `jQuery` - A jQuery object of `TABLE` nodes.
			 *   * `object` - DataTables settings object
			 *   * `DataTables.Api` - API instance
			 * @return {array|null} Matching DataTables settings objects. `null` or
			 *   `undefined` is returned if no matching DataTable is found.
			 * @ignore
			 */
			var _toSettings = function(mixed) {
				var idx, jq;
				var settings = DataTable.settings;
				var tables = $.map(settings, function(el, i) {
					return el.nTable;
				});
				
				if(!mixed) {
					return [];
				} else if(mixed.nTable && mixed.oApi) {
					// DataTables settings object
					return [mixed];
				} else if(mixed.nodeName && mixed.nodeName.toLowerCase() === 'table') {
					// Table node
					idx = $.inArray(mixed, tables);
					return idx !== -1 ? [settings[idx]] : null;
				} else if(mixed && typeof mixed.settings === 'function') {
					return mixed.settings().toArray();
				} else if(typeof mixed === 'string') {
					// jQuery selector
					jq = $(mixed);
				} else if(mixed instanceof $) {
					// jQuery object (also DataTables instance)
					jq = mixed;
				}
				
				if(jq) {
					return jq.map(function(i) {
						idx = $.inArray(this, tables);
						return idx !== -1 ? settings[idx] : null;
					}).toArray();
				}
			};
			
			
			/**
			 * DataTables API class - used to control and interface with  one or more
			 * DataTables enhanced tables.
			 *
			 * The API class is heavily based on jQuery, presenting a chainable interface
			 * that you can use to interact with tables. Each instance of the API class has
			 * a "context" - i.e. the tables that it will operate on. This could be a single
			 * table, all tables on a page or a sub-set thereof.
			 *
			 * Additionally the API is designed to allow you to easily work with the data in
			 * the tables, retrieving and manipulating it as required. This is done by
			 * presenting the API class as an array like interface. The contents of the
			 * array depend upon the actions requested by each method (for example
			 * `rows().nodes()` will return an array of nodes, while `rows().data()` will
			 * return an array of objects or arrays depending upon your table's
			 * configuration). The API object has a number of array like methods (`push`,
			 * `pop`, `reverse` etc) as well as additional helper methods (`each`, `pluck`,
			 * `unique` etc) to assist your working with the data held in a table.
			 *
			 * Most methods (those which return an Api instance) are chainable, which means
			 * the return from a method call also has all of the methods available that the
			 * top level object had. For example, these two calls are equivalent:
			 *
			 *     // Not chained
			 *     api.row.add( {...} );
			 *     api.draw();
			 *
			 *     // Chained
			 *     api.row.add( {...} ).draw();
			 *
			 * @class DataTable.Api
			 * @param {array|object|string|jQuery} context DataTable identifier. This is
			 *   used to define which DataTables enhanced tables this API will operate on.
			 *   Can be one of:
			 *
			 *   * `string` - jQuery selector. Any DataTables' matching the given selector
			 *     with be found and used.
			 *   * `node` - `TABLE` node which has already been formed into a DataTable.
			 *   * `jQuery` - A jQuery object of `TABLE` nodes.
			 *   * `object` - DataTables settings object
			 * @param {array} [data] Data to initialise the Api instance with.
			 *
			 * @example
			 *   // Direct initialisation during DataTables construction
			 *   var api = $('#example').DataTable();
			 *
			 * @example
			 *   // Initialisation using a DataTables jQuery object
			 *   var api = $('#example').dataTable().api();
			 *
			 * @example
			 *   // Initialisation as a constructor
			 *   var api = new $.fn.DataTable.Api( 'table.dataTable' );
			 */
			_Api = function(context, data) {
				if(!(this instanceof _Api)) {
					return new _Api(context, data);
				}
				
				var settings = [];
				var ctxSettings = function(o) {
					var a = _toSettings(o);
					if(a) {
						settings = settings.concat(a);
					}
				};
				
				if($.isArray(context)) {
					for(var i = 0, ien = context.length; i < ien; i++) {
						ctxSettings(context[i]);
					}
				} else {
					ctxSettings(context);
				}
				
				// Remove duplicates
				this.context = _unique(settings);
				
				// Initial data
				if(data) {
					$.merge(this, data);
				}
				
				// selector
				this.selector = {
					rows: null,
					cols: null,
					opts: null
				};
				
				_Api.extend(this, this, __apiStruct);
			};
			
			DataTable.Api = _Api;
			
			// Don't destroy the existing prototype, just extend it. Required for jQuery 2's
			// isPlainObject.
			$.extend(_Api.prototype, {
				any: function() {
					return this.count() !== 0;
				},
				
				
				concat: __arrayProto.concat,
				
				
				context: [], // array of table settings objects
				
				
				count: function() {
					return this.flatten().length;
				},
				
				
				each: function(fn) {
					for(var i = 0, ien = this.length; i < ien; i++) {
						fn.call(this, this[i], i, this);
					}
					
					return this;
				},
				
				
				eq: function(idx) {
					var ctx = this.context;
					
					return ctx.length > idx ?
						new _Api(ctx[idx], this[idx]) :
						null;
				},
				
				
				filter: function(fn) {
					var a = [];
					
					if(__arrayProto.filter) {
						a = __arrayProto.filter.call(this, fn, this);
					} else {
						// Compatibility for browsers without EMCA-252-5 (JS 1.6)
						for(var i = 0, ien = this.length; i < ien; i++) {
							if(fn.call(this, this[i], i, this)) {
								a.push(this[i]);
							}
						}
					}
					
					return new _Api(this.context, a);
				},
				
				
				flatten: function() {
					var a = [];
					return new _Api(this.context, a.concat.apply(a, this.toArray()));
				},
				
				
				join: __arrayProto.join,
				
				
				indexOf: __arrayProto.indexOf || function(obj, start) {
					for(var i = (start || 0), ien = this.length; i < ien; i++) {
						if(this[i] === obj) {
							return i;
						}
					}
					return -1;
				},
				
				iterator: function(flatten, type, fn, alwaysNew) {
					var
						a = [], ret,
						i, ien, j, jen,
						context = this.context,
						rows, items, item,
						selector = this.selector;
					
					// Argument shifting
					if(typeof flatten === 'string') {
						alwaysNew = fn;
						fn = type;
						type = flatten;
						flatten = false;
					}
					
					for(i = 0, ien = context.length; i < ien; i++) {
						var apiInst = new _Api(context[i]);
						
						if(type === 'table') {
							ret = fn.call(apiInst, context[i], i);
							
							if(ret !== undefined) {
								a.push(ret);
							}
						} else if(type === 'columns' || type === 'rows') {
							// this has same length as context - one entry for each table
							ret = fn.call(apiInst, context[i], this[i], i);
							
							if(ret !== undefined) {
								a.push(ret);
							}
						} else if(type === 'column' || type === 'column-rows' || type === 'row' || type === 'cell') {
							// columns and rows share the same structure.
							// 'this' is an array of column indexes for each context
							items = this[i];
							
							if(type === 'column-rows') {
								rows = _selector_row_indexes(context[i], selector.opts);
							}
							
							for(j = 0, jen = items.length; j < jen; j++) {
								item = items[j];
								
								if(type === 'cell') {
									ret = fn.call(apiInst, context[i], item.row, item.column, i, j);
								} else {
									ret = fn.call(apiInst, context[i], item, i, j, rows);
								}
								
								if(ret !== undefined) {
									a.push(ret);
								}
							}
						}
					}
					
					if(a.length || alwaysNew) {
						var api = new _Api(context, flatten ? a.concat.apply([], a) : a);
						var apiSelector = api.selector;
						apiSelector.rows = selector.rows;
						apiSelector.cols = selector.cols;
						apiSelector.opts = selector.opts;
						return api;
					}
					return this;
				},
				
				
				lastIndexOf: __arrayProto.lastIndexOf || function(obj, start) {
					// Bit cheeky...
					return this.indexOf.apply(this.toArray.reverse(), arguments);
				},
				
				
				length: 0,
				
				
				map: function(fn) {
					var a = [];
					
					if(__arrayProto.map) {
						a = __arrayProto.map.call(this, fn, this);
					} else {
						// Compatibility for browsers without EMCA-252-5 (JS 1.6)
						for(var i = 0, ien = this.length; i < ien; i++) {
							a.push(fn.call(this, this[i], i));
						}
					}
					
					return new _Api(this.context, a);
				},
				
				
				pluck: function(prop) {
					return this.map(function(el) {
						return el[prop];
					});
				},
				
				pop: __arrayProto.pop,
				
				
				push: __arrayProto.push,
				
				
				// Does not return an API instance
				reduce: __arrayProto.reduce || function(fn, init) {
					return _fnReduce(this, fn, init, 0, this.length, 1);
				},
				
				
				reduceRight: __arrayProto.reduceRight || function(fn, init) {
					return _fnReduce(this, fn, init, this.length - 1, -1, -1);
				},
				
				
				reverse: __arrayProto.reverse,
				
				
				// Object with rows, columns and opts
				selector: null,
				
				
				shift: __arrayProto.shift,
				
				
				slice: function() {
					return new _Api(this.context, this);
				},
				
				
				sort: __arrayProto.sort, // ? name - order?
				
				
				splice: __arrayProto.splice,
				
				
				toArray: function() {
					return __arrayProto.slice.call(this);
				},
				
				
				to$: function() {
					return $(this);
				},
				
				
				toJQuery: function() {
					return $(this);
				},
				
				
				unique: function() {
					return new _Api(this.context, _unique(this));
				},
				
				
				unshift: __arrayProto.unshift
			});
			
			
			_Api.extend = function(scope, obj, ext) {
				// Only extend API instances and static properties of the API
				if(!ext.length || !obj || (!(obj instanceof _Api) && !obj.__dt_wrapper)) {
					return;
				}
				
				var
					i, ien,
					j, jen,
					struct, inner,
					methodScoping = function(scope, fn, struc) {
						return function() {
							var ret = fn.apply(scope, arguments);
							
							// Method extension
							_Api.extend(ret, ret, struc.methodExt);
							return ret;
						};
					};
				
				for(i = 0, ien = ext.length; i < ien; i++) {
					struct = ext[i];
					
					// Value
					obj[struct.name] = typeof struct.val === 'function' ?
						methodScoping(scope, struct.val, struct) :
						$.isPlainObject(struct.val) ?
							{} :
							struct.val;
					
					obj[struct.name].__dt_wrapper = true;
					
					// Property extension
					_Api.extend(scope, obj[struct.name], struct.propExt);
				}
			};
			
			
			// @todo - Is there need for an augment function?
			// _Api.augment = function ( inst, name )
			// {
			// 	// Find src object in the structure from the name
			// 	var parts = name.split('.');
			
			// 	_Api.extend( inst, obj );
			// };
			
			
			//     [
			//       {
			//         name:      'data'                -- string   - Property name
			//         val:       function () {},       -- function - Api method (or undefined if just an object
			//         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result
			//         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property
			//       },
			//       {
			//         name:     'row'
			//         val:       {},
			//         methodExt: [ ... ],
			//         propExt:   [
			//           {
			//             name:      'data'
			//             val:       function () {},
			//             methodExt: [ ... ],
			//             propExt:   [ ... ]
			//           },
			//           ...
			//         ]
			//       }
			//     ]
			
			_Api.register = _api_register = function(name, val) {
				if($.isArray(name)) {
					for(var j = 0, jen = name.length; j < jen; j++) {
						_Api.register(name[j], val);
					}
					return;
				}
				
				var
					i, ien,
					heir = name.split('.'),
					struct = __apiStruct,
					key, method;
				
				var find = function(src, name) {
					for(var i = 0, ien = src.length; i < ien; i++) {
						if(src[i].name === name) {
							return src[i];
						}
					}
					return null;
				};
				
				for(i = 0, ien = heir.length; i < ien; i++) {
					method = heir[i].indexOf('()') !== -1;
					key = method ?
						heir[i].replace('()', '') :
						heir[i];
					
					var src = find(struct, key);
					if(!src) {
						src = {
							name: key,
							val: {},
							methodExt: [],
							propExt: []
						};
						struct.push(src);
					}
					
					if(i === ien - 1) {
						src.val = val;
					} else {
						struct = method ?
							src.methodExt :
							src.propExt;
					}
				}
			};
			
			
			_Api.registerPlural = _api_registerPlural = function(pluralName, singularName, val) {
				_Api.register(pluralName, val);
				
				_Api.register(singularName, function() {
					var ret = val.apply(this, arguments);
					
					if(ret === this) {
						// Returned item is the API instance that was passed in, return it
						return this;
					} else if(ret instanceof _Api) {
						// New API instance returned, want the value from the first item
						// in the returned array for the singular result.
						return ret.length ?
							$.isArray(ret[0]) ?
								new _Api(ret.context, ret[0]) : // Array results are 'enhanced'
								ret[0] :
							undefined;
					}
					
					// Non-API return - just fire it back
					return ret;
				});
			};
			
			
			/**
			 * Selector for HTML tables. Apply the given selector to the give array of
			 * DataTables settings objects.
			 *
			 * @param {string|integer} [selector] jQuery selector string or integer
			 * @param  {array} Array of DataTables settings objects to be filtered
			 * @return {array}
			 * @ignore
			 */
			var __table_selector = function(selector, a) {
				// Integer is used to pick out a table by index
				if(typeof selector === 'number') {
					return [a[selector]];
				}
				
				// Perform a jQuery selector on the table nodes
				var nodes = $.map(a, function(el, i) {
					return el.nTable;
				});
				
				return $(nodes)
					.filter(selector)
					.map(function(i) {
						// Need to translate back from the table node to the settings
						var idx = $.inArray(this, nodes);
						return a[idx];
					})
					.toArray();
			};
			
			
			/**
			 * Context selector for the API's context (i.e. the tables the API instance
			 * refers to.
			 *
			 * @name    DataTable.Api#tables
			 * @param {string|integer} [selector] Selector to pick which tables the iterator
			 *   should operate on. If not given, all tables in the current context are
			 *   used. This can be given as a jQuery selector (for example `':gt(0)'`) to
			 *   select multiple tables or as an integer to select a single table.
			 * @returns {DataTable.Api} Returns a new API instance if a selector is given.
			 */
			_api_register('tables()', function(selector) {
				// A new instance is created if there was a selector specified
				return selector ?
					new _Api(__table_selector(selector, this.context)) :
					this;
			});
			
			
			_api_register('table()', function(selector) {
				var tables = this.tables(selector);
				var ctx = tables.context;
				
				// Truncate to the first matched table
				return ctx.length ?
					new _Api(ctx[0]) :
					tables;
			});
			
			
			_api_registerPlural('tables().nodes()', 'table().node()', function() {
				return this.iterator('table', function(ctx) {
					return ctx.nTable;
				}, 1);
			});
			
			
			_api_registerPlural('tables().body()', 'table().body()', function() {
				return this.iterator('table', function(ctx) {
					return ctx.nTBody;
				}, 1);
			});
			
			
			_api_registerPlural('tables().header()', 'table().header()', function() {
				return this.iterator('table', function(ctx) {
					return ctx.nTHead;
				}, 1);
			});
			
			
			_api_registerPlural('tables().footer()', 'table().footer()', function() {
				return this.iterator('table', function(ctx) {
					return ctx.nTFoot;
				}, 1);
			});
			
			
			_api_registerPlural('tables().containers()', 'table().container()', function() {
				return this.iterator('table', function(ctx) {
					return ctx.nTableWrapper;
				}, 1);
			});
			
			
			/**
			 * Redraw the tables in the current context.
			 */
			_api_register('draw()', function(paging) {
				return this.iterator('table', function(settings) {
					if(paging === 'page') {
						_fnDraw(settings);
					} else {
						if(typeof paging === 'string') {
							paging = paging === 'full-hold' ?
								false :
								true;
						}
						
						_fnReDraw(settings, paging === false);
					}
				});
			});
			
			
			/**
			 * Get the current page index.
			 *
			 * @return {integer} Current page index (zero based)
			 */
			/**
			 * Set the current page.
			 *
			 * Note that if you attempt to show a page which does not exist, DataTables will
			 * not throw an error, but rather reset the paging.
			 *
			 * @param {integer|string} action The paging action to take. This can be one of:
			 *  * `integer` - The page index to jump to
			 *  * `string` - An action to take:
			 *    * `first` - Jump to first page.
			 *    * `next` - Jump to the next page
			 *    * `previous` - Jump to previous page
			 *    * `last` - Jump to the last page.
			 * @returns {DataTables.Api} this
			 */
			_api_register('page()', function(action) {
				if(action === undefined) {
					return this.page.info().page; // not an expensive call
				}
				
				// else, have an action to take on all tables
				return this.iterator('table', function(settings) {
					_fnPageChange(settings, action);
				});
			});
			
			
			/**
			 * Paging information for the first table in the current context.
			 *
			 * If you require paging information for another table, use the `table()` method
			 * with a suitable selector.
			 *
			 * @return {object} Object with the following properties set:
			 *  * `page` - Current page index (zero based - i.e. the first page is `0`)
			 *  * `pages` - Total number of pages
			 *  * `start` - Display index for the first record shown on the current page
			 *  * `end` - Display index for the last record shown on the current page
			 *  * `length` - Display length (number of records). Note that generally `start
			 *    + length = end`, but this is not always true, for example if there are
			 *    only 2 records to show on the final page, with a length of 10.
			 *  * `recordsTotal` - Full data set length
			 *  * `recordsDisplay` - Data set length once the current filtering criterion
			 *    are applied.
			 */
			_api_register('page.info()', function(action) {
				if(this.context.length === 0) {
					return undefined;
				}
				
				var
					settings = this.context[0],
					start = settings._iDisplayStart,
					len = settings.oFeatures.bPaginate ? settings._iDisplayLength : -1,
					visRecords = settings.fnRecordsDisplay(),
					all = len === -1;
				
				return {
					"page": all ? 0 : Math.floor(start / len),
					"pages": all ? 1 : Math.ceil(visRecords / len),
					"start": start,
					"end": settings.fnDisplayEnd(),
					"length": len,
					"recordsTotal": settings.fnRecordsTotal(),
					"recordsDisplay": visRecords,
					"serverSide": _fnDataSource(settings) === 'ssp'
				};
			});
			
			
			/**
			 * Get the current page length.
			 *
			 * @return {integer} Current page length. Note `-1` indicates that all records
			 *   are to be shown.
			 */
			/**
			 * Set the current page length.
			 *
			 * @param {integer} Page length to set. Use `-1` to show all records.
			 * @returns {DataTables.Api} this
			 */
			_api_register('page.len()', function(len) {
				// Note that we can't call this function 'length()' because `length`
				// is a Javascript property of functions which defines how many arguments
				// the function expects.
				if(len === undefined) {
					return this.context.length !== 0 ?
						this.context[0]._iDisplayLength :
						undefined;
				}
				
				// else, set the page length
				return this.iterator('table', function(settings) {
					_fnLengthChange(settings, len);
				});
			});
			
			
			var __reload = function(settings, holdPosition, callback) {
				// Use the draw event to trigger a callback
				if(callback) {
					var api = new _Api(settings);
					
					api.one('draw', function() {
						callback(api.ajax.json());
					});
				}
				
				if(_fnDataSource(settings) == 'ssp') {
					_fnReDraw(settings, holdPosition);
				} else {
					_fnProcessingDisplay(settings, true);
					
					// Cancel an existing request
					var xhr = settings.jqXHR;
					if(xhr && xhr.readyState !== 4) {
						xhr.abort();
					}
					
					// Trigger xhr
					_fnBuildAjax(settings, [], function(json) {
						_fnClearTable(settings);
						
						var data = _fnAjaxDataSrc(settings, json);
						for(var i = 0, ien = data.length; i < ien; i++) {
							_fnAddData(settings, data[i]);
						}
						
						_fnReDraw(settings, holdPosition);
						_fnProcessingDisplay(settings, false);
					});
				}
			};
			
			
			/**
			 * Get the JSON response from the last Ajax request that DataTables made to the
			 * server. Note that this returns the JSON from the first table in the current
			 * context.
			 *
			 * @return {object} JSON received from the server.
			 */
			_api_register('ajax.json()', function() {
				var ctx = this.context;
				
				if(ctx.length > 0) {
					return ctx[0].json;
				}
				
				// else return undefined;
			});
			
			
			/**
			 * Get the data submitted in the last Ajax request
			 */
			_api_register('ajax.params()', function() {
				var ctx = this.context;
				
				if(ctx.length > 0) {
					return ctx[0].oAjaxData;
				}
				
				// else return undefined;
			});
			
			
			/**
			 * Reload tables from the Ajax data source. Note that this function will
			 * automatically re-draw the table when the remote data has been loaded.
			 *
			 * @param {boolean} [reset=true] Reset (default) or hold the current paging
			 *   position. A full re-sort and re-filter is performed when this method is
			 *   called, which is why the pagination reset is the default action.
			 * @returns {DataTables.Api} this
			 */
			_api_register('ajax.reload()', function(callback, resetPaging) {
				return this.iterator('table', function(settings) {
					__reload(settings, resetPaging === false, callback);
				});
			});
			
			
			/**
			 * Get the current Ajax URL. Note that this returns the URL from the first
			 * table in the current context.
			 *
			 * @return {string} Current Ajax source URL
			 */
			/**
			 * Set the Ajax URL. Note that this will set the URL for all tables in the
			 * current context.
			 *
			 * @param {string} url URL to set.
			 * @returns {DataTables.Api} this
			 */
			_api_register('ajax.url()', function(url) {
				var ctx = this.context;
				
				if(url === undefined) {
					// get
					if(ctx.length === 0) {
						return undefined;
					}
					ctx = ctx[0];
					
					return ctx.ajax ?
						$.isPlainObject(ctx.ajax) ?
							ctx.ajax.url :
							ctx.ajax :
						ctx.sAjaxSource;
				}
				
				// set
				return this.iterator('table', function(settings) {
					if($.isPlainObject(settings.ajax)) {
						settings.ajax.url = url;
					} else {
						settings.ajax = url;
					}
					// No need to consider sAjaxSource here since DataTables gives priority
					// to `ajax` over `sAjaxSource`. So setting `ajax` here, renders any
					// value of `sAjaxSource` redundant.
				});
			});
			
			
			/**
			 * Load data from the newly set Ajax URL. Note that this method is only
			 * available when `ajax.url()` is used to set a URL. Additionally, this method
			 * has the same effect as calling `ajax.reload()` but is provided for
			 * convenience when setting a new URL. Like `ajax.reload()` it will
			 * automatically redraw the table once the remote data has been loaded.
			 *
			 * @returns {DataTables.Api} this
			 */
			_api_register('ajax.url().load()', function(callback, resetPaging) {
				// Same as a reload, but makes sense to present it for easy access after a
				// url change
				return this.iterator('table', function(ctx) {
					__reload(ctx, resetPaging === false, callback);
				});
			});
			
			
			var _selector_run = function(type, selector, selectFn, settings, opts) {
				var
					out = [], res,
					a, i, ien, j, jen,
					selectorType = typeof selector;
				
				// Can't just check for isArray here, as an API or jQuery instance might be
				// given with their array like look
				if(!selector || selectorType === 'string' || selectorType === 'function' || selector.length === undefined) {
					selector = [selector];
				}
				
				for(i = 0, ien = selector.length; i < ien; i++) {
					// Only split on simple strings - complex expressions will be jQuery selectors
					a = selector[i] && selector[i].split && !selector[i].match(/[\[\(:]/) ?
						selector[i].split(',') :
						[selector[i]];
					
					for(j = 0, jen = a.length; j < jen; j++) {
						res = selectFn(typeof a[j] === 'string' ? $.trim(a[j]) : a[j]);
						
						if(res && res.length) {
							out = out.concat(res);
						}
					}
				}
				
				// selector extensions
				var ext = _ext.selector[type];
				if(ext.length) {
					for(i = 0, ien = ext.length; i < ien; i++) {
						out = ext[i](settings, opts, out);
					}
				}
				
				return _unique(out);
			};
			
			
			var _selector_opts = function(opts) {
				if(!opts) {
					opts = {};
				}
				
				// Backwards compatibility for 1.9- which used the terminology filter rather
				// than search
				if(opts.filter && opts.search === undefined) {
					opts.search = opts.filter;
				}
				
				return $.extend({
					search: 'none',
					order: 'current',
					page: 'all'
				}, opts);
			};
			
			
			var _selector_first = function(inst) {
				// Reduce the API instance to the first item found
				for(var i = 0, ien = inst.length; i < ien; i++) {
					if(inst[i].length > 0) {
						// Assign the first element to the first item in the instance
						// and truncate the instance and context
						inst[0] = inst[i];
						inst[0].length = 1;
						inst.length = 1;
						inst.context = [inst.context[i]];
						
						return inst;
					}
				}
				
				// Not found - return an empty instance
				inst.length = 0;
				return inst;
			};
			
			
			var _selector_row_indexes = function(settings, opts) {
				var
					i, ien, tmp, a = [],
					displayFiltered = settings.aiDisplay,
					displayMaster = settings.aiDisplayMaster;
				
				var
					search = opts.search,  // none, applied, removed
					order = opts.order,   // applied, current, index (original - compatibility with 1.9)
					page = opts.page;    // all, current
				
				if(_fnDataSource(settings) == 'ssp') {
					// In server-side processing mode, most options are irrelevant since
					// rows not shown don't exist and the index order is the applied order
					// Removed is a special case - for consistency just return an empty
					// array
					return search === 'removed' ?
						[] :
						_range(0, displayMaster.length);
				} else if(page == 'current') {
					// Current page implies that order=current and fitler=applied, since it is
					// fairly senseless otherwise, regardless of what order and search actually
					// are
					for(i = settings._iDisplayStart, ien = settings.fnDisplayEnd(); i < ien; i++) {
						a.push(displayFiltered[i]);
					}
				} else if(order == 'current' || order == 'applied') {
					if(search == 'none') {
						a = displayMaster.slice();
					} else if(search == 'applied') {
						a = displayFiltered.slice();
					} else if(search == 'removed') {
						// O(n+m) solution by creating a hash map
						var displayFilteredMap = {};
						
						for(var i = 0, ien = displayFiltered.length; i < ien; i++) {
							displayFilteredMap[displayFiltered[i]] = null;
						}
						
						a = $.map(displayMaster, function(el) {
							return !displayFilteredMap.hasOwnProperty(el) ?
								el :
								null;
						});
					}
				} else if(order == 'index' || order == 'original') {
					for(i = 0, ien = settings.aoData.length; i < ien; i++) {
						if(search == 'none') {
							a.push(i);
						} else { // applied | removed
							tmp = $.inArray(i, displayFiltered);
							
							if((tmp === -1 && search == 'removed') ||
								(tmp >= 0 && search == 'applied')) {
								a.push(i);
							}
						}
					}
				}
				
				return a;
			};
			
			
			/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Rows
	 *
	 * {}          - no selector - use all available rows
	 * {integer}   - row aoData index
	 * {node}      - TR node
	 * {string}    - jQuery selector to apply to the TR elements
	 * {array}     - jQuery array of nodes, or simply an array of TR nodes
	 *
	 */
			var __row_selector = function(settings, selector, opts) {
				var rows;
				var run = function(sel) {
					var selInt = _intVal(sel);
					var i, ien;
					var aoData = settings.aoData;
					
					// Short cut - selector is a number and no options provided (default is
					// all records, so no need to check if the index is in there, since it
					// must be - dev error if the index doesn't exist).
					if(selInt !== null && !opts) {
						return [selInt];
					}
					
					if(!rows) {
						rows = _selector_row_indexes(settings, opts);
					}
					
					if(selInt !== null && $.inArray(selInt, rows) !== -1) {
						// Selector - integer
						return [selInt];
					} else if(sel === null || sel === undefined || sel === '') {
						// Selector - none
						return rows;
					}
					
					// Selector - function
					if(typeof sel === 'function') {
						return $.map(rows, function(idx) {
							var row = aoData[idx];
							return sel(idx, row._aData, row.nTr) ? idx : null;
						});
					}
					
					// Selector - node
					if(sel.nodeName) {
						var rowIdx = sel._DT_RowIndex;  // Property added by DT for fast lookup
						var cellIdx = sel._DT_CellIndex;
						
						if(rowIdx !== undefined) {
							// Make sure that the row is actually still present in the table
							return aoData[rowIdx] && aoData[rowIdx].nTr === sel ?
								[rowIdx] :
								[];
						} else if(cellIdx) {
							return aoData[cellIdx.row] && aoData[cellIdx.row].nTr === sel ?
								[cellIdx.row] :
								[];
						} else {
							var host = $(sel).closest('*[data-dt-row]');
							return host.length ?
								[host.data('dt-row')] :
								[];
						}
					}
					
					// ID selector. Want to always be able to select rows by id, regardless
					// of if the tr element has been created or not, so can't rely upon
					// jQuery here - hence a custom implementation. This does not match
					// Sizzle's fast selector or HTML4 - in HTML5 the ID can be anything,
					// but to select it using a CSS selector engine (like Sizzle or
					// querySelect) it would need to need to be escaped for some characters.
					// DataTables simplifies this for row selectors since you can select
					// only a row. A # indicates an id any anything that follows is the id -
					// unescaped.
					if(typeof sel === 'string' && sel.charAt(0) === '#') {
						// get row index from id
						var rowObj = settings.aIds[sel.replace(/^#/, '')];
						if(rowObj !== undefined) {
							return [rowObj.idx];
						}
						
						// need to fall through to jQuery in case there is DOM id that
						// matches
					}
					
					// Get nodes in the order from the `rows` array with null values removed
					var nodes = _removeEmpty(
						_pluck_order(settings.aoData, rows, 'nTr')
					);
					
					// Selector - jQuery selector string, array of nodes or jQuery object/
					// As jQuery's .filter() allows jQuery objects to be passed in filter,
					// it also allows arrays, so this will cope with all three options
					return $(nodes)
						.filter(sel)
						.map(function() {
							return this._DT_RowIndex;
						})
						.toArray();
				};
				
				return _selector_run('row', selector, run, settings, opts);
			};
			
			
			_api_register('rows()', function(selector, opts) {
				// argument shifting
				if(selector === undefined) {
					selector = '';
				} else if($.isPlainObject(selector)) {
					opts = selector;
					selector = '';
				}
				
				opts = _selector_opts(opts);
				
				var inst = this.iterator('table', function(settings) {
					return __row_selector(settings, selector, opts);
				}, 1);
				
				// Want argument shifting here and in __row_selector?
				inst.selector.rows = selector;
				inst.selector.opts = opts;
				
				return inst;
			});
			
			_api_register('rows().nodes()', function() {
				return this.iterator('row', function(settings, row) {
					return settings.aoData[row].nTr || undefined;
				}, 1);
			});
			
			_api_register('rows().data()', function() {
				return this.iterator(true, 'rows', function(settings, rows) {
					return _pluck_order(settings.aoData, rows, '_aData');
				}, 1);
			});
			
			_api_registerPlural('rows().cache()', 'row().cache()', function(type) {
				return this.iterator('row', function(settings, row) {
					var r = settings.aoData[row];
					return type === 'search' ? r._aFilterData : r._aSortData;
				}, 1);
			});
			
			_api_registerPlural('rows().invalidate()', 'row().invalidate()', function(src) {
				return this.iterator('row', function(settings, row) {
					_fnInvalidate(settings, row, src);
				});
			});
			
			_api_registerPlural('rows().indexes()', 'row().index()', function() {
				return this.iterator('row', function(settings, row) {
					return row;
				}, 1);
			});
			
			_api_registerPlural('rows().ids()', 'row().id()', function(hash) {
				var a = [];
				var context = this.context;
				
				// `iterator` will drop undefined values, but in this case we want them
				for(var i = 0, ien = context.length; i < ien; i++) {
					for(var j = 0, jen = this[i].length; j < jen; j++) {
						var id = context[i].rowIdFn(context[i].aoData[this[i][j]]._aData);
						a.push((hash === true ? '#' : '') + id);
					}
				}
				
				return new _Api(context, a);
			});
			
			_api_registerPlural('rows().remove()', 'row().remove()', function() {
				var that = this;
				
				this.iterator('row', function(settings, row, thatIdx) {
					var data = settings.aoData;
					var rowData = data[row];
					var i, ien, j, jen;
					var loopRow, loopCells;
					
					data.splice(row, 1);
					
					// Update the cached indexes
					for(i = 0, ien = data.length; i < ien; i++) {
						loopRow = data[i];
						loopCells = loopRow.anCells;
						
						// Rows
						if(loopRow.nTr !== null) {
							loopRow.nTr._DT_RowIndex = i;
						}
						
						// Cells
						if(loopCells !== null) {
							for(j = 0, jen = loopCells.length; j < jen; j++) {
								loopCells[j]._DT_CellIndex.row = i;
							}
						}
					}
					
					// Delete from the display arrays
					_fnDeleteIndex(settings.aiDisplayMaster, row);
					_fnDeleteIndex(settings.aiDisplay, row);
					_fnDeleteIndex(that[thatIdx], row, false); // maintain local indexes
					
					// For server-side processing tables - subtract the deleted row from the count
					if(settings._iRecordsDisplay > 0) {
						settings._iRecordsDisplay--;
					}
					
					// Check for an 'overflow' they case for displaying the table
					_fnLengthOverflow(settings);
					
					// Remove the row's ID reference if there is one
					var id = settings.rowIdFn(rowData._aData);
					if(id !== undefined) {
						delete settings.aIds[id];
					}
				});
				
				this.iterator('table', function(settings) {
					for(var i = 0, ien = settings.aoData.length; i < ien; i++) {
						settings.aoData[i].idx = i;
					}
				});
				
				return this;
			});
			
			
			_api_register('rows.add()', function(rows) {
				var newRows = this.iterator('table', function(settings) {
					var row, i, ien;
					var out = [];
					
					for(i = 0, ien = rows.length; i < ien; i++) {
						row = rows[i];
						
						if(row.nodeName && row.nodeName.toUpperCase() === 'TR') {
							out.push(_fnAddTr(settings, row)[0]);
						} else {
							out.push(_fnAddData(settings, row));
						}
					}
					
					return out;
				}, 1);
				
				// Return an Api.rows() extended instance, so rows().nodes() etc can be used
				var modRows = this.rows(-1);
				modRows.pop();
				$.merge(modRows, newRows);
				
				return modRows;
			});
			
			
			/**
			 *
			 */
			_api_register('row()', function(selector, opts) {
				return _selector_first(this.rows(selector, opts));
			});
			
			
			_api_register('row().data()', function(data) {
				var ctx = this.context;
				
				if(data === undefined) {
					// Get
					return ctx.length && this.length ?
						ctx[0].aoData[this[0]]._aData :
						undefined;
				}
				
				// Set
				var row = ctx[0].aoData[this[0]];
				row._aData = data;
				
				// If the DOM has an id, and the data source is an array
				if($.isArray(data) && row.nTr.id) {
					_fnSetObjectDataFn(ctx[0].rowId)(data, row.nTr.id);
				}
				
				// Automatically invalidate
				_fnInvalidate(ctx[0], this[0], 'data');
				
				return this;
			});
			
			
			_api_register('row().node()', function() {
				var ctx = this.context;
				
				return ctx.length && this.length ?
					ctx[0].aoData[this[0]].nTr || null :
					null;
			});
			
			
			_api_register('row.add()', function(row) {
				// Allow a jQuery object to be passed in - only a single row is added from
				// it though - the first element in the set
				if(row instanceof $ && row.length) {
					row = row[0];
				}
				
				var rows = this.iterator('table', function(settings) {
					if(row.nodeName && row.nodeName.toUpperCase() === 'TR') {
						return _fnAddTr(settings, row)[0];
					}
					return _fnAddData(settings, row);
				});
				
				// Return an Api.rows() extended instance, with the newly added row selected
				return this.row(rows[0]);
			});
			
			
			var __details_add = function(ctx, row, data, klass) {
				// Convert to array of TR elements
				var rows = [];
				var addRow = function(r, k) {
					// Recursion to allow for arrays of jQuery objects
					if($.isArray(r) || r instanceof $) {
						for(var i = 0, ien = r.length; i < ien; i++) {
							addRow(r[i], k);
						}
						return;
					}
					
					// If we get a TR element, then just add it directly - up to the dev
					// to add the correct number of columns etc
					if(r.nodeName && r.nodeName.toLowerCase() === 'tr') {
						rows.push(r);
					} else {
						// Otherwise create a row with a wrapper
						var created = $('<tr><td/></tr>').addClass(k);
						$('td', created)
							.addClass(k)
							.html(r)
							[0].colSpan = _fnVisbleColumns(ctx);
						
						rows.push(created[0]);
					}
				};
				
				addRow(data, klass);
				
				if(row._details) {
					row._details.detach();
				}
				
				row._details = $(rows);
				
				// If the children were already shown, that state should be retained
				if(row._detailsShow) {
					row._details.insertAfter(row.nTr);
				}
			};
			
			
			var __details_remove = function(api, idx) {
				var ctx = api.context;
				
				if(ctx.length) {
					var row = ctx[0].aoData[idx !== undefined ? idx : api[0]];
					
					if(row && row._details) {
						row._details.remove();
						
						row._detailsShow = undefined;
						row._details = undefined;
					}
				}
			};
			
			
			var __details_display = function(api, show) {
				var ctx = api.context;
				
				if(ctx.length && api.length) {
					var row = ctx[0].aoData[api[0]];
					
					if(row._details) {
						row._detailsShow = show;
						
						if(show) {
							row._details.insertAfter(row.nTr);
						} else {
							row._details.detach();
						}
						
						__details_events(ctx[0]);
					}
				}
			};
			
			
			var __details_events = function(settings) {
				var api = new _Api(settings);
				var namespace = '.dt.DT_details';
				var drawEvent = 'draw' + namespace;
				var colvisEvent = 'column-visibility' + namespace;
				var destroyEvent = 'destroy' + namespace;
				var data = settings.aoData;
				
				api.off(drawEvent + ' ' + colvisEvent + ' ' + destroyEvent);
				
				if(_pluck(data, '_details').length > 0) {
					// On each draw, insert the required elements into the document
					api.on(drawEvent, function(e, ctx) {
						if(settings !== ctx) {
							return;
						}
						
						api.rows({page: 'current'}).eq(0).each(function(idx) {
							// Internal data grab
							var row = data[idx];
							
							if(row._detailsShow) {
								row._details.insertAfter(row.nTr);
							}
						});
					});
					
					// Column visibility change - update the colspan
					api.on(colvisEvent, function(e, ctx, idx, vis) {
						if(settings !== ctx) {
							return;
						}
						
						// Update the colspan for the details rows (note, only if it already has
						// a colspan)
						var row, visible = _fnVisbleColumns(ctx);
						
						for(var i = 0, ien = data.length; i < ien; i++) {
							row = data[i];
							
							if(row._details) {
								row._details.children('td[colspan]').attr('colspan', visible);
							}
						}
					});
					
					// Table destroyed - nuke any child rows
					api.on(destroyEvent, function(e, ctx) {
						if(settings !== ctx) {
							return;
						}
						
						for(var i = 0, ien = data.length; i < ien; i++) {
							if(data[i]._details) {
								__details_remove(api, i);
							}
						}
					});
				}
			};
			
			// Strings for the method names to help minification
			var _emp = '';
			var _child_obj = _emp + 'row().child';
			var _child_mth = _child_obj + '()';
			
			// data can be:
			//  tr
			//  string
			//  jQuery or array of any of the above
			_api_register(_child_mth, function(data, klass) {
				var ctx = this.context;
				
				if(data === undefined) {
					// get
					return ctx.length && this.length ?
						ctx[0].aoData[this[0]]._details :
						undefined;
				} else if(data === true) {
					// show
					this.child.show();
				} else if(data === false) {
					// remove
					__details_remove(this);
				} else if(ctx.length && this.length) {
					// set
					__details_add(ctx[0], ctx[0].aoData[this[0]], data, klass);
				}
				
				return this;
			});
			
			
			_api_register([
				_child_obj + '.show()',
				_child_mth + '.show()' // only when `child()` was called with parameters (without
			], function(show) {   // it returns an object and this method is not executed)
				__details_display(this, true);
				return this;
			});
			
			
			_api_register([
				_child_obj + '.hide()',
				_child_mth + '.hide()' // only when `child()` was called with parameters (without
			], function() {         // it returns an object and this method is not executed)
				__details_display(this, false);
				return this;
			});
			
			
			_api_register([
				_child_obj + '.remove()',
				_child_mth + '.remove()' // only when `child()` was called with parameters (without
			], function() {           // it returns an object and this method is not executed)
				__details_remove(this);
				return this;
			});
			
			
			_api_register(_child_obj + '.isShown()', function() {
				var ctx = this.context;
				
				if(ctx.length && this.length) {
					// _detailsShown as false or undefined will fall through to return false
					return ctx[0].aoData[this[0]]._detailsShow || false;
				}
				return false;
			});
			
			
			/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Columns
	 *
	 * {integer}           - column index (>=0 count from left, <0 count from right)
	 * "{integer}:visIdx"  - visible column index (i.e. translate to column index)  (>=0 count from left, <0 count from right)
	 * "{integer}:visible" - alias for {integer}:visIdx  (>=0 count from left, <0 count from right)
	 * "{string}:name"     - column name
	 * "{string}"          - jQuery selector on column header nodes
	 *
	 */
			
			// can be an array of these items, comma separated list, or an array of comma
			// separated lists
			
			var __re_column_selector = /^([^:]+):(name|visIdx|visible)$/;
			
			
			// r1 and r2 are redundant - but it means that the parameters match for the
			// iterator callback in columns().data()
			var __columnData = function(settings, column, r1, r2, rows) {
				var a = [];
				for(var row = 0, ien = rows.length; row < ien; row++) {
					a.push(_fnGetCellData(settings, rows[row], column));
				}
				return a;
			};
			
			
			var __column_selector = function(settings, selector, opts) {
				var
					columns = settings.aoColumns,
					names = _pluck(columns, 'sName'),
					nodes = _pluck(columns, 'nTh');
				
				var run = function(s) {
					var selInt = _intVal(s);
					
					// Selector - all
					if(s === '') {
						return _range(columns.length);
					}
					
					// Selector - index
					if(selInt !== null) {
						return [selInt >= 0 ?
							selInt : // Count from left
							columns.length + selInt // Count from right (+ because its a negative value)
						];
					}
					
					// Selector = function
					if(typeof s === 'function') {
						var rows = _selector_row_indexes(settings, opts);
						
						return $.map(columns, function(col, idx) {
							return s(
								idx,
								__columnData(settings, idx, 0, 0, rows),
								nodes[idx]
							) ? idx : null;
						});
					}
					
					// jQuery or string selector
					var match = typeof s === 'string' ?
						s.match(__re_column_selector) :
						'';
					
					if(match) {
						switch(match[2]) {
							case 'visIdx':
							case 'visible':
								var idx = parseInt(match[1], 10);
								// Visible index given, convert to column index
								if(idx < 0) {
									// Counting from the right
									var visColumns = $.map(columns, function(col, i) {
										return col.bVisible ? i : null;
									});
									return [visColumns[visColumns.length + idx]];
								}
								// Counting from the left
								return [_fnVisibleToColumnIndex(settings, idx)];
							
							case 'name':
								// match by name. `names` is column index complete and in order
								return $.map(names, function(name, i) {
									return name === match[1] ? i : null;
								});
							
							default:
								return [];
						}
					}
					
					// Cell in the table body
					if(s.nodeName && s._DT_CellIndex) {
						return [s._DT_CellIndex.column];
					}
					
					// jQuery selector on the TH elements for the columns
					var jqResult = $(nodes)
						.filter(s)
						.map(function() {
							return $.inArray(this, nodes); // `nodes` is column index complete and in order
						})
						.toArray();
					
					if(jqResult.length || !s.nodeName) {
						return jqResult;
					}
					
					// Otherwise a node which might have a `dt-column` data attribute, or be
					// a child or such an element
					var host = $(s).closest('*[data-dt-column]');
					return host.length ?
						[host.data('dt-column')] :
						[];
				};
				
				return _selector_run('column', selector, run, settings, opts);
			};
			
			
			var __setColumnVis = function(settings, column, vis) {
				var
					cols = settings.aoColumns,
					col = cols[column],
					data = settings.aoData,
					row, cells, i, ien, tr;
				
				// Get
				if(vis === undefined) {
					return col.bVisible;
				}
				
				// Set
				// No change
				if(col.bVisible === vis) {
					return;
				}
				
				if(vis) {
					// Insert column
					// Need to decide if we should use appendChild or insertBefore
					var insertBefore = $.inArray(true, _pluck(cols, 'bVisible'), column + 1);
					
					for(i = 0, ien = data.length; i < ien; i++) {
						tr = data[i].nTr;
						cells = data[i].anCells;
						
						if(tr) {
							// insertBefore can act like appendChild if 2nd arg is null
							tr.insertBefore(cells[column], cells[insertBefore] || null);
						}
					}
				} else {
					// Remove column
					$(_pluck(settings.aoData, 'anCells', column)).detach();
				}
				
				// Common actions
				col.bVisible = vis;
				_fnDrawHead(settings, settings.aoHeader);
				_fnDrawHead(settings, settings.aoFooter);
				
				// Update colspan for no records display. Child rows and extensions will use their own
				// listeners to do this - only need to update the empty table item here
				if(!settings.aiDisplay.length) {
					$(settings.nTBody).find('td[colspan]').attr('colspan', _fnVisbleColumns(settings));
				}
				
				_fnSaveState(settings);
			};
			
			
			_api_register('columns()', function(selector, opts) {
				// argument shifting
				if(selector === undefined) {
					selector = '';
				} else if($.isPlainObject(selector)) {
					opts = selector;
					selector = '';
				}
				
				opts = _selector_opts(opts);
				
				var inst = this.iterator('table', function(settings) {
					return __column_selector(settings, selector, opts);
				}, 1);
				
				// Want argument shifting here and in _row_selector?
				inst.selector.cols = selector;
				inst.selector.opts = opts;
				
				return inst;
			});
			
			_api_registerPlural('columns().header()', 'column().header()', function(selector, opts) {
				return this.iterator('column', function(settings, column) {
					return settings.aoColumns[column].nTh;
				}, 1);
			});
			
			_api_registerPlural('columns().footer()', 'column().footer()', function(selector, opts) {
				return this.iterator('column', function(settings, column) {
					return settings.aoColumns[column].nTf;
				}, 1);
			});
			
			_api_registerPlural('columns().data()', 'column().data()', function() {
				return this.iterator('column-rows', __columnData, 1);
			});
			
			_api_registerPlural('columns().dataSrc()', 'column().dataSrc()', function() {
				return this.iterator('column', function(settings, column) {
					return settings.aoColumns[column].mData;
				}, 1);
			});
			
			_api_registerPlural('columns().cache()', 'column().cache()', function(type) {
				return this.iterator('column-rows', function(settings, column, i, j, rows) {
					return _pluck_order(settings.aoData, rows,
						type === 'search' ? '_aFilterData' : '_aSortData', column
					);
				}, 1);
			});
			
			_api_registerPlural('columns().nodes()', 'column().nodes()', function() {
				return this.iterator('column-rows', function(settings, column, i, j, rows) {
					return _pluck_order(settings.aoData, rows, 'anCells', column);
				}, 1);
			});
			
			_api_registerPlural('columns().visible()', 'column().visible()', function(vis, calc) {
				var ret = this.iterator('column', function(settings, column) {
					if(vis === undefined) {
						return settings.aoColumns[column].bVisible;
					} // else
					__setColumnVis(settings, column, vis);
				});
				
				// Group the column visibility changes
				if(vis !== undefined) {
					// Second loop once the first is done for events
					this.iterator('column', function(settings, column) {
						_fnCallbackFire(settings, null, 'column-visibility', [settings, column, vis, calc]);
					});
					
					if(calc === undefined || calc) {
						this.columns.adjust();
					}
				}
				
				return ret;
			});
			
			_api_registerPlural('columns().indexes()', 'column().index()', function(type) {
				return this.iterator('column', function(settings, column) {
					return type === 'visible' ?
						_fnColumnIndexToVisible(settings, column) :
						column;
				}, 1);
			});
			
			_api_register('columns.adjust()', function() {
				return this.iterator('table', function(settings) {
					_fnAdjustColumnSizing(settings);
				}, 1);
			});
			
			_api_register('column.index()', function(type, idx) {
				if(this.context.length !== 0) {
					var ctx = this.context[0];
					
					if(type === 'fromVisible' || type === 'toData') {
						return _fnVisibleToColumnIndex(ctx, idx);
					} else if(type === 'fromData' || type === 'toVisible') {
						return _fnColumnIndexToVisible(ctx, idx);
					}
				}
			});
			
			_api_register('column()', function(selector, opts) {
				return _selector_first(this.columns(selector, opts));
			});
			
			
			var __cell_selector = function(settings, selector, opts) {
				var data = settings.aoData;
				var rows = _selector_row_indexes(settings, opts);
				var cells = _removeEmpty(_pluck_order(data, rows, 'anCells'));
				var allCells = $([].concat.apply([], cells));
				var row;
				var columns = settings.aoColumns.length;
				var a, i, ien, j, o, host;
				
				var run = function(s) {
					var fnSelector = typeof s === 'function';
					
					if(s === null || s === undefined || fnSelector) {
						// All cells and function selectors
						a = [];
						
						for(i = 0, ien = rows.length; i < ien; i++) {
							row = rows[i];
							
							for(j = 0; j < columns; j++) {
								o = {
									row: row,
									column: j
								};
								
								if(fnSelector) {
									// Selector - function
									host = data[row];
									
									if(s(o, _fnGetCellData(settings, row, j), host.anCells ? host.anCells[j] : null)) {
										a.push(o);
									}
								} else {
									// Selector - all
									a.push(o);
								}
							}
						}
						
						return a;
					}
					
					// Selector - index
					if($.isPlainObject(s)) {
						// Valid cell index and its in the array of selectable rows
						return s.column !== undefined && s.row !== undefined && $.inArray(s.row, rows) !== -1 ?
							[s] :
							[];
					}
					
					// Selector - jQuery filtered cells
					var jqResult = allCells
						.filter(s)
						.map(function(i, el) {
							return { // use a new object, in case someone changes the values
								row: el._DT_CellIndex.row,
								column: el._DT_CellIndex.column
							};
						})
						.toArray();
					
					if(jqResult.length || !s.nodeName) {
						return jqResult;
					}
					
					// Otherwise the selector is a node, and there is one last option - the
					// element might be a child of an element which has dt-row and dt-column
					// data attributes
					host = $(s).closest('*[data-dt-row]');
					return host.length ?
						[{
							row: host.data('dt-row'),
							column: host.data('dt-column')
						}] :
						[];
				};
				
				return _selector_run('cell', selector, run, settings, opts);
			};
			
			
			_api_register('cells()', function(rowSelector, columnSelector, opts) {
				// Argument shifting
				if($.isPlainObject(rowSelector)) {
					// Indexes
					if(rowSelector.row === undefined) {
						// Selector options in first parameter
						opts = rowSelector;
						rowSelector = null;
					} else {
						// Cell index objects in first parameter
						opts = columnSelector;
						columnSelector = null;
					}
				}
				if($.isPlainObject(columnSelector)) {
					opts = columnSelector;
					columnSelector = null;
				}
				
				// Cell selector
				if(columnSelector === null || columnSelector === undefined) {
					return this.iterator('table', function(settings) {
						return __cell_selector(settings, rowSelector, _selector_opts(opts));
					});
				}
				
				// Row + column selector
				var columns = this.columns(columnSelector);
				var rows = this.rows(rowSelector);
				var a, i, ien, j, jen;
				
				this.iterator('table', function(settings, idx) {
					a = [];
					
					for(i = 0, ien = rows[idx].length; i < ien; i++) {
						for(j = 0, jen = columns[idx].length; j < jen; j++) {
							a.push({
								row: rows[idx][i],
								column: columns[idx][j]
							});
						}
					}
				}, 1);
				
				// Now pass through the cell selector for options
				var cells = this.cells(a, opts);
				
				$.extend(cells.selector, {
					cols: columnSelector,
					rows: rowSelector,
					opts: opts
				});
				
				return cells;
			});
			
			
			_api_registerPlural('cells().nodes()', 'cell().node()', function() {
				return this.iterator('cell', function(settings, row, column) {
					var data = settings.aoData[row];
					
					return data && data.anCells ?
						data.anCells[column] :
						undefined;
				}, 1);
			});
			
			
			_api_register('cells().data()', function() {
				return this.iterator('cell', function(settings, row, column) {
					return _fnGetCellData(settings, row, column);
				}, 1);
			});
			
			
			_api_registerPlural('cells().cache()', 'cell().cache()', function(type) {
				type = type === 'search' ? '_aFilterData' : '_aSortData';
				
				return this.iterator('cell', function(settings, row, column) {
					return settings.aoData[row][type][column];
				}, 1);
			});
			
			
			_api_registerPlural('cells().render()', 'cell().render()', function(type) {
				return this.iterator('cell', function(settings, row, column) {
					return _fnGetCellData(settings, row, column, type);
				}, 1);
			});
			
			
			_api_registerPlural('cells().indexes()', 'cell().index()', function() {
				return this.iterator('cell', function(settings, row, column) {
					return {
						row: row,
						column: column,
						columnVisible: _fnColumnIndexToVisible(settings, column)
					};
				}, 1);
			});
			
			
			_api_registerPlural('cells().invalidate()', 'cell().invalidate()', function(src) {
				return this.iterator('cell', function(settings, row, column) {
					_fnInvalidate(settings, row, src, column);
				});
			});
			
			
			_api_register('cell()', function(rowSelector, columnSelector, opts) {
				return _selector_first(this.cells(rowSelector, columnSelector, opts));
			});
			
			
			_api_register('cell().data()', function(data) {
				var ctx = this.context;
				var cell = this[0];
				
				if(data === undefined) {
					// Get
					return ctx.length && cell.length ?
						_fnGetCellData(ctx[0], cell[0].row, cell[0].column) :
						undefined;
				}
				
				// Set
				_fnSetCellData(ctx[0], cell[0].row, cell[0].column, data);
				_fnInvalidate(ctx[0], cell[0].row, 'data', cell[0].column);
				
				return this;
			});
			
			
			/**
			 * Get current ordering (sorting) that has been applied to the table.
			 *
			 * @returns {array} 2D array containing the sorting information for the first
			 *   table in the current context. Each element in the parent array represents
			 *   a column being sorted upon (i.e. multi-sorting with two columns would have
			 *   2 inner arrays). The inner arrays may have 2 or 3 elements. The first is
			 *   the column index that the sorting condition applies to, the second is the
			 *   direction of the sort (`desc` or `asc`) and, optionally, the third is the
			 *   index of the sorting order from the `column.sorting` initialisation array.
			 *//**
			 * Set the ordering for the table.
			 *
			 * @param {integer} order Column index to sort upon.
			 * @param {string} direction Direction of the sort to be applied (`asc` or `desc`)
			 * @returns {DataTables.Api} this
			 *//**
			 * Set the ordering for the table.
			 *
			 * @param {array} order 1D array of sorting information to be applied.
			 * @param {array} [...] Optional additional sorting conditions
			 * @returns {DataTables.Api} this
			 */
			/**
			 * Set the ordering for the table.
			 *
			 * @param {array} order 2D array of sorting information to be applied.
			 * @returns {DataTables.Api} this
			 */
			_api_register('order()', function(order, dir) {
				var ctx = this.context;
				
				if(order === undefined) {
					// get
					return ctx.length !== 0 ?
						ctx[0].aaSorting :
						undefined;
				}
				
				// set
				if(typeof order === 'number') {
					// Simple column / direction passed in
					order = [[order, dir]];
				} else if(order.length && !$.isArray(order[0])) {
					// Arguments passed in (list of 1D arrays)
					order = Array.prototype.slice.call(arguments);
				}
				// otherwise a 2D array was passed in
				
				return this.iterator('table', function(settings) {
					settings.aaSorting = order.slice();
				});
			});
			
			
			/**
			 * Attach a sort listener to an element for a given column
			 *
			 * @param {node|jQuery|string} node Identifier for the element(s) to attach the
			 *   listener to. This can take the form of a single DOM node, a jQuery
			 *   collection of nodes or a jQuery selector which will identify the node(s).
			 * @param {integer} column the column that a click on this node will sort on
			 * @param {function} [callback] callback function when sort is run
			 * @returns {DataTables.Api} this
			 */
			_api_register('order.listener()', function(node, column, callback) {
				return this.iterator('table', function(settings) {
					_fnSortAttachListener(settings, node, column, callback);
				});
			});
			
			
			_api_register('order.fixed()', function(set) {
				if(!set) {
					var ctx = this.context;
					var fixed = ctx.length ?
						ctx[0].aaSortingFixed :
						undefined;
					
					return $.isArray(fixed) ?
						{pre: fixed} :
						fixed;
				}
				
				return this.iterator('table', function(settings) {
					settings.aaSortingFixed = $.extend(true, {}, set);
				});
			});
			
			
			// Order by the selected column(s)
			_api_register([
				'columns().order()',
				'column().order()'
			], function(dir) {
				var that = this;
				
				return this.iterator('table', function(settings, i) {
					var sort = [];
					
					$.each(that[i], function(j, col) {
						sort.push([col, dir]);
					});
					
					settings.aaSorting = sort;
				});
			});
			
			
			_api_register('search()', function(input, regex, smart, caseInsen) {
				var ctx = this.context;
				
				if(input === undefined) {
					// get
					return ctx.length !== 0 ?
						ctx[0].oPreviousSearch.sSearch :
						undefined;
				}
				
				// set
				return this.iterator('table', function(settings) {
					if(!settings.oFeatures.bFilter) {
						return;
					}
					
					_fnFilterComplete(settings, $.extend({}, settings.oPreviousSearch, {
						"sSearch": input + "",
						"bRegex": regex === null ? false : regex,
						"bSmart": smart === null ? true : smart,
						"bCaseInsensitive": caseInsen === null ? true : caseInsen
					}), 1);
				});
			});
			
			
			_api_registerPlural(
				'columns().search()',
				'column().search()',
				function(input, regex, smart, caseInsen) {
					return this.iterator('column', function(settings, column) {
						var preSearch = settings.aoPreSearchCols;
						
						if(input === undefined) {
							// get
							return preSearch[column].sSearch;
						}
						
						// set
						if(!settings.oFeatures.bFilter) {
							return;
						}
						
						$.extend(preSearch[column], {
							"sSearch": input + "",
							"bRegex": regex === null ? false : regex,
							"bSmart": smart === null ? true : smart,
							"bCaseInsensitive": caseInsen === null ? true : caseInsen
						});
						
						_fnFilterComplete(settings, settings.oPreviousSearch, 1);
					});
				}
			);
			
			/*
	 * State API methods
	 */
			
			_api_register('state()', function() {
				return this.context.length ?
					this.context[0].oSavedState :
					null;
			});
			
			
			_api_register('state.clear()', function() {
				return this.iterator('table', function(settings) {
					// Save an empty object
					settings.fnStateSaveCallback.call(settings.oInstance, settings, {});
				});
			});
			
			
			_api_register('state.loaded()', function() {
				return this.context.length ?
					this.context[0].oLoadedState :
					null;
			});
			
			
			_api_register('state.save()', function() {
				return this.iterator('table', function(settings) {
					_fnSaveState(settings);
				});
			});
			
			
			/**
			 * Provide a common method for plug-ins to check the version of DataTables being
			 * used, in order to ensure compatibility.
			 *
			 *  @param {string} version Version string to check for, in the format "X.Y.Z".
			 *    Note that the formats "X" and "X.Y" are also acceptable.
			 *  @returns {boolean} true if this version of DataTables is greater or equal to
			 *    the required version, or false if this version of DataTales is not
			 *    suitable
			 *  @static
			 *  @dtopt API-Static
			 *
			 *  @example
			 *    alert( $.fn.dataTable.versionCheck( '1.9.0' ) );
			 */
			DataTable.versionCheck = DataTable.fnVersionCheck = function(version) {
				var aThis = DataTable.version.split('.');
				var aThat = version.split('.');
				var iThis, iThat;
				
				for(var i = 0, iLen = aThat.length; i < iLen; i++) {
					iThis = parseInt(aThis[i], 10) || 0;
					iThat = parseInt(aThat[i], 10) || 0;
					
					// Parts are the same, keep comparing
					if(iThis === iThat) {
						continue;
					}
					
					// Parts are different, return immediately
					return iThis > iThat;
				}
				
				return true;
			};
			
			
			/**
			 * Check if a `<table>` node is a DataTable table already or not.
			 *
			 *  @param {node|jquery|string} table Table node, jQuery object or jQuery
			 *      selector for the table to test. Note that if more than more than one
			 *      table is passed on, only the first will be checked
			 *  @returns {boolean} true the table given is a DataTable, or false otherwise
			 *  @static
			 *  @dtopt API-Static
			 *
			 *  @example
			 *    if ( ! $.fn.DataTable.isDataTable( '#example' ) ) {
			 *      $('#example').dataTable();
			 *    }
			 */
			DataTable.isDataTable = DataTable.fnIsDataTable = function(table) {
				var t = $(table).get(0);
				var is = false;
				
				if(table instanceof DataTable.Api) {
					return true;
				}
				
				$.each(DataTable.settings, function(i, o) {
					var head = o.nScrollHead ? $('table', o.nScrollHead)[0] : null;
					var foot = o.nScrollFoot ? $('table', o.nScrollFoot)[0] : null;
					
					if(o.nTable === t || head === t || foot === t) {
						is = true;
					}
				});
				
				return is;
			};
			
			
			/**
			 * Get all DataTable tables that have been initialised - optionally you can
			 * select to get only currently visible tables.
			 *
			 *  @param {boolean} [visible=false] Flag to indicate if you want all (default)
			 *    or visible tables only.
			 *  @returns {array} Array of `table` nodes (not DataTable instances) which are
			 *    DataTables
			 *  @static
			 *  @dtopt API-Static
			 *
			 *  @example
			 *    $.each( $.fn.dataTable.tables(true), function () {
			 *      $(table).DataTable().columns.adjust();
			 *    } );
			 */
			DataTable.tables = DataTable.fnTables = function(visible) {
				var api = false;
				
				if($.isPlainObject(visible)) {
					api = visible.api;
					visible = visible.visible;
				}
				
				var a = $.map(DataTable.settings, function(o) {
					if(!visible || (visible && $(o.nTable).is(':visible'))) {
						return o.nTable;
					}
				});
				
				return api ?
					new _Api(a) :
					a;
			};
			
			
			/**
			 * Convert from camel case parameters to Hungarian notation. This is made public
			 * for the extensions to provide the same ability as DataTables core to accept
			 * either the 1.9 style Hungarian notation, or the 1.10+ style camelCase
			 * parameters.
			 *
			 *  @param {object} src The model object which holds all parameters that can be
			 *    mapped.
			 *  @param {object} user The object to convert from camel case to Hungarian.
			 *  @param {boolean} force When set to `true`, properties which already have a
			 *    Hungarian value in the `user` object will be overwritten. Otherwise they
			 *    won't be.
			 */
			DataTable.camelToHungarian = _fnCamelToHungarian;
			
			
			/**
			 *
			 */
			_api_register('$()', function(selector, opts) {
				var
					rows = this.rows(opts).nodes(), // Get all rows
					jqRows = $(rows);
				
				return $([].concat(
					jqRows.filter(selector).toArray(),
					jqRows.find(selector).toArray()
				));
			});
			
			
			// jQuery functions to operate on the tables
			$.each(['on', 'one', 'off'], function(i, key) {
				_api_register(key + '()', function( /* event, handler */) {
					var args = Array.prototype.slice.call(arguments);
					
					// Add the `dt` namespace automatically if it isn't already present
					args[0] = $.map(args[0].split(/\s/), function(e) {
						return !e.match(/\.dt\b/) ?
							e + '.dt' :
							e;
					}).join(' ');
					
					var inst = $(this.tables().nodes());
					inst[key].apply(inst, args);
					return this;
				});
			});
			
			
			_api_register('clear()', function() {
				return this.iterator('table', function(settings) {
					_fnClearTable(settings);
				});
			});
			
			
			_api_register('settings()', function() {
				return new _Api(this.context, this.context);
			});
			
			
			_api_register('init()', function() {
				var ctx = this.context;
				return ctx.length ? ctx[0].oInit : null;
			});
			
			
			_api_register('data()', function() {
				return this.iterator('table', function(settings) {
					return _pluck(settings.aoData, '_aData');
				}).flatten();
			});
			
			
			_api_register('destroy()', function(remove) {
				remove = remove || false;
				
				return this.iterator('table', function(settings) {
					var orig = settings.nTableWrapper.parentNode;
					var classes = settings.oClasses;
					var table = settings.nTable;
					var tbody = settings.nTBody;
					var thead = settings.nTHead;
					var tfoot = settings.nTFoot;
					var jqTable = $(table);
					var jqTbody = $(tbody);
					var jqWrapper = $(settings.nTableWrapper);
					var rows = $.map(settings.aoData, function(r) {
						return r.nTr;
					});
					var i, ien;
					
					// Flag to note that the table is currently being destroyed - no action
					// should be taken
					settings.bDestroying = true;
					
					// Fire off the destroy callbacks for plug-ins etc
					_fnCallbackFire(settings, "aoDestroyCallback", "destroy", [settings]);
					
					// If not being removed from the document, make all columns visible
					if(!remove) {
						new _Api(settings).columns().visible(true);
					}
					
					// Blitz all `DT` namespaced events (these are internal events, the
					// lowercase, `dt` events are user subscribed and they are responsible
					// for removing them
					jqWrapper.off('.DT').find(':not(tbody *)').off('.DT');
					$(window).off('.DT-' + settings.sInstance);
					
					// When scrolling we had to break the table up - restore it
					if(table != thead.parentNode) {
						jqTable.children('thead').detach();
						jqTable.append(thead);
					}
					
					if(tfoot && table != tfoot.parentNode) {
						jqTable.children('tfoot').detach();
						jqTable.append(tfoot);
					}
					
					settings.aaSorting = [];
					settings.aaSortingFixed = [];
					_fnSortingClasses(settings);
					
					$(rows).removeClass(settings.asStripeClasses.join(' '));
					
					$('th, td', thead).removeClass(classes.sSortable + ' ' +
						classes.sSortableAsc + ' ' + classes.sSortableDesc + ' ' + classes.sSortableNone
					);
					
					// Add the TR elements back into the table in their original order
					jqTbody.children().detach();
					jqTbody.append(rows);
					
					// Remove the DataTables generated nodes, events and classes
					var removedMethod = remove ? 'remove' : 'detach';
					jqTable[removedMethod]();
					jqWrapper[removedMethod]();
					
					// If we need to reattach the table to the document
					if(!remove && orig) {
						// insertBefore acts like appendChild if !arg[1]
						orig.insertBefore(table, settings.nTableReinsertBefore);
						
						// Restore the width of the original table - was read from the style property,
						// so we can restore directly to that
						jqTable
							.css('width', settings.sDestroyWidth)
							.removeClass(classes.sTable);
						
						// If the were originally stripe classes - then we add them back here.
						// Note this is not fool proof (for example if not all rows had stripe
						// classes - but it's a good effort without getting carried away
						ien = settings.asDestroyStripes.length;
						
						if(ien) {
							jqTbody.children().each(function(i) {
								$(this).addClass(settings.asDestroyStripes[i % ien]);
							});
						}
					}
					
					/* Remove the settings object from the settings array */
					var idx = $.inArray(settings, DataTable.settings);
					if(idx !== -1) {
						DataTable.settings.splice(idx, 1);
					}
				});
			});
			
			
			// Add the `every()` method for rows, columns and cells in a compact form
			$.each(['column', 'row', 'cell'], function(i, type) {
				_api_register(type + 's().every()', function(fn) {
					var opts = this.selector.opts;
					var api = this;
					
					return this.iterator(type, function(settings, arg1, arg2, arg3, arg4) {
						// Rows and columns:
						//  arg1 - index
						//  arg2 - table counter
						//  arg3 - loop counter
						//  arg4 - undefined
						// Cells:
						//  arg1 - row index
						//  arg2 - column index
						//  arg3 - table counter
						//  arg4 - loop counter
						fn.call(
							api[type](
								arg1,
								type === 'cell' ? arg2 : opts,
								type === 'cell' ? opts : undefined
							),
							arg1, arg2, arg3, arg4
						);
					});
				});
			});
			
			
			// i18n method for extensions to be able to use the language object from the
			// DataTable
			_api_register('i18n()', function(token, def, plural) {
				var ctx = this.context[0];
				var resolved = _fnGetObjectDataFn(token)(ctx.oLanguage);
				
				if(resolved === undefined) {
					resolved = def;
				}
				
				if(plural !== undefined && $.isPlainObject(resolved)) {
					resolved = resolved[plural] !== undefined ?
						resolved[plural] :
						resolved._;
				}
				
				return resolved.replace('%d', plural); // nb: plural might be undefined,
			});
			/**
			 * Version string for plug-ins to check compatibility. Allowed format is
			 * `a.b.c-d` where: a:int, b:int, c:int, d:string(dev|beta|alpha). `d` is used
			 * only for non-release builds. See http://semver.org/ for more information.
			 *  @member
			 *  @type string
			 *  @default Version number
			 */
			DataTable.version = "1.10.19";
			
			/**
			 * Private data store, containing all of the settings objects that are
			 * created for the tables on a given page.
			 *
			 * Note that the `DataTable.settings` object is aliased to
			 * `jQuery.fn.dataTableExt` through which it may be accessed and
			 * manipulated, or `jQuery.fn.dataTable.settings`.
			 *  @member
			 *  @type array
			 *  @default []
			 *  @private
			 */
			DataTable.settings = [];
			
			/**
			 * Object models container, for the various models that DataTables has
			 * available to it. These models define the objects that are used to hold
			 * the active state and configuration of the table.
			 *  @namespace
			 */
			DataTable.models = {};
			
			
			/**
			 * Template object for the way in which DataTables holds information about
			 * search information for the global filter and individual column filters.
			 *  @namespace
			 */
			DataTable.models.oSearch = {
				/**
				 * Flag to indicate if the filtering should be case insensitive or not
				 *  @type boolean
				 *  @default true
				 */
				"bCaseInsensitive": true,
				
				/**
				 * Applied search term
				 *  @type string
				 *  @default <i>Empty string</i>
				 */
				"sSearch": "",
				
				/**
				 * Flag to indicate if the search term should be interpreted as a
				 * regular expression (true) or not (false) and therefore and special
				 * regex characters escaped.
				 *  @type boolean
				 *  @default false
				 */
				"bRegex": false,
				
				/**
				 * Flag to indicate if DataTables is to use its smart filtering or not.
				 *  @type boolean
				 *  @default true
				 */
				"bSmart": true
			};
			
			
			/**
			 * Template object for the way in which DataTables holds information about
			 * each individual row. This is the object format used for the settings
			 * aoData array.
			 *  @namespace
			 */
			DataTable.models.oRow = {
				/**
				 * TR element for the row
				 *  @type node
				 *  @default null
				 */
				"nTr": null,
				
				/**
				 * Array of TD elements for each row. This is null until the row has been
				 * created.
				 *  @type array nodes
				 *  @default []
				 */
				"anCells": null,
				
				/**
				 * Data object from the original data source for the row. This is either
				 * an array if using the traditional form of DataTables, or an object if
				 * using mData options. The exact type will depend on the passed in
				 * data from the data source, or will be an array if using DOM a data
				 * source.
				 *  @type array|object
				 *  @default []
				 */
				"_aData": [],
				
				/**
				 * Sorting data cache - this array is ostensibly the same length as the
				 * number of columns (although each index is generated only as it is
				 * needed), and holds the data that is used for sorting each column in the
				 * row. We do this cache generation at the start of the sort in order that
				 * the formatting of the sort data need be done only once for each cell
				 * per sort. This array should not be read from or written to by anything
				 * other than the master sorting methods.
				 *  @type array
				 *  @default null
				 *  @private
				 */
				"_aSortData": null,
				
				/**
				 * Per cell filtering data cache. As per the sort data cache, used to
				 * increase the performance of the filtering in DataTables
				 *  @type array
				 *  @default null
				 *  @private
				 */
				"_aFilterData": null,
				
				/**
				 * Filtering data cache. This is the same as the cell filtering cache, but
				 * in this case a string rather than an array. This is easily computed with
				 * a join on `_aFilterData`, but is provided as a cache so the join isn't
				 * needed on every search (memory traded for performance)
				 *  @type array
				 *  @default null
				 *  @private
				 */
				"_sFilterRow": null,
				
				/**
				 * Cache of the class name that DataTables has applied to the row, so we
				 * can quickly look at this variable rather than needing to do a DOM check
				 * on className for the nTr property.
				 *  @type string
				 *  @default <i>Empty string</i>
				 *  @private
				 */
				"_sRowStripe": "",
				
				/**
				 * Denote if the original data source was from the DOM, or the data source
				 * object. This is used for invalidating data, so DataTables can
				 * automatically read data from the original source, unless uninstructed
				 * otherwise.
				 *  @type string
				 *  @default null
				 *  @private
				 */
				"src": null,
				
				/**
				 * Index in the aoData array. This saves an indexOf lookup when we have the
				 * object, but want to know the index
				 *  @type integer
				 *  @default -1
				 *  @private
				 */
				"idx": -1
			};
			
			
			/**
			 * Template object for the column information object in DataTables. This object
			 * is held in the settings aoColumns array and contains all the information that
			 * DataTables needs about each individual column.
			 *
			 * Note that this object is related to {@link DataTable.defaults.column}
			 * but this one is the internal data store for DataTables's cache of columns.
			 * It should NOT be manipulated outside of DataTables. Any configuration should
			 * be done through the initialisation options.
			 *  @namespace
			 */
			DataTable.models.oColumn = {
				/**
				 * Column index. This could be worked out on-the-fly with $.inArray, but it
				 * is faster to just hold it as a variable
				 *  @type integer
				 *  @default null
				 */
				"idx": null,
				
				/**
				 * A list of the columns that sorting should occur on when this column
				 * is sorted. That this property is an array allows multi-column sorting
				 * to be defined for a column (for example first name / last name columns
				 * would benefit from this). The values are integers pointing to the
				 * columns to be sorted on (typically it will be a single integer pointing
				 * at itself, but that doesn't need to be the case).
				 *  @type array
				 */
				"aDataSort": null,
				
				/**
				 * Define the sorting directions that are applied to the column, in sequence
				 * as the column is repeatedly sorted upon - i.e. the first value is used
				 * as the sorting direction when the column if first sorted (clicked on).
				 * Sort it again (click again) and it will move on to the next index.
				 * Repeat until loop.
				 *  @type array
				 */
				"asSorting": null,
				
				/**
				 * Flag to indicate if the column is searchable, and thus should be included
				 * in the filtering or not.
				 *  @type boolean
				 */
				"bSearchable": null,
				
				/**
				 * Flag to indicate if the column is sortable or not.
				 *  @type boolean
				 */
				"bSortable": null,
				
				/**
				 * Flag to indicate if the column is currently visible in the table or not
				 *  @type boolean
				 */
				"bVisible": null,
				
				/**
				 * Store for manual type assignment using the `column.type` option. This
				 * is held in store so we can manipulate the column's `sType` property.
				 *  @type string
				 *  @default null
				 *  @private
				 */
				"_sManualType": null,
				
				/**
				 * Flag to indicate if HTML5 data attributes should be used as the data
				 * source for filtering or sorting. True is either are.
				 *  @type boolean
				 *  @default false
				 *  @private
				 */
				"_bAttrSrc": false,
				
				/**
				 * Developer definable function that is called whenever a cell is created (Ajax source,
				 * etc) or processed for input (DOM source). This can be used as a compliment to mRender
				 * allowing you to modify the DOM element (add background colour for example) when the
				 * element is available.
				 *  @type function
				 *  @param {element} nTd The TD node that has been created
				 *  @param {*} sData The Data for the cell
				 *  @param {array|object} oData The data for the whole row
				 *  @param {int} iRow The row index for the aoData data store
				 *  @default null
				 */
				"fnCreatedCell": null,
				
				/**
				 * Function to get data from a cell in a column. You should <b>never</b>
				 * access data directly through _aData internally in DataTables - always use
				 * the method attached to this property. It allows mData to function as
				 * required. This function is automatically assigned by the column
				 * initialisation method
				 *  @type function
				 *  @param {array|object} oData The data array/object for the array
				 *    (i.e. aoData[]._aData)
				 *  @param {string} sSpecific The specific data type you want to get -
				 *    'display', 'type' 'filter' 'sort'
				 *  @returns {*} The data for the cell from the given row's data
				 *  @default null
				 */
				"fnGetData": null,
				
				/**
				 * Function to set data for a cell in the column. You should <b>never</b>
				 * set the data directly to _aData internally in DataTables - always use
				 * this method. It allows mData to function as required. This function
				 * is automatically assigned by the column initialisation method
				 *  @type function
				 *  @param {array|object} oData The data array/object for the array
				 *    (i.e. aoData[]._aData)
				 *  @param {*} sValue Value to set
				 *  @default null
				 */
				"fnSetData": null,
				
				/**
				 * Property to read the value for the cells in the column from the data
				 * source array / object. If null, then the default content is used, if a
				 * function is given then the return from the function is used.
				 *  @type function|int|string|null
				 *  @default null
				 */
				"mData": null,
				
				/**
				 * Partner property to mData which is used (only when defined) to get
				 * the data - i.e. it is basically the same as mData, but without the
				 * 'set' option, and also the data fed to it is the result from mData.
				 * This is the rendering method to match the data method of mData.
				 *  @type function|int|string|null
				 *  @default null
				 */
				"mRender": null,
				
				/**
				 * Unique header TH/TD element for this column - this is what the sorting
				 * listener is attached to (if sorting is enabled.)
				 *  @type node
				 *  @default null
				 */
				"nTh": null,
				
				/**
				 * Unique footer TH/TD element for this column (if there is one). Not used
				 * in DataTables as such, but can be used for plug-ins to reference the
				 * footer for each column.
				 *  @type node
				 *  @default null
				 */
				"nTf": null,
				
				/**
				 * The class to apply to all TD elements in the table's TBODY for the column
				 *  @type string
				 *  @default null
				 */
				"sClass": null,
				
				/**
				 * When DataTables calculates the column widths to assign to each column,
				 * it finds the longest string in each column and then constructs a
				 * temporary table and reads the widths from that. The problem with this
				 * is that "mmm" is much wider then "iiii", but the latter is a longer
				 * string - thus the calculation can go wrong (doing it properly and putting
				 * it into an DOM object and measuring that is horribly(!) slow). Thus as
				 * a "work around" we provide this option. It will append its value to the
				 * text that is found to be the longest string for the column - i.e. padding.
				 *  @type string
				 */
				"sContentPadding": null,
				
				/**
				 * Allows a default value to be given for a column's data, and will be used
				 * whenever a null data source is encountered (this can be because mData
				 * is set to null, or because the data source itself is null).
				 *  @type string
				 *  @default null
				 */
				"sDefaultContent": null,
				
				/**
				 * Name for the column, allowing reference to the column by name as well as
				 * by index (needs a lookup to work by name).
				 *  @type string
				 */
				"sName": null,
				
				/**
				 * Custom sorting data type - defines which of the available plug-ins in
				 * afnSortData the custom sorting will use - if any is defined.
				 *  @type string
				 *  @default std
				 */
				"sSortDataType": 'std',
				
				/**
				 * Class to be applied to the header element when sorting on this column
				 *  @type string
				 *  @default null
				 */
				"sSortingClass": null,
				
				/**
				 * Class to be applied to the header element when sorting on this column -
				 * when jQuery UI theming is used.
				 *  @type string
				 *  @default null
				 */
				"sSortingClassJUI": null,
				
				/**
				 * Title of the column - what is seen in the TH element (nTh).
				 *  @type string
				 */
				"sTitle": null,
				
				/**
				 * Column sorting and filtering type
				 *  @type string
				 *  @default null
				 */
				"sType": null,
				
				/**
				 * Width of the column
				 *  @type string
				 *  @default null
				 */
				"sWidth": null,
				
				/**
				 * Width of the column when it was first "encountered"
				 *  @type string
				 *  @default null
				 */
				"sWidthOrig": null
			};
			
			
			/*
	 * Developer note: The properties of the object below are given in Hungarian
	 * notation, that was used as the interface for DataTables prior to v1.10, however
	 * from v1.10 onwards the primary interface is camel case. In order to avoid
	 * breaking backwards compatibility utterly with this change, the Hungarian
	 * version is still, internally the primary interface, but is is not documented
	 * - hence the @name tags in each doc comment. This allows a Javascript function
	 * to create a map from Hungarian notation to camel case (going the other direction
	 * would require each property to be listed, which would at around 3K to the size
	 * of DataTables, while this method is about a 0.5K hit.
	 *
	 * Ultimately this does pave the way for Hungarian notation to be dropped
	 * completely, but that is a massive amount of work and will break current
	 * installs (therefore is on-hold until v2).
	 */
			
			/**
			 * Initialisation options that can be given to DataTables at initialisation
			 * time.
			 *  @namespace
			 */
			DataTable.defaults = {
				/**
				 * An array of data to use for the table, passed in at initialisation which
				 * will be used in preference to any data which is already in the DOM. This is
				 * particularly useful for constructing tables purely in Javascript, for
				 * example with a custom Ajax call.
				 *  @type array
				 *  @default null
				 *
				 *  @dtopt Option
				 *  @name DataTable.defaults.data
				 *
				 *  @example
				 *    // Using a 2D array data source
				 *    $(document).ready( function () {
				 *      $('#example').dataTable( {
				 *        "data": [
				 *          ['Trident', 'Internet Explorer 4.0', 'Win 95+', 4, 'X'],
				 *          ['Trident', 'Internet Explorer 5.0', 'Win 95+', 5, 'C'],
				 *        ],
				 *        "columns": [
				 *          { "title": "Engine" },
				 *          { "title": "Browser" },
				 *          { "title": "Platform" },
				 *          { "title": "Version" },
				 *          { "title": "Grade" }
				 *        ]
				 *      } );
				 *    } );
				 *
				 *  @example
				 *    // Using an array of objects as a data source (`data`)
				 *    $(document).ready( function () {
				 *      $('#example').dataTable( {
				 *        "data": [
				 *          {
				 *            "engine":   "Trident",
				 *            "browser":  "Internet Explorer 4.0",
				 *            "platform": "Win 95+",
				 *            "version":  4,
				 *            "grade":    "X"
				 *          },
				 *          {
				 *            "engine":   "Trident",
				 *            "browser":  "Internet Explorer 5.0",
				 *            "platform": "Win 95+",
				 *            "version":  5,
				 *            "grade":    "C"
				 *          }
				 *        ],
				 *        "columns": [
				 *          { "title": "Engine",   "data": "engine" },
				 *          { "title": "Browser",  "data": "browser" },
				 *          { "title": "Platform", "data": "platform" },
				 *          { "title": "Version",  "data": "version" },
				 *          { "title": "Grade",    "data": "grade" }
				 *        ]
				 *      } );
				 *    } );
				 */
				"aaData": null,
				
				
				/**
				 * If ordering is enabled, then DataTables will perform a first pass sort on
				 * initialisation. You can define which column(s) the sort is performed
				 * upon, and the sorting direction, with this variable. The `sorting` array
				 * should contain an array for each column to be sorted initially containing
				 * the column's index and a direction string ('asc' or 'desc').
				 *  @type array
				 *  @default [[0,'asc']]
				 *
				 *  @dtopt Option
				 *  @name DataTable.defaults.order
				 *
				 *  @example
				 *    // Sort by 3rd column first, and then 4th column
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "order": [[2,'asc'], [3,'desc']]
				 *      } );
				 *    } );
				 *
				 *    // No initial sorting
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "order": []
				 *      } );
				 *    } );
				 */
				"aaSorting": [[0, 'asc']],
				
				
				/**
				 * This parameter is basically identical to the `sorting` parameter, but
				 * cannot be overridden by user interaction with the table. What this means
				 * is that you could have a column (visible or hidden) which the sorting
				 * will always be forced on first - any sorting after that (from the user)
				 * will then be performed as required. This can be useful for grouping rows
				 * together.
				 *  @type array
				 *  @default null
				 *
				 *  @dtopt Option
				 *  @name DataTable.defaults.orderFixed
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "orderFixed": [[0,'asc']]
				 *      } );
				 *    } )
				 */
				"aaSortingFixed": [],
				
				
				/**
				 * DataTables can be instructed to load data to display in the table from a
				 * Ajax source. This option defines how that Ajax call is made and where to.
				 *
				 * The `ajax` property has three different modes of operation, depending on
				 * how it is defined. These are:
				 *
				 * * `string` - Set the URL from where the data should be loaded from.
				 * * `object` - Define properties for `jQuery.ajax`.
				 * * `function` - Custom data get function
				 *
				 * `string`
				 * --------
				 *
				 * As a string, the `ajax` property simply defines the URL from which
				 * DataTables will load data.
				 *
				 * `object`
				 * --------
				 *
				 * As an object, the parameters in the object are passed to
				 * [jQuery.ajax](http://api.jquery.com/jQuery.ajax/) allowing fine control
				 * of the Ajax request. DataTables has a number of default parameters which
				 * you can override using this option. Please refer to the jQuery
				 * documentation for a full description of the options available, although
				 * the following parameters provide additional options in DataTables or
				 * require special consideration:
				 *
				 * * `data` - As with jQuery, `data` can be provided as an object, but it
				 *   can also be used as a function to manipulate the data DataTables sends
				 *   to the server. The function takes a single parameter, an object of
				 *   parameters with the values that DataTables has readied for sending. An
				 *   object may be returned which will be merged into the DataTables
				 *   defaults, or you can add the items to the object that was passed in and
				 *   not return anything from the function. This supersedes `fnServerParams`
				 *   from DataTables 1.9-.
				 *
				 * * `dataSrc` - By default DataTables will look for the property `data` (or
				 *   `aaData` for compatibility with DataTables 1.9-) when obtaining data
				 *   from an Ajax source or for server-side processing - this parameter
				 *   allows that property to be changed. You can use Javascript dotted
				 *   object notation to get a data source for multiple levels of nesting, or
				 *   it my be used as a function. As a function it takes a single parameter,
				 *   the JSON returned from the server, which can be manipulated as
				 *   required, with the returned value being that used by DataTables as the
				 *   data source for the table. This supersedes `sAjaxDataProp` from
				 *   DataTables 1.9-.
				 *
				 * * `success` - Should not be overridden it is used internally in
				 *   DataTables. To manipulate / transform the data returned by the server
				 *   use `ajax.dataSrc`, or use `ajax` as a function (see below).
				 *
				 * `function`
				 * ----------
				 *
				 * As a function, making the Ajax call is left up to yourself allowing
				 * complete control of the Ajax request. Indeed, if desired, a method other
				 * than Ajax could be used to obtain the required data, such as Web storage
				 * or an AIR database.
				 *
				 * The function is given four parameters and no return is required. The
				 * parameters are:
				 *
				 * 1. _object_ - Data to send to the server
				 * 2. _function_ - Callback function that must be executed when the required
				 *    data has been obtained. That data should be passed into the callback
				 *    as the only parameter
				 * 3. _object_ - DataTables settings object for the table
				 *
				 * Note that this supersedes `fnServerData` from DataTables 1.9-.
				 *
				 *  @type string|object|function
				 *  @default null
				 *
				 *  @dtopt Option
				 *  @name DataTable.defaults.ajax
				 *  @since 1.10.0
				 *
				 * @example
				 *   // Get JSON data from a file via Ajax.
				 *   // Note DataTables expects data in the form `{ data: [ ...data... ] }` by default).
				 *   $('#example').dataTable( {
				 *     "ajax": "data.json"
				 *   } );
				 *
				 * @example
				 *   // Get JSON data from a file via Ajax, using `dataSrc` to change
				 *   // `data` to `tableData` (i.e. `{ tableData: [ ...data... ] }`)
				 *   $('#example').dataTable( {
				 *     "ajax": {
				 *       "url": "data.json",
				 *       "dataSrc": "tableData"
				 *     }
				 *   } );
				 *
				 * @example
				 *   // Get JSON data from a file via Ajax, using `dataSrc` to read data
				 *   // from a plain array rather than an array in an object
				 *   $('#example').dataTable( {
				 *     "ajax": {
				 *       "url": "data.json",
				 *       "dataSrc": ""
				 *     }
				 *   } );
				 *
				 * @example
				 *   // Manipulate the data returned from the server - add a link to data
				 *   // (note this can, should, be done using `render` for the column - this
				 *   // is just a simple example of how the data can be manipulated).
				 *   $('#example').dataTable( {
				 *     "ajax": {
				 *       "url": "data.json",
				 *       "dataSrc": function ( json ) {
				 *         for ( var i=0, ien=json.length ; i<ien ; i++ ) {
				 *           json[i][0] = '<a href="/message/'+json[i][0]+'>View message</a>';
				 *         }
				 *         return json;
				 *       }
				 *     }
				 *   } );
				 *
				 * @example
				 *   // Add data to the request
				 *   $('#example').dataTable( {
				 *     "ajax": {
				 *       "url": "data.json",
				 *       "data": function ( d ) {
				 *         return {
				 *           "extra_search": $('#extra').val()
				 *         };
				 *       }
				 *     }
				 *   } );
				 *
				 * @example
				 *   // Send request as POST
				 *   $('#example').dataTable( {
				 *     "ajax": {
				 *       "url": "data.json",
				 *       "type": "POST"
				 *     }
				 *   } );
				 *
				 * @example
				 *   // Get the data from localStorage (could interface with a form for
				 *   // adding, editing and removing rows).
				 *   $('#example').dataTable( {
				 *     "ajax": function (data, callback, settings) {
				 *       callback(
				 *         JSON.parse( localStorage.getItem('dataTablesData') )
				 *       );
				 *     }
				 *   } );
				 */
				"ajax": null,
				
				
				/**
				 * This parameter allows you to readily specify the entries in the length drop
				 * down menu that DataTables shows when pagination is enabled. It can be
				 * either a 1D array of options which will be used for both the displayed
				 * option and the value, or a 2D array which will use the array in the first
				 * position as the value, and the array in the second position as the
				 * displayed options (useful for language strings such as 'All').
				 *
				 * Note that the `pageLength` property will be automatically set to the
				 * first value given in this array, unless `pageLength` is also provided.
				 *  @type array
				 *  @default [ 10, 25, 50, 100 ]
				 *
				 *  @dtopt Option
				 *  @name DataTable.defaults.lengthMenu
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "lengthMenu": [[10, 25, 50, -1], [10, 25, 50, "All"]]
				 *      } );
				 *    } );
				 */
				"aLengthMenu": [10, 25, 50, 100],
				
				
				/**
				 * The `columns` option in the initialisation parameter allows you to define
				 * details about the way individual columns behave. For a full list of
				 * column options that can be set, please see
				 * {@link DataTable.defaults.column}. Note that if you use `columns` to
				 * define your columns, you must have an entry in the array for every single
				 * column that you have in your table (these can be null if you don't which
				 * to specify any options).
				 *  @member
				 *
				 *  @name DataTable.defaults.column
				 */
				"aoColumns": null,
				
				/**
				 * Very similar to `columns`, `columnDefs` allows you to target a specific
				 * column, multiple columns, or all columns, using the `targets` property of
				 * each object in the array. This allows great flexibility when creating
				 * tables, as the `columnDefs` arrays can be of any length, targeting the
				 * columns you specifically want. `columnDefs` may use any of the column
				 * options available: {@link DataTable.defaults.column}, but it _must_
				 * have `targets` defined in each object in the array. Values in the `targets`
				 * array may be:
				 *   <ul>
				 *     <li>a string - class name will be matched on the TH for the column</li>
				 *     <li>0 or a positive integer - column index counting from the left</li>
				 *     <li>a negative integer - column index counting from the right</li>
				 *     <li>the string "_all" - all columns (i.e. assign a default)</li>
				 *   </ul>
				 *  @member
				 *
				 *  @name DataTable.defaults.columnDefs
				 */
				"aoColumnDefs": null,
				
				
				/**
				 * Basically the same as `search`, this parameter defines the individual column
				 * filtering state at initialisation time. The array must be of the same size
				 * as the number of columns, and each element be an object with the parameters
				 * `search` and `escapeRegex` (the latter is optional). 'null' is also
				 * accepted and the default will be used.
				 *  @type array
				 *  @default []
				 *
				 *  @dtopt Option
				 *  @name DataTable.defaults.searchCols
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "searchCols": [
				 *          null,
				 *          { "search": "My filter" },
				 *          null,
				 *          { "search": "^[0-9]", "escapeRegex": false }
				 *        ]
				 *      } );
				 *    } )
				 */
				"aoSearchCols": [],
				
				
				/**
				 * An array of CSS classes that should be applied to displayed rows. This
				 * array may be of any length, and DataTables will apply each class
				 * sequentially, looping when required.
				 *  @type array
				 *  @default null <i>Will take the values determined by the `oClasses.stripe*`
				 *    options</i>
				 *
				 *  @dtopt Option
				 *  @name DataTable.defaults.stripeClasses
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "stripeClasses": [ 'strip1', 'strip2', 'strip3' ]
				 *      } );
				 *    } )
				 */
				"asStripeClasses": null,
				
				
				/**
				 * Enable or disable automatic column width calculation. This can be disabled
				 * as an optimisation (it takes some time to calculate the widths) if the
				 * tables widths are passed in using `columns`.
				 *  @type boolean
				 *  @default true
				 *
				 *  @dtopt Features
				 *  @name DataTable.defaults.autoWidth
				 *
				 *  @example
				 *    $(document).ready( function () {
				 *      $('#example').dataTable( {
				 *        "autoWidth": false
				 *      } );
				 *    } );
				 */
				"bAutoWidth": true,
				
				
				/**
				 * Deferred rendering can provide DataTables with a huge speed boost when you
				 * are using an Ajax or JS data source for the table. This option, when set to
				 * true, will cause DataTables to defer the creation of the table elements for
				 * each row until they are needed for a draw - saving a significant amount of
				 * time.
				 *  @type boolean
				 *  @default false
				 *
				 *  @dtopt Features
				 *  @name DataTable.defaults.deferRender
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "ajax": "sources/arrays.txt",
				 *        "deferRender": true
				 *      } );
				 *    } );
				 */
				"bDeferRender": false,
				
				
				/**
				 * Replace a DataTable which matches the given selector and replace it with
				 * one which has the properties of the new initialisation object passed. If no
				 * table matches the selector, then the new DataTable will be constructed as
				 * per normal.
				 *  @type boolean
				 *  @default false
				 *
				 *  @dtopt Options
				 *  @name DataTable.defaults.destroy
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "srollY": "200px",
				 *        "paginate": false
				 *      } );
				 *
				 *      // Some time later....
				 *      $('#example').dataTable( {
				 *        "filter": false,
				 *        "destroy": true
				 *      } );
				 *    } );
				 */
				"bDestroy": false,
				
				
				/**
				 * Enable or disable filtering of data. Filtering in DataTables is "smart" in
				 * that it allows the end user to input multiple words (space separated) and
				 * will match a row containing those words, even if not in the order that was
				 * specified (this allow matching across multiple columns). Note that if you
				 * wish to use filtering in DataTables this must remain 'true' - to remove the
				 * default filtering input box and retain filtering abilities, please use
				 * {@link DataTable.defaults.dom}.
				 *  @type boolean
				 *  @default true
				 *
				 *  @dtopt Features
				 *  @name DataTable.defaults.searching
				 *
				 *  @example
				 *    $(document).ready( function () {
				 *      $('#example').dataTable( {
				 *        "searching": false
				 *      } );
				 *    } );
				 */
				"bFilter": true,
				
				
				/**
				 * Enable or disable the table information display. This shows information
				 * about the data that is currently visible on the page, including information
				 * about filtered data if that action is being performed.
				 *  @type boolean
				 *  @default true
				 *
				 *  @dtopt Features
				 *  @name DataTable.defaults.info
				 *
				 *  @example
				 *    $(document).ready( function () {
				 *      $('#example').dataTable( {
				 *        "info": false
				 *      } );
				 *    } );
				 */
				"bInfo": true,
				
				
				/**
				 * Allows the end user to select the size of a formatted page from a select
				 * menu (sizes are 10, 25, 50 and 100). Requires pagination (`paginate`).
				 *  @type boolean
				 *  @default true
				 *
				 *  @dtopt Features
				 *  @name DataTable.defaults.lengthChange
				 *
				 *  @example
				 *    $(document).ready( function () {
				 *      $('#example').dataTable( {
				 *        "lengthChange": false
				 *      } );
				 *    } );
				 */
				"bLengthChange": true,
				
				
				/**
				 * Enable or disable pagination.
				 *  @type boolean
				 *  @default true
				 *
				 *  @dtopt Features
				 *  @name DataTable.defaults.paging
				 *
				 *  @example
				 *    $(document).ready( function () {
				 *      $('#example').dataTable( {
				 *        "paging": false
				 *      } );
				 *    } );
				 */
				"bPaginate": true,
				
				
				/**
				 * Enable or disable the display of a 'processing' indicator when the table is
				 * being processed (e.g. a sort). This is particularly useful for tables with
				 * large amounts of data where it can take a noticeable amount of time to sort
				 * the entries.
				 *  @type boolean
				 *  @default false
				 *
				 *  @dtopt Features
				 *  @name DataTable.defaults.processing
				 *
				 *  @example
				 *    $(document).ready( function () {
				 *      $('#example').dataTable( {
				 *        "processing": true
				 *      } );
				 *    } );
				 */
				"bProcessing": false,
				
				
				/**
				 * Retrieve the DataTables object for the given selector. Note that if the
				 * table has already been initialised, this parameter will cause DataTables
				 * to simply return the object that has already been set up - it will not take
				 * account of any changes you might have made to the initialisation object
				 * passed to DataTables (setting this parameter to true is an acknowledgement
				 * that you understand this). `destroy` can be used to reinitialise a table if
				 * you need.
				 *  @type boolean
				 *  @default false
				 *
				 *  @dtopt Options
				 *  @name DataTable.defaults.retrieve
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      initTable();
				 *      tableActions();
				 *    } );
				 *
				 *    function initTable ()
				 *    {
				 *      return $('#example').dataTable( {
				 *        "scrollY": "200px",
				 *        "paginate": false,
				 *        "retrieve": true
				 *      } );
				 *    }
				 *
				 *    function tableActions ()
				 *    {
				 *      var table = initTable();
				 *      // perform API operations with oTable
				 *    }
				 */
				"bRetrieve": false,
				
				
				/**
				 * When vertical (y) scrolling is enabled, DataTables will force the height of
				 * the table's viewport to the given height at all times (useful for layout).
				 * However, this can look odd when filtering data down to a small data set,
				 * and the footer is left "floating" further down. This parameter (when
				 * enabled) will cause DataTables to collapse the table's viewport down when
				 * the result set will fit within the given Y height.
				 *  @type boolean
				 *  @default false
				 *
				 *  @dtopt Options
				 *  @name DataTable.defaults.scrollCollapse
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "scrollY": "200",
				 *        "scrollCollapse": true
				 *      } );
				 *    } );
				 */
				"bScrollCollapse": false,
				
				
				/**
				 * Configure DataTables to use server-side processing. Note that the
				 * `ajax` parameter must also be given in order to give DataTables a
				 * source to obtain the required data for each draw.
				 *  @type boolean
				 *  @default false
				 *
				 *  @dtopt Features
				 *  @dtopt Server-side
				 *  @name DataTable.defaults.serverSide
				 *
				 *  @example
				 *    $(document).ready( function () {
				 *      $('#example').dataTable( {
				 *        "serverSide": true,
				 *        "ajax": "xhr.php"
				 *      } );
				 *    } );
				 */
				"bServerSide": false,
				
				
				/**
				 * Enable or disable sorting of columns. Sorting of individual columns can be
				 * disabled by the `sortable` option for each column.
				 *  @type boolean
				 *  @default true
				 *
				 *  @dtopt Features
				 *  @name DataTable.defaults.ordering
				 *
				 *  @example
				 *    $(document).ready( function () {
				 *      $('#example').dataTable( {
				 *        "ordering": false
				 *      } );
				 *    } );
				 */
				"bSort": true,
				
				
				/**
				 * Enable or display DataTables' ability to sort multiple columns at the
				 * same time (activated by shift-click by the user).
				 *  @type boolean
				 *  @default true
				 *
				 *  @dtopt Options
				 *  @name DataTable.defaults.orderMulti
				 *
				 *  @example
				 *    // Disable multiple column sorting ability
				 *    $(document).ready( function () {
				 *      $('#example').dataTable( {
				 *        "orderMulti": false
				 *      } );
				 *    } );
				 */
				"bSortMulti": true,
				
				
				/**
				 * Allows control over whether DataTables should use the top (true) unique
				 * cell that is found for a single column, or the bottom (false - default).
				 * This is useful when using complex headers.
				 *  @type boolean
				 *  @default false
				 *
				 *  @dtopt Options
				 *  @name DataTable.defaults.orderCellsTop
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "orderCellsTop": true
				 *      } );
				 *    } );
				 */
				"bSortCellsTop": false,
				
				
				/**
				 * Enable or disable the addition of the classes `sorting\_1`, `sorting\_2` and
				 * `sorting\_3` to the columns which are currently being sorted on. This is
				 * presented as a feature switch as it can increase processing time (while
				 * classes are removed and added) so for large data sets you might want to
				 * turn this off.
				 *  @type boolean
				 *  @default true
				 *
				 *  @dtopt Features
				 *  @name DataTable.defaults.orderClasses
				 *
				 *  @example
				 *    $(document).ready( function () {
				 *      $('#example').dataTable( {
				 *        "orderClasses": false
				 *      } );
				 *    } );
				 */
				"bSortClasses": true,
				
				
				/**
				 * Enable or disable state saving. When enabled HTML5 `localStorage` will be
				 * used to save table display information such as pagination information,
				 * display length, filtering and sorting. As such when the end user reloads
				 * the page the display display will match what thy had previously set up.
				 *
				 * Due to the use of `localStorage` the default state saving is not supported
				 * in IE6 or 7. If state saving is required in those browsers, use
				 * `stateSaveCallback` to provide a storage solution such as cookies.
				 *  @type boolean
				 *  @default false
				 *
				 *  @dtopt Features
				 *  @name DataTable.defaults.stateSave
				 *
				 *  @example
				 *    $(document).ready( function () {
				 *      $('#example').dataTable( {
				 *        "stateSave": true
				 *      } );
				 *    } );
				 */
				"bStateSave": false,
				
				
				/**
				 * This function is called when a TR element is created (and all TD child
				 * elements have been inserted), or registered if using a DOM source, allowing
				 * manipulation of the TR element (adding classes etc).
				 *  @type function
				 *  @param {node} row "TR" element for the current row
				 *  @param {array} data Raw data array for this row
				 *  @param {int} dataIndex The index of this row in the internal aoData array
				 *
				 *  @dtopt Callbacks
				 *  @name DataTable.defaults.createdRow
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "createdRow": function( row, data, dataIndex ) {
				 *          // Bold the grade for all 'A' grade browsers
				 *          if ( data[4] == "A" )
				 *          {
				 *            $('td:eq(4)', row).html( '<b>A</b>' );
				 *          }
				 *        }
				 *      } );
				 *    } );
				 */
				"fnCreatedRow": null,
				
				
				/**
				 * This function is called on every 'draw' event, and allows you to
				 * dynamically modify any aspect you want about the created DOM.
				 *  @type function
				 *  @param {object} settings DataTables settings object
				 *
				 *  @dtopt Callbacks
				 *  @name DataTable.defaults.drawCallback
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "drawCallback": function( settings ) {
				 *          alert( 'DataTables has redrawn the table' );
				 *        }
				 *      } );
				 *    } );
				 */
				"fnDrawCallback": null,
				
				
				/**
				 * Identical to fnHeaderCallback() but for the table footer this function
				 * allows you to modify the table footer on every 'draw' event.
				 *  @type function
				 *  @param {node} foot "TR" element for the footer
				 *  @param {array} data Full table data (as derived from the original HTML)
				 *  @param {int} start Index for the current display starting point in the
				 *    display array
				 *  @param {int} end Index for the current display ending point in the
				 *    display array
				 *  @param {array int} display Index array to translate the visual position
				 *    to the full data array
				 *
				 *  @dtopt Callbacks
				 *  @name DataTable.defaults.footerCallback
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "footerCallback": function( tfoot, data, start, end, display ) {
				 *          tfoot.getElementsByTagName('th')[0].innerHTML = "Starting index is "+start;
				 *        }
				 *      } );
				 *    } )
				 */
				"fnFooterCallback": null,
				
				
				/**
				 * When rendering large numbers in the information element for the table
				 * (i.e. "Showing 1 to 10 of 57 entries") DataTables will render large numbers
				 * to have a comma separator for the 'thousands' units (e.g. 1 million is
				 * rendered as "1,000,000") to help readability for the end user. This
				 * function will override the default method DataTables uses.
				 *  @type function
				 *  @member
				 *  @param {int} toFormat number to be formatted
				 *  @returns {string} formatted string for DataTables to show the number
				 *
				 *  @dtopt Callbacks
				 *  @name DataTable.defaults.formatNumber
				 *
				 *  @example
				 *    // Format a number using a single quote for the separator (note that
				 *    // this can also be done with the language.thousands option)
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "formatNumber": function ( toFormat ) {
				 *          return toFormat.toString().replace(
				 *            /\B(?=(\d{3})+(?!\d))/g, "'"
				 *          );
				 *        };
				 *      } );
				 *    } );
				 */
				"fnFormatNumber": function(toFormat) {
					return toFormat.toString().replace(
						/\B(?=(\d{3})+(?!\d))/g,
						this.oLanguage.sThousands
					);
				},
				
				
				/**
				 * This function is called on every 'draw' event, and allows you to
				 * dynamically modify the header row. This can be used to calculate and
				 * display useful information about the table.
				 *  @type function
				 *  @param {node} head "TR" element for the header
				 *  @param {array} data Full table data (as derived from the original HTML)
				 *  @param {int} start Index for the current display starting point in the
				 *    display array
				 *  @param {int} end Index for the current display ending point in the
				 *    display array
				 *  @param {array int} display Index array to translate the visual position
				 *    to the full data array
				 *
				 *  @dtopt Callbacks
				 *  @name DataTable.defaults.headerCallback
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "fheaderCallback": function( head, data, start, end, display ) {
				 *          head.getElementsByTagName('th')[0].innerHTML = "Displaying "+(end-start)+" records";
				 *        }
				 *      } );
				 *    } )
				 */
				"fnHeaderCallback": null,
				
				
				/**
				 * The information element can be used to convey information about the current
				 * state of the table. Although the internationalisation options presented by
				 * DataTables are quite capable of dealing with most customisations, there may
				 * be times where you wish to customise the string further. This callback
				 * allows you to do exactly that.
				 *  @type function
				 *  @param {object} oSettings DataTables settings object
				 *  @param {int} start Starting position in data for the draw
				 *  @param {int} end End position in data for the draw
				 *  @param {int} max Total number of rows in the table (regardless of
				 *    filtering)
				 *  @param {int} total Total number of rows in the data set, after filtering
				 *  @param {string} pre The string that DataTables has formatted using it's
				 *    own rules
				 *  @returns {string} The string to be displayed in the information element.
				 *
				 *  @dtopt Callbacks
				 *  @name DataTable.defaults.infoCallback
				 *
				 *  @example
				 *    $('#example').dataTable( {
				 *      "infoCallback": function( settings, start, end, max, total, pre ) {
				 *        return start +" to "+ end;
				 *      }
				 *    } );
				 */
				"fnInfoCallback": null,
				
				
				/**
				 * Called when the table has been initialised. Normally DataTables will
				 * initialise sequentially and there will be no need for this function,
				 * however, this does not hold true when using external language information
				 * since that is obtained using an async XHR call.
				 *  @type function
				 *  @param {object} settings DataTables settings object
				 *  @param {object} json The JSON object request from the server - only
				 *    present if client-side Ajax sourced data is used
				 *
				 *  @dtopt Callbacks
				 *  @name DataTable.defaults.initComplete
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "initComplete": function(settings, json) {
				 *          alert( 'DataTables has finished its initialisation.' );
				 *        }
				 *      } );
				 *    } )
				 */
				"fnInitComplete": null,
				
				
				/**
				 * Called at the very start of each table draw and can be used to cancel the
				 * draw by returning false, any other return (including undefined) results in
				 * the full draw occurring).
				 *  @type function
				 *  @param {object} settings DataTables settings object
				 *  @returns {boolean} False will cancel the draw, anything else (including no
				 *    return) will allow it to complete.
				 *
				 *  @dtopt Callbacks
				 *  @name DataTable.defaults.preDrawCallback
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "preDrawCallback": function( settings ) {
				 *          if ( $('#test').val() == 1 ) {
				 *            return false;
				 *          }
				 *        }
				 *      } );
				 *    } );
				 */
				"fnPreDrawCallback": null,
				
				
				/**
				 * This function allows you to 'post process' each row after it have been
				 * generated for each table draw, but before it is rendered on screen. This
				 * function might be used for setting the row class name etc.
				 *  @type function
				 *  @param {node} row "TR" element for the current row
				 *  @param {array} data Raw data array for this row
				 *  @param {int} displayIndex The display index for the current table draw
				 *  @param {int} displayIndexFull The index of the data in the full list of
				 *    rows (after filtering)
				 *
				 *  @dtopt Callbacks
				 *  @name DataTable.defaults.rowCallback
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "rowCallback": function( row, data, displayIndex, displayIndexFull ) {
				 *          // Bold the grade for all 'A' grade browsers
				 *          if ( data[4] == "A" ) {
				 *            $('td:eq(4)', row).html( '<b>A</b>' );
				 *          }
				 *        }
				 *      } );
				 *    } );
				 */
				"fnRowCallback": null,
				
				
				/**
				 * __Deprecated__ The functionality provided by this parameter has now been
				 * superseded by that provided through `ajax`, which should be used instead.
				 *
				 * This parameter allows you to override the default function which obtains
				 * the data from the server so something more suitable for your application.
				 * For example you could use POST data, or pull information from a Gears or
				 * AIR database.
				 *  @type function
				 *  @member
				 *  @param {string} source HTTP source to obtain the data from (`ajax`)
				 *  @param {array} data A key/value pair object containing the data to send
				 *    to the server
				 *  @param {function} callback to be called on completion of the data get
				 *    process that will draw the data on the page.
				 *  @param {object} settings DataTables settings object
				 *
				 *  @dtopt Callbacks
				 *  @dtopt Server-side
				 *  @name DataTable.defaults.serverData
				 *
				 *  @deprecated 1.10. Please use `ajax` for this functionality now.
				 */
				"fnServerData": null,
				
				
				/**
				 * __Deprecated__ The functionality provided by this parameter has now been
				 * superseded by that provided through `ajax`, which should be used instead.
				 *
				 *  It is often useful to send extra data to the server when making an Ajax
				 * request - for example custom filtering information, and this callback
				 * function makes it trivial to send extra information to the server. The
				 * passed in parameter is the data set that has been constructed by
				 * DataTables, and you can add to this or modify it as you require.
				 *  @type function
				 *  @param {array} data Data array (array of objects which are name/value
				 *    pairs) that has been constructed by DataTables and will be sent to the
				 *    server. In the case of Ajax sourced data with server-side processing
				 *    this will be an empty array, for server-side processing there will be a
				 *    significant number of parameters!
				 *  @returns {undefined} Ensure that you modify the data array passed in,
				 *    as this is passed by reference.
				 *
				 *  @dtopt Callbacks
				 *  @dtopt Server-side
				 *  @name DataTable.defaults.serverParams
				 *
				 *  @deprecated 1.10. Please use `ajax` for this functionality now.
				 */
				"fnServerParams": null,
				
				
				/**
				 * Load the table state. With this function you can define from where, and how, the
				 * state of a table is loaded. By default DataTables will load from `localStorage`
				 * but you might wish to use a server-side database or cookies.
				 *  @type function
				 *  @member
				 *  @param {object} settings DataTables settings object
				 *  @param {object} callback Callback that can be executed when done. It
				 *    should be passed the loaded state object.
				 *  @return {object} The DataTables state object to be loaded
				 *
				 *  @dtopt Callbacks
				 *  @name DataTable.defaults.stateLoadCallback
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "stateSave": true,
				 *        "stateLoadCallback": function (settings, callback) {
				 *          $.ajax( {
				 *            "url": "/state_load",
				 *            "dataType": "json",
				 *            "success": function (json) {
				 *              callback( json );
				 *            }
				 *          } );
				 *        }
				 *      } );
				 *    } );
				 */
				"fnStateLoadCallback": function(settings) {
					try {
						return JSON.parse(
							(settings.iStateDuration === -1 ? sessionStorage : localStorage).getItem(
								'DataTables_' + settings.sInstance + '_' + location.pathname
							)
						);
					} catch(e) {
					}
				},
				
				
				/**
				 * Callback which allows modification of the saved state prior to loading that state.
				 * This callback is called when the table is loading state from the stored data, but
				 * prior to the settings object being modified by the saved state. Note that for
				 * plug-in authors, you should use the `stateLoadParams` event to load parameters for
				 * a plug-in.
				 *  @type function
				 *  @param {object} settings DataTables settings object
				 *  @param {object} data The state object that is to be loaded
				 *
				 *  @dtopt Callbacks
				 *  @name DataTable.defaults.stateLoadParams
				 *
				 *  @example
				 *    // Remove a saved filter, so filtering is never loaded
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "stateSave": true,
				 *        "stateLoadParams": function (settings, data) {
				 *          data.oSearch.sSearch = "";
				 *        }
				 *      } );
				 *    } );
				 *
				 *  @example
				 *    // Disallow state loading by returning false
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "stateSave": true,
				 *        "stateLoadParams": function (settings, data) {
				 *          return false;
				 *        }
				 *      } );
				 *    } );
				 */
				"fnStateLoadParams": null,
				
				
				/**
				 * Callback that is called when the state has been loaded from the state saving method
				 * and the DataTables settings object has been modified as a result of the loaded state.
				 *  @type function
				 *  @param {object} settings DataTables settings object
				 *  @param {object} data The state object that was loaded
				 *
				 *  @dtopt Callbacks
				 *  @name DataTable.defaults.stateLoaded
				 *
				 *  @example
				 *    // Show an alert with the filtering value that was saved
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "stateSave": true,
				 *        "stateLoaded": function (settings, data) {
				 *          alert( 'Saved filter was: '+data.oSearch.sSearch );
				 *        }
				 *      } );
				 *    } );
				 */
				"fnStateLoaded": null,
				
				
				/**
				 * Save the table state. This function allows you to define where and how the state
				 * information for the table is stored By default DataTables will use `localStorage`
				 * but you might wish to use a server-side database or cookies.
				 *  @type function
				 *  @member
				 *  @param {object} settings DataTables settings object
				 *  @param {object} data The state object to be saved
				 *
				 *  @dtopt Callbacks
				 *  @name DataTable.defaults.stateSaveCallback
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "stateSave": true,
				 *        "stateSaveCallback": function (settings, data) {
				 *          // Send an Ajax request to the server with the state object
				 *          $.ajax( {
				 *            "url": "/state_save",
				 *            "data": data,
				 *            "dataType": "json",
				 *            "method": "POST"
				 *            "success": function () {}
				 *          } );
				 *        }
				 *      } );
				 *    } );
				 */
				"fnStateSaveCallback": function(settings, data) {
					try {
						(settings.iStateDuration === -1 ? sessionStorage : localStorage).setItem(
							'DataTables_' + settings.sInstance + '_' + location.pathname,
							JSON.stringify(data)
						);
					} catch(e) {
					}
				},
				
				
				/**
				 * Callback which allows modification of the state to be saved. Called when the table
				 * has changed state a new state save is required. This method allows modification of
				 * the state saving object prior to actually doing the save, including addition or
				 * other state properties or modification. Note that for plug-in authors, you should
				 * use the `stateSaveParams` event to save parameters for a plug-in.
				 *  @type function
				 *  @param {object} settings DataTables settings object
				 *  @param {object} data The state object to be saved
				 *
				 *  @dtopt Callbacks
				 *  @name DataTable.defaults.stateSaveParams
				 *
				 *  @example
				 *    // Remove a saved filter, so filtering is never saved
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "stateSave": true,
				 *        "stateSaveParams": function (settings, data) {
				 *          data.oSearch.sSearch = "";
				 *        }
				 *      } );
				 *    } );
				 */
				"fnStateSaveParams": null,
				
				
				/**
				 * Duration for which the saved state information is considered valid. After this period
				 * has elapsed the state will be returned to the default.
				 * Value is given in seconds.
				 *  @type int
				 *  @default 7200 <i>(2 hours)</i>
				 *
				 *  @dtopt Options
				 *  @name DataTable.defaults.stateDuration
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "stateDuration": 60*60*24; // 1 day
				 *      } );
				 *    } )
				 */
				"iStateDuration": 7200,
				
				
				/**
				 * When enabled DataTables will not make a request to the server for the first
				 * page draw - rather it will use the data already on the page (no sorting etc
				 * will be applied to it), thus saving on an XHR at load time. `deferLoading`
				 * is used to indicate that deferred loading is required, but it is also used
				 * to tell DataTables how many records there are in the full table (allowing
				 * the information element and pagination to be displayed correctly). In the case
				 * where a filtering is applied to the table on initial load, this can be
				 * indicated by giving the parameter as an array, where the first element is
				 * the number of records available after filtering and the second element is the
				 * number of records without filtering (allowing the table information element
				 * to be shown correctly).
				 *  @type int | array
				 *  @default null
				 *
				 *  @dtopt Options
				 *  @name DataTable.defaults.deferLoading
				 *
				 *  @example
				 *    // 57 records available in the table, no filtering applied
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "serverSide": true,
				 *        "ajax": "scripts/server_processing.php",
				 *        "deferLoading": 57
				 *      } );
				 *    } );
				 *
				 *  @example
				 *    // 57 records after filtering, 100 without filtering (an initial filter applied)
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "serverSide": true,
				 *        "ajax": "scripts/server_processing.php",
				 *        "deferLoading": [ 57, 100 ],
				 *        "search": {
				 *          "search": "my_filter"
				 *        }
				 *      } );
				 *    } );
				 */
				"iDeferLoading": null,
				
				
				/**
				 * Number of rows to display on a single page when using pagination. If
				 * feature enabled (`lengthChange`) then the end user will be able to override
				 * this to a custom setting using a pop-up menu.
				 *  @type int
				 *  @default 10
				 *
				 *  @dtopt Options
				 *  @name DataTable.defaults.pageLength
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "pageLength": 50
				 *      } );
				 *    } )
				 */
				"iDisplayLength": 10,
				
				
				/**
				 * Define the starting point for data display when using DataTables with
				 * pagination. Note that this parameter is the number of records, rather than
				 * the page number, so if you have 10 records per page and want to start on
				 * the third page, it should be "20".
				 *  @type int
				 *  @default 0
				 *
				 *  @dtopt Options
				 *  @name DataTable.defaults.displayStart
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "displayStart": 20
				 *      } );
				 *    } )
				 */
				"iDisplayStart": 0,
				
				
				/**
				 * By default DataTables allows keyboard navigation of the table (sorting, paging,
				 * and filtering) by adding a `tabindex` attribute to the required elements. This
				 * allows you to tab through the controls and press the enter key to activate them.
				 * The tabindex is default 0, meaning that the tab follows the flow of the document.
				 * You can overrule this using this parameter if you wish. Use a value of -1 to
				 * disable built-in keyboard navigation.
				 *  @type int
				 *  @default 0
				 *
				 *  @dtopt Options
				 *  @name DataTable.defaults.tabIndex
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "tabIndex": 1
				 *      } );
				 *    } );
				 */
				"iTabIndex": 0,
				
				
				/**
				 * Classes that DataTables assigns to the various components and features
				 * that it adds to the HTML table. This allows classes to be configured
				 * during initialisation in addition to through the static
				 * {@link DataTable.ext.oStdClasses} object).
				 *  @namespace
				 *  @name DataTable.defaults.classes
				 */
				"oClasses": {},
				
				
				/**
				 * All strings that DataTables uses in the user interface that it creates
				 * are defined in this object, allowing you to modified them individually or
				 * completely replace them all as required.
				 *  @namespace
				 *  @name DataTable.defaults.language
				 */
				"oLanguage": {
					/**
					 * Strings that are used for WAI-ARIA labels and controls only (these are not
					 * actually visible on the page, but will be read by screenreaders, and thus
					 * must be internationalised as well).
					 *  @namespace
					 *  @name DataTable.defaults.language.aria
					 */
					"oAria": {
						/**
						 * ARIA label that is added to the table headers when the column may be
						 * sorted ascending by activing the column (click or return when focused).
						 * Note that the column header is prefixed to this string.
						 *  @type string
						 *  @default : activate to sort column ascending
						 *
						 *  @dtopt Language
						 *  @name DataTable.defaults.language.aria.sortAscending
						 *
						 *  @example
						 *    $(document).ready( function() {
						 *      $('#example').dataTable( {
						 *        "language": {
						 *          "aria": {
						 *            "sortAscending": " - click/return to sort ascending"
						 *          }
						 *        }
						 *      } );
						 *    } );
						 */
						"sSortAscending": ": activate to sort column ascending",
						
						/**
						 * ARIA label that is added to the table headers when the column may be
						 * sorted descending by activing the column (click or return when focused).
						 * Note that the column header is prefixed to this string.
						 *  @type string
						 *  @default : activate to sort column ascending
						 *
						 *  @dtopt Language
						 *  @name DataTable.defaults.language.aria.sortDescending
						 *
						 *  @example
						 *    $(document).ready( function() {
						 *      $('#example').dataTable( {
						 *        "language": {
						 *          "aria": {
						 *            "sortDescending": " - click/return to sort descending"
						 *          }
						 *        }
						 *      } );
						 *    } );
						 */
						"sSortDescending": ": activate to sort column descending"
					},
					
					/**
					 * Pagination string used by DataTables for the built-in pagination
					 * control types.
					 *  @namespace
					 *  @name DataTable.defaults.language.paginate
					 */
					"oPaginate": {
						/**
						 * Text to use when using the 'full_numbers' type of pagination for the
						 * button to take the user to the first page.
						 *  @type string
						 *  @default First
						 *
						 *  @dtopt Language
						 *  @name DataTable.defaults.language.paginate.first
						 *
						 *  @example
						 *    $(document).ready( function() {
						 *      $('#example').dataTable( {
						 *        "language": {
						 *          "paginate": {
						 *            "first": "First page"
						 *          }
						 *        }
						 *      } );
						 *    } );
						 */
						"sFirst": "First",
						
						
						/**
						 * Text to use when using the 'full_numbers' type of pagination for the
						 * button to take the user to the last page.
						 *  @type string
						 *  @default Last
						 *
						 *  @dtopt Language
						 *  @name DataTable.defaults.language.paginate.last
						 *
						 *  @example
						 *    $(document).ready( function() {
						 *      $('#example').dataTable( {
						 *        "language": {
						 *          "paginate": {
						 *            "last": "Last page"
						 *          }
						 *        }
						 *      } );
						 *    } );
						 */
						"sLast": "Last",
						
						
						/**
						 * Text to use for the 'next' pagination button (to take the user to the
						 * next page).
						 *  @type string
						 *  @default Next
						 *
						 *  @dtopt Language
						 *  @name DataTable.defaults.language.paginate.next
						 *
						 *  @example
						 *    $(document).ready( function() {
						 *      $('#example').dataTable( {
						 *        "language": {
						 *          "paginate": {
						 *            "next": "Next page"
						 *          }
						 *        }
						 *      } );
						 *    } );
						 */
						"sNext": "Next",
						
						
						/**
						 * Text to use for the 'previous' pagination button (to take the user to
						 * the previous page).
						 *  @type string
						 *  @default Previous
						 *
						 *  @dtopt Language
						 *  @name DataTable.defaults.language.paginate.previous
						 *
						 *  @example
						 *    $(document).ready( function() {
						 *      $('#example').dataTable( {
						 *        "language": {
						 *          "paginate": {
						 *            "previous": "Previous page"
						 *          }
						 *        }
						 *      } );
						 *    } );
						 */
						"sPrevious": "Previous"
					},
					
					/**
					 * This string is shown in preference to `zeroRecords` when the table is
					 * empty of data (regardless of filtering). Note that this is an optional
					 * parameter - if it is not given, the value of `zeroRecords` will be used
					 * instead (either the default or given value).
					 *  @type string
					 *  @default No data available in table
					 *
					 *  @dtopt Language
					 *  @name DataTable.defaults.language.emptyTable
					 *
					 *  @example
					 *    $(document).ready( function() {
					 *      $('#example').dataTable( {
					 *        "language": {
					 *          "emptyTable": "No data available in table"
					 *        }
					 *      } );
					 *    } );
					 */
					"sEmptyTable": "No data available in table",
					
					
					/**
					 * This string gives information to the end user about the information
					 * that is current on display on the page. The following tokens can be
					 * used in the string and will be dynamically replaced as the table
					 * display updates. This tokens can be placed anywhere in the string, or
					 * removed as needed by the language requires:
					 *
					 * * `\_START\_` - Display index of the first record on the current page
					 * * `\_END\_` - Display index of the last record on the current page
					 * * `\_TOTAL\_` - Number of records in the table after filtering
					 * * `\_MAX\_` - Number of records in the table without filtering
					 * * `\_PAGE\_` - Current page number
					 * * `\_PAGES\_` - Total number of pages of data in the table
					 *
					 *  @type string
					 *  @default Showing _START_ to _END_ of _TOTAL_ entries
					 *
					 *  @dtopt Language
					 *  @name DataTable.defaults.language.info
					 *
					 *  @example
					 *    $(document).ready( function() {
					 *      $('#example').dataTable( {
					 *        "language": {
					 *          "info": "Showing page _PAGE_ of _PAGES_"
					 *        }
					 *      } );
					 *    } );
					 */
					"sInfo": "Showing _START_ to _END_ of _TOTAL_ entries",
					
					
					/**
					 * Display information string for when the table is empty. Typically the
					 * format of this string should match `info`.
					 *  @type string
					 *  @default Showing 0 to 0 of 0 entries
					 *
					 *  @dtopt Language
					 *  @name DataTable.defaults.language.infoEmpty
					 *
					 *  @example
					 *    $(document).ready( function() {
					 *      $('#example').dataTable( {
					 *        "language": {
					 *          "infoEmpty": "No entries to show"
					 *        }
					 *      } );
					 *    } );
					 */
					"sInfoEmpty": "Showing 0 to 0 of 0 entries",
					
					
					/**
					 * When a user filters the information in a table, this string is appended
					 * to the information (`info`) to give an idea of how strong the filtering
					 * is. The variable _MAX_ is dynamically updated.
					 *  @type string
					 *  @default (filtered from _MAX_ total entries)
					 *
					 *  @dtopt Language
					 *  @name DataTable.defaults.language.infoFiltered
					 *
					 *  @example
					 *    $(document).ready( function() {
					 *      $('#example').dataTable( {
					 *        "language": {
					 *          "infoFiltered": " - filtering from _MAX_ records"
					 *        }
					 *      } );
					 *    } );
					 */
					"sInfoFiltered": "(filtered from _MAX_ total entries)",
					
					
					/**
					 * If can be useful to append extra information to the info string at times,
					 * and this variable does exactly that. This information will be appended to
					 * the `info` (`infoEmpty` and `infoFiltered` in whatever combination they are
					 * being used) at all times.
					 *  @type string
					 *  @default <i>Empty string</i>
					 *
					 *  @dtopt Language
					 *  @name DataTable.defaults.language.infoPostFix
					 *
					 *  @example
					 *    $(document).ready( function() {
					 *      $('#example').dataTable( {
					 *        "language": {
					 *          "infoPostFix": "All records shown are derived from real information."
					 *        }
					 *      } );
					 *    } );
					 */
					"sInfoPostFix": "",
					
					
					/**
					 * This decimal place operator is a little different from the other
					 * language options since DataTables doesn't output floating point
					 * numbers, so it won't ever use this for display of a number. Rather,
					 * what this parameter does is modify the sort methods of the table so
					 * that numbers which are in a format which has a character other than
					 * a period (`.`) as a decimal place will be sorted numerically.
					 *
					 * Note that numbers with different decimal places cannot be shown in
					 * the same table and still be sortable, the table must be consistent.
					 * However, multiple different tables on the page can use different
					 * decimal place characters.
					 *  @type string
					 *  @default
					 *
					 *  @dtopt Language
					 *  @name DataTable.defaults.language.decimal
					 *
					 *  @example
					 *    $(document).ready( function() {
					 *      $('#example').dataTable( {
					 *        "language": {
					 *          "decimal": ","
					 *          "thousands": "."
					 *        }
					 *      } );
					 *    } );
					 */
					"sDecimal": "",
					
					
					/**
					 * DataTables has a build in number formatter (`formatNumber`) which is
					 * used to format large numbers that are used in the table information.
					 * By default a comma is used, but this can be trivially changed to any
					 * character you wish with this parameter.
					 *  @type string
					 *  @default ,
					 *
					 *  @dtopt Language
					 *  @name DataTable.defaults.language.thousands
					 *
					 *  @example
					 *    $(document).ready( function() {
					 *      $('#example').dataTable( {
					 *        "language": {
					 *          "thousands": "'"
					 *        }
					 *      } );
					 *    } );
					 */
					"sThousands": ",",
					
					
					/**
					 * Detail the action that will be taken when the drop down menu for the
					 * pagination length option is changed. The '_MENU_' variable is replaced
					 * with a default select list of 10, 25, 50 and 100, and can be replaced
					 * with a custom select box if required.
					 *  @type string
					 *  @default Show _MENU_ entries
					 *
					 *  @dtopt Language
					 *  @name DataTable.defaults.language.lengthMenu
					 *
					 *  @example
					 *    // Language change only
					 *    $(document).ready( function() {
					 *      $('#example').dataTable( {
					 *        "language": {
					 *          "lengthMenu": "Display _MENU_ records"
					 *        }
					 *      } );
					 *    } );
					 *
					 *  @example
					 *    // Language and options change
					 *    $(document).ready( function() {
					 *      $('#example').dataTable( {
					 *        "language": {
					 *          "lengthMenu": 'Display <select>'+
					 *            '<option value="10">10</option>'+
					 *            '<option value="20">20</option>'+
					 *            '<option value="30">30</option>'+
					 *            '<option value="40">40</option>'+
					 *            '<option value="50">50</option>'+
					 *            '<option value="-1">All</option>'+
					 *            '</select> records'
					 *        }
					 *      } );
					 *    } );
					 */
					"sLengthMenu": "Show _MENU_ entries",
					
					
					/**
					 * When using Ajax sourced data and during the first draw when DataTables is
					 * gathering the data, this message is shown in an empty row in the table to
					 * indicate to the end user the the data is being loaded. Note that this
					 * parameter is not used when loading data by server-side processing, just
					 * Ajax sourced data with client-side processing.
					 *  @type string
					 *  @default Loading...
					 *
					 *  @dtopt Language
					 *  @name DataTable.defaults.language.loadingRecords
					 *
					 *  @example
					 *    $(document).ready( function() {
					 *      $('#example').dataTable( {
					 *        "language": {
					 *          "loadingRecords": "Please wait - loading..."
					 *        }
					 *      } );
					 *    } );
					 */
					"sLoadingRecords": "Loading...",
					
					
					/**
					 * Text which is displayed when the table is processing a user action
					 * (usually a sort command or similar).
					 *  @type string
					 *  @default Processing...
					 *
					 *  @dtopt Language
					 *  @name DataTable.defaults.language.processing
					 *
					 *  @example
					 *    $(document).ready( function() {
					 *      $('#example').dataTable( {
					 *        "language": {
					 *          "processing": "DataTables is currently busy"
					 *        }
					 *      } );
					 *    } );
					 */
					"sProcessing": "Processing...",
					
					
					/**
					 * Details the actions that will be taken when the user types into the
					 * filtering input text box. The variable "_INPUT_", if used in the string,
					 * is replaced with the HTML text box for the filtering input allowing
					 * control over where it appears in the string. If "_INPUT_" is not given
					 * then the input box is appended to the string automatically.
					 *  @type string
					 *  @default Search:
					 *
					 *  @dtopt Language
					 *  @name DataTable.defaults.language.search
					 *
					 *  @example
					 *    // Input text box will be appended at the end automatically
					 *    $(document).ready( function() {
					 *      $('#example').dataTable( {
					 *        "language": {
					 *          "search": "Filter records:"
					 *        }
					 *      } );
					 *    } );
					 *
					 *  @example
					 *    // Specify where the filter should appear
					 *    $(document).ready( function() {
					 *      $('#example').dataTable( {
					 *        "language": {
					 *          "search": "Apply filter _INPUT_ to table"
					 *        }
					 *      } );
					 *    } );
					 */
					"sSearch": "Search:",
					
					
					/**
					 * Assign a `placeholder` attribute to the search `input` element
					 *  @type string
					 *  @default
					 *
					 *  @dtopt Language
					 *  @name DataTable.defaults.language.searchPlaceholder
					 */
					"sSearchPlaceholder": "",
					
					
					/**
					 * All of the language information can be stored in a file on the
					 * server-side, which DataTables will look up if this parameter is passed.
					 * It must store the URL of the language file, which is in a JSON format,
					 * and the object has the same properties as the oLanguage object in the
					 * initialiser object (i.e. the above parameters). Please refer to one of
					 * the example language files to see how this works in action.
					 *  @type string
					 *  @default <i>Empty string - i.e. disabled</i>
					 *
					 *  @dtopt Language
					 *  @name DataTable.defaults.language.url
					 *
					 *  @example
					 *    $(document).ready( function() {
					 *      $('#example').dataTable( {
					 *        "language": {
					 *          "url": "http://www.sprymedia.co.uk/dataTables/lang.txt"
					 *        }
					 *      } );
					 *    } );
					 */
					"sUrl": "",
					
					
					/**
					 * Text shown inside the table records when the is no information to be
					 * displayed after filtering. `emptyTable` is shown when there is simply no
					 * information in the table at all (regardless of filtering).
					 *  @type string
					 *  @default No matching records found
					 *
					 *  @dtopt Language
					 *  @name DataTable.defaults.language.zeroRecords
					 *
					 *  @example
					 *    $(document).ready( function() {
					 *      $('#example').dataTable( {
					 *        "language": {
					 *          "zeroRecords": "No records to display"
					 *        }
					 *      } );
					 *    } );
					 */
					"sZeroRecords": "No matching records found"
				},
				
				
				/**
				 * This parameter allows you to have define the global filtering state at
				 * initialisation time. As an object the `search` parameter must be
				 * defined, but all other parameters are optional. When `regex` is true,
				 * the search string will be treated as a regular expression, when false
				 * (default) it will be treated as a straight string. When `smart`
				 * DataTables will use it's smart filtering methods (to word match at
				 * any point in the data), when false this will not be done.
				 *  @namespace
				 *  @extends DataTable.models.oSearch
				 *
				 *  @dtopt Options
				 *  @name DataTable.defaults.search
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "search": {"search": "Initial search"}
				 *      } );
				 *    } )
				 */
				"oSearch": $.extend({}, DataTable.models.oSearch),
				
				
				/**
				 * __Deprecated__ The functionality provided by this parameter has now been
				 * superseded by that provided through `ajax`, which should be used instead.
				 *
				 * By default DataTables will look for the property `data` (or `aaData` for
				 * compatibility with DataTables 1.9-) when obtaining data from an Ajax
				 * source or for server-side processing - this parameter allows that
				 * property to be changed. You can use Javascript dotted object notation to
				 * get a data source for multiple levels of nesting.
				 *  @type string
				 *  @default data
				 *
				 *  @dtopt Options
				 *  @dtopt Server-side
				 *  @name DataTable.defaults.ajaxDataProp
				 *
				 *  @deprecated 1.10. Please use `ajax` for this functionality now.
				 */
				"sAjaxDataProp": "data",
				
				
				/**
				 * __Deprecated__ The functionality provided by this parameter has now been
				 * superseded by that provided through `ajax`, which should be used instead.
				 *
				 * You can instruct DataTables to load data from an external
				 * source using this parameter (use aData if you want to pass data in you
				 * already have). Simply provide a url a JSON object can be obtained from.
				 *  @type string
				 *  @default null
				 *
				 *  @dtopt Options
				 *  @dtopt Server-side
				 *  @name DataTable.defaults.ajaxSource
				 *
				 *  @deprecated 1.10. Please use `ajax` for this functionality now.
				 */
				"sAjaxSource": null,
				
				
				/**
				 * This initialisation variable allows you to specify exactly where in the
				 * DOM you want DataTables to inject the various controls it adds to the page
				 * (for example you might want the pagination controls at the top of the
				 * table). DIV elements (with or without a custom class) can also be added to
				 * aid styling. The follow syntax is used:
				 *   <ul>
				 *     <li>The following options are allowed:
				 *       <ul>
				 *         <li>'l' - Length changing</li>
				 *         <li>'f' - Filtering input</li>
				 *         <li>'t' - The table!</li>
				 *         <li>'i' - Information</li>
				 *         <li>'p' - Pagination</li>
				 *         <li>'r' - pRocessing</li>
				 *       </ul>
				 *     </li>
				 *     <li>The following constants are allowed:
				 *       <ul>
				 *         <li>'H' - jQueryUI theme "header" classes ('fg-toolbar ui-widget-header ui-corner-tl ui-corner-tr ui-helper-clearfix')</li>
				 *         <li>'F' - jQueryUI theme "footer" classes ('fg-toolbar ui-widget-header ui-corner-bl ui-corner-br ui-helper-clearfix')</li>
				 *       </ul>
				 *     </li>
				 *     <li>The following syntax is expected:
				 *       <ul>
				 *         <li>'&lt;' and '&gt;' - div elements</li>
				 *         <li>'&lt;"class" and '&gt;' - div with a class</li>
				 *         <li>'&lt;"#id" and '&gt;' - div with an ID</li>
				 *       </ul>
				 *     </li>
				 *     <li>Examples:
				 *       <ul>
				 *         <li>'&lt;"wrapper"flipt&gt;'</li>
				 *         <li>'&lt;lf&lt;t&gt;ip&gt;'</li>
				 *       </ul>
				 *     </li>
				 *   </ul>
				 *  @type string
				 *  @default lfrtip <i>(when `jQueryUI` is false)</i> <b>or</b>
				 *    <"H"lfr>t<"F"ip> <i>(when `jQueryUI` is true)</i>
				 *
				 *  @dtopt Options
				 *  @name DataTable.defaults.dom
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "dom": '&lt;"top"i&gt;rt&lt;"bottom"flp&gt;&lt;"clear"&gt;'
				 *      } );
				 *    } );
				 */
				"sDom": "lfrtip",
				
				
				/**
				 * Search delay option. This will throttle full table searches that use the
				 * DataTables provided search input element (it does not effect calls to
				 * `dt-api search()`, providing a delay before the search is made.
				 *  @type integer
				 *  @default 0
				 *
				 *  @dtopt Options
				 *  @name DataTable.defaults.searchDelay
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "searchDelay": 200
				 *      } );
				 *    } )
				 */
				"searchDelay": null,
				
				
				/**
				 * DataTables features six different built-in options for the buttons to
				 * display for pagination control:
				 *
				 * * `numbers` - Page number buttons only
				 * * `simple` - 'Previous' and 'Next' buttons only
				 * * 'simple_numbers` - 'Previous' and 'Next' buttons, plus page numbers
				 * * `full` - 'First', 'Previous', 'Next' and 'Last' buttons
				 * * `full_numbers` - 'First', 'Previous', 'Next' and 'Last' buttons, plus page numbers
				 * * `first_last_numbers` - 'First' and 'Last' buttons, plus page numbers
				 *
				 * Further methods can be added using {@link DataTable.ext.oPagination}.
				 *  @type string
				 *  @default simple_numbers
				 *
				 *  @dtopt Options
				 *  @name DataTable.defaults.pagingType
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "pagingType": "full_numbers"
				 *      } );
				 *    } )
				 */
				"sPaginationType": "simple_numbers",
				
				
				/**
				 * Enable horizontal scrolling. When a table is too wide to fit into a
				 * certain layout, or you have a large number of columns in the table, you
				 * can enable x-scrolling to show the table in a viewport, which can be
				 * scrolled. This property can be `true` which will allow the table to
				 * scroll horizontally when needed, or any CSS unit, or a number (in which
				 * case it will be treated as a pixel measurement). Setting as simply `true`
				 * is recommended.
				 *  @type boolean|string
				 *  @default <i>blank string - i.e. disabled</i>
				 *
				 *  @dtopt Features
				 *  @name DataTable.defaults.scrollX
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "scrollX": true,
				 *        "scrollCollapse": true
				 *      } );
				 *    } );
				 */
				"sScrollX": "",
				
				
				/**
				 * This property can be used to force a DataTable to use more width than it
				 * might otherwise do when x-scrolling is enabled. For example if you have a
				 * table which requires to be well spaced, this parameter is useful for
				 * "over-sizing" the table, and thus forcing scrolling. This property can by
				 * any CSS unit, or a number (in which case it will be treated as a pixel
				 * measurement).
				 *  @type string
				 *  @default <i>blank string - i.e. disabled</i>
				 *
				 *  @dtopt Options
				 *  @name DataTable.defaults.scrollXInner
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "scrollX": "100%",
				 *        "scrollXInner": "110%"
				 *      } );
				 *    } );
				 */
				"sScrollXInner": "",
				
				
				/**
				 * Enable vertical scrolling. Vertical scrolling will constrain the DataTable
				 * to the given height, and enable scrolling for any data which overflows the
				 * current viewport. This can be used as an alternative to paging to display
				 * a lot of data in a small area (although paging and scrolling can both be
				 * enabled at the same time). This property can be any CSS unit, or a number
				 * (in which case it will be treated as a pixel measurement).
				 *  @type string
				 *  @default <i>blank string - i.e. disabled</i>
				 *
				 *  @dtopt Features
				 *  @name DataTable.defaults.scrollY
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "scrollY": "200px",
				 *        "paginate": false
				 *      } );
				 *    } );
				 */
				"sScrollY": "",
				
				
				/**
				 * __Deprecated__ The functionality provided by this parameter has now been
				 * superseded by that provided through `ajax`, which should be used instead.
				 *
				 * Set the HTTP method that is used to make the Ajax call for server-side
				 * processing or Ajax sourced data.
				 *  @type string
				 *  @default GET
				 *
				 *  @dtopt Options
				 *  @dtopt Server-side
				 *  @name DataTable.defaults.serverMethod
				 *
				 *  @deprecated 1.10. Please use `ajax` for this functionality now.
				 */
				"sServerMethod": "GET",
				
				
				/**
				 * DataTables makes use of renderers when displaying HTML elements for
				 * a table. These renderers can be added or modified by plug-ins to
				 * generate suitable mark-up for a site. For example the Bootstrap
				 * integration plug-in for DataTables uses a paging button renderer to
				 * display pagination buttons in the mark-up required by Bootstrap.
				 *
				 * For further information about the renderers available see
				 * DataTable.ext.renderer
				 *  @type string|object
				 *  @default null
				 *
				 *  @name DataTable.defaults.renderer
				 *
				 */
				"renderer": null,
				
				
				/**
				 * Set the data property name that DataTables should use to get a row's id
				 * to set as the `id` property in the node.
				 *  @type string
				 *  @default DT_RowId
				 *
				 *  @name DataTable.defaults.rowId
				 */
				"rowId": "DT_RowId"
			};
			
			_fnHungarianMap(DataTable.defaults);
			
			
			/*
	 * Developer note - See note in model.defaults.js about the use of Hungarian
	 * notation and camel case.
	 */
			
			/**
			 * Column options that can be given to DataTables at initialisation time.
			 *  @namespace
			 */
			DataTable.defaults.column = {
				/**
				 * Define which column(s) an order will occur on for this column. This
				 * allows a column's ordering to take multiple columns into account when
				 * doing a sort or use the data from a different column. For example first
				 * name / last name columns make sense to do a multi-column sort over the
				 * two columns.
				 *  @type array|int
				 *  @default null <i>Takes the value of the column index automatically</i>
				 *
				 *  @name DataTable.defaults.column.orderData
				 *  @dtopt Columns
				 *
				 *  @example
				 *    // Using `columnDefs`
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "columnDefs": [
				 *          { "orderData": [ 0, 1 ], "targets": [ 0 ] },
				 *          { "orderData": [ 1, 0 ], "targets": [ 1 ] },
				 *          { "orderData": 2, "targets": [ 2 ] }
				 *        ]
				 *      } );
				 *    } );
				 *
				 *  @example
				 *    // Using `columns`
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "columns": [
				 *          { "orderData": [ 0, 1 ] },
				 *          { "orderData": [ 1, 0 ] },
				 *          { "orderData": 2 },
				 *          null,
				 *          null
				 *        ]
				 *      } );
				 *    } );
				 */
				"aDataSort": null,
				"iDataSort": -1,
				
				
				/**
				 * You can control the default ordering direction, and even alter the
				 * behaviour of the sort handler (i.e. only allow ascending ordering etc)
				 * using this parameter.
				 *  @type array
				 *  @default [ 'asc', 'desc' ]
				 *
				 *  @name DataTable.defaults.column.orderSequence
				 *  @dtopt Columns
				 *
				 *  @example
				 *    // Using `columnDefs`
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "columnDefs": [
				 *          { "orderSequence": [ "asc" ], "targets": [ 1 ] },
				 *          { "orderSequence": [ "desc", "asc", "asc" ], "targets": [ 2 ] },
				 *          { "orderSequence": [ "desc" ], "targets": [ 3 ] }
				 *        ]
				 *      } );
				 *    } );
				 *
				 *  @example
				 *    // Using `columns`
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "columns": [
				 *          null,
				 *          { "orderSequence": [ "asc" ] },
				 *          { "orderSequence": [ "desc", "asc", "asc" ] },
				 *          { "orderSequence": [ "desc" ] },
				 *          null
				 *        ]
				 *      } );
				 *    } );
				 */
				"asSorting": ['asc', 'desc'],
				
				
				/**
				 * Enable or disable filtering on the data in this column.
				 *  @type boolean
				 *  @default true
				 *
				 *  @name DataTable.defaults.column.searchable
				 *  @dtopt Columns
				 *
				 *  @example
				 *    // Using `columnDefs`
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "columnDefs": [
				 *          { "searchable": false, "targets": [ 0 ] }
				 *        ] } );
				 *    } );
				 *
				 *  @example
				 *    // Using `columns`
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "columns": [
				 *          { "searchable": false },
				 *          null,
				 *          null,
				 *          null,
				 *          null
				 *        ] } );
				 *    } );
				 */
				"bSearchable": true,
				
				
				/**
				 * Enable or disable ordering on this column.
				 *  @type boolean
				 *  @default true
				 *
				 *  @name DataTable.defaults.column.orderable
				 *  @dtopt Columns
				 *
				 *  @example
				 *    // Using `columnDefs`
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "columnDefs": [
				 *          { "orderable": false, "targets": [ 0 ] }
				 *        ] } );
				 *    } );
				 *
				 *  @example
				 *    // Using `columns`
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "columns": [
				 *          { "orderable": false },
				 *          null,
				 *          null,
				 *          null,
				 *          null
				 *        ] } );
				 *    } );
				 */
				"bSortable": true,
				
				
				/**
				 * Enable or disable the display of this column.
				 *  @type boolean
				 *  @default true
				 *
				 *  @name DataTable.defaults.column.visible
				 *  @dtopt Columns
				 *
				 *  @example
				 *    // Using `columnDefs`
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "columnDefs": [
				 *          { "visible": false, "targets": [ 0 ] }
				 *        ] } );
				 *    } );
				 *
				 *  @example
				 *    // Using `columns`
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "columns": [
				 *          { "visible": false },
				 *          null,
				 *          null,
				 *          null,
				 *          null
				 *        ] } );
				 *    } );
				 */
				"bVisible": true,
				
				
				/**
				 * Developer definable function that is called whenever a cell is created (Ajax source,
				 * etc) or processed for input (DOM source). This can be used as a compliment to mRender
				 * allowing you to modify the DOM element (add background colour for example) when the
				 * element is available.
				 *  @type function
				 *  @param {element} td The TD node that has been created
				 *  @param {*} cellData The Data for the cell
				 *  @param {array|object} rowData The data for the whole row
				 *  @param {int} row The row index for the aoData data store
				 *  @param {int} col The column index for aoColumns
				 *
				 *  @name DataTable.defaults.column.createdCell
				 *  @dtopt Columns
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "columnDefs": [ {
				 *          "targets": [3],
				 *          "createdCell": function (td, cellData, rowData, row, col) {
				 *            if ( cellData == "1.7" ) {
				 *              $(td).css('color', 'blue')
				 *            }
				 *          }
				 *        } ]
				 *      });
				 *    } );
				 */
				"fnCreatedCell": null,
				
				
				/**
				 * This parameter has been replaced by `data` in DataTables to ensure naming
				 * consistency. `dataProp` can still be used, as there is backwards
				 * compatibility in DataTables for this option, but it is strongly
				 * recommended that you use `data` in preference to `dataProp`.
				 *  @name DataTable.defaults.column.dataProp
				 */
				
				
				/**
				 * This property can be used to read data from any data source property,
				 * including deeply nested objects / properties. `data` can be given in a
				 * number of different ways which effect its behaviour:
				 *
				 * * `integer` - treated as an array index for the data source. This is the
				 *   default that DataTables uses (incrementally increased for each column).
				 * * `string` - read an object property from the data source. There are
				 *   three 'special' options that can be used in the string to alter how
				 *   DataTables reads the data from the source object:
				 *    * `.` - Dotted Javascript notation. Just as you use a `.` in
				 *      Javascript to read from nested objects, so to can the options
				 *      specified in `data`. For example: `browser.version` or
				 *      `browser.name`. If your object parameter name contains a period, use
				 *      `\\` to escape it - i.e. `first\\.name`.
				 *    * `[]` - Array notation. DataTables can automatically combine data
				 *      from and array source, joining the data with the characters provided
				 *      between the two brackets. For example: `name[, ]` would provide a
				 *      comma-space separated list from the source array. If no characters
				 *      are provided between the brackets, the original array source is
				 *      returned.
				 *    * `()` - Function notation. Adding `()` to the end of a parameter will
				 *      execute a function of the name given. For example: `browser()` for a
				 *      simple function on the data source, `browser.version()` for a
				 *      function in a nested property or even `browser().version` to get an
				 *      object property if the function called returns an object. Note that
				 *      function notation is recommended for use in `render` rather than
				 *      `data` as it is much simpler to use as a renderer.
				 * * `null` - use the original data source for the row rather than plucking
				 *   data directly from it. This action has effects on two other
				 *   initialisation options:
				 *    * `defaultContent` - When null is given as the `data` option and
				 *      `defaultContent` is specified for the column, the value defined by
				 *      `defaultContent` will be used for the cell.
				 *    * `render` - When null is used for the `data` option and the `render`
				 *      option is specified for the column, the whole data source for the
				 *      row is used for the renderer.
				 * * `function` - the function given will be executed whenever DataTables
				 *   needs to set or get the data for a cell in the column. The function
				 *   takes three parameters:
				 *    * Parameters:
				 *      * `{array|object}` The data source for the row
				 *      * `{string}` The type call data requested - this will be 'set' when
				 *        setting data or 'filter', 'display', 'type', 'sort' or undefined
				 *        when gathering data. Note that when `undefined` is given for the
				 *        type DataTables expects to get the raw data for the object back<
				 *      * `{*}` Data to set when the second parameter is 'set'.
				 *    * Return:
				 *      * The return value from the function is not required when 'set' is
				 *        the type of call, but otherwise the return is what will be used
				 *        for the data requested.
				 *
				 * Note that `data` is a getter and setter option. If you just require
				 * formatting of data for output, you will likely want to use `render` which
				 * is simply a getter and thus simpler to use.
				 *
				 * Note that prior to DataTables 1.9.2 `data` was called `mDataProp`. The
				 * name change reflects the flexibility of this property and is consistent
				 * with the naming of mRender. If 'mDataProp' is given, then it will still
				 * be used by DataTables, as it automatically maps the old name to the new
				 * if required.
				 *
				 *  @type string|int|function|null
				 *  @default null <i>Use automatically calculated column index</i>
				 *
				 *  @name DataTable.defaults.column.data
				 *  @dtopt Columns
				 *
				 *  @example
				 *    // Read table data from objects
				 *    // JSON structure for each row:
				 *    //   {
				 *    //      "engine": {value},
				 *    //      "browser": {value},
				 *    //      "platform": {value},
				 *    //      "version": {value},
				 *    //      "grade": {value}
				 *    //   }
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "ajaxSource": "sources/objects.txt",
				 *        "columns": [
				 *          { "data": "engine" },
				 *          { "data": "browser" },
				 *          { "data": "platform" },
				 *          { "data": "version" },
				 *          { "data": "grade" }
				 *        ]
				 *      } );
				 *    } );
				 *
				 *  @example
				 *    // Read information from deeply nested objects
				 *    // JSON structure for each row:
				 *    //   {
				 *    //      "engine": {value},
				 *    //      "browser": {value},
				 *    //      "platform": {
				 *    //         "inner": {value}
				 *    //      },
				 *    //      "details": [
				 *    //         {value}, {value}
				 *    //      ]
				 *    //   }
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "ajaxSource": "sources/deep.txt",
				 *        "columns": [
				 *          { "data": "engine" },
				 *          { "data": "browser" },
				 *          { "data": "platform.inner" },
				 *          { "data": "details.0" },
				 *          { "data": "details.1" }
				 *        ]
				 *      } );
				 *    } );
				 *
				 *  @example
				 *    // Using `data` as a function to provide different information for
				 *    // sorting, filtering and display. In this case, currency (price)
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "columnDefs": [ {
				 *          "targets": [ 0 ],
				 *          "data": function ( source, type, val ) {
				 *            if (type === 'set') {
				 *              source.price = val;
				 *              // Store the computed dislay and filter values for efficiency
				 *              source.price_display = val=="" ? "" : "$"+numberFormat(val);
				 *              source.price_filter  = val=="" ? "" : "$"+numberFormat(val)+" "+val;
				 *              return;
				 *            }
				 *            else if (type === 'display') {
				 *              return source.price_display;
				 *            }
				 *            else if (type === 'filter') {
				 *              return source.price_filter;
				 *            }
				 *            // 'sort', 'type' and undefined all just use the integer
				 *            return source.price;
				 *          }
				 *        } ]
				 *      } );
				 *    } );
				 *
				 *  @example
				 *    // Using default content
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "columnDefs": [ {
				 *          "targets": [ 0 ],
				 *          "data": null,
				 *          "defaultContent": "Click to edit"
				 *        } ]
				 *      } );
				 *    } );
				 *
				 *  @example
				 *    // Using array notation - outputting a list from an array
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "columnDefs": [ {
				 *          "targets": [ 0 ],
				 *          "data": "name[, ]"
				 *        } ]
				 *      } );
				 *    } );
				 *
				 */
				"mData": null,
				
				
				/**
				 * This property is the rendering partner to `data` and it is suggested that
				 * when you want to manipulate data for display (including filtering,
				 * sorting etc) without altering the underlying data for the table, use this
				 * property. `render` can be considered to be the the read only companion to
				 * `data` which is read / write (then as such more complex). Like `data`
				 * this option can be given in a number of different ways to effect its
				 * behaviour:
				 *
				 * * `integer` - treated as an array index for the data source. This is the
				 *   default that DataTables uses (incrementally increased for each column).
				 * * `string` - read an object property from the data source. There are
				 *   three 'special' options that can be used in the string to alter how
				 *   DataTables reads the data from the source object:
				 *    * `.` - Dotted Javascript notation. Just as you use a `.` in
				 *      Javascript to read from nested objects, so to can the options
				 *      specified in `data`. For example: `browser.version` or
				 *      `browser.name`. If your object parameter name contains a period, use
				 *      `\\` to escape it - i.e. `first\\.name`.
				 *    * `[]` - Array notation. DataTables can automatically combine data
				 *      from and array source, joining the data with the characters provided
				 *      between the two brackets. For example: `name[, ]` would provide a
				 *      comma-space separated list from the source array. If no characters
				 *      are provided between the brackets, the original array source is
				 *      returned.
				 *    * `()` - Function notation. Adding `()` to the end of a parameter will
				 *      execute a function of the name given. For example: `browser()` for a
				 *      simple function on the data source, `browser.version()` for a
				 *      function in a nested property or even `browser().version` to get an
				 *      object property if the function called returns an object.
				 * * `object` - use different data for the different data types requested by
				 *   DataTables ('filter', 'display', 'type' or 'sort'). The property names
				 *   of the object is the data type the property refers to and the value can
				 *   defined using an integer, string or function using the same rules as
				 *   `render` normally does. Note that an `_` option _must_ be specified.
				 *   This is the default value to use if you haven't specified a value for
				 *   the data type requested by DataTables.
				 * * `function` - the function given will be executed whenever DataTables
				 *   needs to set or get the data for a cell in the column. The function
				 *   takes three parameters:
				 *    * Parameters:
				 *      * {array|object} The data source for the row (based on `data`)
				 *      * {string} The type call data requested - this will be 'filter',
				 *        'display', 'type' or 'sort'.
				 *      * {array|object} The full data source for the row (not based on
				 *        `data`)
				 *    * Return:
				 *      * The return value from the function is what will be used for the
				 *        data requested.
				 *
				 *  @type string|int|function|object|null
				 *  @default null Use the data source value.
				 *
				 *  @name DataTable.defaults.column.render
				 *  @dtopt Columns
				 *
				 *  @example
				 *    // Create a comma separated list from an array of objects
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "ajaxSource": "sources/deep.txt",
				 *        "columns": [
				 *          { "data": "engine" },
				 *          { "data": "browser" },
				 *          {
				 *            "data": "platform",
				 *            "render": "[, ].name"
				 *          }
				 *        ]
				 *      } );
				 *    } );
				 *
				 *  @example
				 *    // Execute a function to obtain data
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "columnDefs": [ {
				 *          "targets": [ 0 ],
				 *          "data": null, // Use the full data source object for the renderer's source
				 *          "render": "browserName()"
				 *        } ]
				 *      } );
				 *    } );
				 *
				 *  @example
				 *    // As an object, extracting different data for the different types
				 *    // This would be used with a data source such as:
				 *    //   { "phone": 5552368, "phone_filter": "5552368 555-2368", "phone_display": "555-2368" }
				 *    // Here the `phone` integer is used for sorting and type detection, while `phone_filter`
				 *    // (which has both forms) is used for filtering for if a user inputs either format, while
				 *    // the formatted phone number is the one that is shown in the table.
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "columnDefs": [ {
				 *          "targets": [ 0 ],
				 *          "data": null, // Use the full data source object for the renderer's source
				 *          "render": {
				 *            "_": "phone",
				 *            "filter": "phone_filter",
				 *            "display": "phone_display"
				 *          }
				 *        } ]
				 *      } );
				 *    } );
				 *
				 *  @example
				 *    // Use as a function to create a link from the data source
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "columnDefs": [ {
				 *          "targets": [ 0 ],
				 *          "data": "download_link",
				 *          "render": function ( data, type, full ) {
				 *            return '<a href="'+data+'">Download</a>';
				 *          }
				 *        } ]
				 *      } );
				 *    } );
				 */
				"mRender": null,
				
				
				/**
				 * Change the cell type created for the column - either TD cells or TH cells. This
				 * can be useful as TH cells have semantic meaning in the table body, allowing them
				 * to act as a header for a row (you may wish to add scope='row' to the TH elements).
				 *  @type string
				 *  @default td
				 *
				 *  @name DataTable.defaults.column.cellType
				 *  @dtopt Columns
				 *
				 *  @example
				 *    // Make the first column use TH cells
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "columnDefs": [ {
				 *          "targets": [ 0 ],
				 *          "cellType": "th"
				 *        } ]
				 *      } );
				 *    } );
				 */
				"sCellType": "td",
				
				
				/**
				 * Class to give to each cell in this column.
				 *  @type string
				 *  @default <i>Empty string</i>
				 *
				 *  @name DataTable.defaults.column.class
				 *  @dtopt Columns
				 *
				 *  @example
				 *    // Using `columnDefs`
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "columnDefs": [
				 *          { "class": "my_class", "targets": [ 0 ] }
				 *        ]
				 *      } );
				 *    } );
				 *
				 *  @example
				 *    // Using `columns`
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "columns": [
				 *          { "class": "my_class" },
				 *          null,
				 *          null,
				 *          null,
				 *          null
				 *        ]
				 *      } );
				 *    } );
				 */
				"sClass": "",
				
				/**
				 * When DataTables calculates the column widths to assign to each column,
				 * it finds the longest string in each column and then constructs a
				 * temporary table and reads the widths from that. The problem with this
				 * is that "mmm" is much wider then "iiii", but the latter is a longer
				 * string - thus the calculation can go wrong (doing it properly and putting
				 * it into an DOM object and measuring that is horribly(!) slow). Thus as
				 * a "work around" we provide this option. It will append its value to the
				 * text that is found to be the longest string for the column - i.e. padding.
				 * Generally you shouldn't need this!
				 *  @type string
				 *  @default <i>Empty string<i>
				 *
				 *  @name DataTable.defaults.column.contentPadding
				 *  @dtopt Columns
				 *
				 *  @example
				 *    // Using `columns`
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "columns": [
				 *          null,
				 *          null,
				 *          null,
				 *          {
				 *            "contentPadding": "mmm"
				 *          }
				 *        ]
				 *      } );
				 *    } );
				 */
				"sContentPadding": "",
				
				
				/**
				 * Allows a default value to be given for a column's data, and will be used
				 * whenever a null data source is encountered (this can be because `data`
				 * is set to null, or because the data source itself is null).
				 *  @type string
				 *  @default null
				 *
				 *  @name DataTable.defaults.column.defaultContent
				 *  @dtopt Columns
				 *
				 *  @example
				 *    // Using `columnDefs`
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "columnDefs": [
				 *          {
				 *            "data": null,
				 *            "defaultContent": "Edit",
				 *            "targets": [ -1 ]
				 *          }
				 *        ]
				 *      } );
				 *    } );
				 *
				 *  @example
				 *    // Using `columns`
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "columns": [
				 *          null,
				 *          null,
				 *          null,
				 *          {
				 *            "data": null,
				 *            "defaultContent": "Edit"
				 *          }
				 *        ]
				 *      } );
				 *    } );
				 */
				"sDefaultContent": null,
				
				
				/**
				 * This parameter is only used in DataTables' server-side processing. It can
				 * be exceptionally useful to know what columns are being displayed on the
				 * client side, and to map these to database fields. When defined, the names
				 * also allow DataTables to reorder information from the server if it comes
				 * back in an unexpected order (i.e. if you switch your columns around on the
				 * client-side, your server-side code does not also need updating).
				 *  @type string
				 *  @default <i>Empty string</i>
				 *
				 *  @name DataTable.defaults.column.name
				 *  @dtopt Columns
				 *
				 *  @example
				 *    // Using `columnDefs`
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "columnDefs": [
				 *          { "name": "engine", "targets": [ 0 ] },
				 *          { "name": "browser", "targets": [ 1 ] },
				 *          { "name": "platform", "targets": [ 2 ] },
				 *          { "name": "version", "targets": [ 3 ] },
				 *          { "name": "grade", "targets": [ 4 ] }
				 *        ]
				 *      } );
				 *    } );
				 *
				 *  @example
				 *    // Using `columns`
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "columns": [
				 *          { "name": "engine" },
				 *          { "name": "browser" },
				 *          { "name": "platform" },
				 *          { "name": "version" },
				 *          { "name": "grade" }
				 *        ]
				 *      } );
				 *    } );
				 */
				"sName": "",
				
				
				/**
				 * Defines a data source type for the ordering which can be used to read
				 * real-time information from the table (updating the internally cached
				 * version) prior to ordering. This allows ordering to occur on user
				 * editable elements such as form inputs.
				 *  @type string
				 *  @default std
				 *
				 *  @name DataTable.defaults.column.orderDataType
				 *  @dtopt Columns
				 *
				 *  @example
				 *    // Using `columnDefs`
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "columnDefs": [
				 *          { "orderDataType": "dom-text", "targets": [ 2, 3 ] },
				 *          { "type": "numeric", "targets": [ 3 ] },
				 *          { "orderDataType": "dom-select", "targets": [ 4 ] },
				 *          { "orderDataType": "dom-checkbox", "targets": [ 5 ] }
				 *        ]
				 *      } );
				 *    } );
				 *
				 *  @example
				 *    // Using `columns`
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "columns": [
				 *          null,
				 *          null,
				 *          { "orderDataType": "dom-text" },
				 *          { "orderDataType": "dom-text", "type": "numeric" },
				 *          { "orderDataType": "dom-select" },
				 *          { "orderDataType": "dom-checkbox" }
				 *        ]
				 *      } );
				 *    } );
				 */
				"sSortDataType": "std",
				
				
				/**
				 * The title of this column.
				 *  @type string
				 *  @default null <i>Derived from the 'TH' value for this column in the
				 *    original HTML table.</i>
				 *
				 *  @name DataTable.defaults.column.title
				 *  @dtopt Columns
				 *
				 *  @example
				 *    // Using `columnDefs`
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "columnDefs": [
				 *          { "title": "My column title", "targets": [ 0 ] }
				 *        ]
				 *      } );
				 *    } );
				 *
				 *  @example
				 *    // Using `columns`
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "columns": [
				 *          { "title": "My column title" },
				 *          null,
				 *          null,
				 *          null,
				 *          null
				 *        ]
				 *      } );
				 *    } );
				 */
				"sTitle": null,
				
				
				/**
				 * The type allows you to specify how the data for this column will be
				 * ordered. Four types (string, numeric, date and html (which will strip
				 * HTML tags before ordering)) are currently available. Note that only date
				 * formats understood by Javascript's Date() object will be accepted as type
				 * date. For example: "Mar 26, 2008 5:03 PM". May take the values: 'string',
				 * 'numeric', 'date' or 'html' (by default). Further types can be adding
				 * through plug-ins.
				 *  @type string
				 *  @default null <i>Auto-detected from raw data</i>
				 *
				 *  @name DataTable.defaults.column.type
				 *  @dtopt Columns
				 *
				 *  @example
				 *    // Using `columnDefs`
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "columnDefs": [
				 *          { "type": "html", "targets": [ 0 ] }
				 *        ]
				 *      } );
				 *    } );
				 *
				 *  @example
				 *    // Using `columns`
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "columns": [
				 *          { "type": "html" },
				 *          null,
				 *          null,
				 *          null,
				 *          null
				 *        ]
				 *      } );
				 *    } );
				 */
				"sType": null,
				
				
				/**
				 * Defining the width of the column, this parameter may take any CSS value
				 * (3em, 20px etc). DataTables applies 'smart' widths to columns which have not
				 * been given a specific width through this interface ensuring that the table
				 * remains readable.
				 *  @type string
				 *  @default null <i>Automatic</i>
				 *
				 *  @name DataTable.defaults.column.width
				 *  @dtopt Columns
				 *
				 *  @example
				 *    // Using `columnDefs`
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "columnDefs": [
				 *          { "width": "20%", "targets": [ 0 ] }
				 *        ]
				 *      } );
				 *    } );
				 *
				 *  @example
				 *    // Using `columns`
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "columns": [
				 *          { "width": "20%" },
				 *          null,
				 *          null,
				 *          null,
				 *          null
				 *        ]
				 *      } );
				 *    } );
				 */
				"sWidth": null
			};
			
			_fnHungarianMap(DataTable.defaults.column);
			
			
			/**
			 * DataTables settings object - this holds all the information needed for a
			 * given table, including configuration, data and current application of the
			 * table options. DataTables does not have a single instance for each DataTable
			 * with the settings attached to that instance, but rather instances of the
			 * DataTable "class" are created on-the-fly as needed (typically by a
			 * $().dataTable() call) and the settings object is then applied to that
			 * instance.
			 *
			 * Note that this object is related to {@link DataTable.defaults} but this
			 * one is the internal data store for DataTables's cache of columns. It should
			 * NOT be manipulated outside of DataTables. Any configuration should be done
			 * through the initialisation options.
			 *  @namespace
			 *  @todo Really should attach the settings object to individual instances so we
			 *    don't need to create new instances on each $().dataTable() call (if the
			 *    table already exists). It would also save passing oSettings around and
			 *    into every single function. However, this is a very significant
			 *    architecture change for DataTables and will almost certainly break
			 *    backwards compatibility with older installations. This is something that
			 *    will be done in 2.0.
			 */
			DataTable.models.oSettings = {
				/**
				 * Primary features of DataTables and their enablement state.
				 *  @namespace
				 */
				"oFeatures": {
					
					/**
					 * Flag to say if DataTables should automatically try to calculate the
					 * optimum table and columns widths (true) or not (false).
					 * Note that this parameter will be set by the initialisation routine. To
					 * set a default use {@link DataTable.defaults}.
					 *  @type boolean
					 */
					"bAutoWidth": null,
					
					/**
					 * Delay the creation of TR and TD elements until they are actually
					 * needed by a driven page draw. This can give a significant speed
					 * increase for Ajax source and Javascript source data, but makes no
					 * difference at all fro DOM and server-side processing tables.
					 * Note that this parameter will be set by the initialisation routine. To
					 * set a default use {@link DataTable.defaults}.
					 *  @type boolean
					 */
					"bDeferRender": null,
					
					/**
					 * Enable filtering on the table or not. Note that if this is disabled
					 * then there is no filtering at all on the table, including fnFilter.
					 * To just remove the filtering input use sDom and remove the 'f' option.
					 * Note that this parameter will be set by the initialisation routine. To
					 * set a default use {@link DataTable.defaults}.
					 *  @type boolean
					 */
					"bFilter": null,
					
					/**
					 * Table information element (the 'Showing x of y records' div) enable
					 * flag.
					 * Note that this parameter will be set by the initialisation routine. To
					 * set a default use {@link DataTable.defaults}.
					 *  @type boolean
					 */
					"bInfo": null,
					
					/**
					 * Present a user control allowing the end user to change the page size
					 * when pagination is enabled.
					 * Note that this parameter will be set by the initialisation routine. To
					 * set a default use {@link DataTable.defaults}.
					 *  @type boolean
					 */
					"bLengthChange": null,
					
					/**
					 * Pagination enabled or not. Note that if this is disabled then length
					 * changing must also be disabled.
					 * Note that this parameter will be set by the initialisation routine. To
					 * set a default use {@link DataTable.defaults}.
					 *  @type boolean
					 */
					"bPaginate": null,
					
					/**
					 * Processing indicator enable flag whenever DataTables is enacting a
					 * user request - typically an Ajax request for server-side processing.
					 * Note that this parameter will be set by the initialisation routine. To
					 * set a default use {@link DataTable.defaults}.
					 *  @type boolean
					 */
					"bProcessing": null,
					
					/**
					 * Server-side processing enabled flag - when enabled DataTables will
					 * get all data from the server for every draw - there is no filtering,
					 * sorting or paging done on the client-side.
					 * Note that this parameter will be set by the initialisation routine. To
					 * set a default use {@link DataTable.defaults}.
					 *  @type boolean
					 */
					"bServerSide": null,
					
					/**
					 * Sorting enablement flag.
					 * Note that this parameter will be set by the initialisation routine. To
					 * set a default use {@link DataTable.defaults}.
					 *  @type boolean
					 */
					"bSort": null,
					
					/**
					 * Multi-column sorting
					 * Note that this parameter will be set by the initialisation routine. To
					 * set a default use {@link DataTable.defaults}.
					 *  @type boolean
					 */
					"bSortMulti": null,
					
					/**
					 * Apply a class to the columns which are being sorted to provide a
					 * visual highlight or not. This can slow things down when enabled since
					 * there is a lot of DOM interaction.
					 * Note that this parameter will be set by the initialisation routine. To
					 * set a default use {@link DataTable.defaults}.
					 *  @type boolean
					 */
					"bSortClasses": null,
					
					/**
					 * State saving enablement flag.
					 * Note that this parameter will be set by the initialisation routine. To
					 * set a default use {@link DataTable.defaults}.
					 *  @type boolean
					 */
					"bStateSave": null
				},
				
				
				/**
				 * Scrolling settings for a table.
				 *  @namespace
				 */
				"oScroll": {
					/**
					 * When the table is shorter in height than sScrollY, collapse the
					 * table container down to the height of the table (when true).
					 * Note that this parameter will be set by the initialisation routine. To
					 * set a default use {@link DataTable.defaults}.
					 *  @type boolean
					 */
					"bCollapse": null,
					
					/**
					 * Width of the scrollbar for the web-browser's platform. Calculated
					 * during table initialisation.
					 *  @type int
					 *  @default 0
					 */
					"iBarWidth": 0,
					
					/**
					 * Viewport width for horizontal scrolling. Horizontal scrolling is
					 * disabled if an empty string.
					 * Note that this parameter will be set by the initialisation routine. To
					 * set a default use {@link DataTable.defaults}.
					 *  @type string
					 */
					"sX": null,
					
					/**
					 * Width to expand the table to when using x-scrolling. Typically you
					 * should not need to use this.
					 * Note that this parameter will be set by the initialisation routine. To
					 * set a default use {@link DataTable.defaults}.
					 *  @type string
					 *  @deprecated
					 */
					"sXInner": null,
					
					/**
					 * Viewport height for vertical scrolling. Vertical scrolling is disabled
					 * if an empty string.
					 * Note that this parameter will be set by the initialisation routine. To
					 * set a default use {@link DataTable.defaults}.
					 *  @type string
					 */
					"sY": null
				},
				
				/**
				 * Language information for the table.
				 *  @namespace
				 *  @extends DataTable.defaults.oLanguage
				 */
				"oLanguage": {
					/**
					 * Information callback function. See
					 * {@link DataTable.defaults.fnInfoCallback}
					 *  @type function
					 *  @default null
					 */
					"fnInfoCallback": null
				},
				
				/**
				 * Browser support parameters
				 *  @namespace
				 */
				"oBrowser": {
					/**
					 * Indicate if the browser incorrectly calculates width:100% inside a
					 * scrolling element (IE6/7)
					 *  @type boolean
					 *  @default false
					 */
					"bScrollOversize": false,
					
					/**
					 * Determine if the vertical scrollbar is on the right or left of the
					 * scrolling container - needed for rtl language layout, although not
					 * all browsers move the scrollbar (Safari).
					 *  @type boolean
					 *  @default false
					 */
					"bScrollbarLeft": false,
					
					/**
					 * Flag for if `getBoundingClientRect` is fully supported or not
					 *  @type boolean
					 *  @default false
					 */
					"bBounding": false,
					
					/**
					 * Browser scrollbar width
					 *  @type integer
					 *  @default 0
					 */
					"barWidth": 0
				},
				
				
				"ajax": null,
				
				
				/**
				 * Array referencing the nodes which are used for the features. The
				 * parameters of this object match what is allowed by sDom - i.e.
				 *   <ul>
				 *     <li>'l' - Length changing</li>
				 *     <li>'f' - Filtering input</li>
				 *     <li>'t' - The table!</li>
				 *     <li>'i' - Information</li>
				 *     <li>'p' - Pagination</li>
				 *     <li>'r' - pRocessing</li>
				 *   </ul>
				 *  @type array
				 *  @default []
				 */
				"aanFeatures": [],
				
				/**
				 * Store data information - see {@link DataTable.models.oRow} for detailed
				 * information.
				 *  @type array
				 *  @default []
				 */
				"aoData": [],
				
				/**
				 * Array of indexes which are in the current display (after filtering etc)
				 *  @type array
				 *  @default []
				 */
				"aiDisplay": [],
				
				/**
				 * Array of indexes for display - no filtering
				 *  @type array
				 *  @default []
				 */
				"aiDisplayMaster": [],
				
				/**
				 * Map of row ids to data indexes
				 *  @type object
				 *  @default {}
				 */
				"aIds": {},
				
				/**
				 * Store information about each column that is in use
				 *  @type array
				 *  @default []
				 */
				"aoColumns": [],
				
				/**
				 * Store information about the table's header
				 *  @type array
				 *  @default []
				 */
				"aoHeader": [],
				
				/**
				 * Store information about the table's footer
				 *  @type array
				 *  @default []
				 */
				"aoFooter": [],
				
				/**
				 * Store the applied global search information in case we want to force a
				 * research or compare the old search to a new one.
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @namespace
				 *  @extends DataTable.models.oSearch
				 */
				"oPreviousSearch": {},
				
				/**
				 * Store the applied search for each column - see
				 * {@link DataTable.models.oSearch} for the format that is used for the
				 * filtering information for each column.
				 *  @type array
				 *  @default []
				 */
				"aoPreSearchCols": [],
				
				/**
				 * Sorting that is applied to the table. Note that the inner arrays are
				 * used in the following manner:
				 * <ul>
				 *   <li>Index 0 - column number</li>
				 *   <li>Index 1 - current sorting direction</li>
				 * </ul>
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type array
				 *  @todo These inner arrays should really be objects
				 */
				"aaSorting": null,
				
				/**
				 * Sorting that is always applied to the table (i.e. prefixed in front of
				 * aaSorting).
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type array
				 *  @default []
				 */
				"aaSortingFixed": [],
				
				/**
				 * Classes to use for the striping of a table.
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type array
				 *  @default []
				 */
				"asStripeClasses": null,
				
				/**
				 * If restoring a table - we should restore its striping classes as well
				 *  @type array
				 *  @default []
				 */
				"asDestroyStripes": [],
				
				/**
				 * If restoring a table - we should restore its width
				 *  @type int
				 *  @default 0
				 */
				"sDestroyWidth": 0,
				
				/**
				 * Callback functions array for every time a row is inserted (i.e. on a draw).
				 *  @type array
				 *  @default []
				 */
				"aoRowCallback": [],
				
				/**
				 * Callback functions for the header on each draw.
				 *  @type array
				 *  @default []
				 */
				"aoHeaderCallback": [],
				
				/**
				 * Callback function for the footer on each draw.
				 *  @type array
				 *  @default []
				 */
				"aoFooterCallback": [],
				
				/**
				 * Array of callback functions for draw callback functions
				 *  @type array
				 *  @default []
				 */
				"aoDrawCallback": [],
				
				/**
				 * Array of callback functions for row created function
				 *  @type array
				 *  @default []
				 */
				"aoRowCreatedCallback": [],
				
				/**
				 * Callback functions for just before the table is redrawn. A return of
				 * false will be used to cancel the draw.
				 *  @type array
				 *  @default []
				 */
				"aoPreDrawCallback": [],
				
				/**
				 * Callback functions for when the table has been initialised.
				 *  @type array
				 *  @default []
				 */
				"aoInitComplete": [],
				
				
				/**
				 * Callbacks for modifying the settings to be stored for state saving, prior to
				 * saving state.
				 *  @type array
				 *  @default []
				 */
				"aoStateSaveParams": [],
				
				/**
				 * Callbacks for modifying the settings that have been stored for state saving
				 * prior to using the stored values to restore the state.
				 *  @type array
				 *  @default []
				 */
				"aoStateLoadParams": [],
				
				/**
				 * Callbacks for operating on the settings object once the saved state has been
				 * loaded
				 *  @type array
				 *  @default []
				 */
				"aoStateLoaded": [],
				
				/**
				 * Cache the table ID for quick access
				 *  @type string
				 *  @default <i>Empty string</i>
				 */
				"sTableId": "",
				
				/**
				 * The TABLE node for the main table
				 *  @type node
				 *  @default null
				 */
				"nTable": null,
				
				/**
				 * Permanent ref to the thead element
				 *  @type node
				 *  @default null
				 */
				"nTHead": null,
				
				/**
				 * Permanent ref to the tfoot element - if it exists
				 *  @type node
				 *  @default null
				 */
				"nTFoot": null,
				
				/**
				 * Permanent ref to the tbody element
				 *  @type node
				 *  @default null
				 */
				"nTBody": null,
				
				/**
				 * Cache the wrapper node (contains all DataTables controlled elements)
				 *  @type node
				 *  @default null
				 */
				"nTableWrapper": null,
				
				/**
				 * Indicate if when using server-side processing the loading of data
				 * should be deferred until the second draw.
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type boolean
				 *  @default false
				 */
				"bDeferLoading": false,
				
				/**
				 * Indicate if all required information has been read in
				 *  @type boolean
				 *  @default false
				 */
				"bInitialised": false,
				
				/**
				 * Information about open rows. Each object in the array has the parameters
				 * 'nTr' and 'nParent'
				 *  @type array
				 *  @default []
				 */
				"aoOpenRows": [],
				
				/**
				 * Dictate the positioning of DataTables' control elements - see
				 * {@link DataTable.model.oInit.sDom}.
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type string
				 *  @default null
				 */
				"sDom": null,
				
				/**
				 * Search delay (in mS)
				 *  @type integer
				 *  @default null
				 */
				"searchDelay": null,
				
				/**
				 * Which type of pagination should be used.
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type string
				 *  @default two_button
				 */
				"sPaginationType": "two_button",
				
				/**
				 * The state duration (for `stateSave`) in seconds.
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type int
				 *  @default 0
				 */
				"iStateDuration": 0,
				
				/**
				 * Array of callback functions for state saving. Each array element is an
				 * object with the following parameters:
				 *   <ul>
				 *     <li>function:fn - function to call. Takes two parameters, oSettings
				 *       and the JSON string to save that has been thus far created. Returns
				 *       a JSON string to be inserted into a json object
				 *       (i.e. '"param": [ 0, 1, 2]')</li>
				 *     <li>string:sName - name of callback</li>
				 *   </ul>
				 *  @type array
				 *  @default []
				 */
				"aoStateSave": [],
				
				/**
				 * Array of callback functions for state loading. Each array element is an
				 * object with the following parameters:
				 *   <ul>
				 *     <li>function:fn - function to call. Takes two parameters, oSettings
				 *       and the object stored. May return false to cancel state loading</li>
				 *     <li>string:sName - name of callback</li>
				 *   </ul>
				 *  @type array
				 *  @default []
				 */
				"aoStateLoad": [],
				
				/**
				 * State that was saved. Useful for back reference
				 *  @type object
				 *  @default null
				 */
				"oSavedState": null,
				
				/**
				 * State that was loaded. Useful for back reference
				 *  @type object
				 *  @default null
				 */
				"oLoadedState": null,
				
				/**
				 * Source url for AJAX data for the table.
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type string
				 *  @default null
				 */
				"sAjaxSource": null,
				
				/**
				 * Property from a given object from which to read the table data from. This
				 * can be an empty string (when not server-side processing), in which case
				 * it is  assumed an an array is given directly.
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type string
				 */
				"sAjaxDataProp": null,
				
				/**
				 * Note if draw should be blocked while getting data
				 *  @type boolean
				 *  @default true
				 */
				"bAjaxDataGet": true,
				
				/**
				 * The last jQuery XHR object that was used for server-side data gathering.
				 * This can be used for working with the XHR information in one of the
				 * callbacks
				 *  @type object
				 *  @default null
				 */
				"jqXHR": null,
				
				/**
				 * JSON returned from the server in the last Ajax request
				 *  @type object
				 *  @default undefined
				 */
				"json": undefined,
				
				/**
				 * Data submitted as part of the last Ajax request
				 *  @type object
				 *  @default undefined
				 */
				"oAjaxData": undefined,
				
				/**
				 * Function to get the server-side data.
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type function
				 */
				"fnServerData": null,
				
				/**
				 * Functions which are called prior to sending an Ajax request so extra
				 * parameters can easily be sent to the server
				 *  @type array
				 *  @default []
				 */
				"aoServerParams": [],
				
				/**
				 * Send the XHR HTTP method - GET or POST (could be PUT or DELETE if
				 * required).
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type string
				 */
				"sServerMethod": null,
				
				/**
				 * Format numbers for display.
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type function
				 */
				"fnFormatNumber": null,
				
				/**
				 * List of options that can be used for the user selectable length menu.
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type array
				 *  @default []
				 */
				"aLengthMenu": null,
				
				/**
				 * Counter for the draws that the table does. Also used as a tracker for
				 * server-side processing
				 *  @type int
				 *  @default 0
				 */
				"iDraw": 0,
				
				/**
				 * Indicate if a redraw is being done - useful for Ajax
				 *  @type boolean
				 *  @default false
				 */
				"bDrawing": false,
				
				/**
				 * Draw index (iDraw) of the last error when parsing the returned data
				 *  @type int
				 *  @default -1
				 */
				"iDrawError": -1,
				
				/**
				 * Paging display length
				 *  @type int
				 *  @default 10
				 */
				"_iDisplayLength": 10,
				
				/**
				 * Paging start point - aiDisplay index
				 *  @type int
				 *  @default 0
				 */
				"_iDisplayStart": 0,
				
				/**
				 * Server-side processing - number of records in the result set
				 * (i.e. before filtering), Use fnRecordsTotal rather than
				 * this property to get the value of the number of records, regardless of
				 * the server-side processing setting.
				 *  @type int
				 *  @default 0
				 *  @private
				 */
				"_iRecordsTotal": 0,
				
				/**
				 * Server-side processing - number of records in the current display set
				 * (i.e. after filtering). Use fnRecordsDisplay rather than
				 * this property to get the value of the number of records, regardless of
				 * the server-side processing setting.
				 *  @type boolean
				 *  @default 0
				 *  @private
				 */
				"_iRecordsDisplay": 0,
				
				/**
				 * The classes to use for the table
				 *  @type object
				 *  @default {}
				 */
				"oClasses": {},
				
				/**
				 * Flag attached to the settings object so you can check in the draw
				 * callback if filtering has been done in the draw. Deprecated in favour of
				 * events.
				 *  @type boolean
				 *  @default false
				 *  @deprecated
				 */
				"bFiltered": false,
				
				/**
				 * Flag attached to the settings object so you can check in the draw
				 * callback if sorting has been done in the draw. Deprecated in favour of
				 * events.
				 *  @type boolean
				 *  @default false
				 *  @deprecated
				 */
				"bSorted": false,
				
				/**
				 * Indicate that if multiple rows are in the header and there is more than
				 * one unique cell per column, if the top one (true) or bottom one (false)
				 * should be used for sorting / title by DataTables.
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type boolean
				 */
				"bSortCellsTop": null,
				
				/**
				 * Initialisation object that is used for the table
				 *  @type object
				 *  @default null
				 */
				"oInit": null,
				
				/**
				 * Destroy callback functions - for plug-ins to attach themselves to the
				 * destroy so they can clean up markup and events.
				 *  @type array
				 *  @default []
				 */
				"aoDestroyCallback": [],
				
				
				/**
				 * Get the number of records in the current record set, before filtering
				 *  @type function
				 */
				"fnRecordsTotal": function() {
					return _fnDataSource(this) == 'ssp' ?
						this._iRecordsTotal * 1 :
						this.aiDisplayMaster.length;
				},
				
				/**
				 * Get the number of records in the current record set, after filtering
				 *  @type function
				 */
				"fnRecordsDisplay": function() {
					return _fnDataSource(this) == 'ssp' ?
						this._iRecordsDisplay * 1 :
						this.aiDisplay.length;
				},
				
				/**
				 * Get the display end point - aiDisplay index
				 *  @type function
				 */
				"fnDisplayEnd": function() {
					var
						len = this._iDisplayLength,
						start = this._iDisplayStart,
						calc = start + len,
						records = this.aiDisplay.length,
						features = this.oFeatures,
						paginate = features.bPaginate;
					
					if(features.bServerSide) {
						return paginate === false || len === -1 ?
							start + records :
							Math.min(start + len, this._iRecordsDisplay);
					} else {
						return !paginate || calc > records || len === -1 ?
							records :
							calc;
					}
				},
				
				/**
				 * The DataTables object for this table
				 *  @type object
				 *  @default null
				 */
				"oInstance": null,
				
				/**
				 * Unique identifier for each instance of the DataTables object. If there
				 * is an ID on the table node, then it takes that value, otherwise an
				 * incrementing internal counter is used.
				 *  @type string
				 *  @default null
				 */
				"sInstance": null,
				
				/**
				 * tabindex attribute value that is added to DataTables control elements, allowing
				 * keyboard navigation of the table and its controls.
				 */
				"iTabIndex": 0,
				
				/**
				 * DIV container for the footer scrolling table if scrolling
				 */
				"nScrollHead": null,
				
				/**
				 * DIV container for the footer scrolling table if scrolling
				 */
				"nScrollFoot": null,
				
				/**
				 * Last applied sort
				 *  @type array
				 *  @default []
				 */
				"aLastSort": [],
				
				/**
				 * Stored plug-in instances
				 *  @type object
				 *  @default {}
				 */
				"oPlugins": {},
				
				/**
				 * Function used to get a row's id from the row's data
				 *  @type function
				 *  @default null
				 */
				"rowIdFn": null,
				
				/**
				 * Data location where to store a row's id
				 *  @type string
				 *  @default null
				 */
				"rowId": null
			};
			
			/**
			 * Extension object for DataTables that is used to provide all extension
			 * options.
			 *
			 * Note that the `DataTable.ext` object is available through
			 * `jQuery.fn.dataTable.ext` where it may be accessed and manipulated. It is
			 * also aliased to `jQuery.fn.dataTableExt` for historic reasons.
			 *  @namespace
			 *  @extends DataTable.models.ext
			 */
			
			
			/**
			 * DataTables extensions
			 *
			 * This namespace acts as a collection area for plug-ins that can be used to
			 * extend DataTables capabilities. Indeed many of the build in methods
			 * use this method to provide their own capabilities (sorting methods for
			 * example).
			 *
			 * Note that this namespace is aliased to `jQuery.fn.dataTableExt` for legacy
			 * reasons
			 *
			 *  @namespace
			 */
			DataTable.ext = _ext = {
				/**
				 * Buttons. For use with the Buttons extension for DataTables. This is
				 * defined here so other extensions can define buttons regardless of load
				 * order. It is _not_ used by DataTables core.
				 *
				 *  @type object
				 *  @default {}
				 */
				buttons: {},
				
				
				/**
				 * Element class names
				 *
				 *  @type object
				 *  @default {}
				 */
				classes: {},
				
				
				/**
				 * DataTables build type (expanded by the download builder)
				 *
				 *  @type string
				 */
				builder: "-source-",
				
				
				/**
				 * Error reporting.
				 *
				 * How should DataTables report an error. Can take the value 'alert',
				 * 'throw', 'none' or a function.
				 *
				 *  @type string|function
				 *  @default alert
				 */
				errMode: "alert",
				
				
				/**
				 * Feature plug-ins.
				 *
				 * This is an array of objects which describe the feature plug-ins that are
				 * available to DataTables. These feature plug-ins are then available for
				 * use through the `dom` initialisation option.
				 *
				 * Each feature plug-in is described by an object which must have the
				 * following properties:
				 *
				 * * `fnInit` - function that is used to initialise the plug-in,
				 * * `cFeature` - a character so the feature can be enabled by the `dom`
				 *   instillation option. This is case sensitive.
				 *
				 * The `fnInit` function has the following input parameters:
				 *
				 * 1. `{object}` DataTables settings object: see
				 *    {@link DataTable.models.oSettings}
				 *
				 * And the following return is expected:
				 *
				 * * {node|null} The element which contains your feature. Note that the
				 *   return may also be void if your plug-in does not require to inject any
				 *   DOM elements into DataTables control (`dom`) - for example this might
				 *   be useful when developing a plug-in which allows table control via
				 *   keyboard entry
				 *
				 *  @type array
				 *
				 *  @example
				 *    $.fn.dataTable.ext.features.push( {
				 *      "fnInit": function( oSettings ) {
				 *        return new TableTools( { "oDTSettings": oSettings } );
				 *      },
				 *      "cFeature": "T"
				 *    } );
				 */
				feature: [],
				
				
				/**
				 * Row searching.
				 *
				 * This method of searching is complimentary to the default type based
				 * searching, and a lot more comprehensive as it allows you complete control
				 * over the searching logic. Each element in this array is a function
				 * (parameters described below) that is called for every row in the table,
				 * and your logic decides if it should be included in the searching data set
				 * or not.
				 *
				 * Searching functions have the following input parameters:
				 *
				 * 1. `{object}` DataTables settings object: see
				 *    {@link DataTable.models.oSettings}
				 * 2. `{array|object}` Data for the row to be processed (same as the
				 *    original format that was passed in as the data source, or an array
				 *    from a DOM data source
				 * 3. `{int}` Row index ({@link DataTable.models.oSettings.aoData}), which
				 *    can be useful to retrieve the `TR` element if you need DOM interaction.
				 *
				 * And the following return is expected:
				 *
				 * * {boolean} Include the row in the searched result set (true) or not
				 *   (false)
				 *
				 * Note that as with the main search ability in DataTables, technically this
				 * is "filtering", since it is subtractive. However, for consistency in
				 * naming we call it searching here.
				 *
				 *  @type array
				 *  @default []
				 *
				 *  @example
				 *    // The following example shows custom search being applied to the
				 *    // fourth column (i.e. the data[3] index) based on two input values
				 *    // from the end-user, matching the data in a certain range.
				 *    $.fn.dataTable.ext.search.push(
				 *      function( settings, data, dataIndex ) {
				 *        var min = document.getElementById('min').value * 1;
				 *        var max = document.getElementById('max').value * 1;
				 *        var version = data[3] == "-" ? 0 : data[3]*1;
				 *
				 *        if ( min == "" && max == "" ) {
				 *          return true;
				 *        }
				 *        else if ( min == "" && version < max ) {
				 *          return true;
				 *        }
				 *        else if ( min < version && "" == max ) {
				 *          return true;
				 *        }
				 *        else if ( min < version && version < max ) {
				 *          return true;
				 *        }
				 *        return false;
				 *      }
				 *    );
				 */
				search: [],
				
				
				/**
				 * Selector extensions
				 *
				 * The `selector` option can be used to extend the options available for the
				 * selector modifier options (`selector-modifier` object data type) that
				 * each of the three built in selector types offer (row, column and cell +
				 * their plural counterparts). For example the Select extension uses this
				 * mechanism to provide an option to select only rows, columns and cells
				 * that have been marked as selected by the end user (`{selected: true}`),
				 * which can be used in conjunction with the existing built in selector
				 * options.
				 *
				 * Each property is an array to which functions can be pushed. The functions
				 * take three attributes:
				 *
				 * * Settings object for the host table
				 * * Options object (`selector-modifier` object type)
				 * * Array of selected item indexes
				 *
				 * The return is an array of the resulting item indexes after the custom
				 * selector has been applied.
				 *
				 *  @type object
				 */
				selector: {
					cell: [],
					column: [],
					row: []
				},
				
				
				/**
				 * Internal functions, exposed for used in plug-ins.
				 *
				 * Please note that you should not need to use the internal methods for
				 * anything other than a plug-in (and even then, try to avoid if possible).
				 * The internal function may change between releases.
				 *
				 *  @type object
				 *  @default {}
				 */
				internal: {},
				
				
				/**
				 * Legacy configuration options. Enable and disable legacy options that
				 * are available in DataTables.
				 *
				 *  @type object
				 */
				legacy: {
					/**
					 * Enable / disable DataTables 1.9 compatible server-side processing
					 * requests
					 *
					 *  @type boolean
					 *  @default null
					 */
					ajax: null
				},
				
				
				/**
				 * Pagination plug-in methods.
				 *
				 * Each entry in this object is a function and defines which buttons should
				 * be shown by the pagination rendering method that is used for the table:
				 * {@link DataTable.ext.renderer.pageButton}. The renderer addresses how the
				 * buttons are displayed in the document, while the functions here tell it
				 * what buttons to display. This is done by returning an array of button
				 * descriptions (what each button will do).
				 *
				 * Pagination types (the four built in options and any additional plug-in
				 * options defined here) can be used through the `paginationType`
				 * initialisation parameter.
				 *
				 * The functions defined take two parameters:
				 *
				 * 1. `{int} page` The current page index
				 * 2. `{int} pages` The number of pages in the table
				 *
				 * Each function is expected to return an array where each element of the
				 * array can be one of:
				 *
				 * * `first` - Jump to first page when activated
				 * * `last` - Jump to last page when activated
				 * * `previous` - Show previous page when activated
				 * * `next` - Show next page when activated
				 * * `{int}` - Show page of the index given
				 * * `{array}` - A nested array containing the above elements to add a
				 *   containing 'DIV' element (might be useful for styling).
				 *
				 * Note that DataTables v1.9- used this object slightly differently whereby
				 * an object with two functions would be defined for each plug-in. That
				 * ability is still supported by DataTables 1.10+ to provide backwards
				 * compatibility, but this option of use is now decremented and no longer
				 * documented in DataTables 1.10+.
				 *
				 *  @type object
				 *  @default {}
				 *
				 *  @example
				 *    // Show previous, next and current page buttons only
				 *    $.fn.dataTableExt.oPagination.current = function ( page, pages ) {
				 *      return [ 'previous', page, 'next' ];
				 *    };
				 */
				pager: {},
				
				
				renderer: {
					pageButton: {},
					header: {}
				},
				
				
				/**
				 * Ordering plug-ins - custom data source
				 *
				 * The extension options for ordering of data available here is complimentary
				 * to the default type based ordering that DataTables typically uses. It
				 * allows much greater control over the the data that is being used to
				 * order a column, but is necessarily therefore more complex.
				 *
				 * This type of ordering is useful if you want to do ordering based on data
				 * live from the DOM (for example the contents of an 'input' element) rather
				 * than just the static string that DataTables knows of.
				 *
				 * The way these plug-ins work is that you create an array of the values you
				 * wish to be ordering for the column in question and then return that
				 * array. The data in the array much be in the index order of the rows in
				 * the table (not the currently ordering order!). Which order data gathering
				 * function is run here depends on the `dt-init columns.orderDataType`
				 * parameter that is used for the column (if any).
				 *
				 * The functions defined take two parameters:
				 *
				 * 1. `{object}` DataTables settings object: see
				 *    {@link DataTable.models.oSettings}
				 * 2. `{int}` Target column index
				 *
				 * Each function is expected to return an array:
				 *
				 * * `{array}` Data for the column to be ordering upon
				 *
				 *  @type array
				 *
				 *  @example
				 *    // Ordering using `input` node values
				 *    $.fn.dataTable.ext.order['dom-text'] = function  ( settings, col )
				 *    {
				 *      return this.api().column( col, {order:'index'} ).nodes().map( function ( td, i ) {
				 *        return $('input', td).val();
				 *      } );
				 *    }
				 */
				order: {},
				
				
				/**
				 * Type based plug-ins.
				 *
				 * Each column in DataTables has a type assigned to it, either by automatic
				 * detection or by direct assignment using the `type` option for the column.
				 * The type of a column will effect how it is ordering and search (plug-ins
				 * can also make use of the column type if required).
				 *
				 * @namespace
				 */
				type: {
					/**
					 * Type detection functions.
					 *
					 * The functions defined in this object are used to automatically detect
					 * a column's type, making initialisation of DataTables super easy, even
					 * when complex data is in the table.
					 *
					 * The functions defined take two parameters:
					 *
					 *  1. `{*}` Data from the column cell to be analysed
					 *  2. `{settings}` DataTables settings object. This can be used to
					 *     perform context specific type detection - for example detection
					 *     based on language settings such as using a comma for a decimal
					 *     place. Generally speaking the options from the settings will not
					 *     be required
					 *
					 * Each function is expected to return:
					 *
					 * * `{string|null}` Data type detected, or null if unknown (and thus
					 *   pass it on to the other type detection functions.
					 *
					 *  @type array
					 *
					 *  @example
					 *    // Currency type detection plug-in:
					 *    $.fn.dataTable.ext.type.detect.push(
					 *      function ( data, settings ) {
					 *        // Check the numeric part
					 *        if ( ! data.substring(1).match(/[0-9]/) ) {
					 *          return null;
					 *        }
					 *
					 *        // Check prefixed by currency
					 *        if ( data.charAt(0) == '$' || data.charAt(0) == '&pound;' ) {
					 *          return 'currency';
					 *        }
					 *        return null;
					 *      }
					 *    );
					 */
					detect: [],
					
					
					/**
					 * Type based search formatting.
					 *
					 * The type based searching functions can be used to pre-format the
					 * data to be search on. For example, it can be used to strip HTML
					 * tags or to de-format telephone numbers for numeric only searching.
					 *
					 * Note that is a search is not defined for a column of a given type,
					 * no search formatting will be performed.
					 *
					 * Pre-processing of searching data plug-ins - When you assign the sType
					 * for a column (or have it automatically detected for you by DataTables
					 * or a type detection plug-in), you will typically be using this for
					 * custom sorting, but it can also be used to provide custom searching
					 * by allowing you to pre-processing the data and returning the data in
					 * the format that should be searched upon. This is done by adding
					 * functions this object with a parameter name which matches the sType
					 * for that target column. This is the corollary of <i>afnSortData</i>
					 * for searching data.
					 *
					 * The functions defined take a single parameter:
					 *
					 *  1. `{*}` Data from the column cell to be prepared for searching
					 *
					 * Each function is expected to return:
					 *
					 * * `{string|null}` Formatted string that will be used for the searching.
					 *
					 *  @type object
					 *  @default {}
					 *
					 *  @example
					 *    $.fn.dataTable.ext.type.search['title-numeric'] = function ( d ) {
					 *      return d.replace(/\n/g," ").replace( /<.*?>/g, "" );
					 *    }
					 */
					search: {},
					
					
					/**
					 * Type based ordering.
					 *
					 * The column type tells DataTables what ordering to apply to the table
					 * when a column is sorted upon. The order for each type that is defined,
					 * is defined by the functions available in this object.
					 *
					 * Each ordering option can be described by three properties added to
					 * this object:
					 *
					 * * `{type}-pre` - Pre-formatting function
					 * * `{type}-asc` - Ascending order function
					 * * `{type}-desc` - Descending order function
					 *
					 * All three can be used together, only `{type}-pre` or only
					 * `{type}-asc` and `{type}-desc` together. It is generally recommended
					 * that only `{type}-pre` is used, as this provides the optimal
					 * implementation in terms of speed, although the others are provided
					 * for compatibility with existing Javascript sort functions.
					 *
					 * `{type}-pre`: Functions defined take a single parameter:
					 *
					 *  1. `{*}` Data from the column cell to be prepared for ordering
					 *
					 * And return:
					 *
					 * * `{*}` Data to be sorted upon
					 *
					 * `{type}-asc` and `{type}-desc`: Functions are typical Javascript sort
					 * functions, taking two parameters:
					 *
					 *  1. `{*}` Data to compare to the second parameter
					 *  2. `{*}` Data to compare to the first parameter
					 *
					 * And returning:
					 *
					 * * `{*}` Ordering match: <0 if first parameter should be sorted lower
					 *   than the second parameter, ===0 if the two parameters are equal and
					 *   >0 if the first parameter should be sorted height than the second
					 *   parameter.
					 *
					 *  @type object
					 *  @default {}
					 *
					 *  @example
					 *    // Numeric ordering of formatted numbers with a pre-formatter
					 *    $.extend( $.fn.dataTable.ext.type.order, {
					 *      "string-pre": function(x) {
					 *        a = (a === "-" || a === "") ? 0 : a.replace( /[^\d\-\.]/g, "" );
					 *        return parseFloat( a );
					 *      }
					 *    } );
					 *
					 *  @example
					 *    // Case-sensitive string ordering, with no pre-formatting method
					 *    $.extend( $.fn.dataTable.ext.order, {
					 *      "string-case-asc": function(x,y) {
					 *        return ((x < y) ? -1 : ((x > y) ? 1 : 0));
					 *      },
					 *      "string-case-desc": function(x,y) {
					 *        return ((x < y) ? 1 : ((x > y) ? -1 : 0));
					 *      }
					 *    } );
					 */
					order: {}
				},
				
				/**
				 * Unique DataTables instance counter
				 *
				 * @type int
				 * @private
				 */
				_unique: 0,
				
				
				//
				// Depreciated
				// The following properties are retained for backwards compatiblity only.
				// The should not be used in new projects and will be removed in a future
				// version
				//
				
				/**
				 * Version check function.
				 *  @type function
				 *  @depreciated Since 1.10
				 */
				fnVersionCheck: DataTable.fnVersionCheck,
				
				
				/**
				 * Index for what 'this' index API functions should use
				 *  @type int
				 *  @deprecated Since v1.10
				 */
				iApiIndex: 0,
				
				
				/**
				 * jQuery UI class container
				 *  @type object
				 *  @deprecated Since v1.10
				 */
				oJUIClasses: {},
				
				
				/**
				 * Software version
				 *  @type string
				 *  @deprecated Since v1.10
				 */
				sVersion: DataTable.version
			};
			
			
			//
			// Backwards compatibility. Alias to pre 1.10 Hungarian notation counter parts
			//
			$.extend(_ext, {
				afnFiltering: _ext.search,
				aTypes: _ext.type.detect,
				ofnSearch: _ext.type.search,
				oSort: _ext.type.order,
				afnSortData: _ext.order,
				aoFeatures: _ext.feature,
				oApi: _ext.internal,
				oStdClasses: _ext.classes,
				oPagination: _ext.pager
			});
			
			
			$.extend(DataTable.ext.classes, {
				"sTable": "dataTable",
				"sNoFooter": "no-footer",
				
				/* Paging buttons */
				"sPageButton": "paginate_button",
				"sPageButtonActive": "current",
				"sPageButtonDisabled": "disabled",
				
				/* Striping classes */
				"sStripeOdd": "odd",
				"sStripeEven": "even",
				
				/* Empty row */
				"sRowEmpty": "dataTables_empty",
				
				/* Features */
				"sWrapper": "dataTables_wrapper",
				"sFilter": "dataTables_filter",
				"sInfo": "dataTables_info",
				"sPaging": "dataTables_paginate paging_", /* Note that the type is postfixed */
				"sLength": "dataTables_length",
				"sProcessing": "dataTables_processing",
				
				/* Sorting */
				"sSortAsc": "sorting_asc",
				"sSortDesc": "sorting_desc",
				"sSortable": "sorting", /* Sortable in both directions */
				"sSortableAsc": "sorting_asc_disabled",
				"sSortableDesc": "sorting_desc_disabled",
				"sSortableNone": "sorting_disabled",
				"sSortColumn": "sorting_", /* Note that an int is postfixed for the sorting order */
				
				/* Filtering */
				"sFilterInput": "",
				
				/* Page length */
				"sLengthSelect": "",
				
				/* Scrolling */
				"sScrollWrapper": "dataTables_scroll",
				"sScrollHead": "dataTables_scrollHead",
				"sScrollHeadInner": "dataTables_scrollHeadInner",
				"sScrollBody": "dataTables_scrollBody",
				"sScrollFoot": "dataTables_scrollFoot",
				"sScrollFootInner": "dataTables_scrollFootInner",
				
				/* Misc */
				"sHeaderTH": "",
				"sFooterTH": "",
				
				// Deprecated
				"sSortJUIAsc": "",
				"sSortJUIDesc": "",
				"sSortJUI": "",
				"sSortJUIAscAllowed": "",
				"sSortJUIDescAllowed": "",
				"sSortJUIWrapper": "",
				"sSortIcon": "",
				"sJUIHeader": "",
				"sJUIFooter": ""
			});
			
			
			var extPagination = DataTable.ext.pager;
			
			function _numbers(page, pages) {
				var
					numbers = [],
					buttons = extPagination.numbers_length,
					half = Math.floor(buttons / 2),
					i = 1;
				
				if(pages <= buttons) {
					numbers = _range(0, pages);
				} else if(page <= half) {
					numbers = _range(0, buttons - 2);
					numbers.push('ellipsis');
					numbers.push(pages - 1);
				} else if(page >= pages - 1 - half) {
					numbers = _range(pages - (buttons - 2), pages);
					numbers.splice(0, 0, 'ellipsis'); // no unshift in ie6
					numbers.splice(0, 0, 0);
				} else {
					numbers = _range(page - half + 2, page + half - 1);
					numbers.push('ellipsis');
					numbers.push(pages - 1);
					numbers.splice(0, 0, 'ellipsis');
					numbers.splice(0, 0, 0);
				}
				
				numbers.DT_el = 'span';
				return numbers;
			}
			
			
			$.extend(extPagination, {
				simple: function(page, pages) {
					return ['previous', 'next'];
				},
				
				full: function(page, pages) {
					return ['first', 'previous', 'next', 'last'];
				},
				
				numbers: function(page, pages) {
					return [_numbers(page, pages)];
				},
				
				simple_numbers: function(page, pages) {
					return ['previous', _numbers(page, pages), 'next'];
				},
				
				full_numbers: function(page, pages) {
					return ['first', 'previous', _numbers(page, pages), 'next', 'last'];
				},
				
				first_last_numbers: function(page, pages) {
					return ['first', _numbers(page, pages), 'last'];
				},
				
				// For testing and plug-ins to use
				_numbers: _numbers,
				
				// Number of number buttons (including ellipsis) to show. _Must be odd!_
				numbers_length: 7
			});
			
			
			$.extend(true, DataTable.ext.renderer, {
				pageButton: {
					_: function(settings, host, idx, buttons, page, pages) {
						var classes = settings.oClasses;
						var lang = settings.oLanguage.oPaginate;
						var aria = settings.oLanguage.oAria.paginate || {};
						var btnDisplay, btnClass, counter = 0;
						
						var attach = function(container, buttons) {
							var i, ien, node, button;
							var clickHandler = function(e) {
								_fnPageChange(settings, e.data.action, true);
							};
							
							for(i = 0, ien = buttons.length; i < ien; i++) {
								button = buttons[i];
								
								if($.isArray(button)) {
									var inner = $('<' + (button.DT_el || 'div') + '/>')
										.appendTo(container);
									attach(inner, button);
								} else {
									btnDisplay = null;
									btnClass = '';
									
									switch(button) {
										case 'ellipsis':
											container.append('<span class="ellipsis">&#x2026;</span>');
											break;
										
										case 'first':
											btnDisplay = lang.sFirst;
											btnClass = button + (page > 0 ?
												'' : ' ' + classes.sPageButtonDisabled);
											break;
										
										case 'previous':
											btnDisplay = lang.sPrevious;
											btnClass = button + (page > 0 ?
												'' : ' ' + classes.sPageButtonDisabled);
											break;
										
										case 'next':
											btnDisplay = lang.sNext;
											btnClass = button + (page < pages - 1 ?
												'' : ' ' + classes.sPageButtonDisabled);
											break;
										
										case 'last':
											btnDisplay = lang.sLast;
											btnClass = button + (page < pages - 1 ?
												'' : ' ' + classes.sPageButtonDisabled);
											break;
										
										default:
											btnDisplay = button + 1;
											btnClass = page === button ?
												classes.sPageButtonActive : '';
											break;
									}
									
									if(btnDisplay !== null) {
										node = $('<a>', {
											'class': classes.sPageButton + ' ' + btnClass,
											'aria-controls': settings.sTableId,
											'aria-label': aria[button],
											'data-dt-idx': counter,
											'tabindex': settings.iTabIndex,
											'id': idx === 0 && typeof button === 'string' ?
												settings.sTableId + '_' + button :
												null
										})
											.html(btnDisplay)
											.appendTo(container);
										
										_fnBindAction(
											node, {action: button}, clickHandler
										);
										
										counter++;
									}
								}
							}
						};
						
						// IE9 throws an 'unknown error' if document.activeElement is used
						// inside an iframe or frame. Try / catch the error. Not good for
						// accessibility, but neither are frames.
						var activeEl;
						
						try {
							// Because this approach is destroying and recreating the paging
							// elements, focus is lost on the select button which is bad for
							// accessibility. So we want to restore focus once the draw has
							// completed
							activeEl = $(host).find(document.activeElement).data('dt-idx');
						} catch(e) {
						}
						
						attach($(host).empty(), buttons);
						
						if(activeEl !== undefined) {
							$(host).find('[data-dt-idx=' + activeEl + ']').focus();
						}
					}
				}
			});
			
			
			// Built in type detection. See model.ext.aTypes for information about
			// what is required from this methods.
			$.extend(DataTable.ext.type.detect, [
				// Plain numbers - first since V8 detects some plain numbers as dates
				// e.g. Date.parse('55') (but not all, e.g. Date.parse('22')...).
				function(d, settings) {
					var decimal = settings.oLanguage.sDecimal;
					return _isNumber(d, decimal) ? 'num' + decimal : null;
				},
				
				// Dates (only those recognised by the browser's Date.parse)
				function(d, settings) {
					// V8 tries _very_ hard to make a string passed into `Date.parse()`
					// valid, so we need to use a regex to restrict date formats. Use a
					// plug-in for anything other than ISO8601 style strings
					if(d && !(d instanceof Date) && !_re_date.test(d)) {
						return null;
					}
					var parsed = Date.parse(d);
					return (parsed !== null && !isNaN(parsed)) || _empty(d) ? 'date' : null;
				},
				
				// Formatted numbers
				function(d, settings) {
					var decimal = settings.oLanguage.sDecimal;
					return _isNumber(d, decimal, true) ? 'num-fmt' + decimal : null;
				},
				
				// HTML numeric
				function(d, settings) {
					var decimal = settings.oLanguage.sDecimal;
					return _htmlNumeric(d, decimal) ? 'html-num' + decimal : null;
				},
				
				// HTML numeric, formatted
				function(d, settings) {
					var decimal = settings.oLanguage.sDecimal;
					return _htmlNumeric(d, decimal, true) ? 'html-num-fmt' + decimal : null;
				},
				
				// HTML (this is strict checking - there must be html)
				function(d, settings) {
					return _empty(d) || (typeof d === 'string' && d.indexOf('<') !== -1) ?
						'html' : null;
				}
			]);
			
			
			// Filter formatting functions. See model.ext.ofnSearch for information about
			// what is required from these methods.
			//
			// Note that additional search methods are added for the html numbers and
			// html formatted numbers by `_addNumericSort()` when we know what the decimal
			// place is
			
			
			$.extend(DataTable.ext.type.search, {
				html: function(data) {
					return _empty(data) ?
						data :
						typeof data === 'string' ?
							data
								.replace(_re_new_lines, " ")
								.replace(_re_html, "") :
							'';
				},
				
				string: function(data) {
					return _empty(data) ?
						data :
						typeof data === 'string' ?
							data.replace(_re_new_lines, " ") :
							data;
				}
			});
			
			
			var __numericReplace = function(d, decimalPlace, re1, re2) {
				if(d !== 0 && (!d || d === '-')) {
					return -Infinity;
				}
				
				// If a decimal place other than `.` is used, it needs to be given to the
				// function so we can detect it and replace with a `.` which is the only
				// decimal place Javascript recognises - it is not locale aware.
				if(decimalPlace) {
					d = _numToDecimal(d, decimalPlace);
				}
				
				if(d.replace) {
					if(re1) {
						d = d.replace(re1, '');
					}
					
					if(re2) {
						d = d.replace(re2, '');
					}
				}
				
				return d * 1;
			};
			
			
			// Add the numeric 'deformatting' functions for sorting and search. This is done
			// in a function to provide an easy ability for the language options to add
			// additional methods if a non-period decimal place is used.
			function _addNumericSort(decimalPlace) {
				$.each(
					{
						// Plain numbers
						"num": function(d) {
							return __numericReplace(d, decimalPlace);
						},
						
						// Formatted numbers
						"num-fmt": function(d) {
							return __numericReplace(d, decimalPlace, _re_formatted_numeric);
						},
						
						// HTML numeric
						"html-num": function(d) {
							return __numericReplace(d, decimalPlace, _re_html);
						},
						
						// HTML numeric, formatted
						"html-num-fmt": function(d) {
							return __numericReplace(d, decimalPlace, _re_html, _re_formatted_numeric);
						}
					},
					function(key, fn) {
						// Add the ordering method
						_ext.type.order[key + decimalPlace + '-pre'] = fn;
						
						// For HTML types add a search formatter that will strip the HTML
						if(key.match(/^html\-/)) {
							_ext.type.search[key + decimalPlace] = _ext.type.search.html;
						}
					}
				);
			}
			
			
			// Default sort methods
			$.extend(_ext.type.order, {
				// Dates
				"date-pre": function(d) {
					var ts = Date.parse(d);
					return isNaN(ts) ? -Infinity : ts;
				},
				
				// html
				"html-pre": function(a) {
					return _empty(a) ?
						'' :
						a.replace ?
							a.replace(/<.*?>/g, "").toLowerCase() :
							a + '';
				},
				
				// string
				"string-pre": function(a) {
					// This is a little complex, but faster than always calling toString,
					// http://jsperf.com/tostring-v-check
					return _empty(a) ?
						'' :
						typeof a === 'string' ?
							a.toLowerCase() :
							!a.toString ?
								'' :
								a.toString();
				},
				
				// string-asc and -desc are retained only for compatibility with the old
				// sort methods
				"string-asc": function(x, y) {
					return ((x < y) ? -1 : ((x > y) ? 1 : 0));
				},
				
				"string-desc": function(x, y) {
					return ((x < y) ? 1 : ((x > y) ? -1 : 0));
				}
			});
			
			
			// Numeric sorting types - order doesn't matter here
			_addNumericSort('');
			
			
			$.extend(true, DataTable.ext.renderer, {
				header: {
					_: function(settings, cell, column, classes) {
						// No additional mark-up required
						// Attach a sort listener to update on sort - note that using the
						// `DT` namespace will allow the event to be removed automatically
						// on destroy, while the `dt` namespaced event is the one we are
						// listening for
						$(settings.nTable).on('order.dt.DT', function(e, ctx, sorting, columns) {
							if(settings !== ctx) { // need to check this this is the host
								return;               // table, not a nested one
							}
							
							var colIdx = column.idx;
							
							cell
								.removeClass(
									column.sSortingClass + ' ' +
									classes.sSortAsc + ' ' +
									classes.sSortDesc
								)
								.addClass(columns[colIdx] == 'asc' ?
									classes.sSortAsc : columns[colIdx] == 'desc' ?
										classes.sSortDesc :
										column.sSortingClass
								);
						});
					},
					
					jqueryui: function(settings, cell, column, classes) {
						$('<div/>')
							.addClass(classes.sSortJUIWrapper)
							.append(cell.contents())
							.append($('<span/>')
								.addClass(classes.sSortIcon + ' ' + column.sSortingClassJUI)
							)
							.appendTo(cell);
						
						// Attach a sort listener to update on sort
						$(settings.nTable).on('order.dt.DT', function(e, ctx, sorting, columns) {
							if(settings !== ctx) {
								return;
							}
							
							var colIdx = column.idx;
							
							cell
								.removeClass(classes.sSortAsc + " " + classes.sSortDesc)
								.addClass(columns[colIdx] == 'asc' ?
									classes.sSortAsc : columns[colIdx] == 'desc' ?
										classes.sSortDesc :
										column.sSortingClass
								);
							
							cell
								.find('span.' + classes.sSortIcon)
								.removeClass(
									classes.sSortJUIAsc + " " +
									classes.sSortJUIDesc + " " +
									classes.sSortJUI + " " +
									classes.sSortJUIAscAllowed + " " +
									classes.sSortJUIDescAllowed
								)
								.addClass(columns[colIdx] == 'asc' ?
									classes.sSortJUIAsc : columns[colIdx] == 'desc' ?
										classes.sSortJUIDesc :
										column.sSortingClassJUI
								);
						});
					}
				}
			});
			
			/*
	 * Public helper functions. These aren't used internally by DataTables, or
	 * called by any of the options passed into DataTables, but they can be used
	 * externally by developers working with DataTables. They are helper functions
	 * to make working with DataTables a little bit easier.
	 */
			
			var __htmlEscapeEntities = function(d) {
				return typeof d === 'string' ?
					d.replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;') :
					d;
			};
			
			/**
			 * Helpers for `columns.render`.
			 *
			 * The options defined here can be used with the `columns.render` initialisation
			 * option to provide a display renderer. The following functions are defined:
			 *
			 * * `number` - Will format numeric data (defined by `columns.data`) for
			 *   display, retaining the original unformatted data for sorting and filtering.
			 *   It takes 5 parameters:
			 *   * `string` - Thousands grouping separator
			 *   * `string` - Decimal point indicator
			 *   * `integer` - Number of decimal points to show
			 *   * `string` (optional) - Prefix.
			 *   * `string` (optional) - Postfix (/suffix).
			 * * `text` - Escape HTML to help prevent XSS attacks. It has no optional
			 *   parameters.
			 *
			 * @example
			 *   // Column definition using the number renderer
			 *   {
			 *     data: "salary",
			 *     render: $.fn.dataTable.render.number( '\'', '.', 0, '$' )
			 *   }
			 *
			 * @namespace
			 */
			DataTable.render = {
				number: function(thousands, decimal, precision, prefix, postfix) {
					return {
						display: function(d) {
							if(typeof d !== 'number' && typeof d !== 'string') {
								return d;
							}
							
							var negative = d < 0 ? '-' : '';
							var flo = parseFloat(d);
							
							// If NaN then there isn't much formatting that we can do - just
							// return immediately, escaping any HTML (this was supposed to
							// be a number after all)
							if(isNaN(flo)) {
								return __htmlEscapeEntities(d);
							}
							
							flo = flo.toFixed(precision);
							d = Math.abs(flo);
							
							var intPart = parseInt(d, 10);
							var floatPart = precision ?
								decimal + (d - intPart).toFixed(precision).substring(2) :
								'';
							
							return negative + (prefix || '') +
								intPart.toString().replace(
									/\B(?=(\d{3})+(?!\d))/g, thousands
								) +
								floatPart +
								(postfix || '');
						}
					};
				},
				
				text: function() {
					return {
						display: __htmlEscapeEntities,
						filter: __htmlEscapeEntities
					};
				}
			};
			
			
			/*
	 * This is really a good bit rubbish this method of exposing the internal methods
	 * publicly... - To be fixed in 2.0 using methods on the prototype
	 */
			
			
			/**
			 * Create a wrapper function for exporting an internal functions to an external API.
			 *  @param {string} fn API function name
			 *  @returns {function} wrapped function
			 *  @memberof DataTable#internal
			 */
			function _fnExternApiFunc(fn) {
				return function() {
					var args = [_fnSettingsFromNode(this[DataTable.ext.iApiIndex])].concat(
						Array.prototype.slice.call(arguments)
					);
					return DataTable.ext.internal[fn].apply(this, args);
				};
			}
			
			
			/**
			 * Reference to internal functions for use by plug-in developers. Note that
			 * these methods are references to internal functions and are considered to be
			 * private. If you use these methods, be aware that they are liable to change
			 * between versions.
			 *  @namespace
			 */
			$.extend(DataTable.ext.internal, {
				_fnExternApiFunc: _fnExternApiFunc,
				_fnBuildAjax: _fnBuildAjax,
				_fnAjaxUpdate: _fnAjaxUpdate,
				_fnAjaxParameters: _fnAjaxParameters,
				_fnAjaxUpdateDraw: _fnAjaxUpdateDraw,
				_fnAjaxDataSrc: _fnAjaxDataSrc,
				_fnAddColumn: _fnAddColumn,
				_fnColumnOptions: _fnColumnOptions,
				_fnAdjustColumnSizing: _fnAdjustColumnSizing,
				_fnVisibleToColumnIndex: _fnVisibleToColumnIndex,
				_fnColumnIndexToVisible: _fnColumnIndexToVisible,
				_fnVisbleColumns: _fnVisbleColumns,
				_fnGetColumns: _fnGetColumns,
				_fnColumnTypes: _fnColumnTypes,
				_fnApplyColumnDefs: _fnApplyColumnDefs,
				_fnHungarianMap: _fnHungarianMap,
				_fnCamelToHungarian: _fnCamelToHungarian,
				_fnLanguageCompat: _fnLanguageCompat,
				_fnBrowserDetect: _fnBrowserDetect,
				_fnAddData: _fnAddData,
				_fnAddTr: _fnAddTr,
				_fnNodeToDataIndex: _fnNodeToDataIndex,
				_fnNodeToColumnIndex: _fnNodeToColumnIndex,
				_fnGetCellData: _fnGetCellData,
				_fnSetCellData: _fnSetCellData,
				_fnSplitObjNotation: _fnSplitObjNotation,
				_fnGetObjectDataFn: _fnGetObjectDataFn,
				_fnSetObjectDataFn: _fnSetObjectDataFn,
				_fnGetDataMaster: _fnGetDataMaster,
				_fnClearTable: _fnClearTable,
				_fnDeleteIndex: _fnDeleteIndex,
				_fnInvalidate: _fnInvalidate,
				_fnGetRowElements: _fnGetRowElements,
				_fnCreateTr: _fnCreateTr,
				_fnBuildHead: _fnBuildHead,
				_fnDrawHead: _fnDrawHead,
				_fnDraw: _fnDraw,
				_fnReDraw: _fnReDraw,
				_fnAddOptionsHtml: _fnAddOptionsHtml,
				_fnDetectHeader: _fnDetectHeader,
				_fnGetUniqueThs: _fnGetUniqueThs,
				_fnFeatureHtmlFilter: _fnFeatureHtmlFilter,
				_fnFilterComplete: _fnFilterComplete,
				_fnFilterCustom: _fnFilterCustom,
				_fnFilterColumn: _fnFilterColumn,
				_fnFilter: _fnFilter,
				_fnFilterCreateSearch: _fnFilterCreateSearch,
				_fnEscapeRegex: _fnEscapeRegex,
				_fnFilterData: _fnFilterData,
				_fnFeatureHtmlInfo: _fnFeatureHtmlInfo,
				_fnUpdateInfo: _fnUpdateInfo,
				_fnInfoMacros: _fnInfoMacros,
				_fnInitialise: _fnInitialise,
				_fnInitComplete: _fnInitComplete,
				_fnLengthChange: _fnLengthChange,
				_fnFeatureHtmlLength: _fnFeatureHtmlLength,
				_fnFeatureHtmlPaginate: _fnFeatureHtmlPaginate,
				_fnPageChange: _fnPageChange,
				_fnFeatureHtmlProcessing: _fnFeatureHtmlProcessing,
				_fnProcessingDisplay: _fnProcessingDisplay,
				_fnFeatureHtmlTable: _fnFeatureHtmlTable,
				_fnScrollDraw: _fnScrollDraw,
				_fnApplyToChildren: _fnApplyToChildren,
				_fnCalculateColumnWidths: _fnCalculateColumnWidths,
				_fnThrottle: _fnThrottle,
				_fnConvertToWidth: _fnConvertToWidth,
				_fnGetWidestNode: _fnGetWidestNode,
				_fnGetMaxLenString: _fnGetMaxLenString,
				_fnStringToCss: _fnStringToCss,
				_fnSortFlatten: _fnSortFlatten,
				_fnSort: _fnSort,
				_fnSortAria: _fnSortAria,
				_fnSortListener: _fnSortListener,
				_fnSortAttachListener: _fnSortAttachListener,
				_fnSortingClasses: _fnSortingClasses,
				_fnSortData: _fnSortData,
				_fnSaveState: _fnSaveState,
				_fnLoadState: _fnLoadState,
				_fnSettingsFromNode: _fnSettingsFromNode,
				_fnLog: _fnLog,
				_fnMap: _fnMap,
				_fnBindAction: _fnBindAction,
				_fnCallbackReg: _fnCallbackReg,
				_fnCallbackFire: _fnCallbackFire,
				_fnLengthOverflow: _fnLengthOverflow,
				_fnRenderer: _fnRenderer,
				_fnDataSource: _fnDataSource,
				_fnRowAttributes: _fnRowAttributes,
				_fnExtend: _fnExtend,
				_fnCalculateEnd: function() {
				} // Used by a lot of plug-ins, but redundant
			      // in 1.10, so this dead-end function is
			      // added to prevent errors
			});
			
			
			// jQuery access
			$.fn.dataTable = DataTable;
			
			// Provide access to the host jQuery object (circular reference)
			DataTable.$ = $;
			
			// Legacy aliases
			$.fn.dataTableSettings = DataTable.settings;
			$.fn.dataTableExt = DataTable.ext;
			
			// With a capital `D` we return a DataTables API instance rather than a
			// jQuery object
			$.fn.DataTable = function(opts) {
				return $(this).dataTable(opts).api();
			};
			
			// All properties that are available to $.fn.dataTable should also be
			// available on $.fn.DataTable
			$.each(DataTable, function(prop, val) {
				$.fn.DataTable[prop] = val;
			});
			
			
			// Information about events fired by DataTables - for documentation.
			/**
			 * Draw event, fired whenever the table is redrawn on the page, at the same
			 * point as fnDrawCallback. This may be useful for binding events or
			 * performing calculations when the table is altered at all.
			 *  @name DataTable#draw.dt
			 *  @event
			 *  @param {event} e jQuery event object
			 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
			 */
			
			/**
			 * Search event, fired when the searching applied to the table (using the
			 * built-in global search, or column filters) is altered.
			 *  @name DataTable#search.dt
			 *  @event
			 *  @param {event} e jQuery event object
			 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
			 */
			
			/**
			 * Page change event, fired when the paging of the table is altered.
			 *  @name DataTable#page.dt
			 *  @event
			 *  @param {event} e jQuery event object
			 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
			 */
			
			/**
			 * Order event, fired when the ordering applied to the table is altered.
			 *  @name DataTable#order.dt
			 *  @event
			 *  @param {event} e jQuery event object
			 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
			 */
			
			/**
			 * DataTables initialisation complete event, fired when the table is fully
			 * drawn, including Ajax data loaded, if Ajax data is required.
			 *  @name DataTable#init.dt
			 *  @event
			 *  @param {event} e jQuery event object
			 *  @param {object} oSettings DataTables settings object
			 *  @param {object} json The JSON object request from the server - only
			 *    present if client-side Ajax sourced data is used</li></ol>
			 */
			
			/**
			 * State save event, fired when the table has changed state a new state save
			 * is required. This event allows modification of the state saving object
			 * prior to actually doing the save, including addition or other state
			 * properties (for plug-ins) or modification of a DataTables core property.
			 *  @name DataTable#stateSaveParams.dt
			 *  @event
			 *  @param {event} e jQuery event object
			 *  @param {object} oSettings DataTables settings object
			 *  @param {object} json The state information to be saved
			 */
			
			/**
			 * State load event, fired when the table is loading state from the stored
			 * data, but prior to the settings object being modified by the saved state
			 * - allowing modification of the saved state is required or loading of
			 * state for a plug-in.
			 *  @name DataTable#stateLoadParams.dt
			 *  @event
			 *  @param {event} e jQuery event object
			 *  @param {object} oSettings DataTables settings object
			 *  @param {object} json The saved state information
			 */
			
			/**
			 * State loaded event, fired when state has been loaded from stored data and
			 * the settings object has been modified by the loaded data.
			 *  @name DataTable#stateLoaded.dt
			 *  @event
			 *  @param {event} e jQuery event object
			 *  @param {object} oSettings DataTables settings object
			 *  @param {object} json The saved state information
			 */
			
			/**
			 * Processing event, fired when DataTables is doing some kind of processing
			 * (be it, order, searcg or anything else). It can be used to indicate to
			 * the end user that there is something happening, or that something has
			 * finished.
			 *  @name DataTable#processing.dt
			 *  @event
			 *  @param {event} e jQuery event object
			 *  @param {object} oSettings DataTables settings object
			 *  @param {boolean} bShow Flag for if DataTables is doing processing or not
			 */
			
			/**
			 * Ajax (XHR) event, fired whenever an Ajax request is completed from a
			 * request to made to the server for new data. This event is called before
			 * DataTables processed the returned data, so it can also be used to pre-
			 * process the data returned from the server, if needed.
			 *
			 * Note that this trigger is called in `fnServerData`, if you override
			 * `fnServerData` and which to use this event, you need to trigger it in you
			 * success function.
			 *  @name DataTable#xhr.dt
			 *  @event
			 *  @param {event} e jQuery event object
			 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
			 *  @param {object} json JSON returned from the server
			 *
			 *  @example
			 *     // Use a custom property returned from the server in another DOM element
			 *     $('#table').dataTable().on('xhr.dt', function (e, settings, json) {
			 *       $('#status').html( json.status );
			 *     } );
			 *
			 *  @example
			 *     // Pre-process the data returned from the server
			 *     $('#table').dataTable().on('xhr.dt', function (e, settings, json) {
			 *       for ( var i=0, ien=json.aaData.length ; i<ien ; i++ ) {
			 *         json.aaData[i].sum = json.aaData[i].one + json.aaData[i].two;
			 *       }
			 *       // Note no return - manipulate the data directly in the JSON object.
			 *     } );
			 */
			
			/**
			 * Destroy event, fired when the DataTable is destroyed by calling fnDestroy
			 * or passing the bDestroy:true parameter in the initialisation object. This
			 * can be used to remove bound events, added DOM nodes, etc.
			 *  @name DataTable#destroy.dt
			 *  @event
			 *  @param {event} e jQuery event object
			 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
			 */
			
			/**
			 * Page length change event, fired when number of records to show on each
			 * page (the length) is changed.
			 *  @name DataTable#length.dt
			 *  @event
			 *  @param {event} e jQuery event object
			 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
			 *  @param {integer} len New length
			 */
			
			/**
			 * Column sizing has changed.
			 *  @name DataTable#column-sizing.dt
			 *  @event
			 *  @param {event} e jQuery event object
			 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
			 */
			
			/**
			 * Column visibility has changed.
			 *  @name DataTable#column-visibility.dt
			 *  @event
			 *  @param {event} e jQuery event object
			 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
			 *  @param {int} column Column index
			 *  @param {bool} vis `false` if column now hidden, or `true` if visible
			 */
			
			return $.fn.dataTable;
		}));
		
		
		/***/
	}),
	
	/***/ "./node_modules/handlebars/dist/cjs/handlebars.runtime.js":
	/*!****************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars.runtime.js ***!
  \****************************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		exports.__esModule = true;
// istanbul ignore next
		
		function _interopRequireDefault(obj) {
			return obj && obj.__esModule ? obj : {'default': obj};
		}

// istanbul ignore next
		
		function _interopRequireWildcard(obj) {
			if(obj && obj.__esModule) {
				return obj;
			} else {
				var newObj = {};
				if(obj != null) {
					for(var key in obj) {
						if(Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
					}
				}
				newObj['default'] = obj;
				return newObj;
			}
		}
		
		var _handlebarsBase = __webpack_require__(/*! ./handlebars/base */ "./node_modules/handlebars/dist/cjs/handlebars/base.js");
		
		var base = _interopRequireWildcard(_handlebarsBase);

// Each of these augment the Handlebars object. No need to setup here.
// (This is done to easily share code between commonjs and browse envs)
		
		var _handlebarsSafeString = __webpack_require__(/*! ./handlebars/safe-string */ "./node_modules/handlebars/dist/cjs/handlebars/safe-string.js");
		
		var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);
		
		var _handlebarsException = __webpack_require__(/*! ./handlebars/exception */ "./node_modules/handlebars/dist/cjs/handlebars/exception.js");
		
		var _handlebarsException2 = _interopRequireDefault(_handlebarsException);
		
		var _handlebarsUtils = __webpack_require__(/*! ./handlebars/utils */ "./node_modules/handlebars/dist/cjs/handlebars/utils.js");
		
		var Utils = _interopRequireWildcard(_handlebarsUtils);
		
		var _handlebarsRuntime = __webpack_require__(/*! ./handlebars/runtime */ "./node_modules/handlebars/dist/cjs/handlebars/runtime.js");
		
		var runtime = _interopRequireWildcard(_handlebarsRuntime);
		
		var _handlebarsNoConflict = __webpack_require__(/*! ./handlebars/no-conflict */ "./node_modules/handlebars/dist/cjs/handlebars/no-conflict.js");
		
		var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);

// For compatibility and usage outside of module systems, make the Handlebars object a namespace
		function create() {
			var hb = new base.HandlebarsEnvironment();
			
			Utils.extend(hb, base);
			hb.SafeString = _handlebarsSafeString2['default'];
			hb.Exception = _handlebarsException2['default'];
			hb.Utils = Utils;
			hb.escapeExpression = Utils.escapeExpression;
			
			hb.VM = runtime;
			hb.template = function(spec) {
				return runtime.template(spec, hb);
			};
			
			return hb;
		}
		
		var inst = create();
		inst.create = create;
		
		_handlebarsNoConflict2['default'](inst);
		
		inst['default'] = inst;
		
		exports['default'] = inst;
		module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL2xpYi9oYW5kbGViYXJzLnJ1bnRpbWUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OEJBQXNCLG1CQUFtQjs7SUFBN0IsSUFBSTs7Ozs7b0NBSU8sMEJBQTBCOzs7O21DQUMzQix3QkFBd0I7Ozs7K0JBQ3ZCLG9CQUFvQjs7SUFBL0IsS0FBSzs7aUNBQ1Esc0JBQXNCOztJQUFuQyxPQUFPOztvQ0FFSSwwQkFBMEI7Ozs7O0FBR2pELFNBQVMsTUFBTSxHQUFHO0FBQ2hCLE1BQUksRUFBRSxHQUFHLElBQUksSUFBSSxDQUFDLHFCQUFxQixFQUFFLENBQUM7O0FBRTFDLE9BQUssQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ3ZCLElBQUUsQ0FBQyxVQUFVLG9DQUFhLENBQUM7QUFDM0IsSUFBRSxDQUFDLFNBQVMsbUNBQVksQ0FBQztBQUN6QixJQUFFLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztBQUNqQixJQUFFLENBQUMsZ0JBQWdCLEdBQUcsS0FBSyxDQUFDLGdCQUFnQixDQUFDOztBQUU3QyxJQUFFLENBQUMsRUFBRSxHQUFHLE9BQU8sQ0FBQztBQUNoQixJQUFFLENBQUMsUUFBUSxHQUFHLFVBQVMsSUFBSSxFQUFFO0FBQzNCLFdBQU8sT0FBTyxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUM7R0FDbkMsQ0FBQzs7QUFFRixTQUFPLEVBQUUsQ0FBQztDQUNYOztBQUVELElBQUksSUFBSSxHQUFHLE1BQU0sRUFBRSxDQUFDO0FBQ3BCLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDOztBQUVyQixrQ0FBVyxJQUFJLENBQUMsQ0FBQzs7QUFFakIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLElBQUksQ0FBQzs7cUJBRVIsSUFBSSIsImZpbGUiOiJoYW5kbGViYXJzLnJ1bnRpbWUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBiYXNlIGZyb20gJy4vaGFuZGxlYmFycy9iYXNlJztcblxuLy8gRWFjaCBvZiB0aGVzZSBhdWdtZW50IHRoZSBIYW5kbGViYXJzIG9iamVjdC4gTm8gbmVlZCB0byBzZXR1cCBoZXJlLlxuLy8gKFRoaXMgaXMgZG9uZSB0byBlYXNpbHkgc2hhcmUgY29kZSBiZXR3ZWVuIGNvbW1vbmpzIGFuZCBicm93c2UgZW52cylcbmltcG9ydCBTYWZlU3RyaW5nIGZyb20gJy4vaGFuZGxlYmFycy9zYWZlLXN0cmluZyc7XG5pbXBvcnQgRXhjZXB0aW9uIGZyb20gJy4vaGFuZGxlYmFycy9leGNlcHRpb24nO1xuaW1wb3J0ICogYXMgVXRpbHMgZnJvbSAnLi9oYW5kbGViYXJzL3V0aWxzJztcbmltcG9ydCAqIGFzIHJ1bnRpbWUgZnJvbSAnLi9oYW5kbGViYXJzL3J1bnRpbWUnO1xuXG5pbXBvcnQgbm9Db25mbGljdCBmcm9tICcuL2hhbmRsZWJhcnMvbm8tY29uZmxpY3QnO1xuXG4vLyBGb3IgY29tcGF0aWJpbGl0eSBhbmQgdXNhZ2Ugb3V0c2lkZSBvZiBtb2R1bGUgc3lzdGVtcywgbWFrZSB0aGUgSGFuZGxlYmFycyBvYmplY3QgYSBuYW1lc3BhY2VcbmZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgbGV0IGhiID0gbmV3IGJhc2UuSGFuZGxlYmFyc0Vudmlyb25tZW50KCk7XG5cbiAgVXRpbHMuZXh0ZW5kKGhiLCBiYXNlKTtcbiAgaGIuU2FmZVN0cmluZyA9IFNhZmVTdHJpbmc7XG4gIGhiLkV4Y2VwdGlvbiA9IEV4Y2VwdGlvbjtcbiAgaGIuVXRpbHMgPSBVdGlscztcbiAgaGIuZXNjYXBlRXhwcmVzc2lvbiA9IFV0aWxzLmVzY2FwZUV4cHJlc3Npb247XG5cbiAgaGIuVk0gPSBydW50aW1lO1xuICBoYi50ZW1wbGF0ZSA9IGZ1bmN0aW9uKHNwZWMpIHtcbiAgICByZXR1cm4gcnVudGltZS50ZW1wbGF0ZShzcGVjLCBoYik7XG4gIH07XG5cbiAgcmV0dXJuIGhiO1xufVxuXG5sZXQgaW5zdCA9IGNyZWF0ZSgpO1xuaW5zdC5jcmVhdGUgPSBjcmVhdGU7XG5cbm5vQ29uZmxpY3QoaW5zdCk7XG5cbmluc3RbJ2RlZmF1bHQnXSA9IGluc3Q7XG5cbmV4cG9ydCBkZWZhdWx0IGluc3Q7XG4iXX0=
		
		
		/***/
	}),
	
	/***/ "./node_modules/handlebars/dist/cjs/handlebars/base.js":
	/*!*************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/base.js ***!
  \*************************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		exports.__esModule = true;
		exports.HandlebarsEnvironment = HandlebarsEnvironment;
// istanbul ignore next
		
		function _interopRequireDefault(obj) {
			return obj && obj.__esModule ? obj : {'default': obj};
		}
		
		var _utils = __webpack_require__(/*! ./utils */ "./node_modules/handlebars/dist/cjs/handlebars/utils.js");
		
		var _exception = __webpack_require__(/*! ./exception */ "./node_modules/handlebars/dist/cjs/handlebars/exception.js");
		
		var _exception2 = _interopRequireDefault(_exception);
		
		var _helpers = __webpack_require__(/*! ./helpers */ "./node_modules/handlebars/dist/cjs/handlebars/helpers.js");
		
		var _decorators = __webpack_require__(/*! ./decorators */ "./node_modules/handlebars/dist/cjs/handlebars/decorators.js");
		
		var _logger = __webpack_require__(/*! ./logger */ "./node_modules/handlebars/dist/cjs/handlebars/logger.js");
		
		var _logger2 = _interopRequireDefault(_logger);
		
		var VERSION = '4.1.0';
		exports.VERSION = VERSION;
		var COMPILER_REVISION = 7;
		
		exports.COMPILER_REVISION = COMPILER_REVISION;
		var REVISION_CHANGES = {
			1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
			2: '== 1.0.0-rc.3',
			3: '== 1.0.0-rc.4',
			4: '== 1.x.x',
			5: '== 2.0.0-alpha.x',
			6: '>= 2.0.0-beta.1',
			7: '>= 4.0.0'
		};
		
		exports.REVISION_CHANGES = REVISION_CHANGES;
		var objectType = '[object Object]';
		
		function HandlebarsEnvironment(helpers, partials, decorators) {
			this.helpers = helpers || {};
			this.partials = partials || {};
			this.decorators = decorators || {};
			
			_helpers.registerDefaultHelpers(this);
			_decorators.registerDefaultDecorators(this);
		}
		
		HandlebarsEnvironment.prototype = {
			constructor: HandlebarsEnvironment,
			
			logger: _logger2['default'],
			log: _logger2['default'].log,
			
			registerHelper: function registerHelper(name, fn) {
				if(_utils.toString.call(name) === objectType) {
					if(fn) {
						throw new _exception2['default']('Arg not supported with multiple helpers');
					}
					_utils.extend(this.helpers, name);
				} else {
					this.helpers[name] = fn;
				}
			},
			unregisterHelper: function unregisterHelper(name) {
				delete this.helpers[name];
			},
			
			registerPartial: function registerPartial(name, partial) {
				if(_utils.toString.call(name) === objectType) {
					_utils.extend(this.partials, name);
				} else {
					if(typeof partial === 'undefined') {
						throw new _exception2['default']('Attempting to register a partial called "' + name + '" as undefined');
					}
					this.partials[name] = partial;
				}
			},
			unregisterPartial: function unregisterPartial(name) {
				delete this.partials[name];
			},
			
			registerDecorator: function registerDecorator(name, fn) {
				if(_utils.toString.call(name) === objectType) {
					if(fn) {
						throw new _exception2['default']('Arg not supported with multiple decorators');
					}
					_utils.extend(this.decorators, name);
				} else {
					this.decorators[name] = fn;
				}
			},
			unregisterDecorator: function unregisterDecorator(name) {
				delete this.decorators[name];
			}
		};
		
		var log = _logger2['default'].log;
		
		exports.log = log;
		exports.createFrame = _utils.createFrame;
		exports.logger = _logger2['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL2Jhc2UuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7cUJBQTRDLFNBQVM7O3lCQUMvQixhQUFhOzs7O3VCQUNFLFdBQVc7OzBCQUNSLGNBQWM7O3NCQUNuQyxVQUFVOzs7O0FBRXRCLElBQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQzs7QUFDeEIsSUFBTSxpQkFBaUIsR0FBRyxDQUFDLENBQUM7OztBQUU1QixJQUFNLGdCQUFnQixHQUFHO0FBQzlCLEdBQUMsRUFBRSxhQUFhO0FBQ2hCLEdBQUMsRUFBRSxlQUFlO0FBQ2xCLEdBQUMsRUFBRSxlQUFlO0FBQ2xCLEdBQUMsRUFBRSxVQUFVO0FBQ2IsR0FBQyxFQUFFLGtCQUFrQjtBQUNyQixHQUFDLEVBQUUsaUJBQWlCO0FBQ3BCLEdBQUMsRUFBRSxVQUFVO0NBQ2QsQ0FBQzs7O0FBRUYsSUFBTSxVQUFVLEdBQUcsaUJBQWlCLENBQUM7O0FBRTlCLFNBQVMscUJBQXFCLENBQUMsT0FBTyxFQUFFLFFBQVEsRUFBRSxVQUFVLEVBQUU7QUFDbkUsTUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPLElBQUksRUFBRSxDQUFDO0FBQzdCLE1BQUksQ0FBQyxRQUFRLEdBQUcsUUFBUSxJQUFJLEVBQUUsQ0FBQztBQUMvQixNQUFJLENBQUMsVUFBVSxHQUFHLFVBQVUsSUFBSSxFQUFFLENBQUM7O0FBRW5DLGtDQUF1QixJQUFJLENBQUMsQ0FBQztBQUM3Qix3Q0FBMEIsSUFBSSxDQUFDLENBQUM7Q0FDakM7O0FBRUQscUJBQXFCLENBQUMsU0FBUyxHQUFHO0FBQ2hDLGFBQVcsRUFBRSxxQkFBcUI7O0FBRWxDLFFBQU0scUJBQVE7QUFDZCxLQUFHLEVBQUUsb0JBQU8sR0FBRzs7QUFFZixnQkFBYyxFQUFFLHdCQUFTLElBQUksRUFBRSxFQUFFLEVBQUU7QUFDakMsUUFBSSxnQkFBUyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssVUFBVSxFQUFFO0FBQ3RDLFVBQUksRUFBRSxFQUFFO0FBQUUsY0FBTSwyQkFBYyx5Q0FBeUMsQ0FBQyxDQUFDO09BQUU7QUFDM0Usb0JBQU8sSUFBSSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQztLQUM1QixNQUFNO0FBQ0wsVUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7S0FDekI7R0FDRjtBQUNELGtCQUFnQixFQUFFLDBCQUFTLElBQUksRUFBRTtBQUMvQixXQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7R0FDM0I7O0FBRUQsaUJBQWUsRUFBRSx5QkFBUyxJQUFJLEVBQUUsT0FBTyxFQUFFO0FBQ3ZDLFFBQUksZ0JBQVMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLFVBQVUsRUFBRTtBQUN0QyxvQkFBTyxJQUFJLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxDQUFDO0tBQzdCLE1BQU07QUFDTCxVQUFJLE9BQU8sT0FBTyxLQUFLLFdBQVcsRUFBRTtBQUNsQyxjQUFNLHlFQUEwRCxJQUFJLG9CQUFpQixDQUFDO09BQ3ZGO0FBQ0QsVUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsR0FBRyxPQUFPLENBQUM7S0FDL0I7R0FDRjtBQUNELG1CQUFpQixFQUFFLDJCQUFTLElBQUksRUFBRTtBQUNoQyxXQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7R0FDNUI7O0FBRUQsbUJBQWlCLEVBQUUsMkJBQVMsSUFBSSxFQUFFLEVBQUUsRUFBRTtBQUNwQyxRQUFJLGdCQUFTLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxVQUFVLEVBQUU7QUFDdEMsVUFBSSxFQUFFLEVBQUU7QUFBRSxjQUFNLDJCQUFjLDRDQUE0QyxDQUFDLENBQUM7T0FBRTtBQUM5RSxvQkFBTyxJQUFJLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxDQUFDO0tBQy9CLE1BQU07QUFDTCxVQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztLQUM1QjtHQUNGO0FBQ0QscUJBQW1CLEVBQUUsNkJBQVMsSUFBSSxFQUFFO0FBQ2xDLFdBQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztHQUM5QjtDQUNGLENBQUM7O0FBRUssSUFBSSxHQUFHLEdBQUcsb0JBQU8sR0FBRyxDQUFDOzs7UUFFcEIsV0FBVztRQUFFLE1BQU0iLCJmaWxlIjoiYmFzZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Y3JlYXRlRnJhbWUsIGV4dGVuZCwgdG9TdHJpbmd9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IEV4Y2VwdGlvbiBmcm9tICcuL2V4Y2VwdGlvbic7XG5pbXBvcnQge3JlZ2lzdGVyRGVmYXVsdEhlbHBlcnN9IGZyb20gJy4vaGVscGVycyc7XG5pbXBvcnQge3JlZ2lzdGVyRGVmYXVsdERlY29yYXRvcnN9IGZyb20gJy4vZGVjb3JhdG9ycyc7XG5pbXBvcnQgbG9nZ2VyIGZyb20gJy4vbG9nZ2VyJztcblxuZXhwb3J0IGNvbnN0IFZFUlNJT04gPSAnNC4xLjAnO1xuZXhwb3J0IGNvbnN0IENPTVBJTEVSX1JFVklTSU9OID0gNztcblxuZXhwb3J0IGNvbnN0IFJFVklTSU9OX0NIQU5HRVMgPSB7XG4gIDE6ICc8PSAxLjAucmMuMicsIC8vIDEuMC5yYy4yIGlzIGFjdHVhbGx5IHJldjIgYnV0IGRvZXNuJ3QgcmVwb3J0IGl0XG4gIDI6ICc9PSAxLjAuMC1yYy4zJyxcbiAgMzogJz09IDEuMC4wLXJjLjQnLFxuICA0OiAnPT0gMS54LngnLFxuICA1OiAnPT0gMi4wLjAtYWxwaGEueCcsXG4gIDY6ICc+PSAyLjAuMC1iZXRhLjEnLFxuICA3OiAnPj0gNC4wLjAnXG59O1xuXG5jb25zdCBvYmplY3RUeXBlID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBIYW5kbGViYXJzRW52aXJvbm1lbnQoaGVscGVycywgcGFydGlhbHMsIGRlY29yYXRvcnMpIHtcbiAgdGhpcy5oZWxwZXJzID0gaGVscGVycyB8fCB7fTtcbiAgdGhpcy5wYXJ0aWFscyA9IHBhcnRpYWxzIHx8IHt9O1xuICB0aGlzLmRlY29yYXRvcnMgPSBkZWNvcmF0b3JzIHx8IHt9O1xuXG4gIHJlZ2lzdGVyRGVmYXVsdEhlbHBlcnModGhpcyk7XG4gIHJlZ2lzdGVyRGVmYXVsdERlY29yYXRvcnModGhpcyk7XG59XG5cbkhhbmRsZWJhcnNFbnZpcm9ubWVudC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBIYW5kbGViYXJzRW52aXJvbm1lbnQsXG5cbiAgbG9nZ2VyOiBsb2dnZXIsXG4gIGxvZzogbG9nZ2VyLmxvZyxcblxuICByZWdpc3RlckhlbHBlcjogZnVuY3Rpb24obmFtZSwgZm4pIHtcbiAgICBpZiAodG9TdHJpbmcuY2FsbChuYW1lKSA9PT0gb2JqZWN0VHlwZSkge1xuICAgICAgaWYgKGZuKSB7IHRocm93IG5ldyBFeGNlcHRpb24oJ0FyZyBub3Qgc3VwcG9ydGVkIHdpdGggbXVsdGlwbGUgaGVscGVycycpOyB9XG4gICAgICBleHRlbmQodGhpcy5oZWxwZXJzLCBuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oZWxwZXJzW25hbWVdID0gZm47XG4gICAgfVxuICB9LFxuICB1bnJlZ2lzdGVySGVscGVyOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgZGVsZXRlIHRoaXMuaGVscGVyc1tuYW1lXTtcbiAgfSxcblxuICByZWdpc3RlclBhcnRpYWw6IGZ1bmN0aW9uKG5hbWUsIHBhcnRpYWwpIHtcbiAgICBpZiAodG9TdHJpbmcuY2FsbChuYW1lKSA9PT0gb2JqZWN0VHlwZSkge1xuICAgICAgZXh0ZW5kKHRoaXMucGFydGlhbHMsIG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIHBhcnRpYWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oYEF0dGVtcHRpbmcgdG8gcmVnaXN0ZXIgYSBwYXJ0aWFsIGNhbGxlZCBcIiR7bmFtZX1cIiBhcyB1bmRlZmluZWRgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucGFydGlhbHNbbmFtZV0gPSBwYXJ0aWFsO1xuICAgIH1cbiAgfSxcbiAgdW5yZWdpc3RlclBhcnRpYWw6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBkZWxldGUgdGhpcy5wYXJ0aWFsc1tuYW1lXTtcbiAgfSxcblxuICByZWdpc3RlckRlY29yYXRvcjogZnVuY3Rpb24obmFtZSwgZm4pIHtcbiAgICBpZiAodG9TdHJpbmcuY2FsbChuYW1lKSA9PT0gb2JqZWN0VHlwZSkge1xuICAgICAgaWYgKGZuKSB7IHRocm93IG5ldyBFeGNlcHRpb24oJ0FyZyBub3Qgc3VwcG9ydGVkIHdpdGggbXVsdGlwbGUgZGVjb3JhdG9ycycpOyB9XG4gICAgICBleHRlbmQodGhpcy5kZWNvcmF0b3JzLCBuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZWNvcmF0b3JzW25hbWVdID0gZm47XG4gICAgfVxuICB9LFxuICB1bnJlZ2lzdGVyRGVjb3JhdG9yOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgZGVsZXRlIHRoaXMuZGVjb3JhdG9yc1tuYW1lXTtcbiAgfVxufTtcblxuZXhwb3J0IGxldCBsb2cgPSBsb2dnZXIubG9nO1xuXG5leHBvcnQge2NyZWF0ZUZyYW1lLCBsb2dnZXJ9O1xuIl19
		
		
		/***/
	}),
	
	/***/ "./node_modules/handlebars/dist/cjs/handlebars/decorators.js":
	/*!*******************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/decorators.js ***!
  \*******************************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		exports.__esModule = true;
		exports.registerDefaultDecorators = registerDefaultDecorators;
// istanbul ignore next
		
		function _interopRequireDefault(obj) {
			return obj && obj.__esModule ? obj : {'default': obj};
		}
		
		var _decoratorsInline = __webpack_require__(/*! ./decorators/inline */ "./node_modules/handlebars/dist/cjs/handlebars/decorators/inline.js");
		
		var _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);
		
		function registerDefaultDecorators(instance) {
			_decoratorsInline2['default'](instance);
		}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL2RlY29yYXRvcnMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Z0NBQTJCLHFCQUFxQjs7OztBQUV6QyxTQUFTLHlCQUF5QixDQUFDLFFBQVEsRUFBRTtBQUNsRCxnQ0FBZSxRQUFRLENBQUMsQ0FBQztDQUMxQiIsImZpbGUiOiJkZWNvcmF0b3JzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHJlZ2lzdGVySW5saW5lIGZyb20gJy4vZGVjb3JhdG9ycy9pbmxpbmUnO1xuXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJEZWZhdWx0RGVjb3JhdG9ycyhpbnN0YW5jZSkge1xuICByZWdpc3RlcklubGluZShpbnN0YW5jZSk7XG59XG5cbiJdfQ==
		
		
		/***/
	}),
	
	/***/ "./node_modules/handlebars/dist/cjs/handlebars/decorators/inline.js":
	/*!**************************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/decorators/inline.js ***!
  \**************************************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		exports.__esModule = true;
		
		var _utils = __webpack_require__(/*! ../utils */ "./node_modules/handlebars/dist/cjs/handlebars/utils.js");
		
		exports['default'] = function(instance) {
			instance.registerDecorator('inline', function(fn, props, container, options) {
				var ret = fn;
				if(!props.partials) {
					props.partials = {};
					ret = function(context, options) {
						// Create a new partials stack frame prior to exec.
						var original = container.partials;
						container.partials = _utils.extend({}, original, props.partials);
						var ret = fn(context, options);
						container.partials = original;
						return ret;
					};
				}
				
				props.partials[options.args[0]] = options.fn;
				
				return ret;
			});
		};
		
		module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL2RlY29yYXRvcnMvaW5saW5lLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7cUJBQXFCLFVBQVU7O3FCQUVoQixVQUFTLFFBQVEsRUFBRTtBQUNoQyxVQUFRLENBQUMsaUJBQWlCLENBQUMsUUFBUSxFQUFFLFVBQVMsRUFBRSxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsT0FBTyxFQUFFO0FBQzNFLFFBQUksR0FBRyxHQUFHLEVBQUUsQ0FBQztBQUNiLFFBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxFQUFFO0FBQ25CLFdBQUssQ0FBQyxRQUFRLEdBQUcsRUFBRSxDQUFDO0FBQ3BCLFNBQUcsR0FBRyxVQUFTLE9BQU8sRUFBRSxPQUFPLEVBQUU7O0FBRS9CLFlBQUksUUFBUSxHQUFHLFNBQVMsQ0FBQyxRQUFRLENBQUM7QUFDbEMsaUJBQVMsQ0FBQyxRQUFRLEdBQUcsY0FBTyxFQUFFLEVBQUUsUUFBUSxFQUFFLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUMxRCxZQUFJLEdBQUcsR0FBRyxFQUFFLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0FBQy9CLGlCQUFTLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztBQUM5QixlQUFPLEdBQUcsQ0FBQztPQUNaLENBQUM7S0FDSDs7QUFFRCxTQUFLLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsRUFBRSxDQUFDOztBQUU3QyxXQUFPLEdBQUcsQ0FBQztHQUNaLENBQUMsQ0FBQztDQUNKIiwiZmlsZSI6ImlubGluZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7ZXh0ZW5kfSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gIGluc3RhbmNlLnJlZ2lzdGVyRGVjb3JhdG9yKCdpbmxpbmUnLCBmdW5jdGlvbihmbiwgcHJvcHMsIGNvbnRhaW5lciwgb3B0aW9ucykge1xuICAgIGxldCByZXQgPSBmbjtcbiAgICBpZiAoIXByb3BzLnBhcnRpYWxzKSB7XG4gICAgICBwcm9wcy5wYXJ0aWFscyA9IHt9O1xuICAgICAgcmV0ID0gZnVuY3Rpb24oY29udGV4dCwgb3B0aW9ucykge1xuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgcGFydGlhbHMgc3RhY2sgZnJhbWUgcHJpb3IgdG8gZXhlYy5cbiAgICAgICAgbGV0IG9yaWdpbmFsID0gY29udGFpbmVyLnBhcnRpYWxzO1xuICAgICAgICBjb250YWluZXIucGFydGlhbHMgPSBleHRlbmQoe30sIG9yaWdpbmFsLCBwcm9wcy5wYXJ0aWFscyk7XG4gICAgICAgIGxldCByZXQgPSBmbihjb250ZXh0LCBvcHRpb25zKTtcbiAgICAgICAgY29udGFpbmVyLnBhcnRpYWxzID0gb3JpZ2luYWw7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHByb3BzLnBhcnRpYWxzW29wdGlvbnMuYXJnc1swXV0gPSBvcHRpb25zLmZuO1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfSk7XG59XG4iXX0=
		
		
		/***/
	}),
	
	/***/ "./node_modules/handlebars/dist/cjs/handlebars/exception.js":
	/*!******************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/exception.js ***!
  \******************************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		exports.__esModule = true;
		
		var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];
		
		function Exception(message, node) {
			var loc = node && node.loc,
				line = undefined,
				column = undefined;
			if(loc) {
				line = loc.start.line;
				column = loc.start.column;
				
				message += ' - ' + line + ':' + column;
			}
			
			var tmp = Error.prototype.constructor.call(this, message);
			
			// Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
			for(var idx = 0; idx < errorProps.length; idx++) {
				this[errorProps[idx]] = tmp[errorProps[idx]];
			}
			
			/* istanbul ignore else */
			if(Error.captureStackTrace) {
				Error.captureStackTrace(this, Exception);
			}
			
			try {
				if(loc) {
					this.lineNumber = line;
					
					// Work around issue under safari where we can't directly set the column value
					/* istanbul ignore next */
					if(Object.defineProperty) {
						Object.defineProperty(this, 'column', {
							value: column,
							enumerable: true
						});
					} else {
						this.column = column;
					}
				}
			} catch(nop) {
				/* Ignore if the browser is very particular */
			}
		}
		
		Exception.prototype = new Error();
		
		exports['default'] = Exception;
		module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL2V4Y2VwdGlvbi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQ0EsSUFBTSxVQUFVLEdBQUcsQ0FBQyxhQUFhLEVBQUUsVUFBVSxFQUFFLFlBQVksRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQzs7QUFFbkcsU0FBUyxTQUFTLENBQUMsT0FBTyxFQUFFLElBQUksRUFBRTtBQUNoQyxNQUFJLEdBQUcsR0FBRyxJQUFJLElBQUksSUFBSSxDQUFDLEdBQUc7TUFDdEIsSUFBSSxZQUFBO01BQ0osTUFBTSxZQUFBLENBQUM7QUFDWCxNQUFJLEdBQUcsRUFBRTtBQUNQLFFBQUksR0FBRyxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQztBQUN0QixVQUFNLEdBQUcsR0FBRyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUM7O0FBRTFCLFdBQU8sSUFBSSxLQUFLLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxNQUFNLENBQUM7R0FDeEM7O0FBRUQsTUFBSSxHQUFHLEdBQUcsS0FBSyxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQzs7O0FBRzFELE9BQUssSUFBSSxHQUFHLEdBQUcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxVQUFVLENBQUMsTUFBTSxFQUFFLEdBQUcsRUFBRSxFQUFFO0FBQ2hELFFBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7R0FDOUM7OztBQUdELE1BQUksS0FBSyxDQUFDLGlCQUFpQixFQUFFO0FBQzNCLFNBQUssQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7R0FDMUM7O0FBRUQsTUFBSTtBQUNGLFFBQUksR0FBRyxFQUFFO0FBQ1AsVUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUM7Ozs7QUFJdkIsVUFBSSxNQUFNLENBQUMsY0FBYyxFQUFFO0FBQ3pCLGNBQU0sQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLFFBQVEsRUFBRTtBQUNwQyxlQUFLLEVBQUUsTUFBTTtBQUNiLG9CQUFVLEVBQUUsSUFBSTtTQUNqQixDQUFDLENBQUM7T0FDSixNQUFNO0FBQ0wsWUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7T0FDdEI7S0FDRjtHQUNGLENBQUMsT0FBTyxHQUFHLEVBQUU7O0dBRWI7Q0FDRjs7QUFFRCxTQUFTLENBQUMsU0FBUyxHQUFHLElBQUksS0FBSyxFQUFFLENBQUM7O3FCQUVuQixTQUFTIiwiZmlsZSI6ImV4Y2VwdGlvbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuY29uc3QgZXJyb3JQcm9wcyA9IFsnZGVzY3JpcHRpb24nLCAnZmlsZU5hbWUnLCAnbGluZU51bWJlcicsICdtZXNzYWdlJywgJ25hbWUnLCAnbnVtYmVyJywgJ3N0YWNrJ107XG5cbmZ1bmN0aW9uIEV4Y2VwdGlvbihtZXNzYWdlLCBub2RlKSB7XG4gIGxldCBsb2MgPSBub2RlICYmIG5vZGUubG9jLFxuICAgICAgbGluZSxcbiAgICAgIGNvbHVtbjtcbiAgaWYgKGxvYykge1xuICAgIGxpbmUgPSBsb2Muc3RhcnQubGluZTtcbiAgICBjb2x1bW4gPSBsb2Muc3RhcnQuY29sdW1uO1xuXG4gICAgbWVzc2FnZSArPSAnIC0gJyArIGxpbmUgKyAnOicgKyBjb2x1bW47XG4gIH1cblxuICBsZXQgdG1wID0gRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgbWVzc2FnZSk7XG5cbiAgLy8gVW5mb3J0dW5hdGVseSBlcnJvcnMgYXJlIG5vdCBlbnVtZXJhYmxlIGluIENocm9tZSAoYXQgbGVhc3QpLCBzbyBgZm9yIHByb3AgaW4gdG1wYCBkb2Vzbid0IHdvcmsuXG4gIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGVycm9yUHJvcHMubGVuZ3RoOyBpZHgrKykge1xuICAgIHRoaXNbZXJyb3JQcm9wc1tpZHhdXSA9IHRtcFtlcnJvclByb3BzW2lkeF1dO1xuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgRXhjZXB0aW9uKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgaWYgKGxvYykge1xuICAgICAgdGhpcy5saW5lTnVtYmVyID0gbGluZTtcblxuICAgICAgLy8gV29yayBhcm91bmQgaXNzdWUgdW5kZXIgc2FmYXJpIHdoZXJlIHdlIGNhbid0IGRpcmVjdGx5IHNldCB0aGUgY29sdW1uIHZhbHVlXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2NvbHVtbicsIHtcbiAgICAgICAgICB2YWx1ZTogY29sdW1uLFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbHVtbiA9IGNvbHVtbjtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKG5vcCkge1xuICAgIC8qIElnbm9yZSBpZiB0aGUgYnJvd3NlciBpcyB2ZXJ5IHBhcnRpY3VsYXIgKi9cbiAgfVxufVxuXG5FeGNlcHRpb24ucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG5cbmV4cG9ydCBkZWZhdWx0IEV4Y2VwdGlvbjtcbiJdfQ==
		
		
		/***/
	}),
	
	/***/ "./node_modules/handlebars/dist/cjs/handlebars/helpers.js":
	/*!****************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/helpers.js ***!
  \****************************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		exports.__esModule = true;
		exports.registerDefaultHelpers = registerDefaultHelpers;
// istanbul ignore next
		
		function _interopRequireDefault(obj) {
			return obj && obj.__esModule ? obj : {'default': obj};
		}
		
		var _helpersBlockHelperMissing = __webpack_require__(/*! ./helpers/block-helper-missing */ "./node_modules/handlebars/dist/cjs/handlebars/helpers/block-helper-missing.js");
		
		var _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);
		
		var _helpersEach = __webpack_require__(/*! ./helpers/each */ "./node_modules/handlebars/dist/cjs/handlebars/helpers/each.js");
		
		var _helpersEach2 = _interopRequireDefault(_helpersEach);
		
		var _helpersHelperMissing = __webpack_require__(/*! ./helpers/helper-missing */ "./node_modules/handlebars/dist/cjs/handlebars/helpers/helper-missing.js");
		
		var _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);
		
		var _helpersIf = __webpack_require__(/*! ./helpers/if */ "./node_modules/handlebars/dist/cjs/handlebars/helpers/if.js");
		
		var _helpersIf2 = _interopRequireDefault(_helpersIf);
		
		var _helpersLog = __webpack_require__(/*! ./helpers/log */ "./node_modules/handlebars/dist/cjs/handlebars/helpers/log.js");
		
		var _helpersLog2 = _interopRequireDefault(_helpersLog);
		
		var _helpersLookup = __webpack_require__(/*! ./helpers/lookup */ "./node_modules/handlebars/dist/cjs/handlebars/helpers/lookup.js");
		
		var _helpersLookup2 = _interopRequireDefault(_helpersLookup);
		
		var _helpersWith = __webpack_require__(/*! ./helpers/with */ "./node_modules/handlebars/dist/cjs/handlebars/helpers/with.js");
		
		var _helpersWith2 = _interopRequireDefault(_helpersWith);
		
		function registerDefaultHelpers(instance) {
			_helpersBlockHelperMissing2['default'](instance);
			_helpersEach2['default'](instance);
			_helpersHelperMissing2['default'](instance);
			_helpersIf2['default'](instance);
			_helpersLog2['default'](instance);
			_helpersLookup2['default'](instance);
			_helpersWith2['default'](instance);
		}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL2hlbHBlcnMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7eUNBQXVDLGdDQUFnQzs7OzsyQkFDOUMsZ0JBQWdCOzs7O29DQUNQLDBCQUEwQjs7Ozt5QkFDckMsY0FBYzs7OzswQkFDYixlQUFlOzs7OzZCQUNaLGtCQUFrQjs7OzsyQkFDcEIsZ0JBQWdCOzs7O0FBRWxDLFNBQVMsc0JBQXNCLENBQUMsUUFBUSxFQUFFO0FBQy9DLHlDQUEyQixRQUFRLENBQUMsQ0FBQztBQUNyQywyQkFBYSxRQUFRLENBQUMsQ0FBQztBQUN2QixvQ0FBc0IsUUFBUSxDQUFDLENBQUM7QUFDaEMseUJBQVcsUUFBUSxDQUFDLENBQUM7QUFDckIsMEJBQVksUUFBUSxDQUFDLENBQUM7QUFDdEIsNkJBQWUsUUFBUSxDQUFDLENBQUM7QUFDekIsMkJBQWEsUUFBUSxDQUFDLENBQUM7Q0FDeEIiLCJmaWxlIjoiaGVscGVycy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCByZWdpc3RlckJsb2NrSGVscGVyTWlzc2luZyBmcm9tICcuL2hlbHBlcnMvYmxvY2staGVscGVyLW1pc3NpbmcnO1xuaW1wb3J0IHJlZ2lzdGVyRWFjaCBmcm9tICcuL2hlbHBlcnMvZWFjaCc7XG5pbXBvcnQgcmVnaXN0ZXJIZWxwZXJNaXNzaW5nIGZyb20gJy4vaGVscGVycy9oZWxwZXItbWlzc2luZyc7XG5pbXBvcnQgcmVnaXN0ZXJJZiBmcm9tICcuL2hlbHBlcnMvaWYnO1xuaW1wb3J0IHJlZ2lzdGVyTG9nIGZyb20gJy4vaGVscGVycy9sb2cnO1xuaW1wb3J0IHJlZ2lzdGVyTG9va3VwIGZyb20gJy4vaGVscGVycy9sb29rdXAnO1xuaW1wb3J0IHJlZ2lzdGVyV2l0aCBmcm9tICcuL2hlbHBlcnMvd2l0aCc7XG5cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckRlZmF1bHRIZWxwZXJzKGluc3RhbmNlKSB7XG4gIHJlZ2lzdGVyQmxvY2tIZWxwZXJNaXNzaW5nKGluc3RhbmNlKTtcbiAgcmVnaXN0ZXJFYWNoKGluc3RhbmNlKTtcbiAgcmVnaXN0ZXJIZWxwZXJNaXNzaW5nKGluc3RhbmNlKTtcbiAgcmVnaXN0ZXJJZihpbnN0YW5jZSk7XG4gIHJlZ2lzdGVyTG9nKGluc3RhbmNlKTtcbiAgcmVnaXN0ZXJMb29rdXAoaW5zdGFuY2UpO1xuICByZWdpc3RlcldpdGgoaW5zdGFuY2UpO1xufVxuIl19
		
		
		/***/
	}),
	
	/***/ "./node_modules/handlebars/dist/cjs/handlebars/helpers/block-helper-missing.js":
	/*!*************************************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/helpers/block-helper-missing.js ***!
  \*************************************************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		exports.__esModule = true;
		
		var _utils = __webpack_require__(/*! ../utils */ "./node_modules/handlebars/dist/cjs/handlebars/utils.js");
		
		exports['default'] = function(instance) {
			instance.registerHelper('blockHelperMissing', function(context, options) {
				var inverse = options.inverse,
					fn = options.fn;
				
				if(context === true) {
					return fn(this);
				} else if(context === false || context == null) {
					return inverse(this);
				} else if(_utils.isArray(context)) {
					if(context.length > 0) {
						if(options.ids) {
							options.ids = [options.name];
						}
						
						return instance.helpers.each(context, options);
					} else {
						return inverse(this);
					}
				} else {
					if(options.data && options.ids) {
						var data = _utils.createFrame(options.data);
						data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);
						options = {data: data};
					}
					
					return fn(context, options);
				}
			});
		};
		
		module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL2hlbHBlcnMvYmxvY2staGVscGVyLW1pc3NpbmcuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztxQkFBc0QsVUFBVTs7cUJBRWpELFVBQVMsUUFBUSxFQUFFO0FBQ2hDLFVBQVEsQ0FBQyxjQUFjLENBQUMsb0JBQW9CLEVBQUUsVUFBUyxPQUFPLEVBQUUsT0FBTyxFQUFFO0FBQ3ZFLFFBQUksT0FBTyxHQUFHLE9BQU8sQ0FBQyxPQUFPO1FBQ3pCLEVBQUUsR0FBRyxPQUFPLENBQUMsRUFBRSxDQUFDOztBQUVwQixRQUFJLE9BQU8sS0FBSyxJQUFJLEVBQUU7QUFDcEIsYUFBTyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDakIsTUFBTSxJQUFJLE9BQU8sS0FBSyxLQUFLLElBQUksT0FBTyxJQUFJLElBQUksRUFBRTtBQUMvQyxhQUFPLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUN0QixNQUFNLElBQUksZUFBUSxPQUFPLENBQUMsRUFBRTtBQUMzQixVQUFJLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO0FBQ3RCLFlBQUksT0FBTyxDQUFDLEdBQUcsRUFBRTtBQUNmLGlCQUFPLENBQUMsR0FBRyxHQUFHLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQzlCOztBQUVELGVBQU8sUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO09BQ2hELE1BQU07QUFDTCxlQUFPLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztPQUN0QjtLQUNGLE1BQU07QUFDTCxVQUFJLE9BQU8sQ0FBQyxJQUFJLElBQUksT0FBTyxDQUFDLEdBQUcsRUFBRTtBQUMvQixZQUFJLElBQUksR0FBRyxtQkFBWSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDckMsWUFBSSxDQUFDLFdBQVcsR0FBRyx5QkFBa0IsT0FBTyxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQzdFLGVBQU8sR0FBRyxFQUFDLElBQUksRUFBRSxJQUFJLEVBQUMsQ0FBQztPQUN4Qjs7QUFFRCxhQUFPLEVBQUUsQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7S0FDN0I7R0FDRixDQUFDLENBQUM7Q0FDSiIsImZpbGUiOiJibG9jay1oZWxwZXItbWlzc2luZy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7YXBwZW5kQ29udGV4dFBhdGgsIGNyZWF0ZUZyYW1lLCBpc0FycmF5fSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gIGluc3RhbmNlLnJlZ2lzdGVySGVscGVyKCdibG9ja0hlbHBlck1pc3NpbmcnLCBmdW5jdGlvbihjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgbGV0IGludmVyc2UgPSBvcHRpb25zLmludmVyc2UsXG4gICAgICAgIGZuID0gb3B0aW9ucy5mbjtcblxuICAgIGlmIChjb250ZXh0ID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gZm4odGhpcyk7XG4gICAgfSBlbHNlIGlmIChjb250ZXh0ID09PSBmYWxzZSB8fCBjb250ZXh0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBpbnZlcnNlKHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShjb250ZXh0KSkge1xuICAgICAgaWYgKGNvbnRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAob3B0aW9ucy5pZHMpIHtcbiAgICAgICAgICBvcHRpb25zLmlkcyA9IFtvcHRpb25zLm5hbWVdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLmhlbHBlcnMuZWFjaChjb250ZXh0LCBvcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBpbnZlcnNlKHRoaXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAob3B0aW9ucy5kYXRhICYmIG9wdGlvbnMuaWRzKSB7XG4gICAgICAgIGxldCBkYXRhID0gY3JlYXRlRnJhbWUob3B0aW9ucy5kYXRhKTtcbiAgICAgICAgZGF0YS5jb250ZXh0UGF0aCA9IGFwcGVuZENvbnRleHRQYXRoKG9wdGlvbnMuZGF0YS5jb250ZXh0UGF0aCwgb3B0aW9ucy5uYW1lKTtcbiAgICAgICAgb3B0aW9ucyA9IHtkYXRhOiBkYXRhfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZuKGNvbnRleHQsIG9wdGlvbnMpO1xuICAgIH1cbiAgfSk7XG59XG4iXX0=
		
		
		/***/
	}),
	
	/***/ "./node_modules/handlebars/dist/cjs/handlebars/helpers/each.js":
	/*!*********************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/helpers/each.js ***!
  \*********************************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		exports.__esModule = true;
// istanbul ignore next
		
		function _interopRequireDefault(obj) {
			return obj && obj.__esModule ? obj : {'default': obj};
		}
		
		var _utils = __webpack_require__(/*! ../utils */ "./node_modules/handlebars/dist/cjs/handlebars/utils.js");
		
		var _exception = __webpack_require__(/*! ../exception */ "./node_modules/handlebars/dist/cjs/handlebars/exception.js");
		
		var _exception2 = _interopRequireDefault(_exception);
		
		exports['default'] = function(instance) {
			instance.registerHelper('each', function(context, options) {
				if(!options) {
					throw new _exception2['default']('Must pass iterator to #each');
				}
				
				var fn = options.fn,
					inverse = options.inverse,
					i = 0,
					ret = '',
					data = undefined,
					contextPath = undefined;
				
				if(options.data && options.ids) {
					contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
				}
				
				if(_utils.isFunction(context)) {
					context = context.call(this);
				}
				
				if(options.data) {
					data = _utils.createFrame(options.data);
				}
				
				function execIteration(field, index, last) {
					if(data) {
						data.key = field;
						data.index = index;
						data.first = index === 0;
						data.last = !!last;
						
						if(contextPath) {
							data.contextPath = contextPath + field;
						}
					}
					
					ret = ret + fn(context[field], {
						data: data,
						blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])
					});
				}
				
				if(context && typeof context === 'object') {
					if(_utils.isArray(context)) {
						for(var j = context.length; i < j; i++) {
							if(i in context) {
								execIteration(i, i, i === context.length - 1);
							}
						}
					} else {
						var priorKey = undefined;
						
						for(var key in context) {
							if(context.hasOwnProperty(key)) {
								// We're running the iterations one step out of sync so we can detect
								// the last iteration without have to scan the object twice and create
								// an itermediate keys array.
								if(priorKey !== undefined) {
									execIteration(priorKey, i - 1);
								}
								priorKey = key;
								i++;
							}
						}
						if(priorKey !== undefined) {
							execIteration(priorKey, i - 1, true);
						}
					}
				}
				
				if(i === 0) {
					ret = inverse(this);
				}
				
				return ret;
			});
		};
		
		module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL2hlbHBlcnMvZWFjaC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7O3FCQUErRSxVQUFVOzt5QkFDbkUsY0FBYzs7OztxQkFFckIsVUFBUyxRQUFRLEVBQUU7QUFDaEMsVUFBUSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsVUFBUyxPQUFPLEVBQUUsT0FBTyxFQUFFO0FBQ3pELFFBQUksQ0FBQyxPQUFPLEVBQUU7QUFDWixZQUFNLDJCQUFjLDZCQUE2QixDQUFDLENBQUM7S0FDcEQ7O0FBRUQsUUFBSSxFQUFFLEdBQUcsT0FBTyxDQUFDLEVBQUU7UUFDZixPQUFPLEdBQUcsT0FBTyxDQUFDLE9BQU87UUFDekIsQ0FBQyxHQUFHLENBQUM7UUFDTCxHQUFHLEdBQUcsRUFBRTtRQUNSLElBQUksWUFBQTtRQUNKLFdBQVcsWUFBQSxDQUFDOztBQUVoQixRQUFJLE9BQU8sQ0FBQyxJQUFJLElBQUksT0FBTyxDQUFDLEdBQUcsRUFBRTtBQUMvQixpQkFBVyxHQUFHLHlCQUFrQixPQUFPLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDO0tBQ2pGOztBQUVELFFBQUksa0JBQVcsT0FBTyxDQUFDLEVBQUU7QUFBRSxhQUFPLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUFFOztBQUUxRCxRQUFJLE9BQU8sQ0FBQyxJQUFJLEVBQUU7QUFDaEIsVUFBSSxHQUFHLG1CQUFZLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUNsQzs7QUFFRCxhQUFTLGFBQWEsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRTtBQUN6QyxVQUFJLElBQUksRUFBRTtBQUNSLFlBQUksQ0FBQyxHQUFHLEdBQUcsS0FBSyxDQUFDO0FBQ2pCLFlBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO0FBQ25CLFlBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxLQUFLLENBQUMsQ0FBQztBQUN6QixZQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUM7O0FBRW5CLFlBQUksV0FBVyxFQUFFO0FBQ2YsY0FBSSxDQUFDLFdBQVcsR0FBRyxXQUFXLEdBQUcsS0FBSyxDQUFDO1NBQ3hDO09BQ0Y7O0FBRUQsU0FBRyxHQUFHLEdBQUcsR0FBRyxFQUFFLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxFQUFFO0FBQzdCLFlBQUksRUFBRSxJQUFJO0FBQ1YsbUJBQVcsRUFBRSxtQkFBWSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsRUFBRSxLQUFLLENBQUMsRUFBRSxDQUFDLFdBQVcsR0FBRyxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUM7T0FDL0UsQ0FBQyxDQUFDO0tBQ0o7O0FBRUQsUUFBSSxPQUFPLElBQUksT0FBTyxPQUFPLEtBQUssUUFBUSxFQUFFO0FBQzFDLFVBQUksZUFBUSxPQUFPLENBQUMsRUFBRTtBQUNwQixhQUFLLElBQUksQ0FBQyxHQUFHLE9BQU8sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUN2QyxjQUFJLENBQUMsSUFBSSxPQUFPLEVBQUU7QUFDaEIseUJBQWEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsS0FBSyxPQUFPLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO1dBQy9DO1NBQ0Y7T0FDRixNQUFNO0FBQ0wsWUFBSSxRQUFRLFlBQUEsQ0FBQzs7QUFFYixhQUFLLElBQUksR0FBRyxJQUFJLE9BQU8sRUFBRTtBQUN2QixjQUFJLE9BQU8sQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLEVBQUU7Ozs7QUFJL0IsZ0JBQUksUUFBUSxLQUFLLFNBQVMsRUFBRTtBQUMxQiwyQkFBYSxDQUFDLFFBQVEsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7YUFDaEM7QUFDRCxvQkFBUSxHQUFHLEdBQUcsQ0FBQztBQUNmLGFBQUMsRUFBRSxDQUFDO1dBQ0w7U0FDRjtBQUNELFlBQUksUUFBUSxLQUFLLFNBQVMsRUFBRTtBQUMxQix1QkFBYSxDQUFDLFFBQVEsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO1NBQ3RDO09BQ0Y7S0FDRjs7QUFFRCxRQUFJLENBQUMsS0FBSyxDQUFDLEVBQUU7QUFDWCxTQUFHLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQ3JCOztBQUVELFdBQU8sR0FBRyxDQUFDO0dBQ1osQ0FBQyxDQUFDO0NBQ0oiLCJmaWxlIjoiZWFjaC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7YXBwZW5kQ29udGV4dFBhdGgsIGJsb2NrUGFyYW1zLCBjcmVhdGVGcmFtZSwgaXNBcnJheSwgaXNGdW5jdGlvbn0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IEV4Y2VwdGlvbiBmcm9tICcuLi9leGNlcHRpb24nO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihpbnN0YW5jZSkge1xuICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignZWFjaCcsIGZ1bmN0aW9uKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ011c3QgcGFzcyBpdGVyYXRvciB0byAjZWFjaCcpO1xuICAgIH1cblxuICAgIGxldCBmbiA9IG9wdGlvbnMuZm4sXG4gICAgICAgIGludmVyc2UgPSBvcHRpb25zLmludmVyc2UsXG4gICAgICAgIGkgPSAwLFxuICAgICAgICByZXQgPSAnJyxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgY29udGV4dFBhdGg7XG5cbiAgICBpZiAob3B0aW9ucy5kYXRhICYmIG9wdGlvbnMuaWRzKSB7XG4gICAgICBjb250ZXh0UGF0aCA9IGFwcGVuZENvbnRleHRQYXRoKG9wdGlvbnMuZGF0YS5jb250ZXh0UGF0aCwgb3B0aW9ucy5pZHNbMF0pICsgJy4nO1xuICAgIH1cblxuICAgIGlmIChpc0Z1bmN0aW9uKGNvbnRleHQpKSB7IGNvbnRleHQgPSBjb250ZXh0LmNhbGwodGhpcyk7IH1cblxuICAgIGlmIChvcHRpb25zLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBjcmVhdGVGcmFtZShvcHRpb25zLmRhdGEpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4ZWNJdGVyYXRpb24oZmllbGQsIGluZGV4LCBsYXN0KSB7XG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBkYXRhLmtleSA9IGZpZWxkO1xuICAgICAgICBkYXRhLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIGRhdGEuZmlyc3QgPSBpbmRleCA9PT0gMDtcbiAgICAgICAgZGF0YS5sYXN0ID0gISFsYXN0O1xuXG4gICAgICAgIGlmIChjb250ZXh0UGF0aCkge1xuICAgICAgICAgIGRhdGEuY29udGV4dFBhdGggPSBjb250ZXh0UGF0aCArIGZpZWxkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldCA9IHJldCArIGZuKGNvbnRleHRbZmllbGRdLCB7XG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIGJsb2NrUGFyYW1zOiBibG9ja1BhcmFtcyhbY29udGV4dFtmaWVsZF0sIGZpZWxkXSwgW2NvbnRleHRQYXRoICsgZmllbGQsIG51bGxdKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAoaXNBcnJheShjb250ZXh0KSkge1xuICAgICAgICBmb3IgKGxldCBqID0gY29udGV4dC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgICBpZiAoaSBpbiBjb250ZXh0KSB7XG4gICAgICAgICAgICBleGVjSXRlcmF0aW9uKGksIGksIGkgPT09IGNvbnRleHQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgcHJpb3JLZXk7XG5cbiAgICAgICAgZm9yIChsZXQga2V5IGluIGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAoY29udGV4dC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAvLyBXZSdyZSBydW5uaW5nIHRoZSBpdGVyYXRpb25zIG9uZSBzdGVwIG91dCBvZiBzeW5jIHNvIHdlIGNhbiBkZXRlY3RcbiAgICAgICAgICAgIC8vIHRoZSBsYXN0IGl0ZXJhdGlvbiB3aXRob3V0IGhhdmUgdG8gc2NhbiB0aGUgb2JqZWN0IHR3aWNlIGFuZCBjcmVhdGVcbiAgICAgICAgICAgIC8vIGFuIGl0ZXJtZWRpYXRlIGtleXMgYXJyYXkuXG4gICAgICAgICAgICBpZiAocHJpb3JLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBleGVjSXRlcmF0aW9uKHByaW9yS2V5LCBpIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmlvcktleSA9IGtleTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByaW9yS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBleGVjSXRlcmF0aW9uKHByaW9yS2V5LCBpIC0gMSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgcmV0ID0gaW52ZXJzZSh0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9KTtcbn1cbiJdfQ==
		
		
		/***/
	}),
	
	/***/ "./node_modules/handlebars/dist/cjs/handlebars/helpers/helper-missing.js":
	/*!*******************************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/helpers/helper-missing.js ***!
  \*******************************************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		exports.__esModule = true;
// istanbul ignore next
		
		function _interopRequireDefault(obj) {
			return obj && obj.__esModule ? obj : {'default': obj};
		}
		
		var _exception = __webpack_require__(/*! ../exception */ "./node_modules/handlebars/dist/cjs/handlebars/exception.js");
		
		var _exception2 = _interopRequireDefault(_exception);
		
		exports['default'] = function(instance) {
			instance.registerHelper('helperMissing', function() /* [args, ]options */ {
				if(arguments.length === 1) {
					// A missing field in a {{foo}} construct.
					return undefined;
				} else {
					// Someone is actually trying to call something, blow up.
					throw new _exception2['default']('Missing helper: "' + arguments[arguments.length - 1].name + '"');
				}
			});
		};
		
		module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL2hlbHBlcnMvaGVscGVyLW1pc3NpbmcuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozt5QkFBc0IsY0FBYzs7OztxQkFFckIsVUFBUyxRQUFRLEVBQUU7QUFDaEMsVUFBUSxDQUFDLGNBQWMsQ0FBQyxlQUFlLEVBQUUsaUNBQWdDO0FBQ3ZFLFFBQUksU0FBUyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7O0FBRTFCLGFBQU8sU0FBUyxDQUFDO0tBQ2xCLE1BQU07O0FBRUwsWUFBTSwyQkFBYyxtQkFBbUIsR0FBRyxTQUFTLENBQUMsU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLEdBQUcsR0FBRyxDQUFDLENBQUM7S0FDdkY7R0FDRixDQUFDLENBQUM7Q0FDSiIsImZpbGUiOiJoZWxwZXItbWlzc2luZy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBFeGNlcHRpb24gZnJvbSAnLi4vZXhjZXB0aW9uJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ2hlbHBlck1pc3NpbmcnLCBmdW5jdGlvbigvKiBbYXJncywgXW9wdGlvbnMgKi8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgLy8gQSBtaXNzaW5nIGZpZWxkIGluIGEge3tmb299fSBjb25zdHJ1Y3QuXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTb21lb25lIGlzIGFjdHVhbGx5IHRyeWluZyB0byBjYWxsIHNvbWV0aGluZywgYmxvdyB1cC5cbiAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ01pc3NpbmcgaGVscGVyOiBcIicgKyBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdLm5hbWUgKyAnXCInKTtcbiAgICB9XG4gIH0pO1xufVxuIl19
		
		
		/***/
	}),
	
	/***/ "./node_modules/handlebars/dist/cjs/handlebars/helpers/if.js":
	/*!*******************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/helpers/if.js ***!
  \*******************************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		exports.__esModule = true;
		
		var _utils = __webpack_require__(/*! ../utils */ "./node_modules/handlebars/dist/cjs/handlebars/utils.js");
		
		exports['default'] = function(instance) {
			instance.registerHelper('if', function(conditional, options) {
				if(_utils.isFunction(conditional)) {
					conditional = conditional.call(this);
				}
				
				// Default behavior is to render the positive path if the value is truthy and not empty.
				// The `includeZero` option may be set to treat the condtional as purely not empty based on the
				// behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
				if(!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {
					return options.inverse(this);
				} else {
					return options.fn(this);
				}
			});
			
			instance.registerHelper('unless', function(conditional, options) {
				return instance.helpers['if'].call(this, conditional, {
					fn: options.inverse,
					inverse: options.fn,
					hash: options.hash
				});
			});
		};
		
		module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL2hlbHBlcnMvaWYuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztxQkFBa0MsVUFBVTs7cUJBRTdCLFVBQVMsUUFBUSxFQUFFO0FBQ2hDLFVBQVEsQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLFVBQVMsV0FBVyxFQUFFLE9BQU8sRUFBRTtBQUMzRCxRQUFJLGtCQUFXLFdBQVcsQ0FBQyxFQUFFO0FBQUUsaUJBQVcsR0FBRyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQUU7Ozs7O0FBS3RFLFFBQUksQUFBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsV0FBVyxJQUFJLENBQUMsV0FBVyxJQUFLLGVBQVEsV0FBVyxDQUFDLEVBQUU7QUFDdkUsYUFBTyxPQUFPLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQzlCLE1BQU07QUFDTCxhQUFPLE9BQU8sQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDekI7R0FDRixDQUFDLENBQUM7O0FBRUgsVUFBUSxDQUFDLGNBQWMsQ0FBQyxRQUFRLEVBQUUsVUFBUyxXQUFXLEVBQUUsT0FBTyxFQUFFO0FBQy9ELFdBQU8sUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLFdBQVcsRUFBRSxFQUFDLEVBQUUsRUFBRSxPQUFPLENBQUMsT0FBTyxFQUFFLE9BQU8sRUFBRSxPQUFPLENBQUMsRUFBRSxFQUFFLElBQUksRUFBRSxPQUFPLENBQUMsSUFBSSxFQUFDLENBQUMsQ0FBQztHQUN2SCxDQUFDLENBQUM7Q0FDSiIsImZpbGUiOiJpZi5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7aXNFbXB0eSwgaXNGdW5jdGlvbn0gZnJvbSAnLi4vdXRpbHMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihpbnN0YW5jZSkge1xuICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignaWYnLCBmdW5jdGlvbihjb25kaXRpb25hbCwgb3B0aW9ucykge1xuICAgIGlmIChpc0Z1bmN0aW9uKGNvbmRpdGlvbmFsKSkgeyBjb25kaXRpb25hbCA9IGNvbmRpdGlvbmFsLmNhbGwodGhpcyk7IH1cblxuICAgIC8vIERlZmF1bHQgYmVoYXZpb3IgaXMgdG8gcmVuZGVyIHRoZSBwb3NpdGl2ZSBwYXRoIGlmIHRoZSB2YWx1ZSBpcyB0cnV0aHkgYW5kIG5vdCBlbXB0eS5cbiAgICAvLyBUaGUgYGluY2x1ZGVaZXJvYCBvcHRpb24gbWF5IGJlIHNldCB0byB0cmVhdCB0aGUgY29uZHRpb25hbCBhcyBwdXJlbHkgbm90IGVtcHR5IGJhc2VkIG9uIHRoZVxuICAgIC8vIGJlaGF2aW9yIG9mIGlzRW1wdHkuIEVmZmVjdGl2ZWx5IHRoaXMgZGV0ZXJtaW5lcyBpZiAwIGlzIGhhbmRsZWQgYnkgdGhlIHBvc2l0aXZlIHBhdGggb3IgbmVnYXRpdmUuXG4gICAgaWYgKCghb3B0aW9ucy5oYXNoLmluY2x1ZGVaZXJvICYmICFjb25kaXRpb25hbCkgfHwgaXNFbXB0eShjb25kaXRpb25hbCkpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmludmVyc2UodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmZuKHRoaXMpO1xuICAgIH1cbiAgfSk7XG5cbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ3VubGVzcycsIGZ1bmN0aW9uKGNvbmRpdGlvbmFsLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlLmhlbHBlcnNbJ2lmJ10uY2FsbCh0aGlzLCBjb25kaXRpb25hbCwge2ZuOiBvcHRpb25zLmludmVyc2UsIGludmVyc2U6IG9wdGlvbnMuZm4sIGhhc2g6IG9wdGlvbnMuaGFzaH0pO1xuICB9KTtcbn1cbiJdfQ==
		
		
		/***/
	}),
	
	/***/ "./node_modules/handlebars/dist/cjs/handlebars/helpers/log.js":
	/*!********************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/helpers/log.js ***!
  \********************************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		exports.__esModule = true;
		
		exports['default'] = function(instance) {
			instance.registerHelper('log', function() /* message, options */ {
				var args = [undefined],
					options = arguments[arguments.length - 1];
				for(var i = 0; i < arguments.length - 1; i++) {
					args.push(arguments[i]);
				}
				
				var level = 1;
				if(options.hash.level != null) {
					level = options.hash.level;
				} else if(options.data && options.data.level != null) {
					level = options.data.level;
				}
				args[0] = level;
				
				instance.log.apply(instance, args);
			});
		};
		
		module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL2hlbHBlcnMvbG9nLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7cUJBQWUsVUFBUyxRQUFRLEVBQUU7QUFDaEMsVUFBUSxDQUFDLGNBQWMsQ0FBQyxLQUFLLEVBQUUsa0NBQWlDO0FBQzlELFFBQUksSUFBSSxHQUFHLENBQUMsU0FBUyxDQUFDO1FBQ2xCLE9BQU8sR0FBRyxTQUFTLENBQUMsU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztBQUM5QyxTQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDN0MsVUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUN6Qjs7QUFFRCxRQUFJLEtBQUssR0FBRyxDQUFDLENBQUM7QUFDZCxRQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxJQUFJLElBQUksRUFBRTtBQUM5QixXQUFLLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUM7S0FDNUIsTUFBTSxJQUFJLE9BQU8sQ0FBQyxJQUFJLElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLElBQUksSUFBSSxFQUFFO0FBQ3JELFdBQUssR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQztLQUM1QjtBQUNELFFBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUM7O0FBRWhCLFlBQVEsQ0FBQyxHQUFHLE1BQUEsQ0FBWixRQUFRLEVBQVMsSUFBSSxDQUFDLENBQUM7R0FDeEIsQ0FBQyxDQUFDO0NBQ0oiLCJmaWxlIjoibG9nLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ2xvZycsIGZ1bmN0aW9uKC8qIG1lc3NhZ2UsIG9wdGlvbnMgKi8pIHtcbiAgICBsZXQgYXJncyA9IFt1bmRlZmluZWRdLFxuICAgICAgICBvcHRpb25zID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cblxuICAgIGxldCBsZXZlbCA9IDE7XG4gICAgaWYgKG9wdGlvbnMuaGFzaC5sZXZlbCAhPSBudWxsKSB7XG4gICAgICBsZXZlbCA9IG9wdGlvbnMuaGFzaC5sZXZlbDtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZGF0YSAmJiBvcHRpb25zLmRhdGEubGV2ZWwgIT0gbnVsbCkge1xuICAgICAgbGV2ZWwgPSBvcHRpb25zLmRhdGEubGV2ZWw7XG4gICAgfVxuICAgIGFyZ3NbMF0gPSBsZXZlbDtcblxuICAgIGluc3RhbmNlLmxvZyguLi4gYXJncyk7XG4gIH0pO1xufVxuIl19
		
		
		/***/
	}),
	
	/***/ "./node_modules/handlebars/dist/cjs/handlebars/helpers/lookup.js":
	/*!***********************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/helpers/lookup.js ***!
  \***********************************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		exports.__esModule = true;
		
		exports['default'] = function(instance) {
			instance.registerHelper('lookup', function(obj, field) {
				return obj && obj[field];
			});
		};
		
		module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL2hlbHBlcnMvbG9va3VwLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7cUJBQWUsVUFBUyxRQUFRLEVBQUU7QUFDaEMsVUFBUSxDQUFDLGNBQWMsQ0FBQyxRQUFRLEVBQUUsVUFBUyxHQUFHLEVBQUUsS0FBSyxFQUFFO0FBQ3JELFdBQU8sR0FBRyxJQUFJLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztHQUMxQixDQUFDLENBQUM7Q0FDSiIsImZpbGUiOiJsb29rdXAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihpbnN0YW5jZSkge1xuICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignbG9va3VwJywgZnVuY3Rpb24ob2JqLCBmaWVsZCkge1xuICAgIHJldHVybiBvYmogJiYgb2JqW2ZpZWxkXTtcbiAgfSk7XG59XG4iXX0=
		
		
		/***/
	}),
	
	/***/ "./node_modules/handlebars/dist/cjs/handlebars/helpers/with.js":
	/*!*********************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/helpers/with.js ***!
  \*********************************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		exports.__esModule = true;
		
		var _utils = __webpack_require__(/*! ../utils */ "./node_modules/handlebars/dist/cjs/handlebars/utils.js");
		
		exports['default'] = function(instance) {
			instance.registerHelper('with', function(context, options) {
				if(_utils.isFunction(context)) {
					context = context.call(this);
				}
				
				var fn = options.fn;
				
				if(!_utils.isEmpty(context)) {
					var data = options.data;
					if(options.data && options.ids) {
						data = _utils.createFrame(options.data);
						data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);
					}
					
					return fn(context, {
						data: data,
						blockParams: _utils.blockParams([context], [data && data.contextPath])
					});
				} else {
					return options.inverse(this);
				}
			});
		};
		
		module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL2hlbHBlcnMvd2l0aC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O3FCQUErRSxVQUFVOztxQkFFMUUsVUFBUyxRQUFRLEVBQUU7QUFDaEMsVUFBUSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsVUFBUyxPQUFPLEVBQUUsT0FBTyxFQUFFO0FBQ3pELFFBQUksa0JBQVcsT0FBTyxDQUFDLEVBQUU7QUFBRSxhQUFPLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUFFOztBQUUxRCxRQUFJLEVBQUUsR0FBRyxPQUFPLENBQUMsRUFBRSxDQUFDOztBQUVwQixRQUFJLENBQUMsZUFBUSxPQUFPLENBQUMsRUFBRTtBQUNyQixVQUFJLElBQUksR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDO0FBQ3hCLFVBQUksT0FBTyxDQUFDLElBQUksSUFBSSxPQUFPLENBQUMsR0FBRyxFQUFFO0FBQy9CLFlBQUksR0FBRyxtQkFBWSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDakMsWUFBSSxDQUFDLFdBQVcsR0FBRyx5QkFBa0IsT0FBTyxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO09BQ2hGOztBQUVELGFBQU8sRUFBRSxDQUFDLE9BQU8sRUFBRTtBQUNqQixZQUFJLEVBQUUsSUFBSTtBQUNWLG1CQUFXLEVBQUUsbUJBQVksQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7T0FDaEUsQ0FBQyxDQUFDO0tBQ0osTUFBTTtBQUNMLGFBQU8sT0FBTyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUM5QjtHQUNGLENBQUMsQ0FBQztDQUNKIiwiZmlsZSI6IndpdGguanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge2FwcGVuZENvbnRleHRQYXRoLCBibG9ja1BhcmFtcywgY3JlYXRlRnJhbWUsIGlzRW1wdHksIGlzRnVuY3Rpb259IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ3dpdGgnLCBmdW5jdGlvbihjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24oY29udGV4dCkpIHsgY29udGV4dCA9IGNvbnRleHQuY2FsbCh0aGlzKTsgfVxuXG4gICAgbGV0IGZuID0gb3B0aW9ucy5mbjtcblxuICAgIGlmICghaXNFbXB0eShjb250ZXh0KSkge1xuICAgICAgbGV0IGRhdGEgPSBvcHRpb25zLmRhdGE7XG4gICAgICBpZiAob3B0aW9ucy5kYXRhICYmIG9wdGlvbnMuaWRzKSB7XG4gICAgICAgIGRhdGEgPSBjcmVhdGVGcmFtZShvcHRpb25zLmRhdGEpO1xuICAgICAgICBkYXRhLmNvbnRleHRQYXRoID0gYXBwZW5kQ29udGV4dFBhdGgob3B0aW9ucy5kYXRhLmNvbnRleHRQYXRoLCBvcHRpb25zLmlkc1swXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmbihjb250ZXh0LCB7XG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIGJsb2NrUGFyYW1zOiBibG9ja1BhcmFtcyhbY29udGV4dF0sIFtkYXRhICYmIGRhdGEuY29udGV4dFBhdGhdKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmludmVyc2UodGhpcyk7XG4gICAgfVxuICB9KTtcbn1cbiJdfQ==
		
		
		/***/
	}),
	
	/***/ "./node_modules/handlebars/dist/cjs/handlebars/logger.js":
	/*!***************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/logger.js ***!
  \***************************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		exports.__esModule = true;
		
		var _utils = __webpack_require__(/*! ./utils */ "./node_modules/handlebars/dist/cjs/handlebars/utils.js");
		
		var logger = {
			methodMap: ['debug', 'info', 'warn', 'error'],
			level: 'info',
			
			// Maps a given level value to the `methodMap` indexes above.
			lookupLevel: function lookupLevel(level) {
				if(typeof level === 'string') {
					var levelMap = _utils.indexOf(logger.methodMap, level.toLowerCase());
					if(levelMap >= 0) {
						level = levelMap;
					} else {
						level = parseInt(level, 10);
					}
				}
				
				return level;
			},
			
			// Can be overridden in the host environment
			log: function log(level) {
				level = logger.lookupLevel(level);
				
				if(typeof console !== 'undefined' && logger.lookupLevel(logger.level) <= level) {
					var method = logger.methodMap[level];
					if(!console[method]) {
						// eslint-disable-line no-console
						method = 'log';
					}
					
					for(var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
						message[_key - 1] = arguments[_key];
					}
					
					console[method].apply(console, message); // eslint-disable-line no-console
				}
			}
		};
		
		exports['default'] = logger;
		module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL2xvZ2dlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O3FCQUFzQixTQUFTOztBQUUvQixJQUFJLE1BQU0sR0FBRztBQUNYLFdBQVMsRUFBRSxDQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLE9BQU8sQ0FBQztBQUM3QyxPQUFLLEVBQUUsTUFBTTs7O0FBR2IsYUFBVyxFQUFFLHFCQUFTLEtBQUssRUFBRTtBQUMzQixRQUFJLE9BQU8sS0FBSyxLQUFLLFFBQVEsRUFBRTtBQUM3QixVQUFJLFFBQVEsR0FBRyxlQUFRLE1BQU0sQ0FBQyxTQUFTLEVBQUUsS0FBSyxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUM7QUFDOUQsVUFBSSxRQUFRLElBQUksQ0FBQyxFQUFFO0FBQ2pCLGFBQUssR0FBRyxRQUFRLENBQUM7T0FDbEIsTUFBTTtBQUNMLGFBQUssR0FBRyxRQUFRLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDO09BQzdCO0tBQ0Y7O0FBRUQsV0FBTyxLQUFLLENBQUM7R0FDZDs7O0FBR0QsS0FBRyxFQUFFLGFBQVMsS0FBSyxFQUFjO0FBQy9CLFNBQUssR0FBRyxNQUFNLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDOztBQUVsQyxRQUFJLE9BQU8sT0FBTyxLQUFLLFdBQVcsSUFBSSxNQUFNLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSSxLQUFLLEVBQUU7QUFDL0UsVUFBSSxNQUFNLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUNyQyxVQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxFQUFFOztBQUNwQixjQUFNLEdBQUcsS0FBSyxDQUFDO09BQ2hCOzt3Q0FQbUIsT0FBTztBQUFQLGVBQU87OztBQVEzQixhQUFPLENBQUMsTUFBTSxPQUFDLENBQWYsT0FBTyxFQUFZLE9BQU8sQ0FBQyxDQUFDO0tBQzdCO0dBQ0Y7Q0FDRixDQUFDOztxQkFFYSxNQUFNIiwiZmlsZSI6ImxvZ2dlci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7aW5kZXhPZn0gZnJvbSAnLi91dGlscyc7XG5cbmxldCBsb2dnZXIgPSB7XG4gIG1ldGhvZE1hcDogWydkZWJ1ZycsICdpbmZvJywgJ3dhcm4nLCAnZXJyb3InXSxcbiAgbGV2ZWw6ICdpbmZvJyxcblxuICAvLyBNYXBzIGEgZ2l2ZW4gbGV2ZWwgdmFsdWUgdG8gdGhlIGBtZXRob2RNYXBgIGluZGV4ZXMgYWJvdmUuXG4gIGxvb2t1cExldmVsOiBmdW5jdGlvbihsZXZlbCkge1xuICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICBsZXQgbGV2ZWxNYXAgPSBpbmRleE9mKGxvZ2dlci5tZXRob2RNYXAsIGxldmVsLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgaWYgKGxldmVsTWFwID49IDApIHtcbiAgICAgICAgbGV2ZWwgPSBsZXZlbE1hcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldmVsID0gcGFyc2VJbnQobGV2ZWwsIDEwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbGV2ZWw7XG4gIH0sXG5cbiAgLy8gQ2FuIGJlIG92ZXJyaWRkZW4gaW4gdGhlIGhvc3QgZW52aXJvbm1lbnRcbiAgbG9nOiBmdW5jdGlvbihsZXZlbCwgLi4ubWVzc2FnZSkge1xuICAgIGxldmVsID0gbG9nZ2VyLmxvb2t1cExldmVsKGxldmVsKTtcblxuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbG9nZ2VyLmxvb2t1cExldmVsKGxvZ2dlci5sZXZlbCkgPD0gbGV2ZWwpIHtcbiAgICAgIGxldCBtZXRob2QgPSBsb2dnZXIubWV0aG9kTWFwW2xldmVsXTtcbiAgICAgIGlmICghY29uc29sZVttZXRob2RdKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgICAgICBtZXRob2QgPSAnbG9nJztcbiAgICAgIH1cbiAgICAgIGNvbnNvbGVbbWV0aG9kXSguLi5tZXNzYWdlKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBsb2dnZXI7XG4iXX0=
		
		
		/***/
	}),
	
	/***/ "./node_modules/handlebars/dist/cjs/handlebars/no-conflict.js":
	/*!********************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/no-conflict.js ***!
  \********************************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		/* WEBPACK VAR INJECTION */
		(function(global) {/* global window */
			
			
			exports.__esModule = true;
			
			exports['default'] = function(Handlebars) {
				/* istanbul ignore next */
				var root = typeof global !== 'undefined' ? global : window,
					$Handlebars = root.Handlebars;
				/* istanbul ignore next */
				Handlebars.noConflict = function() {
					if(root.Handlebars === Handlebars) {
						root.Handlebars = $Handlebars;
					}
					return Handlebars;
				};
			};
			
			module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL25vLWNvbmZsaWN0LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O3FCQUNlLFVBQVMsVUFBVSxFQUFFOztBQUVsQyxNQUFJLElBQUksR0FBRyxPQUFPLE1BQU0sS0FBSyxXQUFXLEdBQUcsTUFBTSxHQUFHLE1BQU07TUFDdEQsV0FBVyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUM7O0FBRWxDLFlBQVUsQ0FBQyxVQUFVLEdBQUcsWUFBVztBQUNqQyxRQUFJLElBQUksQ0FBQyxVQUFVLEtBQUssVUFBVSxFQUFFO0FBQ2xDLFVBQUksQ0FBQyxVQUFVLEdBQUcsV0FBVyxDQUFDO0tBQy9CO0FBQ0QsV0FBTyxVQUFVLENBQUM7R0FDbkIsQ0FBQztDQUNIIiwiZmlsZSI6Im5vLWNvbmZsaWN0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZ2xvYmFsIHdpbmRvdyAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oSGFuZGxlYmFycykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBsZXQgcm9vdCA9IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogd2luZG93LFxuICAgICAgJEhhbmRsZWJhcnMgPSByb290LkhhbmRsZWJhcnM7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIEhhbmRsZWJhcnMubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChyb290LkhhbmRsZWJhcnMgPT09IEhhbmRsZWJhcnMpIHtcbiAgICAgIHJvb3QuSGFuZGxlYmFycyA9ICRIYW5kbGViYXJzO1xuICAgIH1cbiAgICByZXR1cm4gSGFuZGxlYmFycztcbiAgfTtcbn1cbiJdfQ==
			
			/* WEBPACK VAR INJECTION */
		}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))
		
		/***/
	}),
	
	/***/ "./node_modules/handlebars/dist/cjs/handlebars/runtime.js":
	/*!****************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/runtime.js ***!
  \****************************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		exports.__esModule = true;
		exports.checkRevision = checkRevision;
		exports.template = template;
		exports.wrapProgram = wrapProgram;
		exports.resolvePartial = resolvePartial;
		exports.invokePartial = invokePartial;
		exports.noop = noop;
// istanbul ignore next
		
		function _interopRequireDefault(obj) {
			return obj && obj.__esModule ? obj : {'default': obj};
		}

// istanbul ignore next
		
		function _interopRequireWildcard(obj) {
			if(obj && obj.__esModule) {
				return obj;
			} else {
				var newObj = {};
				if(obj != null) {
					for(var key in obj) {
						if(Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
					}
				}
				newObj['default'] = obj;
				return newObj;
			}
		}
		
		var _utils = __webpack_require__(/*! ./utils */ "./node_modules/handlebars/dist/cjs/handlebars/utils.js");
		
		var Utils = _interopRequireWildcard(_utils);
		
		var _exception = __webpack_require__(/*! ./exception */ "./node_modules/handlebars/dist/cjs/handlebars/exception.js");
		
		var _exception2 = _interopRequireDefault(_exception);
		
		var _base = __webpack_require__(/*! ./base */ "./node_modules/handlebars/dist/cjs/handlebars/base.js");
		
		function checkRevision(compilerInfo) {
			var compilerRevision = compilerInfo && compilerInfo[0] || 1,
				currentRevision = _base.COMPILER_REVISION;
			
			if(compilerRevision !== currentRevision) {
				if(compilerRevision < currentRevision) {
					var runtimeVersions = _base.REVISION_CHANGES[currentRevision],
						compilerVersions = _base.REVISION_CHANGES[compilerRevision];
					throw new _exception2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');
				} else {
					// Use the embedded version info since the runtime doesn't know about this revision yet
					throw new _exception2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');
				}
			}
		}
		
		function template(templateSpec, env) {
			/* istanbul ignore next */
			if(!env) {
				throw new _exception2['default']('No environment passed to template');
			}
			if(!templateSpec || !templateSpec.main) {
				throw new _exception2['default']('Unknown template object: ' + typeof templateSpec);
			}
			
			templateSpec.main.decorator = templateSpec.main_d;
			
			// Note: Using env.VM references rather than local var references throughout this section to allow
			// for external users to override these as psuedo-supported APIs.
			env.VM.checkRevision(templateSpec.compiler);
			
			function invokePartialWrapper(partial, context, options) {
				if(options.hash) {
					context = Utils.extend({}, context, options.hash);
					if(options.ids) {
						options.ids[0] = true;
					}
				}
				
				partial = env.VM.resolvePartial.call(this, partial, context, options);
				var result = env.VM.invokePartial.call(this, partial, context, options);
				
				if(result == null && env.compile) {
					options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
					result = options.partials[options.name](context, options);
				}
				if(result != null) {
					if(options.indent) {
						var lines = result.split('\n');
						for(var i = 0, l = lines.length; i < l; i++) {
							if(!lines[i] && i + 1 === l) {
								break;
							}
							
							lines[i] = options.indent + lines[i];
						}
						result = lines.join('\n');
					}
					return result;
				} else {
					throw new _exception2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');
				}
			}
			
			// Just add water
			var container = {
				strict: function strict(obj, name) {
					if(!(name in obj)) {
						throw new _exception2['default']('"' + name + '" not defined in ' + obj);
					}
					return obj[name];
				},
				lookup: function lookup(depths, name) {
					var len = depths.length;
					for(var i = 0; i < len; i++) {
						if(depths[i] && depths[i][name] != null) {
							return depths[i][name];
						}
					}
				},
				lambda: function lambda(current, context) {
					return typeof current === 'function' ? current.call(context) : current;
				},
				
				escapeExpression: Utils.escapeExpression,
				invokePartial: invokePartialWrapper,
				
				fn: function fn(i) {
					var ret = templateSpec[i];
					ret.decorator = templateSpec[i + '_d'];
					return ret;
				},
				
				programs: [],
				program: function program(i, data, declaredBlockParams, blockParams, depths) {
					var programWrapper = this.programs[i],
						fn = this.fn(i);
					if(data || depths || blockParams || declaredBlockParams) {
						programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
					} else if(!programWrapper) {
						programWrapper = this.programs[i] = wrapProgram(this, i, fn);
					}
					return programWrapper;
				},
				
				data: function data(value, depth) {
					while(value && depth--) {
						value = value._parent;
					}
					return value;
				},
				merge: function merge(param, common) {
					var obj = param || common;
					
					if(param && common && param !== common) {
						obj = Utils.extend({}, common, param);
					}
					
					return obj;
				},
				// An empty object to use as replacement for null-contexts
				nullContext: Object.seal({}),
				
				noop: env.VM.noop,
				compilerInfo: templateSpec.compiler
			};
			
			function ret(context) {
				var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
				
				var data = options.data;
				
				ret._setup(options);
				if(!options.partial && templateSpec.useData) {
					data = initData(context, data);
				}
				var depths = undefined,
					blockParams = templateSpec.useBlockParams ? [] : undefined;
				if(templateSpec.useDepths) {
					if(options.depths) {
						depths = context != options.depths[0] ? [context].concat(options.depths) : options.depths;
					} else {
						depths = [context];
					}
				}
				
				function main(context /*, options*/) {
					return '' + templateSpec.main(container, context, container.helpers, container.partials, data, blockParams, depths);
				}
				
				main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
				return main(context, options);
			}
			
			ret.isTop = true;
			
			ret._setup = function(options) {
				if(!options.partial) {
					container.helpers = container.merge(options.helpers, env.helpers);
					
					if(templateSpec.usePartial) {
						container.partials = container.merge(options.partials, env.partials);
					}
					if(templateSpec.usePartial || templateSpec.useDecorators) {
						container.decorators = container.merge(options.decorators, env.decorators);
					}
				} else {
					container.helpers = options.helpers;
					container.partials = options.partials;
					container.decorators = options.decorators;
				}
			};
			
			ret._child = function(i, data, blockParams, depths) {
				if(templateSpec.useBlockParams && !blockParams) {
					throw new _exception2['default']('must pass block params');
				}
				if(templateSpec.useDepths && !depths) {
					throw new _exception2['default']('must pass parent depths');
				}
				
				return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
			};
			return ret;
		}
		
		function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
			function prog(context) {
				var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
				
				var currentDepths = depths;
				if(depths && context != depths[0] && !(context === container.nullContext && depths[0] === null)) {
					currentDepths = [context].concat(depths);
				}
				
				return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
			}
			
			prog = executeDecorators(fn, prog, container, depths, data, blockParams);
			
			prog.program = i;
			prog.depth = depths ? depths.length : 0;
			prog.blockParams = declaredBlockParams || 0;
			return prog;
		}
		
		function resolvePartial(partial, context, options) {
			if(!partial) {
				if(options.name === '@partial-block') {
					partial = options.data['partial-block'];
				} else {
					partial = options.partials[options.name];
				}
			} else if(!partial.call && !options.name) {
				// This is a dynamic partial that returned a string
				options.name = partial;
				partial = options.partials[partial];
			}
			return partial;
		}
		
		function invokePartial(partial, context, options) {
			// Use the current closure context to save the partial-block if this partial
			var currentPartialBlock = options.data && options.data['partial-block'];
			options.partial = true;
			if(options.ids) {
				options.data.contextPath = options.ids[0] || options.data.contextPath;
			}
			
			var partialBlock = undefined;
			if(options.fn && options.fn !== noop) {
				(function() {
					options.data = _base.createFrame(options.data);
					// Wrapper function to get access to currentPartialBlock from the closure
					var fn = options.fn;
					partialBlock = options.data['partial-block'] = function partialBlockWrapper(context) {
						var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
						
						// Restore the partial-block from the closure for the execution of the block
						// i.e. the part inside the block of the partial call.
						options.data = _base.createFrame(options.data);
						options.data['partial-block'] = currentPartialBlock;
						return fn(context, options);
					};
					if(fn.partials) {
						options.partials = Utils.extend({}, options.partials, fn.partials);
					}
				})();
			}
			
			if(partial === undefined && partialBlock) {
				partial = partialBlock;
			}
			
			if(partial === undefined) {
				throw new _exception2['default']('The partial ' + options.name + ' could not be found');
			} else if(partial instanceof Function) {
				return partial(context, options);
			}
		}
		
		function noop() {
			return '';
		}
		
		function initData(context, data) {
			if(!data || !('root' in data)) {
				data = data ? _base.createFrame(data) : {};
				data.root = context;
			}
			return data;
		}
		
		function executeDecorators(fn, prog, container, depths, data, blockParams) {
			if(fn.decorator) {
				var props = {};
				prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
				Utils.extend(prog, props);
			}
			return prog;
		}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL3J1bnRpbWUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7cUJBQXVCLFNBQVM7O0lBQXBCLEtBQUs7O3lCQUNLLGFBQWE7Ozs7b0JBQzhCLFFBQVE7O0FBRWxFLFNBQVMsYUFBYSxDQUFDLFlBQVksRUFBRTtBQUMxQyxNQUFNLGdCQUFnQixHQUFHLFlBQVksSUFBSSxZQUFZLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztNQUN2RCxlQUFlLDBCQUFvQixDQUFDOztBQUUxQyxNQUFJLGdCQUFnQixLQUFLLGVBQWUsRUFBRTtBQUN4QyxRQUFJLGdCQUFnQixHQUFHLGVBQWUsRUFBRTtBQUN0QyxVQUFNLGVBQWUsR0FBRyx1QkFBaUIsZUFBZSxDQUFDO1VBQ25ELGdCQUFnQixHQUFHLHVCQUFpQixnQkFBZ0IsQ0FBQyxDQUFDO0FBQzVELFlBQU0sMkJBQWMseUZBQXlGLEdBQ3ZHLHFEQUFxRCxHQUFHLGVBQWUsR0FBRyxtREFBbUQsR0FBRyxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsQ0FBQztLQUNoSyxNQUFNOztBQUVMLFlBQU0sMkJBQWMsd0ZBQXdGLEdBQ3RHLGlEQUFpRCxHQUFHLFlBQVksQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQztLQUNuRjtHQUNGO0NBQ0Y7O0FBRU0sU0FBUyxRQUFRLENBQUMsWUFBWSxFQUFFLEdBQUcsRUFBRTs7QUFFMUMsTUFBSSxDQUFDLEdBQUcsRUFBRTtBQUNSLFVBQU0sMkJBQWMsbUNBQW1DLENBQUMsQ0FBQztHQUMxRDtBQUNELE1BQUksQ0FBQyxZQUFZLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFO0FBQ3ZDLFVBQU0sMkJBQWMsMkJBQTJCLEdBQUcsT0FBTyxZQUFZLENBQUMsQ0FBQztHQUN4RTs7QUFFRCxjQUFZLENBQUMsSUFBSSxDQUFDLFNBQVMsR0FBRyxZQUFZLENBQUMsTUFBTSxDQUFDOzs7O0FBSWxELEtBQUcsQ0FBQyxFQUFFLENBQUMsYUFBYSxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FBQzs7QUFFNUMsV0FBUyxvQkFBb0IsQ0FBQyxPQUFPLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRTtBQUN2RCxRQUFJLE9BQU8sQ0FBQyxJQUFJLEVBQUU7QUFDaEIsYUFBTyxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLE9BQU8sRUFBRSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDbEQsVUFBSSxPQUFPLENBQUMsR0FBRyxFQUFFO0FBQ2YsZUFBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM7T0FDdkI7S0FDRjs7QUFFRCxXQUFPLEdBQUcsR0FBRyxDQUFDLEVBQUUsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0FBQ3RFLFFBQUksTUFBTSxHQUFHLEdBQUcsQ0FBQyxFQUFFLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQzs7QUFFeEUsUUFBSSxNQUFNLElBQUksSUFBSSxJQUFJLEdBQUcsQ0FBQyxPQUFPLEVBQUU7QUFDakMsYUFBTyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsR0FBRyxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsWUFBWSxDQUFDLGVBQWUsRUFBRSxHQUFHLENBQUMsQ0FBQztBQUN6RixZQUFNLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0tBQzNEO0FBQ0QsUUFBSSxNQUFNLElBQUksSUFBSSxFQUFFO0FBQ2xCLFVBQUksT0FBTyxDQUFDLE1BQU0sRUFBRTtBQUNsQixZQUFJLEtBQUssR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQy9CLGFBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDNUMsY0FBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsRUFBRTtBQUM1QixrQkFBTTtXQUNQOztBQUVELGVBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUN0QztBQUNELGNBQU0sR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO09BQzNCO0FBQ0QsYUFBTyxNQUFNLENBQUM7S0FDZixNQUFNO0FBQ0wsWUFBTSwyQkFBYyxjQUFjLEdBQUcsT0FBTyxDQUFDLElBQUksR0FBRywwREFBMEQsQ0FBQyxDQUFDO0tBQ2pIO0dBQ0Y7OztBQUdELE1BQUksU0FBUyxHQUFHO0FBQ2QsVUFBTSxFQUFFLGdCQUFTLEdBQUcsRUFBRSxJQUFJLEVBQUU7QUFDMUIsVUFBSSxFQUFFLElBQUksSUFBSSxHQUFHLENBQUEsQUFBQyxFQUFFO0FBQ2xCLGNBQU0sMkJBQWMsR0FBRyxHQUFHLElBQUksR0FBRyxtQkFBbUIsR0FBRyxHQUFHLENBQUMsQ0FBQztPQUM3RDtBQUNELGFBQU8sR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQ2xCO0FBQ0QsVUFBTSxFQUFFLGdCQUFTLE1BQU0sRUFBRSxJQUFJLEVBQUU7QUFDN0IsVUFBTSxHQUFHLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQztBQUMxQixXQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQzVCLFlBQUksTUFBTSxDQUFDLENBQUMsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxJQUFJLEVBQUU7QUFDeEMsaUJBQU8sTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ3hCO09BQ0Y7S0FDRjtBQUNELFVBQU0sRUFBRSxnQkFBUyxPQUFPLEVBQUUsT0FBTyxFQUFFO0FBQ2pDLGFBQU8sT0FBTyxPQUFPLEtBQUssVUFBVSxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsT0FBTyxDQUFDO0tBQ3hFOztBQUVELG9CQUFnQixFQUFFLEtBQUssQ0FBQyxnQkFBZ0I7QUFDeEMsaUJBQWEsRUFBRSxvQkFBb0I7O0FBRW5DLE1BQUUsRUFBRSxZQUFTLENBQUMsRUFBRTtBQUNkLFVBQUksR0FBRyxHQUFHLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUMxQixTQUFHLENBQUMsU0FBUyxHQUFHLFlBQVksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUM7QUFDdkMsYUFBTyxHQUFHLENBQUM7S0FDWjs7QUFFRCxZQUFRLEVBQUUsRUFBRTtBQUNaLFdBQU8sRUFBRSxpQkFBUyxDQUFDLEVBQUUsSUFBSSxFQUFFLG1CQUFtQixFQUFFLFdBQVcsRUFBRSxNQUFNLEVBQUU7QUFDbkUsVUFBSSxjQUFjLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7VUFDakMsRUFBRSxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDcEIsVUFBSSxJQUFJLElBQUksTUFBTSxJQUFJLFdBQVcsSUFBSSxtQkFBbUIsRUFBRTtBQUN4RCxzQkFBYyxHQUFHLFdBQVcsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxJQUFJLEVBQUUsbUJBQW1CLEVBQUUsV0FBVyxFQUFFLE1BQU0sQ0FBQyxDQUFDO09BQzNGLE1BQU0sSUFBSSxDQUFDLGNBQWMsRUFBRTtBQUMxQixzQkFBYyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEdBQUcsV0FBVyxDQUFDLElBQUksRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7T0FDOUQ7QUFDRCxhQUFPLGNBQWMsQ0FBQztLQUN2Qjs7QUFFRCxRQUFJLEVBQUUsY0FBUyxLQUFLLEVBQUUsS0FBSyxFQUFFO0FBQzNCLGFBQU8sS0FBSyxJQUFJLEtBQUssRUFBRSxFQUFFO0FBQ3ZCLGFBQUssR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDO09BQ3ZCO0FBQ0QsYUFBTyxLQUFLLENBQUM7S0FDZDtBQUNELFNBQUssRUFBRSxlQUFTLEtBQUssRUFBRSxNQUFNLEVBQUU7QUFDN0IsVUFBSSxHQUFHLEdBQUcsS0FBSyxJQUFJLE1BQU0sQ0FBQzs7QUFFMUIsVUFBSSxLQUFLLElBQUksTUFBTSxJQUFLLEtBQUssS0FBSyxNQUFNLEFBQUMsRUFBRTtBQUN6QyxXQUFHLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUFDO09BQ3ZDOztBQUVELGFBQU8sR0FBRyxDQUFDO0tBQ1o7O0FBRUQsZUFBVyxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDOztBQUU1QixRQUFJLEVBQUUsR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJO0FBQ2pCLGdCQUFZLEVBQUUsWUFBWSxDQUFDLFFBQVE7R0FDcEMsQ0FBQzs7QUFFRixXQUFTLEdBQUcsQ0FBQyxPQUFPLEVBQWdCO1FBQWQsT0FBTyx5REFBRyxFQUFFOztBQUNoQyxRQUFJLElBQUksR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDOztBQUV4QixPQUFHLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQ3BCLFFBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxJQUFJLFlBQVksQ0FBQyxPQUFPLEVBQUU7QUFDNUMsVUFBSSxHQUFHLFFBQVEsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLENBQUM7S0FDaEM7QUFDRCxRQUFJLE1BQU0sWUFBQTtRQUNOLFdBQVcsR0FBRyxZQUFZLENBQUMsY0FBYyxHQUFHLEVBQUUsR0FBRyxTQUFTLENBQUM7QUFDL0QsUUFBSSxZQUFZLENBQUMsU0FBUyxFQUFFO0FBQzFCLFVBQUksT0FBTyxDQUFDLE1BQU0sRUFBRTtBQUNsQixjQUFNLEdBQUcsT0FBTyxJQUFJLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUM7T0FDM0YsTUFBTTtBQUNMLGNBQU0sR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO09BQ3BCO0tBQ0Y7O0FBRUQsYUFBUyxJQUFJLENBQUMsT0FBTyxnQkFBZTtBQUNsQyxhQUFPLEVBQUUsR0FBRyxZQUFZLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxPQUFPLEVBQUUsU0FBUyxDQUFDLE9BQU8sRUFBRSxTQUFTLENBQUMsUUFBUSxFQUFFLElBQUksRUFBRSxXQUFXLEVBQUUsTUFBTSxDQUFDLENBQUM7S0FDckg7QUFDRCxRQUFJLEdBQUcsaUJBQWlCLENBQUMsWUFBWSxDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLE9BQU8sQ0FBQyxNQUFNLElBQUksRUFBRSxFQUFFLElBQUksRUFBRSxXQUFXLENBQUMsQ0FBQztBQUN0RyxXQUFPLElBQUksQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7R0FDL0I7QUFDRCxLQUFHLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQzs7QUFFakIsS0FBRyxDQUFDLE1BQU0sR0FBRyxVQUFTLE9BQU8sRUFBRTtBQUM3QixRQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRTtBQUNwQixlQUFTLENBQUMsT0FBTyxHQUFHLFNBQVMsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUM7O0FBRWxFLFVBQUksWUFBWSxDQUFDLFVBQVUsRUFBRTtBQUMzQixpQkFBUyxDQUFDLFFBQVEsR0FBRyxTQUFTLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUUsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDO09BQ3RFO0FBQ0QsVUFBSSxZQUFZLENBQUMsVUFBVSxJQUFJLFlBQVksQ0FBQyxhQUFhLEVBQUU7QUFDekQsaUJBQVMsQ0FBQyxVQUFVLEdBQUcsU0FBUyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsVUFBVSxFQUFFLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQztPQUM1RTtLQUNGLE1BQU07QUFDTCxlQUFTLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUM7QUFDcEMsZUFBUyxDQUFDLFFBQVEsR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDO0FBQ3RDLGVBQVMsQ0FBQyxVQUFVLEdBQUcsT0FBTyxDQUFDLFVBQVUsQ0FBQztLQUMzQztHQUNGLENBQUM7O0FBRUYsS0FBRyxDQUFDLE1BQU0sR0FBRyxVQUFTLENBQUMsRUFBRSxJQUFJLEVBQUUsV0FBVyxFQUFFLE1BQU0sRUFBRTtBQUNsRCxRQUFJLFlBQVksQ0FBQyxjQUFjLElBQUksQ0FBQyxXQUFXLEVBQUU7QUFDL0MsWUFBTSwyQkFBYyx3QkFBd0IsQ0FBQyxDQUFDO0tBQy9DO0FBQ0QsUUFBSSxZQUFZLENBQUMsU0FBUyxJQUFJLENBQUMsTUFBTSxFQUFFO0FBQ3JDLFlBQU0sMkJBQWMseUJBQXlCLENBQUMsQ0FBQztLQUNoRDs7QUFFRCxXQUFPLFdBQVcsQ0FBQyxTQUFTLEVBQUUsQ0FBQyxFQUFFLFlBQVksQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsQ0FBQyxFQUFFLFdBQVcsRUFBRSxNQUFNLENBQUMsQ0FBQztHQUNqRixDQUFDO0FBQ0YsU0FBTyxHQUFHLENBQUM7Q0FDWjs7QUFFTSxTQUFTLFdBQVcsQ0FBQyxTQUFTLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxJQUFJLEVBQUUsbUJBQW1CLEVBQUUsV0FBVyxFQUFFLE1BQU0sRUFBRTtBQUM1RixXQUFTLElBQUksQ0FBQyxPQUFPLEVBQWdCO1FBQWQsT0FBTyx5REFBRyxFQUFFOztBQUNqQyxRQUFJLGFBQWEsR0FBRyxNQUFNLENBQUM7QUFDM0IsUUFBSSxNQUFNLElBQUksT0FBTyxJQUFJLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLE9BQU8sS0FBSyxTQUFTLENBQUMsV0FBVyxJQUFJLE1BQU0sQ0FBQyxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUEsQUFBQyxFQUFFO0FBQ2hHLG1CQUFhLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7S0FDMUM7O0FBRUQsV0FBTyxFQUFFLENBQUMsU0FBUyxFQUNmLE9BQU8sRUFDUCxTQUFTLENBQUMsT0FBTyxFQUFFLFNBQVMsQ0FBQyxRQUFRLEVBQ3JDLE9BQU8sQ0FBQyxJQUFJLElBQUksSUFBSSxFQUNwQixXQUFXLElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxFQUN4RCxhQUFhLENBQUMsQ0FBQztHQUNwQjs7QUFFRCxNQUFJLEdBQUcsaUJBQWlCLENBQUMsRUFBRSxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxXQUFXLENBQUMsQ0FBQzs7QUFFekUsTUFBSSxDQUFDLE9BQU8sR0FBRyxDQUFDLENBQUM7QUFDakIsTUFBSSxDQUFDLEtBQUssR0FBRyxNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7QUFDeEMsTUFBSSxDQUFDLFdBQVcsR0FBRyxtQkFBbUIsSUFBSSxDQUFDLENBQUM7QUFDNUMsU0FBTyxJQUFJLENBQUM7Q0FDYjs7QUFFTSxTQUFTLGNBQWMsQ0FBQyxPQUFPLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRTtBQUN4RCxNQUFJLENBQUMsT0FBTyxFQUFFO0FBQ1osUUFBSSxPQUFPLENBQUMsSUFBSSxLQUFLLGdCQUFnQixFQUFFO0FBQ3JDLGFBQU8sR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDO0tBQ3pDLE1BQU07QUFDTCxhQUFPLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDMUM7R0FDRixNQUFNLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRTs7QUFFekMsV0FBTyxDQUFDLElBQUksR0FBRyxPQUFPLENBQUM7QUFDdkIsV0FBTyxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUM7R0FDckM7QUFDRCxTQUFPLE9BQU8sQ0FBQztDQUNoQjs7QUFFTSxTQUFTLGFBQWEsQ0FBQyxPQUFPLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRTs7QUFFdkQsTUFBTSxtQkFBbUIsR0FBRyxPQUFPLENBQUMsSUFBSSxJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUM7QUFDMUUsU0FBTyxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUM7QUFDdkIsTUFBSSxPQUFPLENBQUMsR0FBRyxFQUFFO0FBQ2YsV0FBTyxDQUFDLElBQUksQ0FBQyxXQUFXLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQztHQUN2RTs7QUFFRCxNQUFJLFlBQVksWUFBQSxDQUFDO0FBQ2pCLE1BQUksT0FBTyxDQUFDLEVBQUUsSUFBSSxPQUFPLENBQUMsRUFBRSxLQUFLLElBQUksRUFBRTs7QUFDckMsYUFBTyxDQUFDLElBQUksR0FBRyxrQkFBWSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7O0FBRXpDLFVBQUksRUFBRSxHQUFHLE9BQU8sQ0FBQyxFQUFFLENBQUM7QUFDcEIsa0JBQVksR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxHQUFHLFNBQVMsbUJBQW1CLENBQUMsT0FBTyxFQUFnQjtZQUFkLE9BQU8seURBQUcsRUFBRTs7OztBQUkvRixlQUFPLENBQUMsSUFBSSxHQUFHLGtCQUFZLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUN6QyxlQUFPLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxHQUFHLG1CQUFtQixDQUFDO0FBQ3BELGVBQU8sRUFBRSxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztPQUM3QixDQUFDO0FBQ0YsVUFBSSxFQUFFLENBQUMsUUFBUSxFQUFFO0FBQ2YsZUFBTyxDQUFDLFFBQVEsR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxPQUFPLENBQUMsUUFBUSxFQUFFLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQztPQUNwRTs7R0FDRjs7QUFFRCxNQUFJLE9BQU8sS0FBSyxTQUFTLElBQUksWUFBWSxFQUFFO0FBQ3pDLFdBQU8sR0FBRyxZQUFZLENBQUM7R0FDeEI7O0FBRUQsTUFBSSxPQUFPLEtBQUssU0FBUyxFQUFFO0FBQ3pCLFVBQU0sMkJBQWMsY0FBYyxHQUFHLE9BQU8sQ0FBQyxJQUFJLEdBQUcscUJBQXFCLENBQUMsQ0FBQztHQUM1RSxNQUFNLElBQUksT0FBTyxZQUFZLFFBQVEsRUFBRTtBQUN0QyxXQUFPLE9BQU8sQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7R0FDbEM7Q0FDRjs7QUFFTSxTQUFTLElBQUksR0FBRztBQUFFLFNBQU8sRUFBRSxDQUFDO0NBQUU7O0FBRXJDLFNBQVMsUUFBUSxDQUFDLE9BQU8sRUFBRSxJQUFJLEVBQUU7QUFDL0IsTUFBSSxDQUFDLElBQUksSUFBSSxFQUFFLE1BQU0sSUFBSSxJQUFJLENBQUEsQUFBQyxFQUFFO0FBQzlCLFFBQUksR0FBRyxJQUFJLEdBQUcsa0JBQVksSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO0FBQ3JDLFFBQUksQ0FBQyxJQUFJLEdBQUcsT0FBTyxDQUFDO0dBQ3JCO0FBQ0QsU0FBTyxJQUFJLENBQUM7Q0FDYjs7QUFFRCxTQUFTLGlCQUFpQixDQUFDLEVBQUUsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsV0FBVyxFQUFFO0FBQ3pFLE1BQUksRUFBRSxDQUFDLFNBQVMsRUFBRTtBQUNoQixRQUFJLEtBQUssR0FBRyxFQUFFLENBQUM7QUFDZixRQUFJLEdBQUcsRUFBRSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxNQUFNLElBQUksTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBRSxXQUFXLEVBQUUsTUFBTSxDQUFDLENBQUM7QUFDNUYsU0FBSyxDQUFDLE1BQU0sQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUM7R0FDM0I7QUFDRCxTQUFPLElBQUksQ0FBQztDQUNiIiwiZmlsZSI6InJ1bnRpbWUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBVdGlscyBmcm9tICcuL3V0aWxzJztcbmltcG9ydCBFeGNlcHRpb24gZnJvbSAnLi9leGNlcHRpb24nO1xuaW1wb3J0IHsgQ09NUElMRVJfUkVWSVNJT04sIFJFVklTSU9OX0NIQU5HRVMsIGNyZWF0ZUZyYW1lIH0gZnJvbSAnLi9iYXNlJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrUmV2aXNpb24oY29tcGlsZXJJbmZvKSB7XG4gIGNvbnN0IGNvbXBpbGVyUmV2aXNpb24gPSBjb21waWxlckluZm8gJiYgY29tcGlsZXJJbmZvWzBdIHx8IDEsXG4gICAgICAgIGN1cnJlbnRSZXZpc2lvbiA9IENPTVBJTEVSX1JFVklTSU9OO1xuXG4gIGlmIChjb21waWxlclJldmlzaW9uICE9PSBjdXJyZW50UmV2aXNpb24pIHtcbiAgICBpZiAoY29tcGlsZXJSZXZpc2lvbiA8IGN1cnJlbnRSZXZpc2lvbikge1xuICAgICAgY29uc3QgcnVudGltZVZlcnNpb25zID0gUkVWSVNJT05fQ0hBTkdFU1tjdXJyZW50UmV2aXNpb25dLFxuICAgICAgICAgICAgY29tcGlsZXJWZXJzaW9ucyA9IFJFVklTSU9OX0NIQU5HRVNbY29tcGlsZXJSZXZpc2lvbl07XG4gICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdUZW1wbGF0ZSB3YXMgcHJlY29tcGlsZWQgd2l0aCBhbiBvbGRlciB2ZXJzaW9uIG9mIEhhbmRsZWJhcnMgdGhhbiB0aGUgY3VycmVudCBydW50aW1lLiAnICtcbiAgICAgICAgICAgICdQbGVhc2UgdXBkYXRlIHlvdXIgcHJlY29tcGlsZXIgdG8gYSBuZXdlciB2ZXJzaW9uICgnICsgcnVudGltZVZlcnNpb25zICsgJykgb3IgZG93bmdyYWRlIHlvdXIgcnVudGltZSB0byBhbiBvbGRlciB2ZXJzaW9uICgnICsgY29tcGlsZXJWZXJzaW9ucyArICcpLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVc2UgdGhlIGVtYmVkZGVkIHZlcnNpb24gaW5mbyBzaW5jZSB0aGUgcnVudGltZSBkb2Vzbid0IGtub3cgYWJvdXQgdGhpcyByZXZpc2lvbiB5ZXRcbiAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ1RlbXBsYXRlIHdhcyBwcmVjb21waWxlZCB3aXRoIGEgbmV3ZXIgdmVyc2lvbiBvZiBIYW5kbGViYXJzIHRoYW4gdGhlIGN1cnJlbnQgcnVudGltZS4gJyArXG4gICAgICAgICAgICAnUGxlYXNlIHVwZGF0ZSB5b3VyIHJ1bnRpbWUgdG8gYSBuZXdlciB2ZXJzaW9uICgnICsgY29tcGlsZXJJbmZvWzFdICsgJykuJyk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZW1wbGF0ZSh0ZW1wbGF0ZVNwZWMsIGVudikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBpZiAoIWVudikge1xuICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ05vIGVudmlyb25tZW50IHBhc3NlZCB0byB0ZW1wbGF0ZScpO1xuICB9XG4gIGlmICghdGVtcGxhdGVTcGVjIHx8ICF0ZW1wbGF0ZVNwZWMubWFpbikge1xuICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ1Vua25vd24gdGVtcGxhdGUgb2JqZWN0OiAnICsgdHlwZW9mIHRlbXBsYXRlU3BlYyk7XG4gIH1cblxuICB0ZW1wbGF0ZVNwZWMubWFpbi5kZWNvcmF0b3IgPSB0ZW1wbGF0ZVNwZWMubWFpbl9kO1xuXG4gIC8vIE5vdGU6IFVzaW5nIGVudi5WTSByZWZlcmVuY2VzIHJhdGhlciB0aGFuIGxvY2FsIHZhciByZWZlcmVuY2VzIHRocm91Z2hvdXQgdGhpcyBzZWN0aW9uIHRvIGFsbG93XG4gIC8vIGZvciBleHRlcm5hbCB1c2VycyB0byBvdmVycmlkZSB0aGVzZSBhcyBwc3VlZG8tc3VwcG9ydGVkIEFQSXMuXG4gIGVudi5WTS5jaGVja1JldmlzaW9uKHRlbXBsYXRlU3BlYy5jb21waWxlcik7XG5cbiAgZnVuY3Rpb24gaW52b2tlUGFydGlhbFdyYXBwZXIocGFydGlhbCwgY29udGV4dCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmhhc2gpIHtcbiAgICAgIGNvbnRleHQgPSBVdGlscy5leHRlbmQoe30sIGNvbnRleHQsIG9wdGlvbnMuaGFzaCk7XG4gICAgICBpZiAob3B0aW9ucy5pZHMpIHtcbiAgICAgICAgb3B0aW9ucy5pZHNbMF0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBhcnRpYWwgPSBlbnYuVk0ucmVzb2x2ZVBhcnRpYWwuY2FsbCh0aGlzLCBwYXJ0aWFsLCBjb250ZXh0LCBvcHRpb25zKTtcbiAgICBsZXQgcmVzdWx0ID0gZW52LlZNLmludm9rZVBhcnRpYWwuY2FsbCh0aGlzLCBwYXJ0aWFsLCBjb250ZXh0LCBvcHRpb25zKTtcblxuICAgIGlmIChyZXN1bHQgPT0gbnVsbCAmJiBlbnYuY29tcGlsZSkge1xuICAgICAgb3B0aW9ucy5wYXJ0aWFsc1tvcHRpb25zLm5hbWVdID0gZW52LmNvbXBpbGUocGFydGlhbCwgdGVtcGxhdGVTcGVjLmNvbXBpbGVyT3B0aW9ucywgZW52KTtcbiAgICAgIHJlc3VsdCA9IG9wdGlvbnMucGFydGlhbHNbb3B0aW9ucy5uYW1lXShjb250ZXh0LCBvcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdCAhPSBudWxsKSB7XG4gICAgICBpZiAob3B0aW9ucy5pbmRlbnQpIHtcbiAgICAgICAgbGV0IGxpbmVzID0gcmVzdWx0LnNwbGl0KCdcXG4nKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBsaW5lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBpZiAoIWxpbmVzW2ldICYmIGkgKyAxID09PSBsKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsaW5lc1tpXSA9IG9wdGlvbnMuaW5kZW50ICsgbGluZXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gbGluZXMuam9pbignXFxuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdUaGUgcGFydGlhbCAnICsgb3B0aW9ucy5uYW1lICsgJyBjb3VsZCBub3QgYmUgY29tcGlsZWQgd2hlbiBydW5uaW5nIGluIHJ1bnRpbWUtb25seSBtb2RlJyk7XG4gICAgfVxuICB9XG5cbiAgLy8gSnVzdCBhZGQgd2F0ZXJcbiAgbGV0IGNvbnRhaW5lciA9IHtcbiAgICBzdHJpY3Q6IGZ1bmN0aW9uKG9iaiwgbmFtZSkge1xuICAgICAgaWYgKCEobmFtZSBpbiBvYmopKSB7XG4gICAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ1wiJyArIG5hbWUgKyAnXCIgbm90IGRlZmluZWQgaW4gJyArIG9iaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqW25hbWVdO1xuICAgIH0sXG4gICAgbG9va3VwOiBmdW5jdGlvbihkZXB0aHMsIG5hbWUpIHtcbiAgICAgIGNvbnN0IGxlbiA9IGRlcHRocy5sZW5ndGg7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChkZXB0aHNbaV0gJiYgZGVwdGhzW2ldW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZGVwdGhzW2ldW25hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBsYW1iZGE6IGZ1bmN0aW9uKGN1cnJlbnQsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgY3VycmVudCA9PT0gJ2Z1bmN0aW9uJyA/IGN1cnJlbnQuY2FsbChjb250ZXh0KSA6IGN1cnJlbnQ7XG4gICAgfSxcblxuICAgIGVzY2FwZUV4cHJlc3Npb246IFV0aWxzLmVzY2FwZUV4cHJlc3Npb24sXG4gICAgaW52b2tlUGFydGlhbDogaW52b2tlUGFydGlhbFdyYXBwZXIsXG5cbiAgICBmbjogZnVuY3Rpb24oaSkge1xuICAgICAgbGV0IHJldCA9IHRlbXBsYXRlU3BlY1tpXTtcbiAgICAgIHJldC5kZWNvcmF0b3IgPSB0ZW1wbGF0ZVNwZWNbaSArICdfZCddO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuXG4gICAgcHJvZ3JhbXM6IFtdLFxuICAgIHByb2dyYW06IGZ1bmN0aW9uKGksIGRhdGEsIGRlY2xhcmVkQmxvY2tQYXJhbXMsIGJsb2NrUGFyYW1zLCBkZXB0aHMpIHtcbiAgICAgIGxldCBwcm9ncmFtV3JhcHBlciA9IHRoaXMucHJvZ3JhbXNbaV0sXG4gICAgICAgICAgZm4gPSB0aGlzLmZuKGkpO1xuICAgICAgaWYgKGRhdGEgfHwgZGVwdGhzIHx8IGJsb2NrUGFyYW1zIHx8IGRlY2xhcmVkQmxvY2tQYXJhbXMpIHtcbiAgICAgICAgcHJvZ3JhbVdyYXBwZXIgPSB3cmFwUHJvZ3JhbSh0aGlzLCBpLCBmbiwgZGF0YSwgZGVjbGFyZWRCbG9ja1BhcmFtcywgYmxvY2tQYXJhbXMsIGRlcHRocyk7XG4gICAgICB9IGVsc2UgaWYgKCFwcm9ncmFtV3JhcHBlcikge1xuICAgICAgICBwcm9ncmFtV3JhcHBlciA9IHRoaXMucHJvZ3JhbXNbaV0gPSB3cmFwUHJvZ3JhbSh0aGlzLCBpLCBmbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvZ3JhbVdyYXBwZXI7XG4gICAgfSxcblxuICAgIGRhdGE6IGZ1bmN0aW9uKHZhbHVlLCBkZXB0aCkge1xuICAgICAgd2hpbGUgKHZhbHVlICYmIGRlcHRoLS0pIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5fcGFyZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgbWVyZ2U6IGZ1bmN0aW9uKHBhcmFtLCBjb21tb24pIHtcbiAgICAgIGxldCBvYmogPSBwYXJhbSB8fCBjb21tb247XG5cbiAgICAgIGlmIChwYXJhbSAmJiBjb21tb24gJiYgKHBhcmFtICE9PSBjb21tb24pKSB7XG4gICAgICAgIG9iaiA9IFV0aWxzLmV4dGVuZCh7fSwgY29tbW9uLCBwYXJhbSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICAvLyBBbiBlbXB0eSBvYmplY3QgdG8gdXNlIGFzIHJlcGxhY2VtZW50IGZvciBudWxsLWNvbnRleHRzXG4gICAgbnVsbENvbnRleHQ6IE9iamVjdC5zZWFsKHt9KSxcblxuICAgIG5vb3A6IGVudi5WTS5ub29wLFxuICAgIGNvbXBpbGVySW5mbzogdGVtcGxhdGVTcGVjLmNvbXBpbGVyXG4gIH07XG5cbiAgZnVuY3Rpb24gcmV0KGNvbnRleHQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBkYXRhID0gb3B0aW9ucy5kYXRhO1xuXG4gICAgcmV0Ll9zZXR1cChvcHRpb25zKTtcbiAgICBpZiAoIW9wdGlvbnMucGFydGlhbCAmJiB0ZW1wbGF0ZVNwZWMudXNlRGF0YSkge1xuICAgICAgZGF0YSA9IGluaXREYXRhKGNvbnRleHQsIGRhdGEpO1xuICAgIH1cbiAgICBsZXQgZGVwdGhzLFxuICAgICAgICBibG9ja1BhcmFtcyA9IHRlbXBsYXRlU3BlYy51c2VCbG9ja1BhcmFtcyA/IFtdIDogdW5kZWZpbmVkO1xuICAgIGlmICh0ZW1wbGF0ZVNwZWMudXNlRGVwdGhzKSB7XG4gICAgICBpZiAob3B0aW9ucy5kZXB0aHMpIHtcbiAgICAgICAgZGVwdGhzID0gY29udGV4dCAhPSBvcHRpb25zLmRlcHRoc1swXSA/IFtjb250ZXh0XS5jb25jYXQob3B0aW9ucy5kZXB0aHMpIDogb3B0aW9ucy5kZXB0aHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZXB0aHMgPSBbY29udGV4dF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFpbihjb250ZXh0LyosIG9wdGlvbnMqLykge1xuICAgICAgcmV0dXJuICcnICsgdGVtcGxhdGVTcGVjLm1haW4oY29udGFpbmVyLCBjb250ZXh0LCBjb250YWluZXIuaGVscGVycywgY29udGFpbmVyLnBhcnRpYWxzLCBkYXRhLCBibG9ja1BhcmFtcywgZGVwdGhzKTtcbiAgICB9XG4gICAgbWFpbiA9IGV4ZWN1dGVEZWNvcmF0b3JzKHRlbXBsYXRlU3BlYy5tYWluLCBtYWluLCBjb250YWluZXIsIG9wdGlvbnMuZGVwdGhzIHx8IFtdLCBkYXRhLCBibG9ja1BhcmFtcyk7XG4gICAgcmV0dXJuIG1haW4oY29udGV4dCwgb3B0aW9ucyk7XG4gIH1cbiAgcmV0LmlzVG9wID0gdHJ1ZTtcblxuICByZXQuX3NldHVwID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucy5wYXJ0aWFsKSB7XG4gICAgICBjb250YWluZXIuaGVscGVycyA9IGNvbnRhaW5lci5tZXJnZShvcHRpb25zLmhlbHBlcnMsIGVudi5oZWxwZXJzKTtcblxuICAgICAgaWYgKHRlbXBsYXRlU3BlYy51c2VQYXJ0aWFsKSB7XG4gICAgICAgIGNvbnRhaW5lci5wYXJ0aWFscyA9IGNvbnRhaW5lci5tZXJnZShvcHRpb25zLnBhcnRpYWxzLCBlbnYucGFydGlhbHMpO1xuICAgICAgfVxuICAgICAgaWYgKHRlbXBsYXRlU3BlYy51c2VQYXJ0aWFsIHx8IHRlbXBsYXRlU3BlYy51c2VEZWNvcmF0b3JzKSB7XG4gICAgICAgIGNvbnRhaW5lci5kZWNvcmF0b3JzID0gY29udGFpbmVyLm1lcmdlKG9wdGlvbnMuZGVjb3JhdG9ycywgZW52LmRlY29yYXRvcnMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb250YWluZXIuaGVscGVycyA9IG9wdGlvbnMuaGVscGVycztcbiAgICAgIGNvbnRhaW5lci5wYXJ0aWFscyA9IG9wdGlvbnMucGFydGlhbHM7XG4gICAgICBjb250YWluZXIuZGVjb3JhdG9ycyA9IG9wdGlvbnMuZGVjb3JhdG9ycztcbiAgICB9XG4gIH07XG5cbiAgcmV0Ll9jaGlsZCA9IGZ1bmN0aW9uKGksIGRhdGEsIGJsb2NrUGFyYW1zLCBkZXB0aHMpIHtcbiAgICBpZiAodGVtcGxhdGVTcGVjLnVzZUJsb2NrUGFyYW1zICYmICFibG9ja1BhcmFtcykge1xuICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbignbXVzdCBwYXNzIGJsb2NrIHBhcmFtcycpO1xuICAgIH1cbiAgICBpZiAodGVtcGxhdGVTcGVjLnVzZURlcHRocyAmJiAhZGVwdGhzKSB7XG4gICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdtdXN0IHBhc3MgcGFyZW50IGRlcHRocycpO1xuICAgIH1cblxuICAgIHJldHVybiB3cmFwUHJvZ3JhbShjb250YWluZXIsIGksIHRlbXBsYXRlU3BlY1tpXSwgZGF0YSwgMCwgYmxvY2tQYXJhbXMsIGRlcHRocyk7XG4gIH07XG4gIHJldHVybiByZXQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3cmFwUHJvZ3JhbShjb250YWluZXIsIGksIGZuLCBkYXRhLCBkZWNsYXJlZEJsb2NrUGFyYW1zLCBibG9ja1BhcmFtcywgZGVwdGhzKSB7XG4gIGZ1bmN0aW9uIHByb2coY29udGV4dCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgbGV0IGN1cnJlbnREZXB0aHMgPSBkZXB0aHM7XG4gICAgaWYgKGRlcHRocyAmJiBjb250ZXh0ICE9IGRlcHRoc1swXSAmJiAhKGNvbnRleHQgPT09IGNvbnRhaW5lci5udWxsQ29udGV4dCAmJiBkZXB0aHNbMF0gPT09IG51bGwpKSB7XG4gICAgICBjdXJyZW50RGVwdGhzID0gW2NvbnRleHRdLmNvbmNhdChkZXB0aHMpO1xuICAgIH1cblxuICAgIHJldHVybiBmbihjb250YWluZXIsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGNvbnRhaW5lci5oZWxwZXJzLCBjb250YWluZXIucGFydGlhbHMsXG4gICAgICAgIG9wdGlvbnMuZGF0YSB8fCBkYXRhLFxuICAgICAgICBibG9ja1BhcmFtcyAmJiBbb3B0aW9ucy5ibG9ja1BhcmFtc10uY29uY2F0KGJsb2NrUGFyYW1zKSxcbiAgICAgICAgY3VycmVudERlcHRocyk7XG4gIH1cblxuICBwcm9nID0gZXhlY3V0ZURlY29yYXRvcnMoZm4sIHByb2csIGNvbnRhaW5lciwgZGVwdGhzLCBkYXRhLCBibG9ja1BhcmFtcyk7XG5cbiAgcHJvZy5wcm9ncmFtID0gaTtcbiAgcHJvZy5kZXB0aCA9IGRlcHRocyA/IGRlcHRocy5sZW5ndGggOiAwO1xuICBwcm9nLmJsb2NrUGFyYW1zID0gZGVjbGFyZWRCbG9ja1BhcmFtcyB8fCAwO1xuICByZXR1cm4gcHJvZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVQYXJ0aWFsKHBhcnRpYWwsIGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgaWYgKCFwYXJ0aWFsKSB7XG4gICAgaWYgKG9wdGlvbnMubmFtZSA9PT0gJ0BwYXJ0aWFsLWJsb2NrJykge1xuICAgICAgcGFydGlhbCA9IG9wdGlvbnMuZGF0YVsncGFydGlhbC1ibG9jayddO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJ0aWFsID0gb3B0aW9ucy5wYXJ0aWFsc1tvcHRpb25zLm5hbWVdO1xuICAgIH1cbiAgfSBlbHNlIGlmICghcGFydGlhbC5jYWxsICYmICFvcHRpb25zLm5hbWUpIHtcbiAgICAvLyBUaGlzIGlzIGEgZHluYW1pYyBwYXJ0aWFsIHRoYXQgcmV0dXJuZWQgYSBzdHJpbmdcbiAgICBvcHRpb25zLm5hbWUgPSBwYXJ0aWFsO1xuICAgIHBhcnRpYWwgPSBvcHRpb25zLnBhcnRpYWxzW3BhcnRpYWxdO1xuICB9XG4gIHJldHVybiBwYXJ0aWFsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW52b2tlUGFydGlhbChwYXJ0aWFsLCBjb250ZXh0LCBvcHRpb25zKSB7XG4gIC8vIFVzZSB0aGUgY3VycmVudCBjbG9zdXJlIGNvbnRleHQgdG8gc2F2ZSB0aGUgcGFydGlhbC1ibG9jayBpZiB0aGlzIHBhcnRpYWxcbiAgY29uc3QgY3VycmVudFBhcnRpYWxCbG9jayA9IG9wdGlvbnMuZGF0YSAmJiBvcHRpb25zLmRhdGFbJ3BhcnRpYWwtYmxvY2snXTtcbiAgb3B0aW9ucy5wYXJ0aWFsID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMuaWRzKSB7XG4gICAgb3B0aW9ucy5kYXRhLmNvbnRleHRQYXRoID0gb3B0aW9ucy5pZHNbMF0gfHwgb3B0aW9ucy5kYXRhLmNvbnRleHRQYXRoO1xuICB9XG5cbiAgbGV0IHBhcnRpYWxCbG9jaztcbiAgaWYgKG9wdGlvbnMuZm4gJiYgb3B0aW9ucy5mbiAhPT0gbm9vcCkge1xuICAgIG9wdGlvbnMuZGF0YSA9IGNyZWF0ZUZyYW1lKG9wdGlvbnMuZGF0YSk7XG4gICAgLy8gV3JhcHBlciBmdW5jdGlvbiB0byBnZXQgYWNjZXNzIHRvIGN1cnJlbnRQYXJ0aWFsQmxvY2sgZnJvbSB0aGUgY2xvc3VyZVxuICAgIGxldCBmbiA9IG9wdGlvbnMuZm47XG4gICAgcGFydGlhbEJsb2NrID0gb3B0aW9ucy5kYXRhWydwYXJ0aWFsLWJsb2NrJ10gPSBmdW5jdGlvbiBwYXJ0aWFsQmxvY2tXcmFwcGVyKGNvbnRleHQsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAvLyBSZXN0b3JlIHRoZSBwYXJ0aWFsLWJsb2NrIGZyb20gdGhlIGNsb3N1cmUgZm9yIHRoZSBleGVjdXRpb24gb2YgdGhlIGJsb2NrXG4gICAgICAvLyBpLmUuIHRoZSBwYXJ0IGluc2lkZSB0aGUgYmxvY2sgb2YgdGhlIHBhcnRpYWwgY2FsbC5cbiAgICAgIG9wdGlvbnMuZGF0YSA9IGNyZWF0ZUZyYW1lKG9wdGlvbnMuZGF0YSk7XG4gICAgICBvcHRpb25zLmRhdGFbJ3BhcnRpYWwtYmxvY2snXSA9IGN1cnJlbnRQYXJ0aWFsQmxvY2s7XG4gICAgICByZXR1cm4gZm4oY29udGV4dCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBpZiAoZm4ucGFydGlhbHMpIHtcbiAgICAgIG9wdGlvbnMucGFydGlhbHMgPSBVdGlscy5leHRlbmQoe30sIG9wdGlvbnMucGFydGlhbHMsIGZuLnBhcnRpYWxzKTtcbiAgICB9XG4gIH1cblxuICBpZiAocGFydGlhbCA9PT0gdW5kZWZpbmVkICYmIHBhcnRpYWxCbG9jaykge1xuICAgIHBhcnRpYWwgPSBwYXJ0aWFsQmxvY2s7XG4gIH1cblxuICBpZiAocGFydGlhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEV4Y2VwdGlvbignVGhlIHBhcnRpYWwgJyArIG9wdGlvbnMubmFtZSArICcgY291bGQgbm90IGJlIGZvdW5kJyk7XG4gIH0gZWxzZSBpZiAocGFydGlhbCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgcmV0dXJuIHBhcnRpYWwoY29udGV4dCwgb3B0aW9ucyk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vb3AoKSB7IHJldHVybiAnJzsgfVxuXG5mdW5jdGlvbiBpbml0RGF0YShjb250ZXh0LCBkYXRhKSB7XG4gIGlmICghZGF0YSB8fCAhKCdyb290JyBpbiBkYXRhKSkge1xuICAgIGRhdGEgPSBkYXRhID8gY3JlYXRlRnJhbWUoZGF0YSkgOiB7fTtcbiAgICBkYXRhLnJvb3QgPSBjb250ZXh0O1xuICB9XG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBleGVjdXRlRGVjb3JhdG9ycyhmbiwgcHJvZywgY29udGFpbmVyLCBkZXB0aHMsIGRhdGEsIGJsb2NrUGFyYW1zKSB7XG4gIGlmIChmbi5kZWNvcmF0b3IpIHtcbiAgICBsZXQgcHJvcHMgPSB7fTtcbiAgICBwcm9nID0gZm4uZGVjb3JhdG9yKHByb2csIHByb3BzLCBjb250YWluZXIsIGRlcHRocyAmJiBkZXB0aHNbMF0sIGRhdGEsIGJsb2NrUGFyYW1zLCBkZXB0aHMpO1xuICAgIFV0aWxzLmV4dGVuZChwcm9nLCBwcm9wcyk7XG4gIH1cbiAgcmV0dXJuIHByb2c7XG59XG4iXX0=
		
		
		/***/
	}),
	
	/***/ "./node_modules/handlebars/dist/cjs/handlebars/safe-string.js":
	/*!********************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/safe-string.js ***!
  \********************************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
// Build out our basic SafeString type
		
		
		exports.__esModule = true;
		
		function SafeString(string) {
			this.string = string;
		}
		
		SafeString.prototype.toString = SafeString.prototype.toHTML = function() {
			return '' + this.string;
		};
		
		exports['default'] = SafeString;
		module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL3NhZmUtc3RyaW5nLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFDQSxTQUFTLFVBQVUsQ0FBQyxNQUFNLEVBQUU7QUFDMUIsTUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7Q0FDdEI7O0FBRUQsVUFBVSxDQUFDLFNBQVMsQ0FBQyxRQUFRLEdBQUcsVUFBVSxDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsWUFBVztBQUN2RSxTQUFPLEVBQUUsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO0NBQ3pCLENBQUM7O3FCQUVhLFVBQVUiLCJmaWxlIjoic2FmZS1zdHJpbmcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBCdWlsZCBvdXQgb3VyIGJhc2ljIFNhZmVTdHJpbmcgdHlwZVxuZnVuY3Rpb24gU2FmZVN0cmluZyhzdHJpbmcpIHtcbiAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XG59XG5cblNhZmVTdHJpbmcucHJvdG90eXBlLnRvU3RyaW5nID0gU2FmZVN0cmluZy5wcm90b3R5cGUudG9IVE1MID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAnJyArIHRoaXMuc3RyaW5nO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgU2FmZVN0cmluZztcbiJdfQ==
		
		
		/***/
	}),
	
	/***/ "./node_modules/handlebars/dist/cjs/handlebars/utils.js":
	/*!**************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/utils.js ***!
  \**************************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		exports.__esModule = true;
		exports.extend = extend;
		exports.indexOf = indexOf;
		exports.escapeExpression = escapeExpression;
		exports.isEmpty = isEmpty;
		exports.createFrame = createFrame;
		exports.blockParams = blockParams;
		exports.appendContextPath = appendContextPath;
		var escape = {
			'&': '&amp;',
			'<': '&lt;',
			'>': '&gt;',
			'"': '&quot;',
			"'": '&#x27;',
			'`': '&#x60;',
			'=': '&#x3D;'
		};
		
		var badChars = /[&<>"'`=]/g,
			possible = /[&<>"'`=]/;
		
		function escapeChar(chr) {
			return escape[chr];
		}
		
		function extend(obj /* , ...source */) {
			for(var i = 1; i < arguments.length; i++) {
				for(var key in arguments[i]) {
					if(Object.prototype.hasOwnProperty.call(arguments[i], key)) {
						obj[key] = arguments[i][key];
					}
				}
			}
			
			return obj;
		}
		
		var toString = Object.prototype.toString;
		
		exports.toString = toString;
// Sourced from lodash
// https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
		/* eslint-disable func-style */
		var isFunction = function isFunction(value) {
			return typeof value === 'function';
		};
// fallback for older versions of Chrome and Safari
		/* istanbul ignore next */
		if(isFunction(/x/)) {
			exports.isFunction = isFunction = function(value) {
				return typeof value === 'function' && toString.call(value) === '[object Function]';
			};
		}
		exports.isFunction = isFunction;
		
		/* eslint-enable func-style */
		
		/* istanbul ignore next */
		var isArray = Array.isArray || function(value) {
			return value && typeof value === 'object' ? toString.call(value) === '[object Array]' : false;
		};
		
		exports.isArray = isArray;
// Older IE versions do not directly support indexOf so we must implement our own, sadly.
		
		function indexOf(array, value) {
			for(var i = 0, len = array.length; i < len; i++) {
				if(array[i] === value) {
					return i;
				}
			}
			return -1;
		}
		
		function escapeExpression(string) {
			if(typeof string !== 'string') {
				// don't escape SafeStrings, since they're already safe
				if(string && string.toHTML) {
					return string.toHTML();
				} else if(string == null) {
					return '';
				} else if(!string) {
					return string + '';
				}
				
				// Force a string conversion as this will be done by the append regardless and
				// the regex test will do this transparently behind the scenes, causing issues if
				// an object's to string has escaped characters in it.
				string = '' + string;
			}
			
			if(!possible.test(string)) {
				return string;
			}
			return string.replace(badChars, escapeChar);
		}
		
		function isEmpty(value) {
			if(!value && value !== 0) {
				return true;
			} else if(isArray(value) && value.length === 0) {
				return true;
			} else {
				return false;
			}
		}
		
		function createFrame(object) {
			var frame = extend({}, object);
			frame._parent = object;
			return frame;
		}
		
		function blockParams(params, ids) {
			params.path = ids;
			return params;
		}
		
		function appendContextPath(contextPath, id) {
			return (contextPath ? contextPath + '.' : '') + id;
		}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL3V0aWxzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxJQUFNLE1BQU0sR0FBRztBQUNiLEtBQUcsRUFBRSxPQUFPO0FBQ1osS0FBRyxFQUFFLE1BQU07QUFDWCxLQUFHLEVBQUUsTUFBTTtBQUNYLEtBQUcsRUFBRSxRQUFRO0FBQ2IsS0FBRyxFQUFFLFFBQVE7QUFDYixLQUFHLEVBQUUsUUFBUTtBQUNiLEtBQUcsRUFBRSxRQUFRO0NBQ2QsQ0FBQzs7QUFFRixJQUFNLFFBQVEsR0FBRyxZQUFZO0lBQ3ZCLFFBQVEsR0FBRyxXQUFXLENBQUM7O0FBRTdCLFNBQVMsVUFBVSxDQUFDLEdBQUcsRUFBRTtBQUN2QixTQUFPLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztDQUNwQjs7QUFFTSxTQUFTLE1BQU0sQ0FBQyxHQUFHLG9CQUFtQjtBQUMzQyxPQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsU0FBUyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUN6QyxTQUFLLElBQUksR0FBRyxJQUFJLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRTtBQUM1QixVQUFJLE1BQU0sQ0FBQyxTQUFTLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLEVBQUU7QUFDM0QsV0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztPQUM5QjtLQUNGO0dBQ0Y7O0FBRUQsU0FBTyxHQUFHLENBQUM7Q0FDWjs7QUFFTSxJQUFJLFFBQVEsR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQzs7Ozs7O0FBS2hELElBQUksVUFBVSxHQUFHLG9CQUFTLEtBQUssRUFBRTtBQUMvQixTQUFPLE9BQU8sS0FBSyxLQUFLLFVBQVUsQ0FBQztDQUNwQyxDQUFDOzs7QUFHRixJQUFJLFVBQVUsQ0FBQyxHQUFHLENBQUMsRUFBRTtBQUNuQixVQUlNLFVBQVUsR0FKaEIsVUFBVSxHQUFHLFVBQVMsS0FBSyxFQUFFO0FBQzNCLFdBQU8sT0FBTyxLQUFLLEtBQUssVUFBVSxJQUFJLFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssbUJBQW1CLENBQUM7R0FDcEYsQ0FBQztDQUNIO1FBQ08sVUFBVSxHQUFWLFVBQVU7Ozs7O0FBSVgsSUFBTSxPQUFPLEdBQUcsS0FBSyxDQUFDLE9BQU8sSUFBSSxVQUFTLEtBQUssRUFBRTtBQUN0RCxTQUFPLEFBQUMsS0FBSyxJQUFJLE9BQU8sS0FBSyxLQUFLLFFBQVEsR0FBSSxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLGdCQUFnQixHQUFHLEtBQUssQ0FBQztDQUNqRyxDQUFDOzs7OztBQUdLLFNBQVMsT0FBTyxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUU7QUFDcEMsT0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxHQUFHLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUNoRCxRQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsS0FBSyxLQUFLLEVBQUU7QUFDdEIsYUFBTyxDQUFDLENBQUM7S0FDVjtHQUNGO0FBQ0QsU0FBTyxDQUFDLENBQUMsQ0FBQztDQUNYOztBQUdNLFNBQVMsZ0JBQWdCLENBQUMsTUFBTSxFQUFFO0FBQ3ZDLE1BQUksT0FBTyxNQUFNLEtBQUssUUFBUSxFQUFFOztBQUU5QixRQUFJLE1BQU0sSUFBSSxNQUFNLENBQUMsTUFBTSxFQUFFO0FBQzNCLGFBQU8sTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDO0tBQ3hCLE1BQU0sSUFBSSxNQUFNLElBQUksSUFBSSxFQUFFO0FBQ3pCLGFBQU8sRUFBRSxDQUFDO0tBQ1gsTUFBTSxJQUFJLENBQUMsTUFBTSxFQUFFO0FBQ2xCLGFBQU8sTUFBTSxHQUFHLEVBQUUsQ0FBQztLQUNwQjs7Ozs7QUFLRCxVQUFNLEdBQUcsRUFBRSxHQUFHLE1BQU0sQ0FBQztHQUN0Qjs7QUFFRCxNQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRTtBQUFFLFdBQU8sTUFBTSxDQUFDO0dBQUU7QUFDOUMsU0FBTyxNQUFNLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxVQUFVLENBQUMsQ0FBQztDQUM3Qzs7QUFFTSxTQUFTLE9BQU8sQ0FBQyxLQUFLLEVBQUU7QUFDN0IsTUFBSSxDQUFDLEtBQUssSUFBSSxLQUFLLEtBQUssQ0FBQyxFQUFFO0FBQ3pCLFdBQU8sSUFBSSxDQUFDO0dBQ2IsTUFBTSxJQUFJLE9BQU8sQ0FBQyxLQUFLLENBQUMsSUFBSSxLQUFLLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtBQUMvQyxXQUFPLElBQUksQ0FBQztHQUNiLE1BQU07QUFDTCxXQUFPLEtBQUssQ0FBQztHQUNkO0NBQ0Y7O0FBRU0sU0FBUyxXQUFXLENBQUMsTUFBTSxFQUFFO0FBQ2xDLE1BQUksS0FBSyxHQUFHLE1BQU0sQ0FBQyxFQUFFLEVBQUUsTUFBTSxDQUFDLENBQUM7QUFDL0IsT0FBSyxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUM7QUFDdkIsU0FBTyxLQUFLLENBQUM7Q0FDZDs7QUFFTSxTQUFTLFdBQVcsQ0FBQyxNQUFNLEVBQUUsR0FBRyxFQUFFO0FBQ3ZDLFFBQU0sQ0FBQyxJQUFJLEdBQUcsR0FBRyxDQUFDO0FBQ2xCLFNBQU8sTUFBTSxDQUFDO0NBQ2Y7O0FBRU0sU0FBUyxpQkFBaUIsQ0FBQyxXQUFXLEVBQUUsRUFBRSxFQUFFO0FBQ2pELFNBQU8sQ0FBQyxXQUFXLEdBQUcsV0FBVyxHQUFHLEdBQUcsR0FBRyxFQUFFLENBQUEsR0FBSSxFQUFFLENBQUM7Q0FDcEQiLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBlc2NhcGUgPSB7XG4gICcmJzogJyZhbXA7JyxcbiAgJzwnOiAnJmx0OycsXG4gICc+JzogJyZndDsnLFxuICAnXCInOiAnJnF1b3Q7JyxcbiAgXCInXCI6ICcmI3gyNzsnLFxuICAnYCc6ICcmI3g2MDsnLFxuICAnPSc6ICcmI3gzRDsnXG59O1xuXG5jb25zdCBiYWRDaGFycyA9IC9bJjw+XCInYD1dL2csXG4gICAgICBwb3NzaWJsZSA9IC9bJjw+XCInYD1dLztcblxuZnVuY3Rpb24gZXNjYXBlQ2hhcihjaHIpIHtcbiAgcmV0dXJuIGVzY2FwZVtjaHJdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kKG9iai8qICwgLi4uc291cmNlICovKSB7XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yIChsZXQga2V5IGluIGFyZ3VtZW50c1tpXSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhcmd1bWVudHNbaV0sIGtleSkpIHtcbiAgICAgICAgb2JqW2tleV0gPSBhcmd1bWVudHNbaV1ba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5leHBvcnQgbGV0IHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLy8gU291cmNlZCBmcm9tIGxvZGFzaFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Jlc3RpZWpzL2xvZGFzaC9ibG9iL21hc3Rlci9MSUNFTlNFLnR4dFxuLyogZXNsaW50LWRpc2FibGUgZnVuYy1zdHlsZSAqL1xubGV0IGlzRnVuY3Rpb24gPSBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xufTtcbi8vIGZhbGxiYWNrIGZvciBvbGRlciB2ZXJzaW9ucyBvZiBDaHJvbWUgYW5kIFNhZmFyaVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmlmIChpc0Z1bmN0aW9uKC94LykpIHtcbiAgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbiAgfTtcbn1cbmV4cG9ydCB7aXNGdW5jdGlvbn07XG4vKiBlc2xpbnQtZW5hYmxlIGZ1bmMtc3R5bGUgKi9cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpID8gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XScgOiBmYWxzZTtcbn07XG5cbi8vIE9sZGVyIElFIHZlcnNpb25zIGRvIG5vdCBkaXJlY3RseSBzdXBwb3J0IGluZGV4T2Ygc28gd2UgbXVzdCBpbXBsZW1lbnQgb3VyIG93biwgc2FkbHkuXG5leHBvcnQgZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgdmFsdWUpIHtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGFycmF5W2ldID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlRXhwcmVzc2lvbihzdHJpbmcpIHtcbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgLy8gZG9uJ3QgZXNjYXBlIFNhZmVTdHJpbmdzLCBzaW5jZSB0aGV5J3JlIGFscmVhZHkgc2FmZVxuICAgIGlmIChzdHJpbmcgJiYgc3RyaW5nLnRvSFRNTCkge1xuICAgICAgcmV0dXJuIHN0cmluZy50b0hUTUwoKTtcbiAgICB9IGVsc2UgaWYgKHN0cmluZyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfSBlbHNlIGlmICghc3RyaW5nKSB7XG4gICAgICByZXR1cm4gc3RyaW5nICsgJyc7XG4gICAgfVxuXG4gICAgLy8gRm9yY2UgYSBzdHJpbmcgY29udmVyc2lvbiBhcyB0aGlzIHdpbGwgYmUgZG9uZSBieSB0aGUgYXBwZW5kIHJlZ2FyZGxlc3MgYW5kXG4gICAgLy8gdGhlIHJlZ2V4IHRlc3Qgd2lsbCBkbyB0aGlzIHRyYW5zcGFyZW50bHkgYmVoaW5kIHRoZSBzY2VuZXMsIGNhdXNpbmcgaXNzdWVzIGlmXG4gICAgLy8gYW4gb2JqZWN0J3MgdG8gc3RyaW5nIGhhcyBlc2NhcGVkIGNoYXJhY3RlcnMgaW4gaXQuXG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmc7XG4gIH1cblxuICBpZiAoIXBvc3NpYmxlLnRlc3Qoc3RyaW5nKSkgeyByZXR1cm4gc3RyaW5nOyB9XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShiYWRDaGFycywgZXNjYXBlQ2hhcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XG4gIGlmICghdmFsdWUgJiYgdmFsdWUgIT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZyYW1lKG9iamVjdCkge1xuICBsZXQgZnJhbWUgPSBleHRlbmQoe30sIG9iamVjdCk7XG4gIGZyYW1lLl9wYXJlbnQgPSBvYmplY3Q7XG4gIHJldHVybiBmcmFtZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJsb2NrUGFyYW1zKHBhcmFtcywgaWRzKSB7XG4gIHBhcmFtcy5wYXRoID0gaWRzO1xuICByZXR1cm4gcGFyYW1zO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kQ29udGV4dFBhdGgoY29udGV4dFBhdGgsIGlkKSB7XG4gIHJldHVybiAoY29udGV4dFBhdGggPyBjb250ZXh0UGF0aCArICcuJyA6ICcnKSArIGlkO1xufVxuIl19
		
		
		/***/
	}),
	
	/***/ "./node_modules/handlebars/runtime.js":
	/*!********************************************!*\
  !*** ./node_modules/handlebars/runtime.js ***!
  \********************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

// Create a simple path alias to allow browserify to resolve
// the runtime on a supported path.
		module.exports = __webpack_require__(/*! ./dist/cjs/handlebars.runtime */ "./node_modules/handlebars/dist/cjs/handlebars.runtime.js")['default'];
		
		
		/***/
	}),
	
	/***/ "./node_modules/jquery/dist/jquery.js":
	/*!********************************************!*\
  !*** ./node_modules/jquery/dist/jquery.js ***!
  \********************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery JavaScript Library v3.3.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2018-01-20T17:24Z
 */
		(function(global, factory) {
			
			"use strict";
			
			if(true && typeof module.exports === "object") {
				
				// For CommonJS and CommonJS-like environments where a proper `window`
				// is present, execute the factory and get jQuery.
				// For environments that do not have a `window` with a `document`
				// (such as Node.js), expose a factory as module.exports.
				// This accentuates the need for the creation of a real `window`.
				// e.g. var jQuery = require("jquery")(window);
				// See ticket #14549 for more info.
				module.exports = global.document ?
					factory(global, true) :
					function(w) {
						if(!w.document) {
							throw new Error("jQuery requires a window with a document");
						}
						return factory(w);
					};
			} else {
				factory(global);
			}

// Pass this if window is not defined yet
		})(typeof window !== "undefined" ? window : this, function(window, noGlobal) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
			"use strict";
			
			var arr = [];
			
			var document = window.document;
			
			var getProto = Object.getPrototypeOf;
			
			var slice = arr.slice;
			
			var concat = arr.concat;
			
			var push = arr.push;
			
			var indexOf = arr.indexOf;
			
			var class2type = {};
			
			var toString = class2type.toString;
			
			var hasOwn = class2type.hasOwnProperty;
			
			var fnToString = hasOwn.toString;
			
			var ObjectFunctionString = fnToString.call(Object);
			
			var support = {};
			
			var isFunction = function isFunction(obj) {
				
				// Support: Chrome <=57, Firefox <=52
				// In some browsers, typeof returns "function" for HTML <object> elements
				// (i.e., `typeof document.createElement( "object" ) === "function"`).
				// We don't want to classify *any* DOM node as a function.
				return typeof obj === "function" && typeof obj.nodeType !== "number";
			};
			
			
			var isWindow = function isWindow(obj) {
				return obj != null && obj === obj.window;
			};
			
			
			var preservedScriptAttributes = {
				type: true,
				src: true,
				noModule: true
			};
			
			function DOMEval(code, doc, node) {
				doc = doc || document;
				
				var i,
					script = doc.createElement("script");
				
				script.text = code;
				if(node) {
					for(i in preservedScriptAttributes) {
						if(node[i]) {
							script[i] = node[i];
						}
					}
				}
				doc.head.appendChild(script).parentNode.removeChild(script);
			}
			
			
			function toType(obj) {
				if(obj == null) {
					return obj + "";
				}
				
				// Support: Android <=2.3 only (functionish RegExp)
				return typeof obj === "object" || typeof obj === "function" ?
					class2type[toString.call(obj)] || "object" :
					typeof obj;
			}
			
			/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module
			
			
			var
				version = "3.3.1",
				
				// Define a local copy of jQuery
				jQuery = function(selector, context) {
					
					// The jQuery object is actually just the init constructor 'enhanced'
					// Need init if jQuery is called (just allow error to be thrown if not included)
					return new jQuery.fn.init(selector, context);
				},
				
				// Support: Android <=4.0 only
				// Make sure we trim BOM and NBSP
				rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
			
			jQuery.fn = jQuery.prototype = {
				
				// The current version of jQuery being used
				jquery: version,
				
				constructor: jQuery,
				
				// The default length of a jQuery object is 0
				length: 0,
				
				toArray: function() {
					return slice.call(this);
				},
				
				// Get the Nth element in the matched element set OR
				// Get the whole matched element set as a clean array
				get: function(num) {
					
					// Return all the elements in a clean array
					if(num == null) {
						return slice.call(this);
					}
					
					// Return just the one element from the set
					return num < 0 ? this[num + this.length] : this[num];
				},
				
				// Take an array of elements and push it onto the stack
				// (returning the new matched element set)
				pushStack: function(elems) {
					
					// Build a new jQuery matched element set
					var ret = jQuery.merge(this.constructor(), elems);
					
					// Add the old object onto the stack (as a reference)
					ret.prevObject = this;
					
					// Return the newly-formed element set
					return ret;
				},
				
				// Execute a callback for every element in the matched set.
				each: function(callback) {
					return jQuery.each(this, callback);
				},
				
				map: function(callback) {
					return this.pushStack(jQuery.map(this, function(elem, i) {
						return callback.call(elem, i, elem);
					}));
				},
				
				slice: function() {
					return this.pushStack(slice.apply(this, arguments));
				},
				
				first: function() {
					return this.eq(0);
				},
				
				last: function() {
					return this.eq(-1);
				},
				
				eq: function(i) {
					var len = this.length,
						j = +i + (i < 0 ? len : 0);
					return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
				},
				
				end: function() {
					return this.prevObject || this.constructor();
				},
				
				// For internal use only.
				// Behaves like an Array's method, not like a jQuery method.
				push: push,
				sort: arr.sort,
				splice: arr.splice
			};
			
			jQuery.extend = jQuery.fn.extend = function() {
				var options, name, src, copy, copyIsArray, clone,
					target = arguments[0] || {},
					i = 1,
					length = arguments.length,
					deep = false;
				
				// Handle a deep copy situation
				if(typeof target === "boolean") {
					deep = target;
					
					// Skip the boolean and the target
					target = arguments[i] || {};
					i++;
				}
				
				// Handle case when target is a string or something (possible in deep copy)
				if(typeof target !== "object" && !isFunction(target)) {
					target = {};
				}
				
				// Extend jQuery itself if only one argument is passed
				if(i === length) {
					target = this;
					i--;
				}
				
				for(; i < length; i++) {
					
					// Only deal with non-null/undefined values
					if((options = arguments[i]) != null) {
						
						// Extend the base object
						for(name in options) {
							src = target[name];
							copy = options[name];
							
							// Prevent never-ending loop
							if(target === copy) {
								continue;
							}
							
							// Recurse if we're merging plain objects or arrays
							if(deep && copy && (jQuery.isPlainObject(copy) ||
								(copyIsArray = Array.isArray(copy)))) {
								
								if(copyIsArray) {
									copyIsArray = false;
									clone = src && Array.isArray(src) ? src : [];
									
								} else {
									clone = src && jQuery.isPlainObject(src) ? src : {};
								}
								
								// Never move original objects, clone them
								target[name] = jQuery.extend(deep, clone, copy);
								
								// Don't bring in undefined values
							} else if(copy !== undefined) {
								target[name] = copy;
							}
						}
					}
				}
				
				// Return the modified object
				return target;
			};
			
			jQuery.extend({
				
				// Unique for each copy of jQuery on the page
				expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
				
				// Assume jQuery is ready without the ready module
				isReady: true,
				
				error: function(msg) {
					throw new Error(msg);
				},
				
				noop: function() {
				},
				
				isPlainObject: function(obj) {
					var proto, Ctor;
					
					// Detect obvious negatives
					// Use toString instead of jQuery.type to catch host objects
					if(!obj || toString.call(obj) !== "[object Object]") {
						return false;
					}
					
					proto = getProto(obj);
					
					// Objects with no prototype (e.g., `Object.create( null )`) are plain
					if(!proto) {
						return true;
					}
					
					// Objects with prototype are plain iff they were constructed by a global Object function
					Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
					return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
				},
				
				isEmptyObject: function(obj) {
					
					/* eslint-disable no-unused-vars */
					// See https://github.com/eslint/eslint/issues/6125
					var name;
					
					for(name in obj) {
						return false;
					}
					return true;
				},
				
				// Evaluates a script in a global context
				globalEval: function(code) {
					DOMEval(code);
				},
				
				each: function(obj, callback) {
					var length, i = 0;
					
					if(isArrayLike(obj)) {
						length = obj.length;
						for(; i < length; i++) {
							if(callback.call(obj[i], i, obj[i]) === false) {
								break;
							}
						}
					} else {
						for(i in obj) {
							if(callback.call(obj[i], i, obj[i]) === false) {
								break;
							}
						}
					}
					
					return obj;
				},
				
				// Support: Android <=4.0 only
				trim: function(text) {
					return text == null ?
						"" :
						(text + "").replace(rtrim, "");
				},
				
				// results is for internal usage only
				makeArray: function(arr, results) {
					var ret = results || [];
					
					if(arr != null) {
						if(isArrayLike(Object(arr))) {
							jQuery.merge(ret,
								typeof arr === "string" ?
									[arr] : arr
							);
						} else {
							push.call(ret, arr);
						}
					}
					
					return ret;
				},
				
				inArray: function(elem, arr, i) {
					return arr == null ? -1 : indexOf.call(arr, elem, i);
				},
				
				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				merge: function(first, second) {
					var len = +second.length,
						j = 0,
						i = first.length;
					
					for(; j < len; j++) {
						first[i++] = second[j];
					}
					
					first.length = i;
					
					return first;
				},
				
				grep: function(elems, callback, invert) {
					var callbackInverse,
						matches = [],
						i = 0,
						length = elems.length,
						callbackExpect = !invert;
					
					// Go through the array, only saving the items
					// that pass the validator function
					for(; i < length; i++) {
						callbackInverse = !callback(elems[i], i);
						if(callbackInverse !== callbackExpect) {
							matches.push(elems[i]);
						}
					}
					
					return matches;
				},
				
				// arg is for internal usage only
				map: function(elems, callback, arg) {
					var length, value,
						i = 0,
						ret = [];
					
					// Go through the array, translating each of the items to their new values
					if(isArrayLike(elems)) {
						length = elems.length;
						for(; i < length; i++) {
							value = callback(elems[i], i, arg);
							
							if(value != null) {
								ret.push(value);
							}
						}
						
						// Go through every key on the object,
					} else {
						for(i in elems) {
							value = callback(elems[i], i, arg);
							
							if(value != null) {
								ret.push(value);
							}
						}
					}
					
					// Flatten any nested arrays
					return concat.apply([], ret);
				},
				
				// A global GUID counter for objects
				guid: 1,
				
				// jQuery.support is not used in Core but other projects attach their
				// properties to it so it needs to exist.
				support: support
			});
			
			if(typeof Symbol === "function") {
				jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
			}

// Populate the class2type map
			jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),
				function(i, name) {
					class2type["[object " + name + "]"] = name.toLowerCase();
				});
			
			function isArrayLike(obj) {
				
				// Support: real iOS 8.2 only (not reproducible in simulator)
				// `in` check used to prevent JIT error (gh-2145)
				// hasOwn isn't used here due to false negatives
				// regarding Nodelist length in IE
				var length = !!obj && "length" in obj && obj.length,
					type = toType(obj);
				
				if(isFunction(obj) || isWindow(obj)) {
					return false;
				}
				
				return type === "array" || length === 0 ||
					typeof length === "number" && length > 0 && (length - 1) in obj;
			}
			
			var Sizzle =
				/*!
 * Sizzle CSS Selector Engine v2.3.3
 * https://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-08-08
 */
				(function(window) {
					
					var i,
						support,
						Expr,
						getText,
						isXML,
						tokenize,
						compile,
						select,
						outermostContext,
						sortInput,
						hasDuplicate,
						
						// Local document vars
						setDocument,
						document,
						docElem,
						documentIsHTML,
						rbuggyQSA,
						rbuggyMatches,
						matches,
						contains,
						
						// Instance-specific data
						expando = "sizzle" + 1 * new Date(),
						preferredDoc = window.document,
						dirruns = 0,
						done = 0,
						classCache = createCache(),
						tokenCache = createCache(),
						compilerCache = createCache(),
						sortOrder = function(a, b) {
							if(a === b) {
								hasDuplicate = true;
							}
							return 0;
						},
						
						// Instance methods
						hasOwn = ({}).hasOwnProperty,
						arr = [],
						pop = arr.pop,
						push_native = arr.push,
						push = arr.push,
						slice = arr.slice,
						// Use a stripped-down indexOf as it's faster than native
						// https://jsperf.com/thor-indexof-vs-for/5
						indexOf = function(list, elem) {
							var i = 0,
								len = list.length;
							for(; i < len; i++) {
								if(list[i] === elem) {
									return i;
								}
							}
							return -1;
						},
						
						booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
						
						// Regular expressions
						
						// http://www.w3.org/TR/css3-selectors/#whitespace
						whitespace = "[\\x20\\t\\r\\n\\f]",
						
						// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
						identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",
						
						// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
						attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
							// Operator (capture 2)
							"*([*^$|!~]?=)" + whitespace +
							// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
							"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
							"*\\]",
						
						pseudos = ":(" + identifier + ")(?:\\((" +
							// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
							// 1. quoted (capture 3; capture 4 or capture 5)
							"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
							// 2. simple (capture 6)
							"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
							// 3. anything else (capture 2)
							".*" +
							")\\)|)",
						
						// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
						rwhitespace = new RegExp(whitespace + "+", "g"),
						rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
						
						rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
						rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
						
						rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),
						
						rpseudo = new RegExp(pseudos),
						ridentifier = new RegExp("^" + identifier + "$"),
						
						matchExpr = {
							"ID": new RegExp("^#(" + identifier + ")"),
							"CLASS": new RegExp("^\\.(" + identifier + ")"),
							"TAG": new RegExp("^(" + identifier + "|[*])"),
							"ATTR": new RegExp("^" + attributes),
							"PSEUDO": new RegExp("^" + pseudos),
							"CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
								"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
								"*(\\d+)|))" + whitespace + "*\\)|)", "i"),
							"bool": new RegExp("^(?:" + booleans + ")$", "i"),
							// For use in libraries implementing .is()
							// We use this for POS matching in `select`
							"needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
								whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
						},
						
						rinputs = /^(?:input|select|textarea|button)$/i,
						rheader = /^h\d$/i,
						
						rnative = /^[^{]+\{\s*\[native \w/,
						
						// Easily-parseable/retrievable ID or TAG or CLASS selectors
						rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
						
						rsibling = /[+~]/,
						
						// CSS escapes
						// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
						runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
						funescape = function(_, escaped, escapedWhitespace) {
							var high = "0x" + escaped - 0x10000;
							// NaN means non-codepoint
							// Support: Firefox<24
							// Workaround erroneous numeric interpretation of +"0x"
							return high !== high || escapedWhitespace ?
								escaped :
								high < 0 ?
									// BMP codepoint
									String.fromCharCode(high + 0x10000) :
									// Supplemental Plane codepoint (surrogate pair)
									String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
						},
						
						// CSS string/identifier serialization
						// https://drafts.csswg.org/cssom/#common-serializing-idioms
						rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
						fcssescape = function(ch, asCodePoint) {
							if(asCodePoint) {
								
								// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
								if(ch === "\0") {
									return "\uFFFD";
								}
								
								// Control characters and (dependent upon position) numbers get escaped as code points
								return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
							}
							
							// Other potentially-special ASCII characters get backslash-escaped
							return "\\" + ch;
						},
						
						// Used for iframes
						// See setDocument()
						// Removing the function wrapper causes a "Permission Denied"
						// error in IE
						unloadHandler = function() {
							setDocument();
						},
						
						disabledAncestor = addCombinator(
							function(elem) {
								return elem.disabled === true && ("form" in elem || "label" in elem);
							},
							{dir: "parentNode", next: "legend"}
						);

// Optimize for push.apply( _, NodeList )
					try {
						push.apply(
							(arr = slice.call(preferredDoc.childNodes)),
							preferredDoc.childNodes
						);
						// Support: Android<4.0
						// Detect silently failing push.apply
						arr[preferredDoc.childNodes.length].nodeType;
					} catch(e) {
						push = {
							apply: arr.length ?
								
								// Leverage slice if possible
								function(target, els) {
									push_native.apply(target, slice.call(els));
								} :
								
								// Support: IE<9
								// Otherwise append directly
								function(target, els) {
									var j = target.length,
										i = 0;
									// Can't trust NodeList.length
									while((target[j++] = els[i++])) {
									}
									target.length = j - 1;
								}
						};
					}
					
					function Sizzle(selector, context, results, seed) {
						var m, i, elem, nid, match, groups, newSelector,
							newContext = context && context.ownerDocument,
							
							// nodeType defaults to 9, since context defaults to document
							nodeType = context ? context.nodeType : 9;
						
						results = results || [];
						
						// Return early from calls with invalid selector or context
						if(typeof selector !== "string" || !selector ||
							nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
							
							return results;
						}
						
						// Try to shortcut find operations (as opposed to filters) in HTML documents
						if(!seed) {
							
							if((context ? context.ownerDocument || context : preferredDoc) !== document) {
								setDocument(context);
							}
							context = context || document;
							
							if(documentIsHTML) {
								
								// If the selector is sufficiently simple, try using a "get*By*" DOM method
								// (excepting DocumentFragment context, where the methods don't exist)
								if(nodeType !== 11 && (match = rquickExpr.exec(selector))) {
									
									// ID selector
									if((m = match[1])) {
										
										// Document context
										if(nodeType === 9) {
											if((elem = context.getElementById(m))) {
												
												// Support: IE, Opera, Webkit
												// TODO: identify versions
												// getElementById can match elements by name instead of ID
												if(elem.id === m) {
													results.push(elem);
													return results;
												}
											} else {
												return results;
											}
											
											// Element context
										} else {
											
											// Support: IE, Opera, Webkit
											// TODO: identify versions
											// getElementById can match elements by name instead of ID
											if(newContext && (elem = newContext.getElementById(m)) &&
												contains(context, elem) &&
												elem.id === m) {
												
												results.push(elem);
												return results;
											}
										}
										
										// Type selector
									} else if(match[2]) {
										push.apply(results, context.getElementsByTagName(selector));
										return results;
										
										// Class selector
									} else if((m = match[3]) && support.getElementsByClassName &&
										context.getElementsByClassName) {
										
										push.apply(results, context.getElementsByClassName(m));
										return results;
									}
								}
								
								// Take advantage of querySelectorAll
								if(support.qsa &&
									!compilerCache[selector + " "] &&
									(!rbuggyQSA || !rbuggyQSA.test(selector))) {
									
									if(nodeType !== 1) {
										newContext = context;
										newSelector = selector;
										
										// qSA looks outside Element context, which is not what we want
										// Thanks to Andrew Dupont for this workaround technique
										// Support: IE <=8
										// Exclude object elements
									} else if(context.nodeName.toLowerCase() !== "object") {
										
										// Capture the context ID, setting it first if necessary
										if((nid = context.getAttribute("id"))) {
											nid = nid.replace(rcssescape, fcssescape);
										} else {
											context.setAttribute("id", (nid = expando));
										}
										
										// Prefix every selector in the list
										groups = tokenize(selector);
										i = groups.length;
										while(i--) {
											groups[i] = "#" + nid + " " + toSelector(groups[i]);
										}
										newSelector = groups.join(",");
										
										// Expand context for sibling selectors
										newContext = rsibling.test(selector) && testContext(context.parentNode) ||
											context;
									}
									
									if(newSelector) {
										try {
											push.apply(results,
												newContext.querySelectorAll(newSelector)
											);
											return results;
										} catch(qsaError) {
										} finally {
											if(nid === expando) {
												context.removeAttribute("id");
											}
										}
									}
								}
							}
						}
						
						// All others
						return select(selector.replace(rtrim, "$1"), context, results, seed);
					}
					
					/**
					 * Create key-value caches of limited size
					 * @returns {function(string, object)} Returns the Object data after storing it on itself with
					 *    property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
					 *    deleting the oldest entry
					 */
					function createCache() {
						var keys = [];
						
						function cache(key, value) {
							// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
							if(keys.push(key + " ") > Expr.cacheLength) {
								// Only keep the most recent entries
								delete cache[keys.shift()];
							}
							return (cache[key + " "] = value);
						}
						
						return cache;
					}
					
					/**
					 * Mark a function for special use by Sizzle
					 * @param {Function} fn The function to mark
					 */
					function markFunction(fn) {
						fn[expando] = true;
						return fn;
					}
					
					/**
					 * Support testing using an element
					 * @param {Function} fn Passed the created element and returns a boolean result
					 */
					function assert(fn) {
						var el = document.createElement("fieldset");
						
						try {
							return !!fn(el);
						} catch(e) {
							return false;
						} finally {
							// Remove from its parent by default
							if(el.parentNode) {
								el.parentNode.removeChild(el);
							}
							// release memory in IE
							el = null;
						}
					}
					
					/**
					 * Adds the same handler for all of the specified attrs
					 * @param {String} attrs Pipe-separated list of attributes
					 * @param {Function} handler The method that will be applied
					 */
					function addHandle(attrs, handler) {
						var arr = attrs.split("|"),
							i = arr.length;
						
						while(i--) {
							Expr.attrHandle[arr[i]] = handler;
						}
					}
					
					/**
					 * Checks document order of two siblings
					 * @param {Element} a
					 * @param {Element} b
					 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
					 */
					function siblingCheck(a, b) {
						var cur = b && a,
							diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
								a.sourceIndex - b.sourceIndex;
						
						// Use IE sourceIndex if available on both nodes
						if(diff) {
							return diff;
						}
						
						// Check if b follows a
						if(cur) {
							while((cur = cur.nextSibling)) {
								if(cur === b) {
									return -1;
								}
							}
						}
						
						return a ? 1 : -1;
					}
					
					/**
					 * Returns a function to use in pseudos for input types
					 * @param {String} type
					 */
					function createInputPseudo(type) {
						return function(elem) {
							var name = elem.nodeName.toLowerCase();
							return name === "input" && elem.type === type;
						};
					}
					
					/**
					 * Returns a function to use in pseudos for buttons
					 * @param {String} type
					 */
					function createButtonPseudo(type) {
						return function(elem) {
							var name = elem.nodeName.toLowerCase();
							return (name === "input" || name === "button") && elem.type === type;
						};
					}
					
					/**
					 * Returns a function to use in pseudos for :enabled/:disabled
					 * @param {Boolean} disabled true for :disabled; false for :enabled
					 */
					function createDisabledPseudo(disabled) {
						
						// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
						return function(elem) {
							
							// Only certain elements can match :enabled or :disabled
							// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
							// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
							if("form" in elem) {
								
								// Check for inherited disabledness on relevant non-disabled elements:
								// * listed form-associated elements in a disabled fieldset
								//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
								//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
								// * option elements in a disabled optgroup
								//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
								// All such elements have a "form" property.
								if(elem.parentNode && elem.disabled === false) {
									
									// Option elements defer to a parent optgroup if present
									if("label" in elem) {
										if("label" in elem.parentNode) {
											return elem.parentNode.disabled === disabled;
										} else {
											return elem.disabled === disabled;
										}
									}
									
									// Support: IE 6 - 11
									// Use the isDisabled shortcut property to check for disabled fieldset ancestors
									return elem.isDisabled === disabled ||
										
										// Where there is no isDisabled, check manually
										/* jshint -W018 */
										elem.isDisabled !== !disabled &&
										disabledAncestor(elem) === disabled;
								}
								
								return elem.disabled === disabled;
								
								// Try to winnow out elements that can't be disabled before trusting the disabled property.
								// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
								// even exist on them, let alone have a boolean value.
							} else if("label" in elem) {
								return elem.disabled === disabled;
							}
							
							// Remaining elements are neither :enabled nor :disabled
							return false;
						};
					}
					
					/**
					 * Returns a function to use in pseudos for positionals
					 * @param {Function} fn
					 */
					function createPositionalPseudo(fn) {
						return markFunction(function(argument) {
							argument = +argument;
							return markFunction(function(seed, matches) {
								var j,
									matchIndexes = fn([], seed.length, argument),
									i = matchIndexes.length;
								
								// Match elements found at the specified indexes
								while(i--) {
									if(seed[(j = matchIndexes[i])]) {
										seed[j] = !(matches[j] = seed[j]);
									}
								}
							});
						});
					}
					
					/**
					 * Checks a node for validity as a Sizzle context
					 * @param {Element|Object=} context
					 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
					 */
					function testContext(context) {
						return context && typeof context.getElementsByTagName !== "undefined" && context;
					}

// Expose support vars for convenience
					support = Sizzle.support = {};
					
					/**
					 * Detects XML nodes
					 * @param {Element|Object} elem An element or a document
					 * @returns {Boolean} True iff elem is a non-HTML XML node
					 */
					isXML = Sizzle.isXML = function(elem) {
						// documentElement is verified for cases where it doesn't yet exist
						// (such as loading iframes in IE - #4833)
						var documentElement = elem && (elem.ownerDocument || elem).documentElement;
						return documentElement ? documentElement.nodeName !== "HTML" : false;
					};
					
					/**
					 * Sets document-related variables once based on the current document
					 * @param {Element|Object} [doc] An element or document object to use to set the document
					 * @returns {Object} Returns the current document
					 */
					setDocument = Sizzle.setDocument = function(node) {
						var hasCompare, subWindow,
							doc = node ? node.ownerDocument || node : preferredDoc;
						
						// Return early if doc is invalid or already selected
						if(doc === document || doc.nodeType !== 9 || !doc.documentElement) {
							return document;
						}
						
						// Update global variables
						document = doc;
						docElem = document.documentElement;
						documentIsHTML = !isXML(document);
						
						// Support: IE 9-11, Edge
						// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
						if(preferredDoc !== document &&
							(subWindow = document.defaultView) && subWindow.top !== subWindow) {
							
							// Support: IE 11, Edge
							if(subWindow.addEventListener) {
								subWindow.addEventListener("unload", unloadHandler, false);
								
								// Support: IE 9 - 10 only
							} else if(subWindow.attachEvent) {
								subWindow.attachEvent("onunload", unloadHandler);
							}
						}
						
						/* Attributes
	---------------------------------------------------------------------- */
						
						// Support: IE<8
						// Verify that getAttribute really returns attributes and not properties
						// (excepting IE8 booleans)
						support.attributes = assert(function(el) {
							el.className = "i";
							return !el.getAttribute("className");
						});
						
						/* getElement(s)By*
	---------------------------------------------------------------------- */
						
						// Check if getElementsByTagName("*") returns only elements
						support.getElementsByTagName = assert(function(el) {
							el.appendChild(document.createComment(""));
							return !el.getElementsByTagName("*").length;
						});
						
						// Support: IE<9
						support.getElementsByClassName = rnative.test(document.getElementsByClassName);
						
						// Support: IE<10
						// Check if getElementById returns elements by name
						// The broken getElementById methods don't pick up programmatically-set names,
						// so use a roundabout getElementsByName test
						support.getById = assert(function(el) {
							docElem.appendChild(el).id = expando;
							return !document.getElementsByName || !document.getElementsByName(expando).length;
						});
						
						// ID filter and find
						if(support.getById) {
							Expr.filter["ID"] = function(id) {
								var attrId = id.replace(runescape, funescape);
								return function(elem) {
									return elem.getAttribute("id") === attrId;
								};
							};
							Expr.find["ID"] = function(id, context) {
								if(typeof context.getElementById !== "undefined" && documentIsHTML) {
									var elem = context.getElementById(id);
									return elem ? [elem] : [];
								}
							};
						} else {
							Expr.filter["ID"] = function(id) {
								var attrId = id.replace(runescape, funescape);
								return function(elem) {
									var node = typeof elem.getAttributeNode !== "undefined" &&
										elem.getAttributeNode("id");
									return node && node.value === attrId;
								};
							};
							
							// Support: IE 6 - 7 only
							// getElementById is not reliable as a find shortcut
							Expr.find["ID"] = function(id, context) {
								if(typeof context.getElementById !== "undefined" && documentIsHTML) {
									var node, i, elems,
										elem = context.getElementById(id);
									
									if(elem) {
										
										// Verify the id attribute
										node = elem.getAttributeNode("id");
										if(node && node.value === id) {
											return [elem];
										}
										
										// Fall back on getElementsByName
										elems = context.getElementsByName(id);
										i = 0;
										while((elem = elems[i++])) {
											node = elem.getAttributeNode("id");
											if(node && node.value === id) {
												return [elem];
											}
										}
									}
									
									return [];
								}
							};
						}
						
						// Tag
						Expr.find["TAG"] = support.getElementsByTagName ?
							function(tag, context) {
								if(typeof context.getElementsByTagName !== "undefined") {
									return context.getElementsByTagName(tag);
									
									// DocumentFragment nodes don't have gEBTN
								} else if(support.qsa) {
									return context.querySelectorAll(tag);
								}
							} :
							
							function(tag, context) {
								var elem,
									tmp = [],
									i = 0,
									// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
									results = context.getElementsByTagName(tag);
								
								// Filter out possible comments
								if(tag === "*") {
									while((elem = results[i++])) {
										if(elem.nodeType === 1) {
											tmp.push(elem);
										}
									}
									
									return tmp;
								}
								return results;
							};
						
						// Class
						Expr.find["CLASS"] = support.getElementsByClassName && function(className, context) {
							if(typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
								return context.getElementsByClassName(className);
							}
						};
						
						/* QSA/matchesSelector
	---------------------------------------------------------------------- */
						
						// QSA and matchesSelector support
						
						// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
						rbuggyMatches = [];
						
						// qSa(:focus) reports false when true (Chrome 21)
						// We allow this because of a bug in IE8/9 that throws an error
						// whenever `document.activeElement` is accessed on an iframe
						// So, we allow :focus to pass through QSA all the time to avoid the IE error
						// See https://bugs.jquery.com/ticket/13378
						rbuggyQSA = [];
						
						if((support.qsa = rnative.test(document.querySelectorAll))) {
							// Build QSA regex
							// Regex strategy adopted from Diego Perini
							assert(function(el) {
								// Select is set to empty string on purpose
								// This is to test IE's treatment of not explicitly
								// setting a boolean content attribute,
								// since its presence should be enough
								// https://bugs.jquery.com/ticket/12359
								docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a>" +
									"<select id='" + expando + "-\r\\' msallowcapture=''>" +
									"<option selected=''></option></select>";
								
								// Support: IE8, Opera 11-12.16
								// Nothing should be selected when empty strings follow ^= or $= or *=
								// The test attribute must be unknown in Opera but "safe" for WinRT
								// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
								if(el.querySelectorAll("[msallowcapture^='']").length) {
									rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
								}
								
								// Support: IE8
								// Boolean attributes and "value" are not treated correctly
								if(!el.querySelectorAll("[selected]").length) {
									rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
								}
								
								// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
								if(!el.querySelectorAll("[id~=" + expando + "-]").length) {
									rbuggyQSA.push("~=");
								}
								
								// Webkit/Opera - :checked should return selected option elements
								// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
								// IE8 throws error here and will not see later tests
								if(!el.querySelectorAll(":checked").length) {
									rbuggyQSA.push(":checked");
								}
								
								// Support: Safari 8+, iOS 8+
								// https://bugs.webkit.org/show_bug.cgi?id=136851
								// In-page `selector#id sibling-combinator selector` fails
								if(!el.querySelectorAll("a#" + expando + "+*").length) {
									rbuggyQSA.push(".#.+[+~]");
								}
							});
							
							assert(function(el) {
								el.innerHTML = "<a href='' disabled='disabled'></a>" +
									"<select disabled='disabled'><option/></select>";
								
								// Support: Windows 8 Native Apps
								// The type and name attributes are restricted during .innerHTML assignment
								var input = document.createElement("input");
								input.setAttribute("type", "hidden");
								el.appendChild(input).setAttribute("name", "D");
								
								// Support: IE8
								// Enforce case-sensitivity of name attribute
								if(el.querySelectorAll("[name=d]").length) {
									rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
								}
								
								// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
								// IE8 throws error here and will not see later tests
								if(el.querySelectorAll(":enabled").length !== 2) {
									rbuggyQSA.push(":enabled", ":disabled");
								}
								
								// Support: IE9-11+
								// IE's :disabled selector does not pick up the children of disabled fieldsets
								docElem.appendChild(el).disabled = true;
								if(el.querySelectorAll(":disabled").length !== 2) {
									rbuggyQSA.push(":enabled", ":disabled");
								}
								
								// Opera 10-11 does not throw on post-comma invalid pseudos
								el.querySelectorAll("*,:x");
								rbuggyQSA.push(",.*:");
							});
						}
						
						if((support.matchesSelector = rnative.test((matches = docElem.matches ||
							docElem.webkitMatchesSelector ||
							docElem.mozMatchesSelector ||
							docElem.oMatchesSelector ||
							docElem.msMatchesSelector)))) {
							
							assert(function(el) {
								// Check to see if it's possible to do matchesSelector
								// on a disconnected node (IE 9)
								support.disconnectedMatch = matches.call(el, "*");
								
								// This should fail with an exception
								// Gecko does not error, returns false instead
								matches.call(el, "[s!='']:x");
								rbuggyMatches.push("!=", pseudos);
							});
						}
						
						rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
						rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
						
						/* Contains
	---------------------------------------------------------------------- */
						hasCompare = rnative.test(docElem.compareDocumentPosition);
						
						// Element contains another
						// Purposefully self-exclusive
						// As in, an element does not contain itself
						contains = hasCompare || rnative.test(docElem.contains) ?
							function(a, b) {
								var adown = a.nodeType === 9 ? a.documentElement : a,
									bup = b && b.parentNode;
								return a === bup || !!(bup && bup.nodeType === 1 && (
									adown.contains ?
										adown.contains(bup) :
										a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16
								));
							} :
							function(a, b) {
								if(b) {
									while((b = b.parentNode)) {
										if(b === a) {
											return true;
										}
									}
								}
								return false;
							};
						
						/* Sorting
	---------------------------------------------------------------------- */
						
						// Document order sorting
						sortOrder = hasCompare ?
							function(a, b) {
								
								// Flag for duplicate removal
								if(a === b) {
									hasDuplicate = true;
									return 0;
								}
								
								// Sort on method existence if only one input has compareDocumentPosition
								var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
								if(compare) {
									return compare;
								}
								
								// Calculate position if both inputs belong to the same document
								compare = (a.ownerDocument || a) === (b.ownerDocument || b) ?
									a.compareDocumentPosition(b) :
									
									// Otherwise we know they are disconnected
									1;
								
								// Disconnected nodes
								if(compare & 1 ||
									(!support.sortDetached && b.compareDocumentPosition(a) === compare)) {
									
									// Choose the first element that is related to our preferred document
									if(a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
										return -1;
									}
									if(b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
										return 1;
									}
									
									// Maintain original order
									return sortInput ?
										(indexOf(sortInput, a) - indexOf(sortInput, b)) :
										0;
								}
								
								return compare & 4 ? -1 : 1;
							} :
							function(a, b) {
								// Exit early if the nodes are identical
								if(a === b) {
									hasDuplicate = true;
									return 0;
								}
								
								var cur,
									i = 0,
									aup = a.parentNode,
									bup = b.parentNode,
									ap = [a],
									bp = [b];
								
								// Parentless nodes are either documents or disconnected
								if(!aup || !bup) {
									return a === document ? -1 :
										b === document ? 1 :
											aup ? -1 :
												bup ? 1 :
													sortInput ?
														(indexOf(sortInput, a) - indexOf(sortInput, b)) :
														0;
									
									// If the nodes are siblings, we can do a quick check
								} else if(aup === bup) {
									return siblingCheck(a, b);
								}
								
								// Otherwise we need full lists of their ancestors for comparison
								cur = a;
								while((cur = cur.parentNode)) {
									ap.unshift(cur);
								}
								cur = b;
								while((cur = cur.parentNode)) {
									bp.unshift(cur);
								}
								
								// Walk down the tree looking for a discrepancy
								while(ap[i] === bp[i]) {
									i++;
								}
								
								return i ?
									// Do a sibling check if the nodes have a common ancestor
									siblingCheck(ap[i], bp[i]) :
									
									// Otherwise nodes in our document sort first
									ap[i] === preferredDoc ? -1 :
										bp[i] === preferredDoc ? 1 :
											0;
							};
						
						return document;
					};
					
					Sizzle.matches = function(expr, elements) {
						return Sizzle(expr, null, null, elements);
					};
					
					Sizzle.matchesSelector = function(elem, expr) {
						// Set document vars if needed
						if((elem.ownerDocument || elem) !== document) {
							setDocument(elem);
						}
						
						// Make sure that attribute selectors are quoted
						expr = expr.replace(rattributeQuotes, "='$1']");
						
						if(support.matchesSelector && documentIsHTML &&
							!compilerCache[expr + " "] &&
							(!rbuggyMatches || !rbuggyMatches.test(expr)) &&
							(!rbuggyQSA || !rbuggyQSA.test(expr))) {
							
							try {
								var ret = matches.call(elem, expr);
								
								// IE 9's matchesSelector returns false on disconnected nodes
								if(ret || support.disconnectedMatch ||
									// As well, disconnected nodes are said to be in a document
									// fragment in IE 9
									elem.document && elem.document.nodeType !== 11) {
									return ret;
								}
							} catch(e) {
							}
						}
						
						return Sizzle(expr, document, null, [elem]).length > 0;
					};
					
					Sizzle.contains = function(context, elem) {
						// Set document vars if needed
						if((context.ownerDocument || context) !== document) {
							setDocument(context);
						}
						return contains(context, elem);
					};
					
					Sizzle.attr = function(elem, name) {
						// Set document vars if needed
						if((elem.ownerDocument || elem) !== document) {
							setDocument(elem);
						}
						
						var fn = Expr.attrHandle[name.toLowerCase()],
							// Don't get fooled by Object.prototype properties (jQuery #13807)
							val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ?
								fn(elem, name, !documentIsHTML) :
								undefined;
						
						return val !== undefined ?
							val :
							support.attributes || !documentIsHTML ?
								elem.getAttribute(name) :
								(val = elem.getAttributeNode(name)) && val.specified ?
									val.value :
									null;
					};
					
					Sizzle.escape = function(sel) {
						return (sel + "").replace(rcssescape, fcssescape);
					};
					
					Sizzle.error = function(msg) {
						throw new Error("Syntax error, unrecognized expression: " + msg);
					};
					
					/**
					 * Document sorting and removing duplicates
					 * @param {ArrayLike} results
					 */
					Sizzle.uniqueSort = function(results) {
						var elem,
							duplicates = [],
							j = 0,
							i = 0;
						
						// Unless we *know* we can detect duplicates, assume their presence
						hasDuplicate = !support.detectDuplicates;
						sortInput = !support.sortStable && results.slice(0);
						results.sort(sortOrder);
						
						if(hasDuplicate) {
							while((elem = results[i++])) {
								if(elem === results[i]) {
									j = duplicates.push(i);
								}
							}
							while(j--) {
								results.splice(duplicates[j], 1);
							}
						}
						
						// Clear input after sorting to release objects
						// See https://github.com/jquery/sizzle/pull/225
						sortInput = null;
						
						return results;
					};
					
					/**
					 * Utility function for retrieving the text value of an array of DOM nodes
					 * @param {Array|Element} elem
					 */
					getText = Sizzle.getText = function(elem) {
						var node,
							ret = "",
							i = 0,
							nodeType = elem.nodeType;
						
						if(!nodeType) {
							// If no nodeType, this is expected to be an array
							while((node = elem[i++])) {
								// Do not traverse comment nodes
								ret += getText(node);
							}
						} else if(nodeType === 1 || nodeType === 9 || nodeType === 11) {
							// Use textContent for elements
							// innerText usage removed for consistency of new lines (jQuery #11153)
							if(typeof elem.textContent === "string") {
								return elem.textContent;
							} else {
								// Traverse its children
								for(elem = elem.firstChild; elem; elem = elem.nextSibling) {
									ret += getText(elem);
								}
							}
						} else if(nodeType === 3 || nodeType === 4) {
							return elem.nodeValue;
						}
						// Do not include comment or processing instruction nodes
						
						return ret;
					};
					
					Expr = Sizzle.selectors = {
						
						// Can be adjusted by the user
						cacheLength: 50,
						
						createPseudo: markFunction,
						
						match: matchExpr,
						
						attrHandle: {},
						
						find: {},
						
						relative: {
							">": {dir: "parentNode", first: true},
							" ": {dir: "parentNode"},
							"+": {dir: "previousSibling", first: true},
							"~": {dir: "previousSibling"}
						},
						
						preFilter: {
							"ATTR": function(match) {
								match[1] = match[1].replace(runescape, funescape);
								
								// Move the given value to match[3] whether quoted or unquoted
								match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
								
								if(match[2] === "~=") {
									match[3] = " " + match[3] + " ";
								}
								
								return match.slice(0, 4);
							},
							
							"CHILD": function(match) {
								/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
								match[1] = match[1].toLowerCase();
								
								if(match[1].slice(0, 3) === "nth") {
									// nth-* requires argument
									if(!match[3]) {
										Sizzle.error(match[0]);
									}
									
									// numeric x and y parameters for Expr.filter.CHILD
									// remember that false/true cast respectively to 0/1
									match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
									match[5] = +((match[7] + match[8]) || match[3] === "odd");
									
									// other types prohibit arguments
								} else if(match[3]) {
									Sizzle.error(match[0]);
								}
								
								return match;
							},
							
							"PSEUDO": function(match) {
								var excess,
									unquoted = !match[6] && match[2];
								
								if(matchExpr["CHILD"].test(match[0])) {
									return null;
								}
								
								// Accept quoted arguments as-is
								if(match[3]) {
									match[2] = match[4] || match[5] || "";
									
									// Strip excess characters from unquoted arguments
								} else if(unquoted && rpseudo.test(unquoted) &&
									// Get excess from tokenize (recursively)
									(excess = tokenize(unquoted, true)) &&
									// advance to the next closing parenthesis
									(excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
									
									// excess is a negative index
									match[0] = match[0].slice(0, excess);
									match[2] = unquoted.slice(0, excess);
								}
								
								// Return only captures needed by the pseudo filter method (type and argument)
								return match.slice(0, 3);
							}
						},
						
						filter: {
							
							"TAG": function(nodeNameSelector) {
								var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
								return nodeNameSelector === "*" ?
									function() {
										return true;
									} :
									function(elem) {
										return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
									};
							},
							
							"CLASS": function(className) {
								var pattern = classCache[className + " "];
								
								return pattern ||
									(pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) &&
									classCache(className, function(elem) {
										return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
									});
							},
							
							"ATTR": function(name, operator, check) {
								return function(elem) {
									var result = Sizzle.attr(elem, name);
									
									if(result == null) {
										return operator === "!=";
									}
									if(!operator) {
										return true;
									}
									
									result += "";
									
									return operator === "=" ? result === check :
										operator === "!=" ? result !== check :
											operator === "^=" ? check && result.indexOf(check) === 0 :
												operator === "*=" ? check && result.indexOf(check) > -1 :
													operator === "$=" ? check && result.slice(-check.length) === check :
														operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 :
															operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" :
																false;
								};
							},
							
							"CHILD": function(type, what, argument, first, last) {
								var simple = type.slice(0, 3) !== "nth",
									forward = type.slice(-4) !== "last",
									ofType = what === "of-type";
								
								return first === 1 && last === 0 ?
									
									// Shortcut for :nth-*(n)
									function(elem) {
										return !!elem.parentNode;
									} :
									
									function(elem, context, xml) {
										var cache, uniqueCache, outerCache, node, nodeIndex, start,
											dir = simple !== forward ? "nextSibling" : "previousSibling",
											parent = elem.parentNode,
											name = ofType && elem.nodeName.toLowerCase(),
											useCache = !xml && !ofType,
											diff = false;
										
										if(parent) {
											
											// :(first|last|only)-(child|of-type)
											if(simple) {
												while(dir) {
													node = elem;
													while((node = node[dir])) {
														if(ofType ?
															node.nodeName.toLowerCase() === name :
															node.nodeType === 1) {
															
															return false;
														}
													}
													// Reverse direction for :only-* (if we haven't yet done so)
													start = dir = type === "only" && !start && "nextSibling";
												}
												return true;
											}
											
											start = [forward ? parent.firstChild : parent.lastChild];
											
											// non-xml :nth-child(...) stores cache data on `parent`
											if(forward && useCache) {
												
												// Seek `elem` from a previously-cached index
												
												// ...in a gzip-friendly way
												node = parent;
												outerCache = node[expando] || (node[expando] = {});
												
												// Support: IE <9 only
												// Defend against cloned attroperties (jQuery gh-1709)
												uniqueCache = outerCache[node.uniqueID] ||
													(outerCache[node.uniqueID] = {});
												
												cache = uniqueCache[type] || [];
												nodeIndex = cache[0] === dirruns && cache[1];
												diff = nodeIndex && cache[2];
												node = nodeIndex && parent.childNodes[nodeIndex];
												
												while((node = ++nodeIndex && node && node[dir] ||
													
													// Fallback to seeking `elem` from the start
													(diff = nodeIndex = 0) || start.pop())) {
													
													// When found, cache indexes on `parent` and break
													if(node.nodeType === 1 && ++diff && node === elem) {
														uniqueCache[type] = [dirruns, nodeIndex, diff];
														break;
													}
												}
												
											} else {
												// Use previously-cached element index if available
												if(useCache) {
													// ...in a gzip-friendly way
													node = elem;
													outerCache = node[expando] || (node[expando] = {});
													
													// Support: IE <9 only
													// Defend against cloned attroperties (jQuery gh-1709)
													uniqueCache = outerCache[node.uniqueID] ||
														(outerCache[node.uniqueID] = {});
													
													cache = uniqueCache[type] || [];
													nodeIndex = cache[0] === dirruns && cache[1];
													diff = nodeIndex;
												}
												
												// xml :nth-child(...)
												// or :nth-last-child(...) or :nth(-last)?-of-type(...)
												if(diff === false) {
													// Use the same loop as above to seek `elem` from the start
													while((node = ++nodeIndex && node && node[dir] ||
														(diff = nodeIndex = 0) || start.pop())) {
														
														if((ofType ?
															node.nodeName.toLowerCase() === name :
															node.nodeType === 1) &&
															++diff) {
															
															// Cache the index of each encountered element
															if(useCache) {
																outerCache = node[expando] || (node[expando] = {});
																
																// Support: IE <9 only
																// Defend against cloned attroperties (jQuery gh-1709)
																uniqueCache = outerCache[node.uniqueID] ||
																	(outerCache[node.uniqueID] = {});
																
																uniqueCache[type] = [dirruns, diff];
															}
															
															if(node === elem) {
																break;
															}
														}
													}
												}
											}
											
											// Incorporate the offset, then check against cycle size
											diff -= last;
											return diff === first || (diff % first === 0 && diff / first >= 0);
										}
									};
							},
							
							"PSEUDO": function(pseudo, argument) {
								// pseudo-class names are case-insensitive
								// http://www.w3.org/TR/selectors/#pseudo-classes
								// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
								// Remember that setFilters inherits from pseudos
								var args,
									fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] ||
										Sizzle.error("unsupported pseudo: " + pseudo);
								
								// The user may use createPseudo to indicate that
								// arguments are needed to create the filter function
								// just as Sizzle does
								if(fn[expando]) {
									return fn(argument);
								}
								
								// But maintain support for old signatures
								if(fn.length > 1) {
									args = [pseudo, pseudo, "", argument];
									return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ?
										markFunction(function(seed, matches) {
											var idx,
												matched = fn(seed, argument),
												i = matched.length;
											while(i--) {
												idx = indexOf(seed, matched[i]);
												seed[idx] = !(matches[idx] = matched[i]);
											}
										}) :
										function(elem) {
											return fn(elem, 0, args);
										};
								}
								
								return fn;
							}
						},
						
						pseudos: {
							// Potentially complex pseudos
							"not": markFunction(function(selector) {
								// Trim the selector passed to compile
								// to avoid treating leading and trailing
								// spaces as combinators
								var input = [],
									results = [],
									matcher = compile(selector.replace(rtrim, "$1"));
								
								return matcher[expando] ?
									markFunction(function(seed, matches, context, xml) {
										var elem,
											unmatched = matcher(seed, null, xml, []),
											i = seed.length;
										
										// Match elements unmatched by `matcher`
										while(i--) {
											if((elem = unmatched[i])) {
												seed[i] = !(matches[i] = elem);
											}
										}
									}) :
									function(elem, context, xml) {
										input[0] = elem;
										matcher(input, null, xml, results);
										// Don't keep the element (issue #299)
										input[0] = null;
										return !results.pop();
									};
							}),
							
							"has": markFunction(function(selector) {
								return function(elem) {
									return Sizzle(selector, elem).length > 0;
								};
							}),
							
							"contains": markFunction(function(text) {
								text = text.replace(runescape, funescape);
								return function(elem) {
									return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
								};
							}),
							
							// "Whether an element is represented by a :lang() selector
							// is based solely on the element's language value
							// being equal to the identifier C,
							// or beginning with the identifier C immediately followed by "-".
							// The matching of C against the element's language value is performed case-insensitively.
							// The identifier C does not have to be a valid language name."
							// http://www.w3.org/TR/selectors/#lang-pseudo
							"lang": markFunction(function(lang) {
								// lang value must be a valid identifier
								if(!ridentifier.test(lang || "")) {
									Sizzle.error("unsupported lang: " + lang);
								}
								lang = lang.replace(runescape, funescape).toLowerCase();
								return function(elem) {
									var elemLang;
									do {
										if((elemLang = documentIsHTML ?
											elem.lang :
											elem.getAttribute("xml:lang") || elem.getAttribute("lang"))) {
											
											elemLang = elemLang.toLowerCase();
											return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
										}
									} while((elem = elem.parentNode) && elem.nodeType === 1);
									return false;
								};
							}),
							
							// Miscellaneous
							"target": function(elem) {
								var hash = window.location && window.location.hash;
								return hash && hash.slice(1) === elem.id;
							},
							
							"root": function(elem) {
								return elem === docElem;
							},
							
							"focus": function(elem) {
								return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
							},
							
							// Boolean properties
							"enabled": createDisabledPseudo(false),
							"disabled": createDisabledPseudo(true),
							
							"checked": function(elem) {
								// In CSS3, :checked should return both checked and selected elements
								// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
								var nodeName = elem.nodeName.toLowerCase();
								return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
							},
							
							"selected": function(elem) {
								// Accessing this property makes selected-by-default
								// options in Safari work properly
								if(elem.parentNode) {
									elem.parentNode.selectedIndex;
								}
								
								return elem.selected === true;
							},
							
							// Contents
							"empty": function(elem) {
								// http://www.w3.org/TR/selectors/#empty-pseudo
								// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
								//   but not by others (comment: 8; processing instruction: 7; etc.)
								// nodeType < 6 works because attributes (2) do not appear as children
								for(elem = elem.firstChild; elem; elem = elem.nextSibling) {
									if(elem.nodeType < 6) {
										return false;
									}
								}
								return true;
							},
							
							"parent": function(elem) {
								return !Expr.pseudos["empty"](elem);
							},
							
							// Element/input types
							"header": function(elem) {
								return rheader.test(elem.nodeName);
							},
							
							"input": function(elem) {
								return rinputs.test(elem.nodeName);
							},
							
							"button": function(elem) {
								var name = elem.nodeName.toLowerCase();
								return name === "input" && elem.type === "button" || name === "button";
							},
							
							"text": function(elem) {
								var attr;
								return elem.nodeName.toLowerCase() === "input" &&
									elem.type === "text" &&
									
									// Support: IE<8
									// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
									((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
							},
							
							// Position-in-collection
							"first": createPositionalPseudo(function() {
								return [0];
							}),
							
							"last": createPositionalPseudo(function(matchIndexes, length) {
								return [length - 1];
							}),
							
							"eq": createPositionalPseudo(function(matchIndexes, length, argument) {
								return [argument < 0 ? argument + length : argument];
							}),
							
							"even": createPositionalPseudo(function(matchIndexes, length) {
								var i = 0;
								for(; i < length; i += 2) {
									matchIndexes.push(i);
								}
								return matchIndexes;
							}),
							
							"odd": createPositionalPseudo(function(matchIndexes, length) {
								var i = 1;
								for(; i < length; i += 2) {
									matchIndexes.push(i);
								}
								return matchIndexes;
							}),
							
							"lt": createPositionalPseudo(function(matchIndexes, length, argument) {
								var i = argument < 0 ? argument + length : argument;
								for(; --i >= 0;) {
									matchIndexes.push(i);
								}
								return matchIndexes;
							}),
							
							"gt": createPositionalPseudo(function(matchIndexes, length, argument) {
								var i = argument < 0 ? argument + length : argument;
								for(; ++i < length;) {
									matchIndexes.push(i);
								}
								return matchIndexes;
							})
						}
					};
					
					Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
					for(i in {radio: true, checkbox: true, file: true, password: true, image: true}) {
						Expr.pseudos[i] = createInputPseudo(i);
					}
					for(i in {submit: true, reset: true}) {
						Expr.pseudos[i] = createButtonPseudo(i);
					}

// Easy API for creating new setFilters
					function setFilters() {
					}
					
					setFilters.prototype = Expr.filters = Expr.pseudos;
					Expr.setFilters = new setFilters();
					
					tokenize = Sizzle.tokenize = function(selector, parseOnly) {
						var matched, match, tokens, type,
							soFar, groups, preFilters,
							cached = tokenCache[selector + " "];
						
						if(cached) {
							return parseOnly ? 0 : cached.slice(0);
						}
						
						soFar = selector;
						groups = [];
						preFilters = Expr.preFilter;
						
						while(soFar) {
							
							// Comma and first run
							if(!matched || (match = rcomma.exec(soFar))) {
								if(match) {
									// Don't consume trailing commas as valid
									soFar = soFar.slice(match[0].length) || soFar;
								}
								groups.push((tokens = []));
							}
							
							matched = false;
							
							// Combinators
							if((match = rcombinators.exec(soFar))) {
								matched = match.shift();
								tokens.push({
									value: matched,
									// Cast descendant combinators to space
									type: match[0].replace(rtrim, " ")
								});
								soFar = soFar.slice(matched.length);
							}
							
							// Filters
							for(type in Expr.filter) {
								if((match = matchExpr[type].exec(soFar)) && (!preFilters[type] ||
									(match = preFilters[type](match)))) {
									matched = match.shift();
									tokens.push({
										value: matched,
										type: type,
										matches: match
									});
									soFar = soFar.slice(matched.length);
								}
							}
							
							if(!matched) {
								break;
							}
						}
						
						// Return the length of the invalid excess
						// if we're just parsing
						// Otherwise, throw an error or return tokens
						return parseOnly ?
							soFar.length :
							soFar ?
								Sizzle.error(selector) :
								// Cache the tokens
								tokenCache(selector, groups).slice(0);
					};
					
					function toSelector(tokens) {
						var i = 0,
							len = tokens.length,
							selector = "";
						for(; i < len; i++) {
							selector += tokens[i].value;
						}
						return selector;
					}
					
					function addCombinator(matcher, combinator, base) {
						var dir = combinator.dir,
							skip = combinator.next,
							key = skip || dir,
							checkNonElements = base && key === "parentNode",
							doneName = done++;
						
						return combinator.first ?
							// Check against closest ancestor/preceding element
							function(elem, context, xml) {
								while((elem = elem[dir])) {
									if(elem.nodeType === 1 || checkNonElements) {
										return matcher(elem, context, xml);
									}
								}
								return false;
							} :
							
							// Check against all ancestor/preceding elements
							function(elem, context, xml) {
								var oldCache, uniqueCache, outerCache,
									newCache = [dirruns, doneName];
								
								// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
								if(xml) {
									while((elem = elem[dir])) {
										if(elem.nodeType === 1 || checkNonElements) {
											if(matcher(elem, context, xml)) {
												return true;
											}
										}
									}
								} else {
									while((elem = elem[dir])) {
										if(elem.nodeType === 1 || checkNonElements) {
											outerCache = elem[expando] || (elem[expando] = {});
											
											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});
											
											if(skip && skip === elem.nodeName.toLowerCase()) {
												elem = elem[dir] || elem;
											} else if((oldCache = uniqueCache[key]) &&
												oldCache[0] === dirruns && oldCache[1] === doneName) {
												
												// Assign to newCache so results back-propagate to previous elements
												return (newCache[2] = oldCache[2]);
											} else {
												// Reuse newcache so results back-propagate to previous elements
												uniqueCache[key] = newCache;
												
												// A match means we're done; a fail means we have to keep checking
												if((newCache[2] = matcher(elem, context, xml))) {
													return true;
												}
											}
										}
									}
								}
								return false;
							};
					}
					
					function elementMatcher(matchers) {
						return matchers.length > 1 ?
							function(elem, context, xml) {
								var i = matchers.length;
								while(i--) {
									if(!matchers[i](elem, context, xml)) {
										return false;
									}
								}
								return true;
							} :
							matchers[0];
					}
					
					function multipleContexts(selector, contexts, results) {
						var i = 0,
							len = contexts.length;
						for(; i < len; i++) {
							Sizzle(selector, contexts[i], results);
						}
						return results;
					}
					
					function condense(unmatched, map, filter, context, xml) {
						var elem,
							newUnmatched = [],
							i = 0,
							len = unmatched.length,
							mapped = map != null;
						
						for(; i < len; i++) {
							if((elem = unmatched[i])) {
								if(!filter || filter(elem, context, xml)) {
									newUnmatched.push(elem);
									if(mapped) {
										map.push(i);
									}
								}
							}
						}
						
						return newUnmatched;
					}
					
					function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
						if(postFilter && !postFilter[expando]) {
							postFilter = setMatcher(postFilter);
						}
						if(postFinder && !postFinder[expando]) {
							postFinder = setMatcher(postFinder, postSelector);
						}
						return markFunction(function(seed, results, context, xml) {
							var temp, i, elem,
								preMap = [],
								postMap = [],
								preexisting = results.length,
								
								// Get initial elements from seed or context
								elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
								
								// Prefilter to get matcher input, preserving a map for seed-results synchronization
								matcherIn = preFilter && (seed || !selector) ?
									condense(elems, preMap, preFilter, context, xml) :
									elems,
								
								matcherOut = matcher ?
									// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
									postFinder || (seed ? preFilter : preexisting || postFilter) ?
										
										// ...intermediate processing is necessary
										[] :
										
										// ...otherwise use results directly
										results :
									matcherIn;
							
							// Find primary matches
							if(matcher) {
								matcher(matcherIn, matcherOut, context, xml);
							}
							
							// Apply postFilter
							if(postFilter) {
								temp = condense(matcherOut, postMap);
								postFilter(temp, [], context, xml);
								
								// Un-match failing elements by moving them back to matcherIn
								i = temp.length;
								while(i--) {
									if((elem = temp[i])) {
										matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
									}
								}
							}
							
							if(seed) {
								if(postFinder || preFilter) {
									if(postFinder) {
										// Get the final matcherOut by condensing this intermediate into postFinder contexts
										temp = [];
										i = matcherOut.length;
										while(i--) {
											if((elem = matcherOut[i])) {
												// Restore matcherIn since elem is not yet a final match
												temp.push((matcherIn[i] = elem));
											}
										}
										postFinder(null, (matcherOut = []), temp, xml);
									}
									
									// Move matched elements from seed to results to keep them synchronized
									i = matcherOut.length;
									while(i--) {
										if((elem = matcherOut[i]) &&
											(temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
											
											seed[temp] = !(results[temp] = elem);
										}
									}
								}
								
								// Add elements to results, through postFinder if defined
							} else {
								matcherOut = condense(
									matcherOut === results ?
										matcherOut.splice(preexisting, matcherOut.length) :
										matcherOut
								);
								if(postFinder) {
									postFinder(null, results, matcherOut, xml);
								} else {
									push.apply(results, matcherOut);
								}
							}
						});
					}
					
					function matcherFromTokens(tokens) {
						var checkContext, matcher, j,
							len = tokens.length,
							leadingRelative = Expr.relative[tokens[0].type],
							implicitRelative = leadingRelative || Expr.relative[" "],
							i = leadingRelative ? 1 : 0,
							
							// The foundational matcher ensures that elements are reachable from top-level context(s)
							matchContext = addCombinator(function(elem) {
								return elem === checkContext;
							}, implicitRelative, true),
							matchAnyContext = addCombinator(function(elem) {
								return indexOf(checkContext, elem) > -1;
							}, implicitRelative, true),
							matchers = [function(elem, context, xml) {
								var ret = (!leadingRelative && (xml || context !== outermostContext)) || (
									(checkContext = context).nodeType ?
										matchContext(elem, context, xml) :
										matchAnyContext(elem, context, xml));
								// Avoid hanging onto element (issue #299)
								checkContext = null;
								return ret;
							}];
						
						for(; i < len; i++) {
							if((matcher = Expr.relative[tokens[i].type])) {
								matchers = [addCombinator(elementMatcher(matchers), matcher)];
							} else {
								matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
								
								// Return special upon seeing a positional matcher
								if(matcher[expando]) {
									// Find the next relative operator (if any) for proper handling
									j = ++i;
									for(; j < len; j++) {
										if(Expr.relative[tokens[j].type]) {
											break;
										}
									}
									return setMatcher(
										i > 1 && elementMatcher(matchers),
										i > 1 && toSelector(
										// If the preceding token was a descendant combinator, insert an implicit any-element `*`
										tokens.slice(0, i - 1).concat({value: tokens[i - 2].type === " " ? "*" : ""})
										).replace(rtrim, "$1"),
										matcher,
										i < j && matcherFromTokens(tokens.slice(i, j)),
										j < len && matcherFromTokens((tokens = tokens.slice(j))),
										j < len && toSelector(tokens)
									);
								}
								matchers.push(matcher);
							}
						}
						
						return elementMatcher(matchers);
					}
					
					function matcherFromGroupMatchers(elementMatchers, setMatchers) {
						var bySet = setMatchers.length > 0,
							byElement = elementMatchers.length > 0,
							superMatcher = function(seed, context, xml, results, outermost) {
								var elem, j, matcher,
									matchedCount = 0,
									i = "0",
									unmatched = seed && [],
									setMatched = [],
									contextBackup = outermostContext,
									// We must always have either seed elements or outermost context
									elems = seed || byElement && Expr.find["TAG"]("*", outermost),
									// Use integer dirruns iff this is the outermost matcher
									dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
									len = elems.length;
								
								if(outermost) {
									outermostContext = context === document || context || outermost;
								}
								
								// Add elements passing elementMatchers directly to results
								// Support: IE<9, Safari
								// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
								for(; i !== len && (elem = elems[i]) != null; i++) {
									if(byElement && elem) {
										j = 0;
										if(!context && elem.ownerDocument !== document) {
											setDocument(elem);
											xml = !documentIsHTML;
										}
										while((matcher = elementMatchers[j++])) {
											if(matcher(elem, context || document, xml)) {
												results.push(elem);
												break;
											}
										}
										if(outermost) {
											dirruns = dirrunsUnique;
										}
									}
									
									// Track unmatched elements for set filters
									if(bySet) {
										// They will have gone through all possible matchers
										if((elem = !matcher && elem)) {
											matchedCount--;
										}
										
										// Lengthen the array for every element, matched or not
										if(seed) {
											unmatched.push(elem);
										}
									}
								}
								
								// `i` is now the count of elements visited above, and adding it to `matchedCount`
								// makes the latter nonnegative.
								matchedCount += i;
								
								// Apply set filters to unmatched elements
								// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
								// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
								// no element matchers and no seed.
								// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
								// case, which will result in a "00" `matchedCount` that differs from `i` but is also
								// numerically zero.
								if(bySet && i !== matchedCount) {
									j = 0;
									while((matcher = setMatchers[j++])) {
										matcher(unmatched, setMatched, context, xml);
									}
									
									if(seed) {
										// Reintegrate element matches to eliminate the need for sorting
										if(matchedCount > 0) {
											while(i--) {
												if(!(unmatched[i] || setMatched[i])) {
													setMatched[i] = pop.call(results);
												}
											}
										}
										
										// Discard index placeholder values to get only actual matches
										setMatched = condense(setMatched);
									}
									
									// Add matches to results
									push.apply(results, setMatched);
									
									// Seedless set matches succeeding multiple successful matchers stipulate sorting
									if(outermost && !seed && setMatched.length > 0 &&
										(matchedCount + setMatchers.length) > 1) {
										
										Sizzle.uniqueSort(results);
									}
								}
								
								// Override manipulation of globals by nested matchers
								if(outermost) {
									dirruns = dirrunsUnique;
									outermostContext = contextBackup;
								}
								
								return unmatched;
							};
						
						return bySet ?
							markFunction(superMatcher) :
							superMatcher;
					}
					
					compile = Sizzle.compile = function(selector, match /* Internal Use Only */) {
						var i,
							setMatchers = [],
							elementMatchers = [],
							cached = compilerCache[selector + " "];
						
						if(!cached) {
							// Generate a function of recursive functions that can be used to check each element
							if(!match) {
								match = tokenize(selector);
							}
							i = match.length;
							while(i--) {
								cached = matcherFromTokens(match[i]);
								if(cached[expando]) {
									setMatchers.push(cached);
								} else {
									elementMatchers.push(cached);
								}
							}
							
							// Cache the compiled function
							cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
							
							// Save selector and tokenization
							cached.selector = selector;
						}
						return cached;
					};
					
					/**
					 * A low-level selection function that works with Sizzle's compiled
					 *  selector functions
					 * @param {String|Function} selector A selector or a pre-compiled
					 *  selector function built with Sizzle.compile
					 * @param {Element} context
					 * @param {Array} [results]
					 * @param {Array} [seed] A set of elements to match against
					 */
					select = Sizzle.select = function(selector, context, results, seed) {
						var i, tokens, token, type, find,
							compiled = typeof selector === "function" && selector,
							match = !seed && tokenize((selector = compiled.selector || selector));
						
						results = results || [];
						
						// Try to minimize operations if there is only one selector in the list and no seed
						// (the latter of which guarantees us context)
						if(match.length === 1) {
							
							// Reduce context if the leading compound selector is an ID
							tokens = match[0] = match[0].slice(0);
							if(tokens.length > 2 && (token = tokens[0]).type === "ID" &&
								context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
								
								context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
								if(!context) {
									return results;
									
									// Precompiled matchers will still verify ancestry, so step up a level
								} else if(compiled) {
									context = context.parentNode;
								}
								
								selector = selector.slice(tokens.shift().value.length);
							}
							
							// Fetch a seed set for right-to-left matching
							i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
							while(i--) {
								token = tokens[i];
								
								// Abort if we hit a combinator
								if(Expr.relative[(type = token.type)]) {
									break;
								}
								if((find = Expr.find[type])) {
									// Search, expanding context for leading sibling combinators
									if((seed = find(
										token.matches[0].replace(runescape, funescape),
										rsibling.test(tokens[0].type) && testContext(context.parentNode) || context
									))) {
										
										// If seed is empty or no tokens remain, we can return early
										tokens.splice(i, 1);
										selector = seed.length && toSelector(tokens);
										if(!selector) {
											push.apply(results, seed);
											return results;
										}
										
										break;
									}
								}
							}
						}
						
						// Compile and execute a filtering function if one is not provided
						// Provide `match` to avoid retokenization if we modified the selector above
						(compiled || compile(selector, match))(
							seed,
							context,
							!documentIsHTML,
							results,
							!context || rsibling.test(selector) && testContext(context.parentNode) || context
						);
						return results;
					};

// One-time assignments

// Sort stability
					support.sortStable = expando.split("").sort(sortOrder).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
					support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
					setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
					support.sortDetached = assert(function(el) {
						// Should return 1, but returns 4 (following)
						return el.compareDocumentPosition(document.createElement("fieldset")) & 1;
					});

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
					if(!assert(function(el) {
						el.innerHTML = "<a href='#'></a>";
						return el.firstChild.getAttribute("href") === "#";
					})) {
						addHandle("type|href|height|width", function(elem, name, isXML) {
							if(!isXML) {
								return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
							}
						});
					}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
					if(!support.attributes || !assert(function(el) {
						el.innerHTML = "<input/>";
						el.firstChild.setAttribute("value", "");
						return el.firstChild.getAttribute("value") === "";
					})) {
						addHandle("value", function(elem, name, isXML) {
							if(!isXML && elem.nodeName.toLowerCase() === "input") {
								return elem.defaultValue;
							}
						});
					}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
					if(!assert(function(el) {
						return el.getAttribute("disabled") == null;
					})) {
						addHandle(booleans, function(elem, name, isXML) {
							var val;
							if(!isXML) {
								return elem[name] === true ? name.toLowerCase() :
									(val = elem.getAttributeNode(name)) && val.specified ?
										val.value :
										null;
							}
						});
					}
					
					return Sizzle;
					
				})(window);
			
			
			jQuery.find = Sizzle;
			jQuery.expr = Sizzle.selectors;

// Deprecated
			jQuery.expr[":"] = jQuery.expr.pseudos;
			jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
			jQuery.text = Sizzle.getText;
			jQuery.isXMLDoc = Sizzle.isXML;
			jQuery.contains = Sizzle.contains;
			jQuery.escapeSelector = Sizzle.escape;
			
			
			var dir = function(elem, dir, until) {
				var matched = [],
					truncate = until !== undefined;
				
				while((elem = elem[dir]) && elem.nodeType !== 9) {
					if(elem.nodeType === 1) {
						if(truncate && jQuery(elem).is(until)) {
							break;
						}
						matched.push(elem);
					}
				}
				return matched;
			};
			
			
			var siblings = function(n, elem) {
				var matched = [];
				
				for(; n; n = n.nextSibling) {
					if(n.nodeType === 1 && n !== elem) {
						matched.push(n);
					}
				}
				
				return matched;
			};
			
			
			var rneedsContext = jQuery.expr.match.needsContext;
			
			
			function nodeName(elem, name) {
				
				return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
				
			};
			var rsingleTag = (/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i);


// Implement the identical functionality for filter and not
			function winnow(elements, qualifier, not) {
				if(isFunction(qualifier)) {
					return jQuery.grep(elements, function(elem, i) {
						return !!qualifier.call(elem, i, elem) !== not;
					});
				}
				
				// Single element
				if(qualifier.nodeType) {
					return jQuery.grep(elements, function(elem) {
						return (elem === qualifier) !== not;
					});
				}
				
				// Arraylike of elements (jQuery, arguments, Array)
				if(typeof qualifier !== "string") {
					return jQuery.grep(elements, function(elem) {
						return (indexOf.call(qualifier, elem) > -1) !== not;
					});
				}
				
				// Filtered directly for both simple and complex selectors
				return jQuery.filter(qualifier, elements, not);
			}
			
			jQuery.filter = function(expr, elems, not) {
				var elem = elems[0];
				
				if(not) {
					expr = ":not(" + expr + ")";
				}
				
				if(elems.length === 1 && elem.nodeType === 1) {
					return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
				}
				
				return jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
					return elem.nodeType === 1;
				}));
			};
			
			jQuery.fn.extend({
				find: function(selector) {
					var i, ret,
						len = this.length,
						self = this;
					
					if(typeof selector !== "string") {
						return this.pushStack(jQuery(selector).filter(function() {
							for(i = 0; i < len; i++) {
								if(jQuery.contains(self[i], this)) {
									return true;
								}
							}
						}));
					}
					
					ret = this.pushStack([]);
					
					for(i = 0; i < len; i++) {
						jQuery.find(selector, self[i], ret);
					}
					
					return len > 1 ? jQuery.uniqueSort(ret) : ret;
				},
				filter: function(selector) {
					return this.pushStack(winnow(this, selector || [], false));
				},
				not: function(selector) {
					return this.pushStack(winnow(this, selector || [], true));
				},
				is: function(selector) {
					return !!winnow(
						this,
						
						// If this is a positional/relative selector, check membership in the returned set
						// so $("p:first").is("p:last") won't return true for a doc with two "p".
						typeof selector === "string" && rneedsContext.test(selector) ?
							jQuery(selector) :
							selector || [],
						false
					).length;
				}
			});


// Initialize a jQuery object


// A central reference to the root jQuery(document)
			var rootjQuery,
				
				// A simple way to check for HTML strings
				// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
				// Strict HTML recognition (#11290: must start with <)
				// Shortcut simple #id case for speed
				rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
				
				init = jQuery.fn.init = function(selector, context, root) {
					var match, elem;
					
					// HANDLE: $(""), $(null), $(undefined), $(false)
					if(!selector) {
						return this;
					}
					
					// Method init() accepts an alternate rootjQuery
					// so migrate can support jQuery.sub (gh-2101)
					root = root || rootjQuery;
					
					// Handle HTML strings
					if(typeof selector === "string") {
						if(selector[0] === "<" &&
							selector[selector.length - 1] === ">" &&
							selector.length >= 3) {
							
							// Assume that strings that start and end with <> are HTML and skip the regex check
							match = [null, selector, null];
							
						} else {
							match = rquickExpr.exec(selector);
						}
						
						// Match html or make sure no context is specified for #id
						if(match && (match[1] || !context)) {
							
							// HANDLE: $(html) -> $(array)
							if(match[1]) {
								context = context instanceof jQuery ? context[0] : context;
								
								// Option to run scripts is true for back-compat
								// Intentionally let the error be thrown if parseHTML is not present
								jQuery.merge(this, jQuery.parseHTML(
									match[1],
									context && context.nodeType ? context.ownerDocument || context : document,
									true
								));
								
								// HANDLE: $(html, props)
								if(rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
									for(match in context) {
										
										// Properties of context are called as methods if possible
										if(isFunction(this[match])) {
											this[match](context[match]);
											
											// ...and otherwise set as attributes
										} else {
											this.attr(match, context[match]);
										}
									}
								}
								
								return this;
								
								// HANDLE: $(#id)
							} else {
								elem = document.getElementById(match[2]);
								
								if(elem) {
									
									// Inject the element directly into the jQuery object
									this[0] = elem;
									this.length = 1;
								}
								return this;
							}
							
							// HANDLE: $(expr, $(...))
						} else if(!context || context.jquery) {
							return (context || root).find(selector);
							
							// HANDLE: $(expr, context)
							// (which is just equivalent to: $(context).find(expr)
						} else {
							return this.constructor(context).find(selector);
						}
						
						// HANDLE: $(DOMElement)
					} else if(selector.nodeType) {
						this[0] = selector;
						this.length = 1;
						return this;
						
						// HANDLE: $(function)
						// Shortcut for document ready
					} else if(isFunction(selector)) {
						return root.ready !== undefined ?
							root.ready(selector) :
							
							// Execute immediately if ready is not present
							selector(jQuery);
					}
					
					return jQuery.makeArray(selector, this);
				};

// Give the init function the jQuery prototype for later instantiation
			init.prototype = jQuery.fn;

// Initialize central reference
			rootjQuery = jQuery(document);
			
			
			var rparentsprev = /^(?:parents|prev(?:Until|All))/,
				
				// Methods guaranteed to produce a unique set when starting from a unique set
				guaranteedUnique = {
					children: true,
					contents: true,
					next: true,
					prev: true
				};
			
			jQuery.fn.extend({
				has: function(target) {
					var targets = jQuery(target, this),
						l = targets.length;
					
					return this.filter(function() {
						var i = 0;
						for(; i < l; i++) {
							if(jQuery.contains(this, targets[i])) {
								return true;
							}
						}
					});
				},
				
				closest: function(selectors, context) {
					var cur,
						i = 0,
						l = this.length,
						matched = [],
						targets = typeof selectors !== "string" && jQuery(selectors);
					
					// Positional selectors never match, since there's no _selection_ context
					if(!rneedsContext.test(selectors)) {
						for(; i < l; i++) {
							for(cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
								
								// Always skip document fragments
								if(cur.nodeType < 11 && (targets ?
									targets.index(cur) > -1 :
									
									// Don't pass non-elements to Sizzle
									cur.nodeType === 1 &&
									jQuery.find.matchesSelector(cur, selectors))) {
									
									matched.push(cur);
									break;
								}
							}
						}
					}
					
					return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
				},
				
				// Determine the position of an element within the set
				index: function(elem) {
					
					// No argument, return index in parent
					if(!elem) {
						return (this[0] && this[0].parentNode) ? this.first().prevAll().length : -1;
					}
					
					// Index in selector
					if(typeof elem === "string") {
						return indexOf.call(jQuery(elem), this[0]);
					}
					
					// Locate the position of the desired element
					return indexOf.call(this,
						
						// If it receives a jQuery object, the first element is used
						elem.jquery ? elem[0] : elem
					);
				},
				
				add: function(selector, context) {
					return this.pushStack(
						jQuery.uniqueSort(
							jQuery.merge(this.get(), jQuery(selector, context))
						)
					);
				},
				
				addBack: function(selector) {
					return this.add(selector == null ?
						this.prevObject : this.prevObject.filter(selector)
					);
				}
			});
			
			function sibling(cur, dir) {
				while((cur = cur[dir]) && cur.nodeType !== 1) {
				}
				return cur;
			}
			
			jQuery.each({
				parent: function(elem) {
					var parent = elem.parentNode;
					return parent && parent.nodeType !== 11 ? parent : null;
				},
				parents: function(elem) {
					return dir(elem, "parentNode");
				},
				parentsUntil: function(elem, i, until) {
					return dir(elem, "parentNode", until);
				},
				next: function(elem) {
					return sibling(elem, "nextSibling");
				},
				prev: function(elem) {
					return sibling(elem, "previousSibling");
				},
				nextAll: function(elem) {
					return dir(elem, "nextSibling");
				},
				prevAll: function(elem) {
					return dir(elem, "previousSibling");
				},
				nextUntil: function(elem, i, until) {
					return dir(elem, "nextSibling", until);
				},
				prevUntil: function(elem, i, until) {
					return dir(elem, "previousSibling", until);
				},
				siblings: function(elem) {
					return siblings((elem.parentNode || {}).firstChild, elem);
				},
				children: function(elem) {
					return siblings(elem.firstChild);
				},
				contents: function(elem) {
					if(nodeName(elem, "iframe")) {
						return elem.contentDocument;
					}
					
					// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
					// Treat the template element as a regular one in browsers that
					// don't support it.
					if(nodeName(elem, "template")) {
						elem = elem.content || elem;
					}
					
					return jQuery.merge([], elem.childNodes);
				}
			}, function(name, fn) {
				jQuery.fn[name] = function(until, selector) {
					var matched = jQuery.map(this, fn, until);
					
					if(name.slice(-5) !== "Until") {
						selector = until;
					}
					
					if(selector && typeof selector === "string") {
						matched = jQuery.filter(selector, matched);
					}
					
					if(this.length > 1) {
						
						// Remove duplicates
						if(!guaranteedUnique[name]) {
							jQuery.uniqueSort(matched);
						}
						
						// Reverse order for parents* and prev-derivatives
						if(rparentsprev.test(name)) {
							matched.reverse();
						}
					}
					
					return this.pushStack(matched);
				};
			});
			var rnothtmlwhite = (/[^\x20\t\r\n\f]+/g);


// Convert String-formatted options into Object-formatted ones
			function createOptions(options) {
				var object = {};
				jQuery.each(options.match(rnothtmlwhite) || [], function(_, flag) {
					object[flag] = true;
				});
				return object;
			}
			
			/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
			jQuery.Callbacks = function(options) {
				
				// Convert options from String-formatted to Object-formatted if needed
				// (we check in cache first)
				options = typeof options === "string" ?
					createOptions(options) :
					jQuery.extend({}, options);
				
				var // Flag to know if list is currently firing
					firing,
					
					// Last fire value for non-forgettable lists
					memory,
					
					// Flag to know if list was already fired
					fired,
					
					// Flag to prevent firing
					locked,
					
					// Actual callback list
					list = [],
					
					// Queue of execution data for repeatable lists
					queue = [],
					
					// Index of currently firing callback (modified by add/remove as needed)
					firingIndex = -1,
					
					// Fire callbacks
					fire = function() {
						
						// Enforce single-firing
						locked = locked || options.once;
						
						// Execute callbacks for all pending executions,
						// respecting firingIndex overrides and runtime changes
						fired = firing = true;
						for(; queue.length; firingIndex = -1) {
							memory = queue.shift();
							while(++firingIndex < list.length) {
								
								// Run callback and check for early termination
								if(list[firingIndex].apply(memory[0], memory[1]) === false &&
									options.stopOnFalse) {
									
									// Jump to end and forget the data so .add doesn't re-fire
									firingIndex = list.length;
									memory = false;
								}
							}
						}
						
						// Forget the data if we're done with it
						if(!options.memory) {
							memory = false;
						}
						
						firing = false;
						
						// Clean up if we're done firing for good
						if(locked) {
							
							// Keep an empty list if we have data for future add calls
							if(memory) {
								list = [];
								
								// Otherwise, this object is spent
							} else {
								list = "";
							}
						}
					},
					
					// Actual Callbacks object
					self = {
						
						// Add a callback or a collection of callbacks to the list
						add: function() {
							if(list) {
								
								// If we have memory from a past run, we should fire after adding
								if(memory && !firing) {
									firingIndex = list.length - 1;
									queue.push(memory);
								}
								
								(function add(args) {
									jQuery.each(args, function(_, arg) {
										if(isFunction(arg)) {
											if(!options.unique || !self.has(arg)) {
												list.push(arg);
											}
										} else if(arg && arg.length && toType(arg) !== "string") {
											
											// Inspect recursively
											add(arg);
										}
									});
								})(arguments);
								
								if(memory && !firing) {
									fire();
								}
							}
							return this;
						},
						
						// Remove a callback from the list
						remove: function() {
							jQuery.each(arguments, function(_, arg) {
								var index;
								while((index = jQuery.inArray(arg, list, index)) > -1) {
									list.splice(index, 1);
									
									// Handle firing indexes
									if(index <= firingIndex) {
										firingIndex--;
									}
								}
							});
							return this;
						},
						
						// Check if a given callback is in the list.
						// If no argument is given, return whether or not list has callbacks attached.
						has: function(fn) {
							return fn ?
								jQuery.inArray(fn, list) > -1 :
								list.length > 0;
						},
						
						// Remove all callbacks from the list
						empty: function() {
							if(list) {
								list = [];
							}
							return this;
						},
						
						// Disable .fire and .add
						// Abort any current/pending executions
						// Clear all callbacks and values
						disable: function() {
							locked = queue = [];
							list = memory = "";
							return this;
						},
						disabled: function() {
							return !list;
						},
						
						// Disable .fire
						// Also disable .add unless we have memory (since it would have no effect)
						// Abort any pending executions
						lock: function() {
							locked = queue = [];
							if(!memory && !firing) {
								list = memory = "";
							}
							return this;
						},
						locked: function() {
							return !!locked;
						},
						
						// Call all callbacks with the given context and arguments
						fireWith: function(context, args) {
							if(!locked) {
								args = args || [];
								args = [context, args.slice ? args.slice() : args];
								queue.push(args);
								if(!firing) {
									fire();
								}
							}
							return this;
						},
						
						// Call all the callbacks with the given arguments
						fire: function() {
							self.fireWith(this, arguments);
							return this;
						},
						
						// To know if the callbacks have already been called at least once
						fired: function() {
							return !!fired;
						}
					};
				
				return self;
			};
			
			
			function Identity(v) {
				return v;
			}
			
			function Thrower(ex) {
				throw ex;
			}
			
			function adoptValue(value, resolve, reject, noValue) {
				var method;
				
				try {
					
					// Check for promise aspect first to privilege synchronous behavior
					if(value && isFunction((method = value.promise))) {
						method.call(value).done(resolve).fail(reject);
						
						// Other thenables
					} else if(value && isFunction((method = value.then))) {
						method.call(value, resolve, reject);
						
						// Other non-thenables
					} else {
						
						// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
						// * false: [ value ].slice( 0 ) => resolve( value )
						// * true: [ value ].slice( 1 ) => resolve()
						resolve.apply(undefined, [value].slice(noValue));
					}
					
					// For Promises/A+, convert exceptions into rejections
					// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
					// Deferred#then to conditionally suppress rejection.
				} catch(value) {
					
					// Support: Android 4.0 only
					// Strict mode functions invoked without .call/.apply get global-object context
					reject.apply(undefined, [value]);
				}
			}
			
			jQuery.extend({
				
				Deferred: function(func) {
					var tuples = [
							
							// action, add listener, callbacks,
							// ... .then handlers, argument index, [final state]
							["notify", "progress", jQuery.Callbacks("memory"),
								jQuery.Callbacks("memory"), 2],
							["resolve", "done", jQuery.Callbacks("once memory"),
								jQuery.Callbacks("once memory"), 0, "resolved"],
							["reject", "fail", jQuery.Callbacks("once memory"),
								jQuery.Callbacks("once memory"), 1, "rejected"]
						],
						state = "pending",
						promise = {
							state: function() {
								return state;
							},
							always: function() {
								deferred.done(arguments).fail(arguments);
								return this;
							},
							"catch": function(fn) {
								return promise.then(null, fn);
							},
							
							// Keep pipe for back-compat
							pipe: function( /* fnDone, fnFail, fnProgress */) {
								var fns = arguments;
								
								return jQuery.Deferred(function(newDefer) {
									jQuery.each(tuples, function(i, tuple) {
										
										// Map tuples (progress, done, fail) to arguments (done, fail, progress)
										var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]];
										
										// deferred.progress(function() { bind to newDefer or newDefer.notify })
										// deferred.done(function() { bind to newDefer or newDefer.resolve })
										// deferred.fail(function() { bind to newDefer or newDefer.reject })
										deferred[tuple[1]](function() {
											var returned = fn && fn.apply(this, arguments);
											if(returned && isFunction(returned.promise)) {
												returned.promise()
													.progress(newDefer.notify)
													.done(newDefer.resolve)
													.fail(newDefer.reject);
											} else {
												newDefer[tuple[0] + "With"](
													this,
													fn ? [returned] : arguments
												);
											}
										});
									});
									fns = null;
								}).promise();
							},
							then: function(onFulfilled, onRejected, onProgress) {
								var maxDepth = 0;
								
								function resolve(depth, deferred, handler, special) {
									return function() {
										var that = this,
											args = arguments,
											mightThrow = function() {
												var returned, then;
												
												// Support: Promises/A+ section 2.3.3.3.3
												// https://promisesaplus.com/#point-59
												// Ignore double-resolution attempts
												if(depth < maxDepth) {
													return;
												}
												
												returned = handler.apply(that, args);
												
												// Support: Promises/A+ section 2.3.1
												// https://promisesaplus.com/#point-48
												if(returned === deferred.promise()) {
													throw new TypeError("Thenable self-resolution");
												}
												
												// Support: Promises/A+ sections 2.3.3.1, 3.5
												// https://promisesaplus.com/#point-54
												// https://promisesaplus.com/#point-75
												// Retrieve `then` only once
												then = returned &&
													
													// Support: Promises/A+ section 2.3.4
													// https://promisesaplus.com/#point-64
													// Only check objects and functions for thenability
													(typeof returned === "object" ||
														typeof returned === "function") &&
													returned.then;
												
												// Handle a returned thenable
												if(isFunction(then)) {
													
													// Special processors (notify) just wait for resolution
													if(special) {
														then.call(
															returned,
															resolve(maxDepth, deferred, Identity, special),
															resolve(maxDepth, deferred, Thrower, special)
														);
														
														// Normal processors (resolve) also hook into progress
													} else {
														
														// ...and disregard older resolution values
														maxDepth++;
														
														then.call(
															returned,
															resolve(maxDepth, deferred, Identity, special),
															resolve(maxDepth, deferred, Thrower, special),
															resolve(maxDepth, deferred, Identity,
																deferred.notifyWith)
														);
													}
													
													// Handle all other returned values
												} else {
													
													// Only substitute handlers pass on context
													// and multiple values (non-spec behavior)
													if(handler !== Identity) {
														that = undefined;
														args = [returned];
													}
													
													// Process the value(s)
													// Default process is resolve
													(special || deferred.resolveWith)(that, args);
												}
											},
											
											// Only normal processors (resolve) catch and reject exceptions
											process = special ?
												mightThrow :
												function() {
													try {
														mightThrow();
													} catch(e) {
														
														if(jQuery.Deferred.exceptionHook) {
															jQuery.Deferred.exceptionHook(e,
																process.stackTrace);
														}
														
														// Support: Promises/A+ section 2.3.3.3.4.1
														// https://promisesaplus.com/#point-61
														// Ignore post-resolution exceptions
														if(depth + 1 >= maxDepth) {
															
															// Only substitute handlers pass on context
															// and multiple values (non-spec behavior)
															if(handler !== Thrower) {
																that = undefined;
																args = [e];
															}
															
															deferred.rejectWith(that, args);
														}
													}
												};
										
										// Support: Promises/A+ section 2.3.3.3.1
										// https://promisesaplus.com/#point-57
										// Re-resolve promises immediately to dodge false rejection from
										// subsequent errors
										if(depth) {
											process();
										} else {
											
											// Call an optional hook to record the stack, in case of exception
											// since it's otherwise lost when execution goes async
											if(jQuery.Deferred.getStackHook) {
												process.stackTrace = jQuery.Deferred.getStackHook();
											}
											window.setTimeout(process);
										}
									};
								}
								
								return jQuery.Deferred(function(newDefer) {
									
									// progress_handlers.add( ... )
									tuples[0][3].add(
										resolve(
											0,
											newDefer,
											isFunction(onProgress) ?
												onProgress :
												Identity,
											newDefer.notifyWith
										)
									);
									
									// fulfilled_handlers.add( ... )
									tuples[1][3].add(
										resolve(
											0,
											newDefer,
											isFunction(onFulfilled) ?
												onFulfilled :
												Identity
										)
									);
									
									// rejected_handlers.add( ... )
									tuples[2][3].add(
										resolve(
											0,
											newDefer,
											isFunction(onRejected) ?
												onRejected :
												Thrower
										)
									);
								}).promise();
							},
							
							// Get a promise for this deferred
							// If obj is provided, the promise aspect is added to the object
							promise: function(obj) {
								return obj != null ? jQuery.extend(obj, promise) : promise;
							}
						},
						deferred = {};
					
					// Add list-specific methods
					jQuery.each(tuples, function(i, tuple) {
						var list = tuple[2],
							stateString = tuple[5];
						
						// promise.progress = list.add
						// promise.done = list.add
						// promise.fail = list.add
						promise[tuple[1]] = list.add;
						
						// Handle state
						if(stateString) {
							list.add(
								function() {
									
									// state = "resolved" (i.e., fulfilled)
									// state = "rejected"
									state = stateString;
								},
								
								// rejected_callbacks.disable
								// fulfilled_callbacks.disable
								tuples[3 - i][2].disable,
								
								// rejected_handlers.disable
								// fulfilled_handlers.disable
								tuples[3 - i][3].disable,
								
								// progress_callbacks.lock
								tuples[0][2].lock,
								
								// progress_handlers.lock
								tuples[0][3].lock
							);
						}
						
						// progress_handlers.fire
						// fulfilled_handlers.fire
						// rejected_handlers.fire
						list.add(tuple[3].fire);
						
						// deferred.notify = function() { deferred.notifyWith(...) }
						// deferred.resolve = function() { deferred.resolveWith(...) }
						// deferred.reject = function() { deferred.rejectWith(...) }
						deferred[tuple[0]] = function() {
							deferred[tuple[0] + "With"](this === deferred ? undefined : this, arguments);
							return this;
						};
						
						// deferred.notifyWith = list.fireWith
						// deferred.resolveWith = list.fireWith
						// deferred.rejectWith = list.fireWith
						deferred[tuple[0] + "With"] = list.fireWith;
					});
					
					// Make the deferred a promise
					promise.promise(deferred);
					
					// Call given func if any
					if(func) {
						func.call(deferred, deferred);
					}
					
					// All done!
					return deferred;
				},
				
				// Deferred helper
				when: function(singleValue) {
					var
						
						// count of uncompleted subordinates
						remaining = arguments.length,
						
						// count of unprocessed arguments
						i = remaining,
						
						// subordinate fulfillment data
						resolveContexts = Array(i),
						resolveValues = slice.call(arguments),
						
						// the master Deferred
						master = jQuery.Deferred(),
						
						// subordinate callback factory
						updateFunc = function(i) {
							return function(value) {
								resolveContexts[i] = this;
								resolveValues[i] = arguments.length > 1 ? slice.call(arguments) : value;
								if(!(--remaining)) {
									master.resolveWith(resolveContexts, resolveValues);
								}
							};
						};
					
					// Single- and empty arguments are adopted like Promise.resolve
					if(remaining <= 1) {
						adoptValue(singleValue, master.done(updateFunc(i)).resolve, master.reject,
							!remaining);
						
						// Use .then() to unwrap secondary thenables (cf. gh-3000)
						if(master.state() === "pending" ||
							isFunction(resolveValues[i] && resolveValues[i].then)) {
							
							return master.then();
						}
					}
					
					// Multiple arguments are aggregated like Promise.all array elements
					while(i--) {
						adoptValue(resolveValues[i], updateFunc(i), master.reject);
					}
					
					return master.promise();
				}
			});


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
			var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
			
			jQuery.Deferred.exceptionHook = function(error, stack) {
				
				// Support: IE 8 - 9 only
				// Console exists when dev tools are open, which can happen at any time
				if(window.console && window.console.warn && error && rerrorNames.test(error.name)) {
					window.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack);
				}
			};
			
			
			jQuery.readyException = function(error) {
				window.setTimeout(function() {
					throw error;
				});
			};


// The deferred used on DOM ready
			var readyList = jQuery.Deferred();
			
			jQuery.fn.ready = function(fn) {
				
				readyList
					.then(fn)
					
					// Wrap jQuery.readyException in a function so that the lookup
					// happens at the time of error handling instead of callback
					// registration.
					.catch(function(error) {
						jQuery.readyException(error);
					});
				
				return this;
			};
			
			jQuery.extend({
				
				// Is the DOM ready to be used? Set to true once it occurs.
				isReady: false,
				
				// A counter to track how many items to wait for before
				// the ready event fires. See #6781
				readyWait: 1,
				
				// Handle when the DOM is ready
				ready: function(wait) {
					
					// Abort if there are pending holds or we're already ready
					if(wait === true ? --jQuery.readyWait : jQuery.isReady) {
						return;
					}
					
					// Remember that the DOM is ready
					jQuery.isReady = true;
					
					// If a normal DOM Ready event fired, decrement, and wait if need be
					if(wait !== true && --jQuery.readyWait > 0) {
						return;
					}
					
					// If there are functions bound, to execute
					readyList.resolveWith(document, [jQuery]);
				}
			});
			
			jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
			function completed() {
				document.removeEventListener("DOMContentLoaded", completed);
				window.removeEventListener("load", completed);
				jQuery.ready();
			}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
			if(document.readyState === "complete" ||
				(document.readyState !== "loading" && !document.documentElement.doScroll)) {
				
				// Handle it asynchronously to allow scripts the opportunity to delay ready
				window.setTimeout(jQuery.ready);
				
			} else {
				
				// Use the handy event callback
				document.addEventListener("DOMContentLoaded", completed);
				
				// A fallback to window.onload, that will always work
				window.addEventListener("load", completed);
			}


// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
			var access = function(elems, fn, key, value, chainable, emptyGet, raw) {
				var i = 0,
					len = elems.length,
					bulk = key == null;
				
				// Sets many values
				if(toType(key) === "object") {
					chainable = true;
					for(i in key) {
						access(elems, fn, i, key[i], true, emptyGet, raw);
					}
					
					// Sets one value
				} else if(value !== undefined) {
					chainable = true;
					
					if(!isFunction(value)) {
						raw = true;
					}
					
					if(bulk) {
						
						// Bulk operations run against the entire set
						if(raw) {
							fn.call(elems, value);
							fn = null;
							
							// ...except when executing function values
						} else {
							bulk = fn;
							fn = function(elem, key, value) {
								return bulk.call(jQuery(elem), value);
							};
						}
					}
					
					if(fn) {
						for(; i < len; i++) {
							fn(
								elems[i], key, raw ?
									value :
									value.call(elems[i], i, fn(elems[i], key))
							);
						}
					}
				}
				
				if(chainable) {
					return elems;
				}
				
				// Gets
				if(bulk) {
					return fn.call(elems);
				}
				
				return len ? fn(elems[0], key) : emptyGet;
			};


// Matches dashed string for camelizing
			var rmsPrefix = /^-ms-/,
				rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
			function fcamelCase(all, letter) {
				return letter.toUpperCase();
			}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (#9572)
			function camelCase(string) {
				return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
			}
			
			var acceptData = function(owner) {
				
				// Accepts only:
				//  - Node
				//    - Node.ELEMENT_NODE
				//    - Node.DOCUMENT_NODE
				//  - Object
				//    - Any
				return owner.nodeType === 1 || owner.nodeType === 9 || !(+owner.nodeType);
			};
			
			
			function Data() {
				this.expando = jQuery.expando + Data.uid++;
			}
			
			Data.uid = 1;
			
			Data.prototype = {
				
				cache: function(owner) {
					
					// Check if the owner object already has a cache
					var value = owner[this.expando];
					
					// If not, create one
					if(!value) {
						value = {};
						
						// We can accept data for non-element nodes in modern browsers,
						// but we should not, see #8335.
						// Always return an empty object.
						if(acceptData(owner)) {
							
							// If it is a node unlikely to be stringify-ed or looped over
							// use plain assignment
							if(owner.nodeType) {
								owner[this.expando] = value;
								
								// Otherwise secure it in a non-enumerable property
								// configurable must be true to allow the property to be
								// deleted when data is removed
							} else {
								Object.defineProperty(owner, this.expando, {
									value: value,
									configurable: true
								});
							}
						}
					}
					
					return value;
				},
				set: function(owner, data, value) {
					var prop,
						cache = this.cache(owner);
					
					// Handle: [ owner, key, value ] args
					// Always use camelCase key (gh-2257)
					if(typeof data === "string") {
						cache[camelCase(data)] = value;
						
						// Handle: [ owner, { properties } ] args
					} else {
						
						// Copy the properties one-by-one to the cache object
						for(prop in data) {
							cache[camelCase(prop)] = data[prop];
						}
					}
					return cache;
				},
				get: function(owner, key) {
					return key === undefined ?
						this.cache(owner) :
						
						// Always use camelCase key (gh-2257)
						owner[this.expando] && owner[this.expando][camelCase(key)];
				},
				access: function(owner, key, value) {
					
					// In cases where either:
					//
					//   1. No key was specified
					//   2. A string key was specified, but no value provided
					//
					// Take the "read" path and allow the get method to determine
					// which value to return, respectively either:
					//
					//   1. The entire cache object
					//   2. The data stored at the key
					//
					if(key === undefined ||
						((key && typeof key === "string") && value === undefined)) {
						
						return this.get(owner, key);
					}
					
					// When the key is not a string, or both a key and value
					// are specified, set or extend (existing objects) with either:
					//
					//   1. An object of properties
					//   2. A key and value
					//
					this.set(owner, key, value);
					
					// Since the "set" path can have two possible entry points
					// return the expected data based on which path was taken[*]
					return value !== undefined ? value : key;
				},
				remove: function(owner, key) {
					var i,
						cache = owner[this.expando];
					
					if(cache === undefined) {
						return;
					}
					
					if(key !== undefined) {
						
						// Support array or space separated string of keys
						if(Array.isArray(key)) {
							
							// If key is an array of keys...
							// We always set camelCase keys, so remove that.
							key = key.map(camelCase);
						} else {
							key = camelCase(key);
							
							// If a key with the spaces exists, use it.
							// Otherwise, create an array by matching non-whitespace
							key = key in cache ?
								[key] :
								(key.match(rnothtmlwhite) || []);
						}
						
						i = key.length;
						
						while(i--) {
							delete cache[key[i]];
						}
					}
					
					// Remove the expando if there's no more data
					if(key === undefined || jQuery.isEmptyObject(cache)) {
						
						// Support: Chrome <=35 - 45
						// Webkit & Blink performance suffers when deleting properties
						// from DOM nodes, so set to undefined instead
						// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
						if(owner.nodeType) {
							owner[this.expando] = undefined;
						} else {
							delete owner[this.expando];
						}
					}
				},
				hasData: function(owner) {
					var cache = owner[this.expando];
					return cache !== undefined && !jQuery.isEmptyObject(cache);
				}
			};
			var dataPriv = new Data();
			
			var dataUser = new Data();


//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014
			
			var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
				rmultiDash = /[A-Z]/g;
			
			function getData(data) {
				if(data === "true") {
					return true;
				}
				
				if(data === "false") {
					return false;
				}
				
				if(data === "null") {
					return null;
				}
				
				// Only convert to a number if it doesn't change the string
				if(data === +data + "") {
					return +data;
				}
				
				if(rbrace.test(data)) {
					return JSON.parse(data);
				}
				
				return data;
			}
			
			function dataAttr(elem, key, data) {
				var name;
				
				// If nothing was found internally, try to fetch any
				// data from the HTML5 data-* attribute
				if(data === undefined && elem.nodeType === 1) {
					name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
					data = elem.getAttribute(name);
					
					if(typeof data === "string") {
						try {
							data = getData(data);
						} catch(e) {
						}
						
						// Make sure we set the data so it isn't changed later
						dataUser.set(elem, key, data);
					} else {
						data = undefined;
					}
				}
				return data;
			}
			
			jQuery.extend({
				hasData: function(elem) {
					return dataUser.hasData(elem) || dataPriv.hasData(elem);
				},
				
				data: function(elem, name, data) {
					return dataUser.access(elem, name, data);
				},
				
				removeData: function(elem, name) {
					dataUser.remove(elem, name);
				},
				
				// TODO: Now that all calls to _data and _removeData have been replaced
				// with direct calls to dataPriv methods, these can be deprecated.
				_data: function(elem, name, data) {
					return dataPriv.access(elem, name, data);
				},
				
				_removeData: function(elem, name) {
					dataPriv.remove(elem, name);
				}
			});
			
			jQuery.fn.extend({
				data: function(key, value) {
					var i, name, data,
						elem = this[0],
						attrs = elem && elem.attributes;
					
					// Gets all values
					if(key === undefined) {
						if(this.length) {
							data = dataUser.get(elem);
							
							if(elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
								i = attrs.length;
								while(i--) {
									
									// Support: IE 11 only
									// The attrs elements can be null (#14894)
									if(attrs[i]) {
										name = attrs[i].name;
										if(name.indexOf("data-") === 0) {
											name = camelCase(name.slice(5));
											dataAttr(elem, name, data[name]);
										}
									}
								}
								dataPriv.set(elem, "hasDataAttrs", true);
							}
						}
						
						return data;
					}
					
					// Sets multiple values
					if(typeof key === "object") {
						return this.each(function() {
							dataUser.set(this, key);
						});
					}
					
					return access(this, function(value) {
						var data;
						
						// The calling jQuery object (element matches) is not empty
						// (and therefore has an element appears at this[ 0 ]) and the
						// `value` parameter was not undefined. An empty jQuery object
						// will result in `undefined` for elem = this[ 0 ] which will
						// throw an exception if an attempt to read a data cache is made.
						if(elem && value === undefined) {
							
							// Attempt to get data from the cache
							// The key will always be camelCased in Data
							data = dataUser.get(elem, key);
							if(data !== undefined) {
								return data;
							}
							
							// Attempt to "discover" the data in
							// HTML5 custom data-* attrs
							data = dataAttr(elem, key);
							if(data !== undefined) {
								return data;
							}
							
							// We tried really hard, but the data doesn't exist.
							return;
						}
						
						// Set the data...
						this.each(function() {
							
							// We always store the camelCased key
							dataUser.set(this, key, value);
						});
					}, null, value, arguments.length > 1, null, true);
				},
				
				removeData: function(key) {
					return this.each(function() {
						dataUser.remove(this, key);
					});
				}
			});
			
			
			jQuery.extend({
				queue: function(elem, type, data) {
					var queue;
					
					if(elem) {
						type = (type || "fx") + "queue";
						queue = dataPriv.get(elem, type);
						
						// Speed up dequeue by getting out quickly if this is just a lookup
						if(data) {
							if(!queue || Array.isArray(data)) {
								queue = dataPriv.access(elem, type, jQuery.makeArray(data));
							} else {
								queue.push(data);
							}
						}
						return queue || [];
					}
				},
				
				dequeue: function(elem, type) {
					type = type || "fx";
					
					var queue = jQuery.queue(elem, type),
						startLength = queue.length,
						fn = queue.shift(),
						hooks = jQuery._queueHooks(elem, type),
						next = function() {
							jQuery.dequeue(elem, type);
						};
					
					// If the fx queue is dequeued, always remove the progress sentinel
					if(fn === "inprogress") {
						fn = queue.shift();
						startLength--;
					}
					
					if(fn) {
						
						// Add a progress sentinel to prevent the fx queue from being
						// automatically dequeued
						if(type === "fx") {
							queue.unshift("inprogress");
						}
						
						// Clear up the last queue stop function
						delete hooks.stop;
						fn.call(elem, next, hooks);
					}
					
					if(!startLength && hooks) {
						hooks.empty.fire();
					}
				},
				
				// Not public - generate a queueHooks object, or return the current one
				_queueHooks: function(elem, type) {
					var key = type + "queueHooks";
					return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
						empty: jQuery.Callbacks("once memory").add(function() {
							dataPriv.remove(elem, [type + "queue", key]);
						})
					});
				}
			});
			
			jQuery.fn.extend({
				queue: function(type, data) {
					var setter = 2;
					
					if(typeof type !== "string") {
						data = type;
						type = "fx";
						setter--;
					}
					
					if(arguments.length < setter) {
						return jQuery.queue(this[0], type);
					}
					
					return data === undefined ?
						this :
						this.each(function() {
							var queue = jQuery.queue(this, type, data);
							
							// Ensure a hooks for this queue
							jQuery._queueHooks(this, type);
							
							if(type === "fx" && queue[0] !== "inprogress") {
								jQuery.dequeue(this, type);
							}
						});
				},
				dequeue: function(type) {
					return this.each(function() {
						jQuery.dequeue(this, type);
					});
				},
				clearQueue: function(type) {
					return this.queue(type || "fx", []);
				},
				
				// Get a promise resolved when queues of a certain type
				// are emptied (fx is the type by default)
				promise: function(type, obj) {
					var tmp,
						count = 1,
						defer = jQuery.Deferred(),
						elements = this,
						i = this.length,
						resolve = function() {
							if(!(--count)) {
								defer.resolveWith(elements, [elements]);
							}
						};
					
					if(typeof type !== "string") {
						obj = type;
						type = undefined;
					}
					type = type || "fx";
					
					while(i--) {
						tmp = dataPriv.get(elements[i], type + "queueHooks");
						if(tmp && tmp.empty) {
							count++;
							tmp.empty.add(resolve);
						}
					}
					resolve();
					return defer.promise(obj);
				}
			});
			var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;
			
			var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
			
			
			var cssExpand = ["Top", "Right", "Bottom", "Left"];
			
			var isHiddenWithinTree = function(elem, el) {
				
				// isHiddenWithinTree might be called from jQuery#filter function;
				// in that case, element will be second argument
				elem = el || elem;
				
				// Inline style trumps all
				return elem.style.display === "none" ||
					elem.style.display === "" &&
					
					// Otherwise, check computed style
					// Support: Firefox <=43 - 45
					// Disconnected elements can have computed display: none, so first confirm that elem is
					// in the document.
					jQuery.contains(elem.ownerDocument, elem) &&
					
					jQuery.css(elem, "display") === "none";
			};
			
			var swap = function(elem, options, callback, args) {
				var ret, name,
					old = {};
				
				// Remember the old values, and insert the new ones
				for(name in options) {
					old[name] = elem.style[name];
					elem.style[name] = options[name];
				}
				
				ret = callback.apply(elem, args || []);
				
				// Revert the old values
				for(name in options) {
					elem.style[name] = old[name];
				}
				
				return ret;
			};
			
			
			function adjustCSS(elem, prop, valueParts, tween) {
				var adjusted, scale,
					maxIterations = 20,
					currentValue = tween ?
						function() {
							return tween.cur();
						} :
						function() {
							return jQuery.css(elem, prop, "");
						},
					initial = currentValue(),
					unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),
					
					// Starting value computation is required for potential unit mismatches
					initialInUnit = (jQuery.cssNumber[prop] || unit !== "px" && +initial) &&
						rcssNum.exec(jQuery.css(elem, prop));
				
				if(initialInUnit && initialInUnit[3] !== unit) {
					
					// Support: Firefox <=54
					// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
					initial = initial / 2;
					
					// Trust units reported by jQuery.css
					unit = unit || initialInUnit[3];
					
					// Iteratively approximate from a nonzero starting point
					initialInUnit = +initial || 1;
					
					while(maxIterations--) {
						
						// Evaluate and update our best guess (doubling guesses that zero out).
						// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
						jQuery.style(elem, prop, initialInUnit + unit);
						if((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
							maxIterations = 0;
						}
						initialInUnit = initialInUnit / scale;
						
					}
					
					initialInUnit = initialInUnit * 2;
					jQuery.style(elem, prop, initialInUnit + unit);
					
					// Make sure we update the tween properties later on
					valueParts = valueParts || [];
				}
				
				if(valueParts) {
					initialInUnit = +initialInUnit || +initial || 0;
					
					// Apply relative offset (+=/-=) if specified
					adjusted = valueParts[1] ?
						initialInUnit + (valueParts[1] + 1) * valueParts[2] :
						+valueParts[2];
					if(tween) {
						tween.unit = unit;
						tween.start = initialInUnit;
						tween.end = adjusted;
					}
				}
				return adjusted;
			}
			
			
			var defaultDisplayMap = {};
			
			function getDefaultDisplay(elem) {
				var temp,
					doc = elem.ownerDocument,
					nodeName = elem.nodeName,
					display = defaultDisplayMap[nodeName];
				
				if(display) {
					return display;
				}
				
				temp = doc.body.appendChild(doc.createElement(nodeName));
				display = jQuery.css(temp, "display");
				
				temp.parentNode.removeChild(temp);
				
				if(display === "none") {
					display = "block";
				}
				defaultDisplayMap[nodeName] = display;
				
				return display;
			}
			
			function showHide(elements, show) {
				var display, elem,
					values = [],
					index = 0,
					length = elements.length;
				
				// Determine new display value for elements that need to change
				for(; index < length; index++) {
					elem = elements[index];
					if(!elem.style) {
						continue;
					}
					
					display = elem.style.display;
					if(show) {
						
						// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
						// check is required in this first loop unless we have a nonempty display value (either
						// inline or about-to-be-restored)
						if(display === "none") {
							values[index] = dataPriv.get(elem, "display") || null;
							if(!values[index]) {
								elem.style.display = "";
							}
						}
						if(elem.style.display === "" && isHiddenWithinTree(elem)) {
							values[index] = getDefaultDisplay(elem);
						}
					} else {
						if(display !== "none") {
							values[index] = "none";
							
							// Remember what we're overwriting
							dataPriv.set(elem, "display", display);
						}
					}
				}
				
				// Set the display of the elements in a second loop to avoid constant reflow
				for(index = 0; index < length; index++) {
					if(values[index] != null) {
						elements[index].style.display = values[index];
					}
				}
				
				return elements;
			}
			
			jQuery.fn.extend({
				show: function() {
					return showHide(this, true);
				},
				hide: function() {
					return showHide(this);
				},
				toggle: function(state) {
					if(typeof state === "boolean") {
						return state ? this.show() : this.hide();
					}
					
					return this.each(function() {
						if(isHiddenWithinTree(this)) {
							jQuery(this).show();
						} else {
							jQuery(this).hide();
						}
					});
				}
			});
			var rcheckableType = (/^(?:checkbox|radio)$/i);
			
			var rtagName = (/<([a-z][^\/\0>\x20\t\r\n\f]+)/i);
			
			var rscriptType = (/^$|^module$|\/(?:java|ecma)script/i);


// We have to close these tags to support XHTML (#13200)
			var wrapMap = {
				
				// Support: IE <=9 only
				option: [1, "<select multiple='multiple'>", "</select>"],
				
				// XHTML parsers do not magically insert elements in the
				// same way that tag soup parsers do. So we cannot shorten
				// this by omitting <tbody> or other required elements.
				thead: [1, "<table>", "</table>"],
				col: [2, "<table><colgroup>", "</colgroup></table>"],
				tr: [2, "<table><tbody>", "</tbody></table>"],
				td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
				
				_default: [0, "", ""]
			};

// Support: IE <=9 only
			wrapMap.optgroup = wrapMap.option;
			
			wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
			wrapMap.th = wrapMap.td;
			
			
			function getAll(context, tag) {
				
				// Support: IE <=9 - 11 only
				// Use typeof to avoid zero-argument method invocation on host objects (#15151)
				var ret;
				
				if(typeof context.getElementsByTagName !== "undefined") {
					ret = context.getElementsByTagName(tag || "*");
					
				} else if(typeof context.querySelectorAll !== "undefined") {
					ret = context.querySelectorAll(tag || "*");
					
				} else {
					ret = [];
				}
				
				if(tag === undefined || tag && nodeName(context, tag)) {
					return jQuery.merge([context], ret);
				}
				
				return ret;
			}


// Mark scripts as having already been evaluated
			function setGlobalEval(elems, refElements) {
				var i = 0,
					l = elems.length;
				
				for(; i < l; i++) {
					dataPriv.set(
						elems[i],
						"globalEval",
						!refElements || dataPriv.get(refElements[i], "globalEval")
					);
				}
			}
			
			
			var rhtml = /<|&#?\w+;/;
			
			function buildFragment(elems, context, scripts, selection, ignored) {
				var elem, tmp, tag, wrap, contains, j,
					fragment = context.createDocumentFragment(),
					nodes = [],
					i = 0,
					l = elems.length;
				
				for(; i < l; i++) {
					elem = elems[i];
					
					if(elem || elem === 0) {
						
						// Add nodes directly
						if(toType(elem) === "object") {
							
							// Support: Android <=4.0 only, PhantomJS 1 only
							// push.apply(_, arraylike) throws on ancient WebKit
							jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
							
							// Convert non-html into a text node
						} else if(!rhtml.test(elem)) {
							nodes.push(context.createTextNode(elem));
							
							// Convert html into DOM nodes
						} else {
							tmp = tmp || fragment.appendChild(context.createElement("div"));
							
							// Deserialize a standard representation
							tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
							wrap = wrapMap[tag] || wrapMap._default;
							tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];
							
							// Descend through wrappers to the right content
							j = wrap[0];
							while(j--) {
								tmp = tmp.lastChild;
							}
							
							// Support: Android <=4.0 only, PhantomJS 1 only
							// push.apply(_, arraylike) throws on ancient WebKit
							jQuery.merge(nodes, tmp.childNodes);
							
							// Remember the top-level container
							tmp = fragment.firstChild;
							
							// Ensure the created nodes are orphaned (#12392)
							tmp.textContent = "";
						}
					}
				}
				
				// Remove wrapper from fragment
				fragment.textContent = "";
				
				i = 0;
				while((elem = nodes[i++])) {
					
					// Skip elements already in the context collection (trac-4087)
					if(selection && jQuery.inArray(elem, selection) > -1) {
						if(ignored) {
							ignored.push(elem);
						}
						continue;
					}
					
					contains = jQuery.contains(elem.ownerDocument, elem);
					
					// Append to fragment
					tmp = getAll(fragment.appendChild(elem), "script");
					
					// Preserve script evaluation history
					if(contains) {
						setGlobalEval(tmp);
					}
					
					// Capture executables
					if(scripts) {
						j = 0;
						while((elem = tmp[j++])) {
							if(rscriptType.test(elem.type || "")) {
								scripts.push(elem);
							}
						}
					}
				}
				
				return fragment;
			}
			
			
			(function() {
				var fragment = document.createDocumentFragment(),
					div = fragment.appendChild(document.createElement("div")),
					input = document.createElement("input");
				
				// Support: Android 4.0 - 4.3 only
				// Check state lost if the name is set (#11217)
				// Support: Windows Web Apps (WWA)
				// `name` and `type` must use .setAttribute for WWA (#14901)
				input.setAttribute("type", "radio");
				input.setAttribute("checked", "checked");
				input.setAttribute("name", "t");
				
				div.appendChild(input);
				
				// Support: Android <=4.1 only
				// Older WebKit doesn't clone checked state correctly in fragments
				support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
				
				// Support: IE <=11 only
				// Make sure textarea (and checkbox) defaultValue is properly cloned
				div.innerHTML = "<textarea>x</textarea>";
				support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
			})();
			var documentElement = document.documentElement;
			
			
			var
				rkeyEvent = /^key/,
				rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
				rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
			
			function returnTrue() {
				return true;
			}
			
			function returnFalse() {
				return false;
			}

// Support: IE <=9 only
// See #13393 for more info
			function safeActiveElement() {
				try {
					return document.activeElement;
				} catch(err) {
				}
			}
			
			function on(elem, types, selector, data, fn, one) {
				var origFn, type;
				
				// Types can be a map of types/handlers
				if(typeof types === "object") {
					
					// ( types-Object, selector, data )
					if(typeof selector !== "string") {
						
						// ( types-Object, data )
						data = data || selector;
						selector = undefined;
					}
					for(type in types) {
						on(elem, type, selector, data, types[type], one);
					}
					return elem;
				}
				
				if(data == null && fn == null) {
					
					// ( types, fn )
					fn = selector;
					data = selector = undefined;
				} else if(fn == null) {
					if(typeof selector === "string") {
						
						// ( types, selector, fn )
						fn = data;
						data = undefined;
					} else {
						
						// ( types, data, fn )
						fn = data;
						data = selector;
						selector = undefined;
					}
				}
				if(fn === false) {
					fn = returnFalse;
				} else if(!fn) {
					return elem;
				}
				
				if(one === 1) {
					origFn = fn;
					fn = function(event) {
						
						// Can use an empty set, since event contains the info
						jQuery().off(event);
						return origFn.apply(this, arguments);
					};
					
					// Use same guid so caller can remove using origFn
					fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
				}
				return elem.each(function() {
					jQuery.event.add(this, types, fn, data, selector);
				});
			}
			
			/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
			jQuery.event = {
				
				global: {},
				
				add: function(elem, types, handler, data, selector) {
					
					var handleObjIn, eventHandle, tmp,
						events, t, handleObj,
						special, handlers, type, namespaces, origType,
						elemData = dataPriv.get(elem);
					
					// Don't attach events to noData or text/comment nodes (but allow plain objects)
					if(!elemData) {
						return;
					}
					
					// Caller can pass in an object of custom data in lieu of the handler
					if(handler.handler) {
						handleObjIn = handler;
						handler = handleObjIn.handler;
						selector = handleObjIn.selector;
					}
					
					// Ensure that invalid selectors throw exceptions at attach time
					// Evaluate against documentElement in case elem is a non-element node (e.g., document)
					if(selector) {
						jQuery.find.matchesSelector(documentElement, selector);
					}
					
					// Make sure that the handler has a unique ID, used to find/remove it later
					if(!handler.guid) {
						handler.guid = jQuery.guid++;
					}
					
					// Init the element's event structure and main handler, if this is the first
					if(!(events = elemData.events)) {
						events = elemData.events = {};
					}
					if(!(eventHandle = elemData.handle)) {
						eventHandle = elemData.handle = function(e) {
							
							// Discard the second event of a jQuery.event.trigger() and
							// when an event is called after a page has unloaded
							return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
								jQuery.event.dispatch.apply(elem, arguments) : undefined;
						};
					}
					
					// Handle multiple events separated by a space
					types = (types || "").match(rnothtmlwhite) || [""];
					t = types.length;
					while(t--) {
						tmp = rtypenamespace.exec(types[t]) || [];
						type = origType = tmp[1];
						namespaces = (tmp[2] || "").split(".").sort();
						
						// There *must* be a type, no attaching namespace-only handlers
						if(!type) {
							continue;
						}
						
						// If event changes its type, use the special event handlers for the changed type
						special = jQuery.event.special[type] || {};
						
						// If selector defined, determine special event api type, otherwise given type
						type = (selector ? special.delegateType : special.bindType) || type;
						
						// Update special based on newly reset type
						special = jQuery.event.special[type] || {};
						
						// handleObj is passed to all event handlers
						handleObj = jQuery.extend({
							type: type,
							origType: origType,
							data: data,
							handler: handler,
							guid: handler.guid,
							selector: selector,
							needsContext: selector && jQuery.expr.match.needsContext.test(selector),
							namespace: namespaces.join(".")
						}, handleObjIn);
						
						// Init the event handler queue if we're the first
						if(!(handlers = events[type])) {
							handlers = events[type] = [];
							handlers.delegateCount = 0;
							
							// Only use addEventListener if the special events handler returns false
							if(!special.setup ||
								special.setup.call(elem, data, namespaces, eventHandle) === false) {
								
								if(elem.addEventListener) {
									elem.addEventListener(type, eventHandle);
								}
							}
						}
						
						if(special.add) {
							special.add.call(elem, handleObj);
							
							if(!handleObj.handler.guid) {
								handleObj.handler.guid = handler.guid;
							}
						}
						
						// Add to the element's handler list, delegates in front
						if(selector) {
							handlers.splice(handlers.delegateCount++, 0, handleObj);
						} else {
							handlers.push(handleObj);
						}
						
						// Keep track of which events have ever been used, for event optimization
						jQuery.event.global[type] = true;
					}
					
				},
				
				// Detach an event or set of events from an element
				remove: function(elem, types, handler, selector, mappedTypes) {
					
					var j, origCount, tmp,
						events, t, handleObj,
						special, handlers, type, namespaces, origType,
						elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
					
					if(!elemData || !(events = elemData.events)) {
						return;
					}
					
					// Once for each type.namespace in types; type may be omitted
					types = (types || "").match(rnothtmlwhite) || [""];
					t = types.length;
					while(t--) {
						tmp = rtypenamespace.exec(types[t]) || [];
						type = origType = tmp[1];
						namespaces = (tmp[2] || "").split(".").sort();
						
						// Unbind all events (on this namespace, if provided) for the element
						if(!type) {
							for(type in events) {
								jQuery.event.remove(elem, type + types[t], handler, selector, true);
							}
							continue;
						}
						
						special = jQuery.event.special[type] || {};
						type = (selector ? special.delegateType : special.bindType) || type;
						handlers = events[type] || [];
						tmp = tmp[2] &&
							new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
						
						// Remove matching events
						origCount = j = handlers.length;
						while(j--) {
							handleObj = handlers[j];
							
							if((mappedTypes || origType === handleObj.origType) &&
								(!handler || handler.guid === handleObj.guid) &&
								(!tmp || tmp.test(handleObj.namespace)) &&
								(!selector || selector === handleObj.selector ||
									selector === "**" && handleObj.selector)) {
								handlers.splice(j, 1);
								
								if(handleObj.selector) {
									handlers.delegateCount--;
								}
								if(special.remove) {
									special.remove.call(elem, handleObj);
								}
							}
						}
						
						// Remove generic event handler if we removed something and no more handlers exist
						// (avoids potential for endless recursion during removal of special event handlers)
						if(origCount && !handlers.length) {
							if(!special.teardown ||
								special.teardown.call(elem, namespaces, elemData.handle) === false) {
								
								jQuery.removeEvent(elem, type, elemData.handle);
							}
							
							delete events[type];
						}
					}
					
					// Remove data and the expando if it's no longer used
					if(jQuery.isEmptyObject(events)) {
						dataPriv.remove(elem, "handle events");
					}
				},
				
				dispatch: function(nativeEvent) {
					
					// Make a writable jQuery.Event from the native event object
					var event = jQuery.event.fix(nativeEvent);
					
					var i, j, ret, matched, handleObj, handlerQueue,
						args = new Array(arguments.length),
						handlers = (dataPriv.get(this, "events") || {})[event.type] || [],
						special = jQuery.event.special[event.type] || {};
					
					// Use the fix-ed jQuery.Event rather than the (read-only) native event
					args[0] = event;
					
					for(i = 1; i < arguments.length; i++) {
						args[i] = arguments[i];
					}
					
					event.delegateTarget = this;
					
					// Call the preDispatch hook for the mapped type, and let it bail if desired
					if(special.preDispatch && special.preDispatch.call(this, event) === false) {
						return;
					}
					
					// Determine handlers
					handlerQueue = jQuery.event.handlers.call(this, event, handlers);
					
					// Run delegates first; they may want to stop propagation beneath us
					i = 0;
					while((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
						event.currentTarget = matched.elem;
						
						j = 0;
						while((handleObj = matched.handlers[j++]) &&
						!event.isImmediatePropagationStopped()) {
							
							// Triggered event must either 1) have no namespace, or 2) have namespace(s)
							// a subset or equal to those in the bound event (both can have no namespace).
							if(!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {
								
								event.handleObj = handleObj;
								event.data = handleObj.data;
								
								ret = ((jQuery.event.special[handleObj.origType] || {}).handle ||
									handleObj.handler).apply(matched.elem, args);
								
								if(ret !== undefined) {
									if((event.result = ret) === false) {
										event.preventDefault();
										event.stopPropagation();
									}
								}
							}
						}
					}
					
					// Call the postDispatch hook for the mapped type
					if(special.postDispatch) {
						special.postDispatch.call(this, event);
					}
					
					return event.result;
				},
				
				handlers: function(event, handlers) {
					var i, handleObj, sel, matchedHandlers, matchedSelectors,
						handlerQueue = [],
						delegateCount = handlers.delegateCount,
						cur = event.target;
					
					// Find delegate handlers
					if(delegateCount &&
						
						// Support: IE <=9
						// Black-hole SVG <use> instance trees (trac-13180)
						cur.nodeType &&
						
						// Support: Firefox <=42
						// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
						// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
						// Support: IE 11 only
						// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
						!(event.type === "click" && event.button >= 1)) {
						
						for(; cur !== this; cur = cur.parentNode || this) {
							
							// Don't check non-elements (#13208)
							// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
							if(cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
								matchedHandlers = [];
								matchedSelectors = {};
								for(i = 0; i < delegateCount; i++) {
									handleObj = handlers[i];
									
									// Don't conflict with Object.prototype properties (#13203)
									sel = handleObj.selector + " ";
									
									if(matchedSelectors[sel] === undefined) {
										matchedSelectors[sel] = handleObj.needsContext ?
											jQuery(sel, this).index(cur) > -1 :
											jQuery.find(sel, this, null, [cur]).length;
									}
									if(matchedSelectors[sel]) {
										matchedHandlers.push(handleObj);
									}
								}
								if(matchedHandlers.length) {
									handlerQueue.push({elem: cur, handlers: matchedHandlers});
								}
							}
						}
					}
					
					// Add the remaining (directly-bound) handlers
					cur = this;
					if(delegateCount < handlers.length) {
						handlerQueue.push({elem: cur, handlers: handlers.slice(delegateCount)});
					}
					
					return handlerQueue;
				},
				
				addProp: function(name, hook) {
					Object.defineProperty(jQuery.Event.prototype, name, {
						enumerable: true,
						configurable: true,
						
						get: isFunction(hook) ?
							function() {
								if(this.originalEvent) {
									return hook(this.originalEvent);
								}
							} :
							function() {
								if(this.originalEvent) {
									return this.originalEvent[name];
								}
							},
						
						set: function(value) {
							Object.defineProperty(this, name, {
								enumerable: true,
								configurable: true,
								writable: true,
								value: value
							});
						}
					});
				},
				
				fix: function(originalEvent) {
					return originalEvent[jQuery.expando] ?
						originalEvent :
						new jQuery.Event(originalEvent);
				},
				
				special: {
					load: {
						
						// Prevent triggered image.load events from bubbling to window.load
						noBubble: true
					},
					focus: {
						
						// Fire native event if possible so blur/focus sequence is correct
						trigger: function() {
							if(this !== safeActiveElement() && this.focus) {
								this.focus();
								return false;
							}
						},
						delegateType: "focusin"
					},
					blur: {
						trigger: function() {
							if(this === safeActiveElement() && this.blur) {
								this.blur();
								return false;
							}
						},
						delegateType: "focusout"
					},
					click: {
						
						// For checkbox, fire native event so checked state will be right
						trigger: function() {
							if(this.type === "checkbox" && this.click && nodeName(this, "input")) {
								this.click();
								return false;
							}
						},
						
						// For cross-browser consistency, don't fire native .click() on links
						_default: function(event) {
							return nodeName(event.target, "a");
						}
					},
					
					beforeunload: {
						postDispatch: function(event) {
							
							// Support: Firefox 20+
							// Firefox doesn't alert if the returnValue field is not set.
							if(event.result !== undefined && event.originalEvent) {
								event.originalEvent.returnValue = event.result;
							}
						}
					}
				}
			};
			
			jQuery.removeEvent = function(elem, type, handle) {
				
				// This "if" is needed for plain objects
				if(elem.removeEventListener) {
					elem.removeEventListener(type, handle);
				}
			};
			
			jQuery.Event = function(src, props) {
				
				// Allow instantiation without the 'new' keyword
				if(!(this instanceof jQuery.Event)) {
					return new jQuery.Event(src, props);
				}
				
				// Event object
				if(src && src.type) {
					this.originalEvent = src;
					this.type = src.type;
					
					// Events bubbling up the document may have been marked as prevented
					// by a handler lower down the tree; reflect the correct value.
					this.isDefaultPrevented = src.defaultPrevented ||
					src.defaultPrevented === undefined &&
					
					// Support: Android <=2.3 only
					src.returnValue === false ?
						returnTrue :
						returnFalse;
					
					// Create target properties
					// Support: Safari <=6 - 7 only
					// Target should not be a text node (#504, #13143)
					this.target = (src.target && src.target.nodeType === 3) ?
						src.target.parentNode :
						src.target;
					
					this.currentTarget = src.currentTarget;
					this.relatedTarget = src.relatedTarget;
					
					// Event type
				} else {
					this.type = src;
				}
				
				// Put explicitly provided properties onto the event object
				if(props) {
					jQuery.extend(this, props);
				}
				
				// Create a timestamp if incoming event doesn't have one
				this.timeStamp = src && src.timeStamp || Date.now();
				
				// Mark it as fixed
				this[jQuery.expando] = true;
			};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
			jQuery.Event.prototype = {
				constructor: jQuery.Event,
				isDefaultPrevented: returnFalse,
				isPropagationStopped: returnFalse,
				isImmediatePropagationStopped: returnFalse,
				isSimulated: false,
				
				preventDefault: function() {
					var e = this.originalEvent;
					
					this.isDefaultPrevented = returnTrue;
					
					if(e && !this.isSimulated) {
						e.preventDefault();
					}
				},
				stopPropagation: function() {
					var e = this.originalEvent;
					
					this.isPropagationStopped = returnTrue;
					
					if(e && !this.isSimulated) {
						e.stopPropagation();
					}
				},
				stopImmediatePropagation: function() {
					var e = this.originalEvent;
					
					this.isImmediatePropagationStopped = returnTrue;
					
					if(e && !this.isSimulated) {
						e.stopImmediatePropagation();
					}
					
					this.stopPropagation();
				}
			};

// Includes all common event props including KeyEvent and MouseEvent specific props
			jQuery.each({
				altKey: true,
				bubbles: true,
				cancelable: true,
				changedTouches: true,
				ctrlKey: true,
				detail: true,
				eventPhase: true,
				metaKey: true,
				pageX: true,
				pageY: true,
				shiftKey: true,
				view: true,
				"char": true,
				charCode: true,
				key: true,
				keyCode: true,
				button: true,
				buttons: true,
				clientX: true,
				clientY: true,
				offsetX: true,
				offsetY: true,
				pointerId: true,
				pointerType: true,
				screenX: true,
				screenY: true,
				targetTouches: true,
				toElement: true,
				touches: true,
				
				which: function(event) {
					var button = event.button;
					
					// Add which for key events
					if(event.which == null && rkeyEvent.test(event.type)) {
						return event.charCode != null ? event.charCode : event.keyCode;
					}
					
					// Add which for click: 1 === left; 2 === middle; 3 === right
					if(!event.which && button !== undefined && rmouseEvent.test(event.type)) {
						if(button & 1) {
							return 1;
						}
						
						if(button & 2) {
							return 3;
						}
						
						if(button & 4) {
							return 2;
						}
						
						return 0;
					}
					
					return event.which;
				}
			}, jQuery.event.addProp);

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
			jQuery.each({
				mouseenter: "mouseover",
				mouseleave: "mouseout",
				pointerenter: "pointerover",
				pointerleave: "pointerout"
			}, function(orig, fix) {
				jQuery.event.special[orig] = {
					delegateType: fix,
					bindType: fix,
					
					handle: function(event) {
						var ret,
							target = this,
							related = event.relatedTarget,
							handleObj = event.handleObj;
						
						// For mouseenter/leave call the handler if related is outside the target.
						// NB: No relatedTarget if the mouse left/entered the browser window
						if(!related || (related !== target && !jQuery.contains(target, related))) {
							event.type = handleObj.origType;
							ret = handleObj.handler.apply(this, arguments);
							event.type = fix;
						}
						return ret;
					}
				};
			});
			
			jQuery.fn.extend({
				
				on: function(types, selector, data, fn) {
					return on(this, types, selector, data, fn);
				},
				one: function(types, selector, data, fn) {
					return on(this, types, selector, data, fn, 1);
				},
				off: function(types, selector, fn) {
					var handleObj, type;
					if(types && types.preventDefault && types.handleObj) {
						
						// ( event )  dispatched jQuery.Event
						handleObj = types.handleObj;
						jQuery(types.delegateTarget).off(
							handleObj.namespace ?
								handleObj.origType + "." + handleObj.namespace :
								handleObj.origType,
							handleObj.selector,
							handleObj.handler
						);
						return this;
					}
					if(typeof types === "object") {
						
						// ( types-object [, selector] )
						for(type in types) {
							this.off(type, selector, types[type]);
						}
						return this;
					}
					if(selector === false || typeof selector === "function") {
						
						// ( types [, fn] )
						fn = selector;
						selector = undefined;
					}
					if(fn === false) {
						fn = returnFalse;
					}
					return this.each(function() {
						jQuery.event.remove(this, types, fn, selector);
					});
				}
			});
			
			
			var
				
				/* eslint-disable max-len */
				
				// See https://github.com/eslint/eslint/issues/3229
				rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,
				
				/* eslint-enable */
				
				// Support: IE <=10 - 11, Edge 12 - 13 only
				// In IE/Edge using regex groups here causes severe slowdowns.
				// See https://connect.microsoft.com/IE/feedback/details/1736512/
				rnoInnerhtml = /<script|<style|<link/i,
				
				// checked="checked" or checked
				rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
				rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
			function manipulationTarget(elem, content) {
				if(nodeName(elem, "table") &&
					nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
					
					return jQuery(elem).children("tbody")[0] || elem;
				}
				
				return elem;
			}

// Replace/restore the type attribute of script elements for safe DOM manipulation
			function disableScript(elem) {
				elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
				return elem;
			}
			
			function restoreScript(elem) {
				if((elem.type || "").slice(0, 5) === "true/") {
					elem.type = elem.type.slice(5);
				} else {
					elem.removeAttribute("type");
				}
				
				return elem;
			}
			
			function cloneCopyEvent(src, dest) {
				var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
				
				if(dest.nodeType !== 1) {
					return;
				}
				
				// 1. Copy private data: events, handlers, etc.
				if(dataPriv.hasData(src)) {
					pdataOld = dataPriv.access(src);
					pdataCur = dataPriv.set(dest, pdataOld);
					events = pdataOld.events;
					
					if(events) {
						delete pdataCur.handle;
						pdataCur.events = {};
						
						for(type in events) {
							for(i = 0, l = events[type].length; i < l; i++) {
								jQuery.event.add(dest, type, events[type][i]);
							}
						}
					}
				}
				
				// 2. Copy user data
				if(dataUser.hasData(src)) {
					udataOld = dataUser.access(src);
					udataCur = jQuery.extend({}, udataOld);
					
					dataUser.set(dest, udataCur);
				}
			}

// Fix IE bugs, see support tests
			function fixInput(src, dest) {
				var nodeName = dest.nodeName.toLowerCase();
				
				// Fails to persist the checked state of a cloned checkbox or radio button.
				if(nodeName === "input" && rcheckableType.test(src.type)) {
					dest.checked = src.checked;
					
					// Fails to return the selected option to the default selected state when cloning options
				} else if(nodeName === "input" || nodeName === "textarea") {
					dest.defaultValue = src.defaultValue;
				}
			}
			
			function domManip(collection, args, callback, ignored) {
				
				// Flatten any nested arrays
				args = concat.apply([], args);
				
				var fragment, first, scripts, hasScripts, node, doc,
					i = 0,
					l = collection.length,
					iNoClone = l - 1,
					value = args[0],
					valueIsFunction = isFunction(value);
				
				// We can't cloneNode fragments that contain checked, in WebKit
				if(valueIsFunction ||
					(l > 1 && typeof value === "string" &&
						!support.checkClone && rchecked.test(value))) {
					return collection.each(function(index) {
						var self = collection.eq(index);
						if(valueIsFunction) {
							args[0] = value.call(this, index, self.html());
						}
						domManip(self, args, callback, ignored);
					});
				}
				
				if(l) {
					fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
					first = fragment.firstChild;
					
					if(fragment.childNodes.length === 1) {
						fragment = first;
					}
					
					// Require either new content or an interest in ignored elements to invoke the callback
					if(first || ignored) {
						scripts = jQuery.map(getAll(fragment, "script"), disableScript);
						hasScripts = scripts.length;
						
						// Use the original fragment for the last item
						// instead of the first because it can end up
						// being emptied incorrectly in certain situations (#8070).
						for(; i < l; i++) {
							node = fragment;
							
							if(i !== iNoClone) {
								node = jQuery.clone(node, true, true);
								
								// Keep references to cloned scripts for later restoration
								if(hasScripts) {
									
									// Support: Android <=4.0 only, PhantomJS 1 only
									// push.apply(_, arraylike) throws on ancient WebKit
									jQuery.merge(scripts, getAll(node, "script"));
								}
							}
							
							callback.call(collection[i], node, i);
						}
						
						if(hasScripts) {
							doc = scripts[scripts.length - 1].ownerDocument;
							
							// Reenable scripts
							jQuery.map(scripts, restoreScript);
							
							// Evaluate executable scripts on first document insertion
							for(i = 0; i < hasScripts; i++) {
								node = scripts[i];
								if(rscriptType.test(node.type || "") &&
									!dataPriv.access(node, "globalEval") &&
									jQuery.contains(doc, node)) {
									
									if(node.src && (node.type || "").toLowerCase() !== "module") {
										
										// Optional AJAX dependency, but won't run scripts if not present
										if(jQuery._evalUrl) {
											jQuery._evalUrl(node.src);
										}
									} else {
										DOMEval(node.textContent.replace(rcleanScript, ""), doc, node);
									}
								}
							}
						}
					}
				}
				
				return collection;
			}
			
			function remove(elem, selector, keepData) {
				var node,
					nodes = selector ? jQuery.filter(selector, elem) : elem,
					i = 0;
				
				for(; (node = nodes[i]) != null; i++) {
					if(!keepData && node.nodeType === 1) {
						jQuery.cleanData(getAll(node));
					}
					
					if(node.parentNode) {
						if(keepData && jQuery.contains(node.ownerDocument, node)) {
							setGlobalEval(getAll(node, "script"));
						}
						node.parentNode.removeChild(node);
					}
				}
				
				return elem;
			}
			
			jQuery.extend({
				htmlPrefilter: function(html) {
					return html.replace(rxhtmlTag, "<$1></$2>");
				},
				
				clone: function(elem, dataAndEvents, deepDataAndEvents) {
					var i, l, srcElements, destElements,
						clone = elem.cloneNode(true),
						inPage = jQuery.contains(elem.ownerDocument, elem);
					
					// Fix IE cloning issues
					if(!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) &&
						!jQuery.isXMLDoc(elem)) {
						
						// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
						destElements = getAll(clone);
						srcElements = getAll(elem);
						
						for(i = 0, l = srcElements.length; i < l; i++) {
							fixInput(srcElements[i], destElements[i]);
						}
					}
					
					// Copy the events from the original to the clone
					if(dataAndEvents) {
						if(deepDataAndEvents) {
							srcElements = srcElements || getAll(elem);
							destElements = destElements || getAll(clone);
							
							for(i = 0, l = srcElements.length; i < l; i++) {
								cloneCopyEvent(srcElements[i], destElements[i]);
							}
						} else {
							cloneCopyEvent(elem, clone);
						}
					}
					
					// Preserve script evaluation history
					destElements = getAll(clone, "script");
					if(destElements.length > 0) {
						setGlobalEval(destElements, !inPage && getAll(elem, "script"));
					}
					
					// Return the cloned set
					return clone;
				},
				
				cleanData: function(elems) {
					var data, elem, type,
						special = jQuery.event.special,
						i = 0;
					
					for(; (elem = elems[i]) !== undefined; i++) {
						if(acceptData(elem)) {
							if((data = elem[dataPriv.expando])) {
								if(data.events) {
									for(type in data.events) {
										if(special[type]) {
											jQuery.event.remove(elem, type);
											
											// This is a shortcut to avoid jQuery.event.remove's overhead
										} else {
											jQuery.removeEvent(elem, type, data.handle);
										}
									}
								}
								
								// Support: Chrome <=35 - 45+
								// Assign undefined instead of using delete, see Data#remove
								elem[dataPriv.expando] = undefined;
							}
							if(elem[dataUser.expando]) {
								
								// Support: Chrome <=35 - 45+
								// Assign undefined instead of using delete, see Data#remove
								elem[dataUser.expando] = undefined;
							}
						}
					}
				}
			});
			
			jQuery.fn.extend({
				detach: function(selector) {
					return remove(this, selector, true);
				},
				
				remove: function(selector) {
					return remove(this, selector);
				},
				
				text: function(value) {
					return access(this, function(value) {
						return value === undefined ?
							jQuery.text(this) :
							this.empty().each(function() {
								if(this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
									this.textContent = value;
								}
							});
					}, null, value, arguments.length);
				},
				
				append: function() {
					return domManip(this, arguments, function(elem) {
						if(this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
							var target = manipulationTarget(this, elem);
							target.appendChild(elem);
						}
					});
				},
				
				prepend: function() {
					return domManip(this, arguments, function(elem) {
						if(this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
							var target = manipulationTarget(this, elem);
							target.insertBefore(elem, target.firstChild);
						}
					});
				},
				
				before: function() {
					return domManip(this, arguments, function(elem) {
						if(this.parentNode) {
							this.parentNode.insertBefore(elem, this);
						}
					});
				},
				
				after: function() {
					return domManip(this, arguments, function(elem) {
						if(this.parentNode) {
							this.parentNode.insertBefore(elem, this.nextSibling);
						}
					});
				},
				
				empty: function() {
					var elem,
						i = 0;
					
					for(; (elem = this[i]) != null; i++) {
						if(elem.nodeType === 1) {
							
							// Prevent memory leaks
							jQuery.cleanData(getAll(elem, false));
							
							// Remove any remaining nodes
							elem.textContent = "";
						}
					}
					
					return this;
				},
				
				clone: function(dataAndEvents, deepDataAndEvents) {
					dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
					deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
					
					return this.map(function() {
						return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
					});
				},
				
				html: function(value) {
					return access(this, function(value) {
						var elem = this[0] || {},
							i = 0,
							l = this.length;
						
						if(value === undefined && elem.nodeType === 1) {
							return elem.innerHTML;
						}
						
						// See if we can take a shortcut and just use innerHTML
						if(typeof value === "string" && !rnoInnerhtml.test(value) &&
							!wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
							
							value = jQuery.htmlPrefilter(value);
							
							try {
								for(; i < l; i++) {
									elem = this[i] || {};
									
									// Remove element nodes and prevent memory leaks
									if(elem.nodeType === 1) {
										jQuery.cleanData(getAll(elem, false));
										elem.innerHTML = value;
									}
								}
								
								elem = 0;
								
								// If using innerHTML throws an exception, use the fallback method
							} catch(e) {
							}
						}
						
						if(elem) {
							this.empty().append(value);
						}
					}, null, value, arguments.length);
				},
				
				replaceWith: function() {
					var ignored = [];
					
					// Make the changes, replacing each non-ignored context element with the new content
					return domManip(this, arguments, function(elem) {
						var parent = this.parentNode;
						
						if(jQuery.inArray(this, ignored) < 0) {
							jQuery.cleanData(getAll(this));
							if(parent) {
								parent.replaceChild(elem, this);
							}
						}
						
						// Force callback invocation
					}, ignored);
				}
			});
			
			jQuery.each({
				appendTo: "append",
				prependTo: "prepend",
				insertBefore: "before",
				insertAfter: "after",
				replaceAll: "replaceWith"
			}, function(name, original) {
				jQuery.fn[name] = function(selector) {
					var elems,
						ret = [],
						insert = jQuery(selector),
						last = insert.length - 1,
						i = 0;
					
					for(; i <= last; i++) {
						elems = i === last ? this : this.clone(true);
						jQuery(insert[i])[original](elems);
						
						// Support: Android <=4.0 only, PhantomJS 1 only
						// .get() because push.apply(_, arraylike) throws on ancient WebKit
						push.apply(ret, elems.get());
					}
					
					return this.pushStack(ret);
				};
			});
			var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
			
			var getStyles = function(elem) {
				
				// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
				// IE throws on elements created in popups
				// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
				var view = elem.ownerDocument.defaultView;
				
				if(!view || !view.opener) {
					view = window;
				}
				
				return view.getComputedStyle(elem);
			};
			
			var rboxStyle = new RegExp(cssExpand.join("|"), "i");
			
			
			(function() {
				
				// Executing both pixelPosition & boxSizingReliable tests require only one layout
				// so they're executed at the same time to save the second computation.
				function computeStyleTests() {
					
					// This is a singleton, we need to execute it only once
					if(!div) {
						return;
					}
					
					container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
						"margin-top:1px;padding:0;border:0";
					div.style.cssText =
						"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
						"margin:auto;border:1px;padding:1px;" +
						"width:60%;top:1%";
					documentElement.appendChild(container).appendChild(div);
					
					var divStyle = window.getComputedStyle(div);
					pixelPositionVal = divStyle.top !== "1%";
					
					// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
					reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;
					
					// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
					// Some styles come back with percentage values, even though they shouldn't
					div.style.right = "60%";
					pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;
					
					// Support: IE 9 - 11 only
					// Detect misreporting of content dimensions for box-sizing:border-box elements
					boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;
					
					// Support: IE 9 only
					// Detect overflow:scroll screwiness (gh-3699)
					div.style.position = "absolute";
					scrollboxSizeVal = div.offsetWidth === 36 || "absolute";
					
					documentElement.removeChild(container);
					
					// Nullify the div so it wouldn't be stored in the memory and
					// it will also be a sign that checks already performed
					div = null;
				}
				
				function roundPixelMeasures(measure) {
					return Math.round(parseFloat(measure));
				}
				
				var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
					reliableMarginLeftVal,
					container = document.createElement("div"),
					div = document.createElement("div");
				
				// Finish early in limited (non-browser) environments
				if(!div.style) {
					return;
				}
				
				// Support: IE <=9 - 11 only
				// Style of cloned element affects source element cloned (#8908)
				div.style.backgroundClip = "content-box";
				div.cloneNode(true).style.backgroundClip = "";
				support.clearCloneStyle = div.style.backgroundClip === "content-box";
				
				jQuery.extend(support, {
					boxSizingReliable: function() {
						computeStyleTests();
						return boxSizingReliableVal;
					},
					pixelBoxStyles: function() {
						computeStyleTests();
						return pixelBoxStylesVal;
					},
					pixelPosition: function() {
						computeStyleTests();
						return pixelPositionVal;
					},
					reliableMarginLeft: function() {
						computeStyleTests();
						return reliableMarginLeftVal;
					},
					scrollboxSize: function() {
						computeStyleTests();
						return scrollboxSizeVal;
					}
				});
			})();
			
			
			function curCSS(elem, name, computed) {
				var width, minWidth, maxWidth, ret,
					
					// Support: Firefox 51+
					// Retrieving style before computed somehow
					// fixes an issue with getting wrong values
					// on detached elements
					style = elem.style;
				
				computed = computed || getStyles(elem);
				
				// getPropertyValue is needed for:
				//   .css('filter') (IE 9 only, #12537)
				//   .css('--customProperty) (#3144)
				if(computed) {
					ret = computed.getPropertyValue(name) || computed[name];
					
					if(ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {
						ret = jQuery.style(elem, name);
					}
					
					// A tribute to the "awesome hack by Dean Edwards"
					// Android Browser returns percentage for some values,
					// but width seems to be reliably pixels.
					// This is against the CSSOM draft spec:
					// https://drafts.csswg.org/cssom/#resolved-values
					if(!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {
						
						// Remember the original values
						width = style.width;
						minWidth = style.minWidth;
						maxWidth = style.maxWidth;
						
						// Put in the new values to get a computed value out
						style.minWidth = style.maxWidth = style.width = ret;
						ret = computed.width;
						
						// Revert the changed values
						style.width = width;
						style.minWidth = minWidth;
						style.maxWidth = maxWidth;
					}
				}
				
				return ret !== undefined ?
					
					// Support: IE <=9 - 11 only
					// IE returns zIndex value as an integer.
					ret + "" :
					ret;
			}
			
			
			function addGetHookIf(conditionFn, hookFn) {
				
				// Define the hook, we'll check on the first run if it's really needed.
				return {
					get: function() {
						if(conditionFn()) {
							
							// Hook not needed (or it's not possible to use it due
							// to missing dependency), remove it.
							delete this.get;
							return;
						}
						
						// Hook needed; redefine it so that the support test is not executed again.
						return (this.get = hookFn).apply(this, arguments);
					}
				};
			}
			
			
			var
				
				// Swappable if display is none or starts with table
				// except "table", "table-cell", or "table-caption"
				// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
				rdisplayswap = /^(none|table(?!-c[ea]).+)/,
				rcustomProp = /^--/,
				cssShow = {position: "absolute", visibility: "hidden", display: "block"},
				cssNormalTransform = {
					letterSpacing: "0",
					fontWeight: "400"
				},
				
				cssPrefixes = ["Webkit", "Moz", "ms"],
				emptyStyle = document.createElement("div").style;

// Return a css property mapped to a potentially vendor prefixed property
			function vendorPropName(name) {
				
				// Shortcut for names that are not vendor prefixed
				if(name in emptyStyle) {
					return name;
				}
				
				// Check for vendor prefixed names
				var capName = name[0].toUpperCase() + name.slice(1),
					i = cssPrefixes.length;
				
				while(i--) {
					name = cssPrefixes[i] + capName;
					if(name in emptyStyle) {
						return name;
					}
				}
			}

// Return a property mapped along what jQuery.cssProps suggests or to
// a vendor prefixed property.
			function finalPropName(name) {
				var ret = jQuery.cssProps[name];
				if(!ret) {
					ret = jQuery.cssProps[name] = vendorPropName(name) || name;
				}
				return ret;
			}
			
			function setPositiveNumber(elem, value, subtract) {
				
				// Any relative (+/-) values have already been
				// normalized at this point
				var matches = rcssNum.exec(value);
				return matches ?
					
					// Guard against undefined "subtract", e.g., when used as in cssHooks
					Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") :
					value;
			}
			
			function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
				var i = dimension === "width" ? 1 : 0,
					extra = 0,
					delta = 0;
				
				// Adjustment may not be necessary
				if(box === (isBorderBox ? "border" : "content")) {
					return 0;
				}
				
				for(; i < 4; i += 2) {
					
					// Both box models exclude margin
					if(box === "margin") {
						delta += jQuery.css(elem, box + cssExpand[i], true, styles);
					}
					
					// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
					if(!isBorderBox) {
						
						// Add padding
						delta += jQuery.css(elem, "padding" + cssExpand[i], true, styles);
						
						// For "border" or "margin", add border
						if(box !== "padding") {
							delta += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
							
							// But still keep track of it otherwise
						} else {
							extra += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
						}
						
						// If we get here with a border-box (content + padding + border), we're seeking "content" or
						// "padding" or "margin"
					} else {
						
						// For "content", subtract padding
						if(box === "content") {
							delta -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
						}
						
						// For "content" or "padding", subtract border
						if(box !== "margin") {
							delta -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
						}
					}
				}
				
				// Account for positive content-box scroll gutter when requested by providing computedVal
				if(!isBorderBox && computedVal >= 0) {
					
					// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
					// Assuming integer scroll gutter, subtract the rest and round down
					delta += Math.max(0, Math.ceil(
						elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] -
						computedVal -
						delta -
						extra -
						0.5
					));
				}
				
				return delta;
			}
			
			function getWidthOrHeight(elem, dimension, extra) {
				
				// Start with computed style
				var styles = getStyles(elem),
					val = curCSS(elem, dimension, styles),
					isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box",
					valueIsBorderBox = isBorderBox;
				
				// Support: Firefox <=54
				// Return a confounding non-pixel value or feign ignorance, as appropriate.
				if(rnumnonpx.test(val)) {
					if(!extra) {
						return val;
					}
					val = "auto";
				}
				
				// Check for style in case a browser which returns unreliable values
				// for getComputedStyle silently falls back to the reliable elem.style
				valueIsBorderBox = valueIsBorderBox &&
					(support.boxSizingReliable() || val === elem.style[dimension]);
				
				// Fall back to offsetWidth/offsetHeight when value is "auto"
				// This happens for inline elements with no explicit setting (gh-3571)
				// Support: Android <=4.1 - 4.3 only
				// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
				if(val === "auto" ||
					!parseFloat(val) && jQuery.css(elem, "display", false, styles) === "inline") {
					
					val = elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)];
					
					// offsetWidth/offsetHeight provide border-box values
					valueIsBorderBox = true;
				}
				
				// Normalize "" and auto
				val = parseFloat(val) || 0;
				
				// Adjust for the element's box model
				return (val +
					boxModelAdjustment(
						elem,
						dimension,
						extra || (isBorderBox ? "border" : "content"),
						valueIsBorderBox,
						styles,
						
						// Provide the current computed size to request scroll gutter calculation (gh-3589)
						val
					)
				) + "px";
			}
			
			jQuery.extend({
				
				// Add in style property hooks for overriding the default
				// behavior of getting and setting a style property
				cssHooks: {
					opacity: {
						get: function(elem, computed) {
							if(computed) {
								
								// We should always get a number back from opacity
								var ret = curCSS(elem, "opacity");
								return ret === "" ? "1" : ret;
							}
						}
					}
				},
				
				// Don't automatically add "px" to these possibly-unitless properties
				cssNumber: {
					"animationIterationCount": true,
					"columnCount": true,
					"fillOpacity": true,
					"flexGrow": true,
					"flexShrink": true,
					"fontWeight": true,
					"lineHeight": true,
					"opacity": true,
					"order": true,
					"orphans": true,
					"widows": true,
					"zIndex": true,
					"zoom": true
				},
				
				// Add in properties whose names you wish to fix before
				// setting or getting the value
				cssProps: {},
				
				// Get and set the style property on a DOM Node
				style: function(elem, name, value, extra) {
					
					// Don't set styles on text and comment nodes
					if(!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
						return;
					}
					
					// Make sure that we're working with the right name
					var ret, type, hooks,
						origName = camelCase(name),
						isCustomProp = rcustomProp.test(name),
						style = elem.style;
					
					// Make sure that we're working with the right name. We don't
					// want to query the value if it is a CSS custom property
					// since they are user-defined.
					if(!isCustomProp) {
						name = finalPropName(origName);
					}
					
					// Gets hook for the prefixed version, then unprefixed version
					hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
					
					// Check if we're setting a value
					if(value !== undefined) {
						type = typeof value;
						
						// Convert "+=" or "-=" to relative numbers (#7345)
						if(type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
							value = adjustCSS(elem, name, ret);
							
							// Fixes bug #9237
							type = "number";
						}
						
						// Make sure that null and NaN values aren't set (#7116)
						if(value == null || value !== value) {
							return;
						}
						
						// If a number was passed in, add the unit (except for certain CSS properties)
						if(type === "number") {
							value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
						}
						
						// background-* props affect original clone's values
						if(!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
							style[name] = "inherit";
						}
						
						// If a hook was provided, use that value, otherwise just set the specified value
						if(!hooks || !("set" in hooks) ||
							(value = hooks.set(elem, value, extra)) !== undefined) {
							
							if(isCustomProp) {
								style.setProperty(name, value);
							} else {
								style[name] = value;
							}
						}
						
					} else {
						
						// If a hook was provided get the non-computed value from there
						if(hooks && "get" in hooks &&
							(ret = hooks.get(elem, false, extra)) !== undefined) {
							
							return ret;
						}
						
						// Otherwise just get the value from the style object
						return style[name];
					}
				},
				
				css: function(elem, name, extra, styles) {
					var val, num, hooks,
						origName = camelCase(name),
						isCustomProp = rcustomProp.test(name);
					
					// Make sure that we're working with the right name. We don't
					// want to modify the value if it is a CSS custom property
					// since they are user-defined.
					if(!isCustomProp) {
						name = finalPropName(origName);
					}
					
					// Try prefixed name followed by the unprefixed name
					hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
					
					// If a hook was provided get the computed value from there
					if(hooks && "get" in hooks) {
						val = hooks.get(elem, true, extra);
					}
					
					// Otherwise, if a way to get the computed value exists, use that
					if(val === undefined) {
						val = curCSS(elem, name, styles);
					}
					
					// Convert "normal" to computed value
					if(val === "normal" && name in cssNormalTransform) {
						val = cssNormalTransform[name];
					}
					
					// Make numeric if forced or a qualifier was provided and val looks numeric
					if(extra === "" || extra) {
						num = parseFloat(val);
						return extra === true || isFinite(num) ? num || 0 : val;
					}
					
					return val;
				}
			});
			
			jQuery.each(["height", "width"], function(i, dimension) {
				jQuery.cssHooks[dimension] = {
					get: function(elem, computed, extra) {
						if(computed) {
							
							// Certain elements can have dimension info if we invisibly show them
							// but it must have a current display style that would benefit
							return rdisplayswap.test(jQuery.css(elem, "display")) &&
							
							// Support: Safari 8+
							// Table columns in Safari have non-zero offsetWidth & zero
							// getBoundingClientRect().width unless display is changed.
							// Support: IE <=11 only
							// Running getBoundingClientRect on a disconnected node
							// in IE throws an error.
							(!elem.getClientRects().length || !elem.getBoundingClientRect().width) ?
								swap(elem, cssShow, function() {
									return getWidthOrHeight(elem, dimension, extra);
								}) :
								getWidthOrHeight(elem, dimension, extra);
						}
					},
					
					set: function(elem, value, extra) {
						var matches,
							styles = getStyles(elem),
							isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box",
							subtract = extra && boxModelAdjustment(
								elem,
								dimension,
								extra,
								isBorderBox,
								styles
							);
						
						// Account for unreliable border-box dimensions by comparing offset* to computed and
						// faking a content-box to get border and padding (gh-3699)
						if(isBorderBox && support.scrollboxSize() === styles.position) {
							subtract -= Math.ceil(
								elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] -
								parseFloat(styles[dimension]) -
								boxModelAdjustment(elem, dimension, "border", false, styles) -
								0.5
							);
						}
						
						// Convert to pixels if value adjustment is needed
						if(subtract && (matches = rcssNum.exec(value)) &&
							(matches[3] || "px") !== "px") {
							
							elem.style[dimension] = value;
							value = jQuery.css(elem, dimension);
						}
						
						return setPositiveNumber(elem, value, subtract);
					}
				};
			});
			
			jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft,
				function(elem, computed) {
					if(computed) {
						return (parseFloat(curCSS(elem, "marginLeft")) ||
							elem.getBoundingClientRect().left -
							swap(elem, {marginLeft: 0}, function() {
								return elem.getBoundingClientRect().left;
							})
						) + "px";
					}
				}
			);

// These hooks are used by animate to expand properties
			jQuery.each({
				margin: "",
				padding: "",
				border: "Width"
			}, function(prefix, suffix) {
				jQuery.cssHooks[prefix + suffix] = {
					expand: function(value) {
						var i = 0,
							expanded = {},
							
							// Assumes a single number if not a string
							parts = typeof value === "string" ? value.split(" ") : [value];
						
						for(; i < 4; i++) {
							expanded[prefix + cssExpand[i] + suffix] =
								parts[i] || parts[i - 2] || parts[0];
						}
						
						return expanded;
					}
				};
				
				if(prefix !== "margin") {
					jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
				}
			});
			
			jQuery.fn.extend({
				css: function(name, value) {
					return access(this, function(elem, name, value) {
						var styles, len,
							map = {},
							i = 0;
						
						if(Array.isArray(name)) {
							styles = getStyles(elem);
							len = name.length;
							
							for(; i < len; i++) {
								map[name[i]] = jQuery.css(elem, name[i], false, styles);
							}
							
							return map;
						}
						
						return value !== undefined ?
							jQuery.style(elem, name, value) :
							jQuery.css(elem, name);
					}, name, value, arguments.length > 1);
				}
			});
			
			
			function Tween(elem, options, prop, end, easing) {
				return new Tween.prototype.init(elem, options, prop, end, easing);
			}
			
			jQuery.Tween = Tween;
			
			Tween.prototype = {
				constructor: Tween,
				init: function(elem, options, prop, end, easing, unit) {
					this.elem = elem;
					this.prop = prop;
					this.easing = easing || jQuery.easing._default;
					this.options = options;
					this.start = this.now = this.cur();
					this.end = end;
					this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
				},
				cur: function() {
					var hooks = Tween.propHooks[this.prop];
					
					return hooks && hooks.get ?
						hooks.get(this) :
						Tween.propHooks._default.get(this);
				},
				run: function(percent) {
					var eased,
						hooks = Tween.propHooks[this.prop];
					
					if(this.options.duration) {
						this.pos = eased = jQuery.easing[this.easing](
							percent, this.options.duration * percent, 0, 1, this.options.duration
						);
					} else {
						this.pos = eased = percent;
					}
					this.now = (this.end - this.start) * eased + this.start;
					
					if(this.options.step) {
						this.options.step.call(this.elem, this.now, this);
					}
					
					if(hooks && hooks.set) {
						hooks.set(this);
					} else {
						Tween.propHooks._default.set(this);
					}
					return this;
				}
			};
			
			Tween.prototype.init.prototype = Tween.prototype;
			
			Tween.propHooks = {
				_default: {
					get: function(tween) {
						var result;
						
						// Use a property on the element directly when it is not a DOM element,
						// or when there is no matching style property that exists.
						if(tween.elem.nodeType !== 1 ||
							tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
							return tween.elem[tween.prop];
						}
						
						// Passing an empty string as a 3rd parameter to .css will automatically
						// attempt a parseFloat and fallback to a string if the parse fails.
						// Simple values such as "10px" are parsed to Float;
						// complex values such as "rotate(1rad)" are returned as-is.
						result = jQuery.css(tween.elem, tween.prop, "");
						
						// Empty strings, null, undefined and "auto" are converted to 0.
						return !result || result === "auto" ? 0 : result;
					},
					set: function(tween) {
						
						// Use step hook for back compat.
						// Use cssHook if its there.
						// Use .style if available and use plain properties where available.
						if(jQuery.fx.step[tween.prop]) {
							jQuery.fx.step[tween.prop](tween);
						} else if(tween.elem.nodeType === 1 &&
							(tween.elem.style[jQuery.cssProps[tween.prop]] != null ||
								jQuery.cssHooks[tween.prop])) {
							jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
						} else {
							tween.elem[tween.prop] = tween.now;
						}
					}
				}
			};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
			Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
				set: function(tween) {
					if(tween.elem.nodeType && tween.elem.parentNode) {
						tween.elem[tween.prop] = tween.now;
					}
				}
			};
			
			jQuery.easing = {
				linear: function(p) {
					return p;
				},
				swing: function(p) {
					return 0.5 - Math.cos(p * Math.PI) / 2;
				},
				_default: "swing"
			};
			
			jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
			jQuery.fx.step = {};
			
			
			var
				fxNow, inProgress,
				rfxtypes = /^(?:toggle|show|hide)$/,
				rrun = /queueHooks$/;
			
			function schedule() {
				if(inProgress) {
					if(document.hidden === false && window.requestAnimationFrame) {
						window.requestAnimationFrame(schedule);
					} else {
						window.setTimeout(schedule, jQuery.fx.interval);
					}
					
					jQuery.fx.tick();
				}
			}

// Animations created synchronously will run synchronously
			function createFxNow() {
				window.setTimeout(function() {
					fxNow = undefined;
				});
				return (fxNow = Date.now());
			}

// Generate parameters to create a standard animation
			function genFx(type, includeWidth) {
				var which,
					i = 0,
					attrs = {height: type};
				
				// If we include width, step value is 1 to do all cssExpand values,
				// otherwise step value is 2 to skip over Left and Right
				includeWidth = includeWidth ? 1 : 0;
				for(; i < 4; i += 2 - includeWidth) {
					which = cssExpand[i];
					attrs["margin" + which] = attrs["padding" + which] = type;
				}
				
				if(includeWidth) {
					attrs.opacity = attrs.width = type;
				}
				
				return attrs;
			}
			
			function createTween(value, prop, animation) {
				var tween,
					collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]),
					index = 0,
					length = collection.length;
				for(; index < length; index++) {
					if((tween = collection[index].call(animation, prop, value))) {
						
						// We're done with this property
						return tween;
					}
				}
			}
			
			function defaultPrefilter(elem, props, opts) {
				var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
					isBox = "width" in props || "height" in props,
					anim = this,
					orig = {},
					style = elem.style,
					hidden = elem.nodeType && isHiddenWithinTree(elem),
					dataShow = dataPriv.get(elem, "fxshow");
				
				// Queue-skipping animations hijack the fx hooks
				if(!opts.queue) {
					hooks = jQuery._queueHooks(elem, "fx");
					if(hooks.unqueued == null) {
						hooks.unqueued = 0;
						oldfire = hooks.empty.fire;
						hooks.empty.fire = function() {
							if(!hooks.unqueued) {
								oldfire();
							}
						};
					}
					hooks.unqueued++;
					
					anim.always(function() {
						
						// Ensure the complete handler is called before this completes
						anim.always(function() {
							hooks.unqueued--;
							if(!jQuery.queue(elem, "fx").length) {
								hooks.empty.fire();
							}
						});
					});
				}
				
				// Detect show/hide animations
				for(prop in props) {
					value = props[prop];
					if(rfxtypes.test(value)) {
						delete props[prop];
						toggle = toggle || value === "toggle";
						if(value === (hidden ? "hide" : "show")) {
							
							// Pretend to be hidden if this is a "show" and
							// there is still data from a stopped show/hide
							if(value === "show" && dataShow && dataShow[prop] !== undefined) {
								hidden = true;
								
								// Ignore all other no-op show/hide data
							} else {
								continue;
							}
						}
						orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
					}
				}
				
				// Bail out if this is a no-op like .hide().hide()
				propTween = !jQuery.isEmptyObject(props);
				if(!propTween && jQuery.isEmptyObject(orig)) {
					return;
				}
				
				// Restrict "overflow" and "display" styles during box animations
				if(isBox && elem.nodeType === 1) {
					
					// Support: IE <=9 - 11, Edge 12 - 15
					// Record all 3 overflow attributes because IE does not infer the shorthand
					// from identically-valued overflowX and overflowY and Edge just mirrors
					// the overflowX value there.
					opts.overflow = [style.overflow, style.overflowX, style.overflowY];
					
					// Identify a display type, preferring old show/hide data over the CSS cascade
					restoreDisplay = dataShow && dataShow.display;
					if(restoreDisplay == null) {
						restoreDisplay = dataPriv.get(elem, "display");
					}
					display = jQuery.css(elem, "display");
					if(display === "none") {
						if(restoreDisplay) {
							display = restoreDisplay;
						} else {
							
							// Get nonempty value(s) by temporarily forcing visibility
							showHide([elem], true);
							restoreDisplay = elem.style.display || restoreDisplay;
							display = jQuery.css(elem, "display");
							showHide([elem]);
						}
					}
					
					// Animate inline elements as inline-block
					if(display === "inline" || display === "inline-block" && restoreDisplay != null) {
						if(jQuery.css(elem, "float") === "none") {
							
							// Restore the original display value at the end of pure show/hide animations
							if(!propTween) {
								anim.done(function() {
									style.display = restoreDisplay;
								});
								if(restoreDisplay == null) {
									display = style.display;
									restoreDisplay = display === "none" ? "" : display;
								}
							}
							style.display = "inline-block";
						}
					}
				}
				
				if(opts.overflow) {
					style.overflow = "hidden";
					anim.always(function() {
						style.overflow = opts.overflow[0];
						style.overflowX = opts.overflow[1];
						style.overflowY = opts.overflow[2];
					});
				}
				
				// Implement show/hide animations
				propTween = false;
				for(prop in orig) {
					
					// General show/hide setup for this element animation
					if(!propTween) {
						if(dataShow) {
							if("hidden" in dataShow) {
								hidden = dataShow.hidden;
							}
						} else {
							dataShow = dataPriv.access(elem, "fxshow", {display: restoreDisplay});
						}
						
						// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
						if(toggle) {
							dataShow.hidden = !hidden;
						}
						
						// Show elements before animating them
						if(hidden) {
							showHide([elem], true);
						}
						
						/* eslint-disable no-loop-func */
						
						anim.done(function() {
							
							/* eslint-enable no-loop-func */
							
							// The final step of a "hide" animation is actually hiding the element
							if(!hidden) {
								showHide([elem]);
							}
							dataPriv.remove(elem, "fxshow");
							for(prop in orig) {
								jQuery.style(elem, prop, orig[prop]);
							}
						});
					}
					
					// Per-property setup
					propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
					if(!(prop in dataShow)) {
						dataShow[prop] = propTween.start;
						if(hidden) {
							propTween.end = propTween.start;
							propTween.start = 0;
						}
					}
				}
			}
			
			function propFilter(props, specialEasing) {
				var index, name, easing, value, hooks;
				
				// camelCase, specialEasing and expand cssHook pass
				for(index in props) {
					name = camelCase(index);
					easing = specialEasing[name];
					value = props[index];
					if(Array.isArray(value)) {
						easing = value[1];
						value = props[index] = value[0];
					}
					
					if(index !== name) {
						props[name] = value;
						delete props[index];
					}
					
					hooks = jQuery.cssHooks[name];
					if(hooks && "expand" in hooks) {
						value = hooks.expand(value);
						delete props[name];
						
						// Not quite $.extend, this won't overwrite existing keys.
						// Reusing 'index' because we have the correct "name"
						for(index in value) {
							if(!(index in props)) {
								props[index] = value[index];
								specialEasing[index] = easing;
							}
						}
					} else {
						specialEasing[name] = easing;
					}
				}
			}
			
			function Animation(elem, properties, options) {
				var result,
					stopped,
					index = 0,
					length = Animation.prefilters.length,
					deferred = jQuery.Deferred().always(function() {
						
						// Don't match elem in the :animated selector
						delete tick.elem;
					}),
					tick = function() {
						if(stopped) {
							return false;
						}
						var currentTime = fxNow || createFxNow(),
							remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
							
							// Support: Android 2.3 only
							// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
							temp = remaining / animation.duration || 0,
							percent = 1 - temp,
							index = 0,
							length = animation.tweens.length;
						
						for(; index < length; index++) {
							animation.tweens[index].run(percent);
						}
						
						deferred.notifyWith(elem, [animation, percent, remaining]);
						
						// If there's more to do, yield
						if(percent < 1 && length) {
							return remaining;
						}
						
						// If this was an empty animation, synthesize a final progress notification
						if(!length) {
							deferred.notifyWith(elem, [animation, 1, 0]);
						}
						
						// Resolve the animation and report its conclusion
						deferred.resolveWith(elem, [animation]);
						return false;
					},
					animation = deferred.promise({
						elem: elem,
						props: jQuery.extend({}, properties),
						opts: jQuery.extend(true, {
							specialEasing: {},
							easing: jQuery.easing._default
						}, options),
						originalProperties: properties,
						originalOptions: options,
						startTime: fxNow || createFxNow(),
						duration: options.duration,
						tweens: [],
						createTween: function(prop, end) {
							var tween = jQuery.Tween(elem, animation.opts, prop, end,
								animation.opts.specialEasing[prop] || animation.opts.easing);
							animation.tweens.push(tween);
							return tween;
						},
						stop: function(gotoEnd) {
							var index = 0,
								
								// If we are going to the end, we want to run all the tweens
								// otherwise we skip this part
								length = gotoEnd ? animation.tweens.length : 0;
							if(stopped) {
								return this;
							}
							stopped = true;
							for(; index < length; index++) {
								animation.tweens[index].run(1);
							}
							
							// Resolve when we played the last frame; otherwise, reject
							if(gotoEnd) {
								deferred.notifyWith(elem, [animation, 1, 0]);
								deferred.resolveWith(elem, [animation, gotoEnd]);
							} else {
								deferred.rejectWith(elem, [animation, gotoEnd]);
							}
							return this;
						}
					}),
					props = animation.props;
				
				propFilter(props, animation.opts.specialEasing);
				
				for(; index < length; index++) {
					result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
					if(result) {
						if(isFunction(result.stop)) {
							jQuery._queueHooks(animation.elem, animation.opts.queue).stop =
								result.stop.bind(result);
						}
						return result;
					}
				}
				
				jQuery.map(props, createTween, animation);
				
				if(isFunction(animation.opts.start)) {
					animation.opts.start.call(elem, animation);
				}
				
				// Attach callbacks from options
				animation
					.progress(animation.opts.progress)
					.done(animation.opts.done, animation.opts.complete)
					.fail(animation.opts.fail)
					.always(animation.opts.always);
				
				jQuery.fx.timer(
					jQuery.extend(tick, {
						elem: elem,
						anim: animation,
						queue: animation.opts.queue
					})
				);
				
				return animation;
			}
			
			jQuery.Animation = jQuery.extend(Animation, {
				
				tweeners: {
					"*": [function(prop, value) {
						var tween = this.createTween(prop, value);
						adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
						return tween;
					}]
				},
				
				tweener: function(props, callback) {
					if(isFunction(props)) {
						callback = props;
						props = ["*"];
					} else {
						props = props.match(rnothtmlwhite);
					}
					
					var prop,
						index = 0,
						length = props.length;
					
					for(; index < length; index++) {
						prop = props[index];
						Animation.tweeners[prop] = Animation.tweeners[prop] || [];
						Animation.tweeners[prop].unshift(callback);
					}
				},
				
				prefilters: [defaultPrefilter],
				
				prefilter: function(callback, prepend) {
					if(prepend) {
						Animation.prefilters.unshift(callback);
					} else {
						Animation.prefilters.push(callback);
					}
				}
			});
			
			jQuery.speed = function(speed, easing, fn) {
				var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
					complete: fn || !fn && easing ||
						isFunction(speed) && speed,
					duration: speed,
					easing: fn && easing || easing && !isFunction(easing) && easing
				};
				
				// Go to the end state if fx are off
				if(jQuery.fx.off) {
					opt.duration = 0;
					
				} else {
					if(typeof opt.duration !== "number") {
						if(opt.duration in jQuery.fx.speeds) {
							opt.duration = jQuery.fx.speeds[opt.duration];
							
						} else {
							opt.duration = jQuery.fx.speeds._default;
						}
					}
				}
				
				// Normalize opt.queue - true/undefined/null -> "fx"
				if(opt.queue == null || opt.queue === true) {
					opt.queue = "fx";
				}
				
				// Queueing
				opt.old = opt.complete;
				
				opt.complete = function() {
					if(isFunction(opt.old)) {
						opt.old.call(this);
					}
					
					if(opt.queue) {
						jQuery.dequeue(this, opt.queue);
					}
				};
				
				return opt;
			};
			
			jQuery.fn.extend({
				fadeTo: function(speed, to, easing, callback) {
					
					// Show any hidden elements after setting opacity to 0
					return this.filter(isHiddenWithinTree).css("opacity", 0).show()
					
					// Animate to the value specified
						.end().animate({opacity: to}, speed, easing, callback);
				},
				animate: function(prop, speed, easing, callback) {
					var empty = jQuery.isEmptyObject(prop),
						optall = jQuery.speed(speed, easing, callback),
						doAnimation = function() {
							
							// Operate on a copy of prop so per-property easing won't be lost
							var anim = Animation(this, jQuery.extend({}, prop), optall);
							
							// Empty animations, or finishing resolves immediately
							if(empty || dataPriv.get(this, "finish")) {
								anim.stop(true);
							}
						};
					doAnimation.finish = doAnimation;
					
					return empty || optall.queue === false ?
						this.each(doAnimation) :
						this.queue(optall.queue, doAnimation);
				},
				stop: function(type, clearQueue, gotoEnd) {
					var stopQueue = function(hooks) {
						var stop = hooks.stop;
						delete hooks.stop;
						stop(gotoEnd);
					};
					
					if(typeof type !== "string") {
						gotoEnd = clearQueue;
						clearQueue = type;
						type = undefined;
					}
					if(clearQueue && type !== false) {
						this.queue(type || "fx", []);
					}
					
					return this.each(function() {
						var dequeue = true,
							index = type != null && type + "queueHooks",
							timers = jQuery.timers,
							data = dataPriv.get(this);
						
						if(index) {
							if(data[index] && data[index].stop) {
								stopQueue(data[index]);
							}
						} else {
							for(index in data) {
								if(data[index] && data[index].stop && rrun.test(index)) {
									stopQueue(data[index]);
								}
							}
						}
						
						for(index = timers.length; index--;) {
							if(timers[index].elem === this &&
								(type == null || timers[index].queue === type)) {
								
								timers[index].anim.stop(gotoEnd);
								dequeue = false;
								timers.splice(index, 1);
							}
						}
						
						// Start the next in the queue if the last step wasn't forced.
						// Timers currently will call their complete callbacks, which
						// will dequeue but only if they were gotoEnd.
						if(dequeue || !gotoEnd) {
							jQuery.dequeue(this, type);
						}
					});
				},
				finish: function(type) {
					if(type !== false) {
						type = type || "fx";
					}
					return this.each(function() {
						var index,
							data = dataPriv.get(this),
							queue = data[type + "queue"],
							hooks = data[type + "queueHooks"],
							timers = jQuery.timers,
							length = queue ? queue.length : 0;
						
						// Enable finishing flag on private data
						data.finish = true;
						
						// Empty the queue first
						jQuery.queue(this, type, []);
						
						if(hooks && hooks.stop) {
							hooks.stop.call(this, true);
						}
						
						// Look for any active animations, and finish them
						for(index = timers.length; index--;) {
							if(timers[index].elem === this && timers[index].queue === type) {
								timers[index].anim.stop(true);
								timers.splice(index, 1);
							}
						}
						
						// Look for any animations in the old queue and finish them
						for(index = 0; index < length; index++) {
							if(queue[index] && queue[index].finish) {
								queue[index].finish.call(this);
							}
						}
						
						// Turn off finishing flag
						delete data.finish;
					});
				}
			});
			
			jQuery.each(["toggle", "show", "hide"], function(i, name) {
				var cssFn = jQuery.fn[name];
				jQuery.fn[name] = function(speed, easing, callback) {
					return speed == null || typeof speed === "boolean" ?
						cssFn.apply(this, arguments) :
						this.animate(genFx(name, true), speed, easing, callback);
				};
			});

// Generate shortcuts for custom animations
			jQuery.each({
				slideDown: genFx("show"),
				slideUp: genFx("hide"),
				slideToggle: genFx("toggle"),
				fadeIn: {opacity: "show"},
				fadeOut: {opacity: "hide"},
				fadeToggle: {opacity: "toggle"}
			}, function(name, props) {
				jQuery.fn[name] = function(speed, easing, callback) {
					return this.animate(props, speed, easing, callback);
				};
			});
			
			jQuery.timers = [];
			jQuery.fx.tick = function() {
				var timer,
					i = 0,
					timers = jQuery.timers;
				
				fxNow = Date.now();
				
				for(; i < timers.length; i++) {
					timer = timers[i];
					
					// Run the timer and safely remove it when done (allowing for external removal)
					if(!timer() && timers[i] === timer) {
						timers.splice(i--, 1);
					}
				}
				
				if(!timers.length) {
					jQuery.fx.stop();
				}
				fxNow = undefined;
			};
			
			jQuery.fx.timer = function(timer) {
				jQuery.timers.push(timer);
				jQuery.fx.start();
			};
			
			jQuery.fx.interval = 13;
			jQuery.fx.start = function() {
				if(inProgress) {
					return;
				}
				
				inProgress = true;
				schedule();
			};
			
			jQuery.fx.stop = function() {
				inProgress = null;
			};
			
			jQuery.fx.speeds = {
				slow: 600,
				fast: 200,
				
				// Default speed
				_default: 400
			};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
			jQuery.fn.delay = function(time, type) {
				time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
				type = type || "fx";
				
				return this.queue(type, function(next, hooks) {
					var timeout = window.setTimeout(next, time);
					hooks.stop = function() {
						window.clearTimeout(timeout);
					};
				});
			};
			
			
			(function() {
				var input = document.createElement("input"),
					select = document.createElement("select"),
					opt = select.appendChild(document.createElement("option"));
				
				input.type = "checkbox";
				
				// Support: Android <=4.3 only
				// Default value for a checkbox should be "on"
				support.checkOn = input.value !== "";
				
				// Support: IE <=11 only
				// Must access selectedIndex to make default options select
				support.optSelected = opt.selected;
				
				// Support: IE <=11 only
				// An input loses its value after becoming a radio
				input = document.createElement("input");
				input.value = "t";
				input.type = "radio";
				support.radioValue = input.value === "t";
			})();
			
			
			var boolHook,
				attrHandle = jQuery.expr.attrHandle;
			
			jQuery.fn.extend({
				attr: function(name, value) {
					return access(this, jQuery.attr, name, value, arguments.length > 1);
				},
				
				removeAttr: function(name) {
					return this.each(function() {
						jQuery.removeAttr(this, name);
					});
				}
			});
			
			jQuery.extend({
				attr: function(elem, name, value) {
					var ret, hooks,
						nType = elem.nodeType;
					
					// Don't get/set attributes on text, comment and attribute nodes
					if(nType === 3 || nType === 8 || nType === 2) {
						return;
					}
					
					// Fallback to prop when attributes are not supported
					if(typeof elem.getAttribute === "undefined") {
						return jQuery.prop(elem, name, value);
					}
					
					// Attribute hooks are determined by the lowercase version
					// Grab necessary hook if one is defined
					if(nType !== 1 || !jQuery.isXMLDoc(elem)) {
						hooks = jQuery.attrHooks[name.toLowerCase()] ||
							(jQuery.expr.match.bool.test(name) ? boolHook : undefined);
					}
					
					if(value !== undefined) {
						if(value === null) {
							jQuery.removeAttr(elem, name);
							return;
						}
						
						if(hooks && "set" in hooks &&
							(ret = hooks.set(elem, value, name)) !== undefined) {
							return ret;
						}
						
						elem.setAttribute(name, value + "");
						return value;
					}
					
					if(hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
						return ret;
					}
					
					ret = jQuery.find.attr(elem, name);
					
					// Non-existent attributes return null, we normalize to undefined
					return ret == null ? undefined : ret;
				},
				
				attrHooks: {
					type: {
						set: function(elem, value) {
							if(!support.radioValue && value === "radio" &&
								nodeName(elem, "input")) {
								var val = elem.value;
								elem.setAttribute("type", value);
								if(val) {
									elem.value = val;
								}
								return value;
							}
						}
					}
				},
				
				removeAttr: function(elem, value) {
					var name,
						i = 0,
						
						// Attribute names can contain non-HTML whitespace characters
						// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
						attrNames = value && value.match(rnothtmlwhite);
					
					if(attrNames && elem.nodeType === 1) {
						while((name = attrNames[i++])) {
							elem.removeAttribute(name);
						}
					}
				}
			});

// Hooks for boolean attributes
			boolHook = {
				set: function(elem, value, name) {
					if(value === false) {
						
						// Remove boolean attributes when set to false
						jQuery.removeAttr(elem, name);
					} else {
						elem.setAttribute(name, name);
					}
					return name;
				}
			};
			
			jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(i, name) {
				var getter = attrHandle[name] || jQuery.find.attr;
				
				attrHandle[name] = function(elem, name, isXML) {
					var ret, handle,
						lowercaseName = name.toLowerCase();
					
					if(!isXML) {
						
						// Avoid an infinite loop by temporarily removing this function from the getter
						handle = attrHandle[lowercaseName];
						attrHandle[lowercaseName] = ret;
						ret = getter(elem, name, isXML) != null ?
							lowercaseName :
							null;
						attrHandle[lowercaseName] = handle;
					}
					return ret;
				};
			});
			
			
			var rfocusable = /^(?:input|select|textarea|button)$/i,
				rclickable = /^(?:a|area)$/i;
			
			jQuery.fn.extend({
				prop: function(name, value) {
					return access(this, jQuery.prop, name, value, arguments.length > 1);
				},
				
				removeProp: function(name) {
					return this.each(function() {
						delete this[jQuery.propFix[name] || name];
					});
				}
			});
			
			jQuery.extend({
				prop: function(elem, name, value) {
					var ret, hooks,
						nType = elem.nodeType;
					
					// Don't get/set properties on text, comment and attribute nodes
					if(nType === 3 || nType === 8 || nType === 2) {
						return;
					}
					
					if(nType !== 1 || !jQuery.isXMLDoc(elem)) {
						
						// Fix name and attach hooks
						name = jQuery.propFix[name] || name;
						hooks = jQuery.propHooks[name];
					}
					
					if(value !== undefined) {
						if(hooks && "set" in hooks &&
							(ret = hooks.set(elem, value, name)) !== undefined) {
							return ret;
						}
						
						return (elem[name] = value);
					}
					
					if(hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
						return ret;
					}
					
					return elem[name];
				},
				
				propHooks: {
					tabIndex: {
						get: function(elem) {
							
							// Support: IE <=9 - 11 only
							// elem.tabIndex doesn't always return the
							// correct value when it hasn't been explicitly set
							// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
							// Use proper attribute retrieval(#12072)
							var tabindex = jQuery.find.attr(elem, "tabindex");
							
							if(tabindex) {
								return parseInt(tabindex, 10);
							}
							
							if(
								rfocusable.test(elem.nodeName) ||
								rclickable.test(elem.nodeName) &&
								elem.href
							) {
								return 0;
							}
							
							return -1;
						}
					}
				},
				
				propFix: {
					"for": "htmlFor",
					"class": "className"
				}
			});

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
			if(!support.optSelected) {
				jQuery.propHooks.selected = {
					get: function(elem) {
						
						/* eslint no-unused-expressions: "off" */
						
						var parent = elem.parentNode;
						if(parent && parent.parentNode) {
							parent.parentNode.selectedIndex;
						}
						return null;
					},
					set: function(elem) {
						
						/* eslint no-unused-expressions: "off" */
						
						var parent = elem.parentNode;
						if(parent) {
							parent.selectedIndex;
							
							if(parent.parentNode) {
								parent.parentNode.selectedIndex;
							}
						}
					}
				};
			}
			
			jQuery.each([
				"tabIndex",
				"readOnly",
				"maxLength",
				"cellSpacing",
				"cellPadding",
				"rowSpan",
				"colSpan",
				"useMap",
				"frameBorder",
				"contentEditable"
			], function() {
				jQuery.propFix[this.toLowerCase()] = this;
			});
			
			
			// Strip and collapse whitespace according to HTML spec
			// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
			function stripAndCollapse(value) {
				var tokens = value.match(rnothtmlwhite) || [];
				return tokens.join(" ");
			}
			
			
			function getClass(elem) {
				return elem.getAttribute && elem.getAttribute("class") || "";
			}
			
			function classesToArray(value) {
				if(Array.isArray(value)) {
					return value;
				}
				if(typeof value === "string") {
					return value.match(rnothtmlwhite) || [];
				}
				return [];
			}
			
			jQuery.fn.extend({
				addClass: function(value) {
					var classes, elem, cur, curValue, clazz, j, finalValue,
						i = 0;
					
					if(isFunction(value)) {
						return this.each(function(j) {
							jQuery(this).addClass(value.call(this, j, getClass(this)));
						});
					}
					
					classes = classesToArray(value);
					
					if(classes.length) {
						while((elem = this[i++])) {
							curValue = getClass(elem);
							cur = elem.nodeType === 1 && (" " + stripAndCollapse(curValue) + " ");
							
							if(cur) {
								j = 0;
								while((clazz = classes[j++])) {
									if(cur.indexOf(" " + clazz + " ") < 0) {
										cur += clazz + " ";
									}
								}
								
								// Only assign if different to avoid unneeded rendering.
								finalValue = stripAndCollapse(cur);
								if(curValue !== finalValue) {
									elem.setAttribute("class", finalValue);
								}
							}
						}
					}
					
					return this;
				},
				
				removeClass: function(value) {
					var classes, elem, cur, curValue, clazz, j, finalValue,
						i = 0;
					
					if(isFunction(value)) {
						return this.each(function(j) {
							jQuery(this).removeClass(value.call(this, j, getClass(this)));
						});
					}
					
					if(!arguments.length) {
						return this.attr("class", "");
					}
					
					classes = classesToArray(value);
					
					if(classes.length) {
						while((elem = this[i++])) {
							curValue = getClass(elem);
							
							// This expression is here for better compressibility (see addClass)
							cur = elem.nodeType === 1 && (" " + stripAndCollapse(curValue) + " ");
							
							if(cur) {
								j = 0;
								while((clazz = classes[j++])) {
									
									// Remove *all* instances
									while(cur.indexOf(" " + clazz + " ") > -1) {
										cur = cur.replace(" " + clazz + " ", " ");
									}
								}
								
								// Only assign if different to avoid unneeded rendering.
								finalValue = stripAndCollapse(cur);
								if(curValue !== finalValue) {
									elem.setAttribute("class", finalValue);
								}
							}
						}
					}
					
					return this;
				},
				
				toggleClass: function(value, stateVal) {
					var type = typeof value,
						isValidValue = type === "string" || Array.isArray(value);
					
					if(typeof stateVal === "boolean" && isValidValue) {
						return stateVal ? this.addClass(value) : this.removeClass(value);
					}
					
					if(isFunction(value)) {
						return this.each(function(i) {
							jQuery(this).toggleClass(
								value.call(this, i, getClass(this), stateVal),
								stateVal
							);
						});
					}
					
					return this.each(function() {
						var className, i, self, classNames;
						
						if(isValidValue) {
							
							// Toggle individual class names
							i = 0;
							self = jQuery(this);
							classNames = classesToArray(value);
							
							while((className = classNames[i++])) {
								
								// Check each className given, space separated list
								if(self.hasClass(className)) {
									self.removeClass(className);
								} else {
									self.addClass(className);
								}
							}
							
							// Toggle whole class name
						} else if(value === undefined || type === "boolean") {
							className = getClass(this);
							if(className) {
								
								// Store className if set
								dataPriv.set(this, "__className__", className);
							}
							
							// If the element has a class name or if we're passed `false`,
							// then remove the whole classname (if there was one, the above saved it).
							// Otherwise bring back whatever was previously saved (if anything),
							// falling back to the empty string if nothing was stored.
							if(this.setAttribute) {
								this.setAttribute("class",
									className || value === false ?
										"" :
										dataPriv.get(this, "__className__") || ""
								);
							}
						}
					});
				},
				
				hasClass: function(selector) {
					var className, elem,
						i = 0;
					
					className = " " + selector + " ";
					while((elem = this[i++])) {
						if(elem.nodeType === 1 &&
							(" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
							return true;
						}
					}
					
					return false;
				}
			});
			
			
			var rreturn = /\r/g;
			
			jQuery.fn.extend({
				val: function(value) {
					var hooks, ret, valueIsFunction,
						elem = this[0];
					
					if(!arguments.length) {
						if(elem) {
							hooks = jQuery.valHooks[elem.type] ||
								jQuery.valHooks[elem.nodeName.toLowerCase()];
							
							if(hooks &&
								"get" in hooks &&
								(ret = hooks.get(elem, "value")) !== undefined
							) {
								return ret;
							}
							
							ret = elem.value;
							
							// Handle most common string cases
							if(typeof ret === "string") {
								return ret.replace(rreturn, "");
							}
							
							// Handle cases where value is null/undef or number
							return ret == null ? "" : ret;
						}
						
						return;
					}
					
					valueIsFunction = isFunction(value);
					
					return this.each(function(i) {
						var val;
						
						if(this.nodeType !== 1) {
							return;
						}
						
						if(valueIsFunction) {
							val = value.call(this, i, jQuery(this).val());
						} else {
							val = value;
						}
						
						// Treat null/undefined as ""; convert numbers to string
						if(val == null) {
							val = "";
							
						} else if(typeof val === "number") {
							val += "";
							
						} else if(Array.isArray(val)) {
							val = jQuery.map(val, function(value) {
								return value == null ? "" : value + "";
							});
						}
						
						hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
						
						// If set returns undefined, fall back to normal setting
						if(!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
							this.value = val;
						}
					});
				}
			});
			
			jQuery.extend({
				valHooks: {
					option: {
						get: function(elem) {
							
							var val = jQuery.find.attr(elem, "value");
							return val != null ?
								val :
								
								// Support: IE <=10 - 11 only
								// option.text throws exceptions (#14686, #14858)
								// Strip and collapse whitespace
								// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
								stripAndCollapse(jQuery.text(elem));
						}
					},
					select: {
						get: function(elem) {
							var value, option, i,
								options = elem.options,
								index = elem.selectedIndex,
								one = elem.type === "select-one",
								values = one ? null : [],
								max = one ? index + 1 : options.length;
							
							if(index < 0) {
								i = max;
								
							} else {
								i = one ? index : 0;
							}
							
							// Loop through all the selected options
							for(; i < max; i++) {
								option = options[i];
								
								// Support: IE <=9 only
								// IE8-9 doesn't update selected after form reset (#2551)
								if((option.selected || i === index) &&
									
									// Don't return options that are disabled or in a disabled optgroup
									!option.disabled &&
									(!option.parentNode.disabled ||
										!nodeName(option.parentNode, "optgroup"))) {
									
									// Get the specific value for the option
									value = jQuery(option).val();
									
									// We don't need an array for one selects
									if(one) {
										return value;
									}
									
									// Multi-Selects return an array
									values.push(value);
								}
							}
							
							return values;
						},
						
						set: function(elem, value) {
							var optionSet, option,
								options = elem.options,
								values = jQuery.makeArray(value),
								i = options.length;
							
							while(i--) {
								option = options[i];
								
								/* eslint-disable no-cond-assign */
								
								if(option.selected =
									jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1
								) {
									optionSet = true;
								}
								
								/* eslint-enable no-cond-assign */
							}
							
							// Force browsers to behave consistently when non-matching value is set
							if(!optionSet) {
								elem.selectedIndex = -1;
							}
							return values;
						}
					}
				}
			});

// Radios and checkboxes getter/setter
			jQuery.each(["radio", "checkbox"], function() {
				jQuery.valHooks[this] = {
					set: function(elem, value) {
						if(Array.isArray(value)) {
							return (elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1);
						}
					}
				};
				if(!support.checkOn) {
					jQuery.valHooks[this].get = function(elem) {
						return elem.getAttribute("value") === null ? "on" : elem.value;
					};
				}
			});


// Return jQuery for attributes-only inclusion
			
			
			support.focusin = "onfocusin" in window;
			
			
			var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
				stopPropagationCallback = function(e) {
					e.stopPropagation();
				};
			
			jQuery.extend(jQuery.event, {
				
				trigger: function(event, data, elem, onlyHandlers) {
					
					var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
						eventPath = [elem || document],
						type = hasOwn.call(event, "type") ? event.type : event,
						namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
					
					cur = lastElement = tmp = elem = elem || document;
					
					// Don't do events on text and comment nodes
					if(elem.nodeType === 3 || elem.nodeType === 8) {
						return;
					}
					
					// focus/blur morphs to focusin/out; ensure we're not firing them right now
					if(rfocusMorph.test(type + jQuery.event.triggered)) {
						return;
					}
					
					if(type.indexOf(".") > -1) {
						
						// Namespaced trigger; create a regexp to match event type in handle()
						namespaces = type.split(".");
						type = namespaces.shift();
						namespaces.sort();
					}
					ontype = type.indexOf(":") < 0 && "on" + type;
					
					// Caller can pass in a jQuery.Event object, Object, or just an event type string
					event = event[jQuery.expando] ?
						event :
						new jQuery.Event(type, typeof event === "object" && event);
					
					// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
					event.isTrigger = onlyHandlers ? 2 : 3;
					event.namespace = namespaces.join(".");
					event.rnamespace = event.namespace ?
						new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") :
						null;
					
					// Clean up the event in case it is being reused
					event.result = undefined;
					if(!event.target) {
						event.target = elem;
					}
					
					// Clone any incoming data and prepend the event, creating the handler arg list
					data = data == null ?
						[event] :
						jQuery.makeArray(data, [event]);
					
					// Allow special events to draw outside the lines
					special = jQuery.event.special[type] || {};
					if(!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
						return;
					}
					
					// Determine event propagation path in advance, per W3C events spec (#9951)
					// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
					if(!onlyHandlers && !special.noBubble && !isWindow(elem)) {
						
						bubbleType = special.delegateType || type;
						if(!rfocusMorph.test(bubbleType + type)) {
							cur = cur.parentNode;
						}
						for(; cur; cur = cur.parentNode) {
							eventPath.push(cur);
							tmp = cur;
						}
						
						// Only add window if we got to document (e.g., not plain obj or detached DOM)
						if(tmp === (elem.ownerDocument || document)) {
							eventPath.push(tmp.defaultView || tmp.parentWindow || window);
						}
					}
					
					// Fire handlers on the event path
					i = 0;
					while((cur = eventPath[i++]) && !event.isPropagationStopped()) {
						lastElement = cur;
						event.type = i > 1 ?
							bubbleType :
							special.bindType || type;
						
						// jQuery handler
						handle = (dataPriv.get(cur, "events") || {})[event.type] &&
							dataPriv.get(cur, "handle");
						if(handle) {
							handle.apply(cur, data);
						}
						
						// Native handler
						handle = ontype && cur[ontype];
						if(handle && handle.apply && acceptData(cur)) {
							event.result = handle.apply(cur, data);
							if(event.result === false) {
								event.preventDefault();
							}
						}
					}
					event.type = type;
					
					// If nobody prevented the default action, do it now
					if(!onlyHandlers && !event.isDefaultPrevented()) {
						
						if((!special._default ||
							special._default.apply(eventPath.pop(), data) === false) &&
							acceptData(elem)) {
							
							// Call a native DOM method on the target with the same name as the event.
							// Don't do default actions on window, that's where global variables be (#6170)
							if(ontype && isFunction(elem[type]) && !isWindow(elem)) {
								
								// Don't re-trigger an onFOO event when we call its FOO() method
								tmp = elem[ontype];
								
								if(tmp) {
									elem[ontype] = null;
								}
								
								// Prevent re-triggering of the same event, since we already bubbled it above
								jQuery.event.triggered = type;
								
								if(event.isPropagationStopped()) {
									lastElement.addEventListener(type, stopPropagationCallback);
								}
								
								elem[type]();
								
								if(event.isPropagationStopped()) {
									lastElement.removeEventListener(type, stopPropagationCallback);
								}
								
								jQuery.event.triggered = undefined;
								
								if(tmp) {
									elem[ontype] = tmp;
								}
							}
						}
					}
					
					return event.result;
				},
				
				// Piggyback on a donor event to simulate a different one
				// Used only for `focus(in | out)` events
				simulate: function(type, elem, event) {
					var e = jQuery.extend(
						new jQuery.Event(),
						event,
						{
							type: type,
							isSimulated: true
						}
					);
					
					jQuery.event.trigger(e, null, elem);
				}
				
			});
			
			jQuery.fn.extend({
				
				trigger: function(type, data) {
					return this.each(function() {
						jQuery.event.trigger(type, data, this);
					});
				},
				triggerHandler: function(type, data) {
					var elem = this[0];
					if(elem) {
						return jQuery.event.trigger(type, data, elem, true);
					}
				}
			});


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
			if(!support.focusin) {
				jQuery.each({focus: "focusin", blur: "focusout"}, function(orig, fix) {
					
					// Attach a single capturing handler on the document while someone wants focusin/focusout
					var handler = function(event) {
						jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
					};
					
					jQuery.event.special[fix] = {
						setup: function() {
							var doc = this.ownerDocument || this,
								attaches = dataPriv.access(doc, fix);
							
							if(!attaches) {
								doc.addEventListener(orig, handler, true);
							}
							dataPriv.access(doc, fix, (attaches || 0) + 1);
						},
						teardown: function() {
							var doc = this.ownerDocument || this,
								attaches = dataPriv.access(doc, fix) - 1;
							
							if(!attaches) {
								doc.removeEventListener(orig, handler, true);
								dataPriv.remove(doc, fix);
								
							} else {
								dataPriv.access(doc, fix, attaches);
							}
						}
					};
				});
			}
			var location = window.location;
			
			var nonce = Date.now();
			
			var rquery = (/\?/);


// Cross-browser xml parsing
			jQuery.parseXML = function(data) {
				var xml;
				if(!data || typeof data !== "string") {
					return null;
				}
				
				// Support: IE 9 - 11 only
				// IE throws on parseFromString with invalid input.
				try {
					xml = (new window.DOMParser()).parseFromString(data, "text/xml");
				} catch(e) {
					xml = undefined;
				}
				
				if(!xml || xml.getElementsByTagName("parsererror").length) {
					jQuery.error("Invalid XML: " + data);
				}
				return xml;
			};
			
			
			var
				rbracket = /\[\]$/,
				rCRLF = /\r?\n/g,
				rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
				rsubmittable = /^(?:input|select|textarea|keygen)/i;
			
			function buildParams(prefix, obj, traditional, add) {
				var name;
				
				if(Array.isArray(obj)) {
					
					// Serialize array item.
					jQuery.each(obj, function(i, v) {
						if(traditional || rbracket.test(prefix)) {
							
							// Treat each array item as a scalar.
							add(prefix, v);
							
						} else {
							
							// Item is non-scalar (array or object), encode its numeric index.
							buildParams(
								prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]",
								v,
								traditional,
								add
							);
						}
					});
					
				} else if(!traditional && toType(obj) === "object") {
					
					// Serialize object item.
					for(name in obj) {
						buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
					}
					
				} else {
					
					// Serialize scalar item.
					add(prefix, obj);
				}
			}

// Serialize an array of form elements or a set of
// key/values into a query string
			jQuery.param = function(a, traditional) {
				var prefix,
					s = [],
					add = function(key, valueOrFunction) {
						
						// If value is a function, invoke it and use its return value
						var value = isFunction(valueOrFunction) ?
							valueOrFunction() :
							valueOrFunction;
						
						s[s.length] = encodeURIComponent(key) + "=" +
							encodeURIComponent(value == null ? "" : value);
					};
				
				// If an array was passed in, assume that it is an array of form elements.
				if(Array.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {
					
					// Serialize the form elements
					jQuery.each(a, function() {
						add(this.name, this.value);
					});
					
				} else {
					
					// If traditional, encode the "old" way (the way 1.3.2 or older
					// did it), otherwise encode params recursively.
					for(prefix in a) {
						buildParams(prefix, a[prefix], traditional, add);
					}
				}
				
				// Return the resulting serialization
				return s.join("&");
			};
			
			jQuery.fn.extend({
				serialize: function() {
					return jQuery.param(this.serializeArray());
				},
				serializeArray: function() {
					return this.map(function() {
						
						// Can add propHook for "elements" to filter or add form elements
						var elements = jQuery.prop(this, "elements");
						return elements ? jQuery.makeArray(elements) : this;
					})
						.filter(function() {
							var type = this.type;
							
							// Use .is( ":disabled" ) so that fieldset[disabled] works
							return this.name && !jQuery(this).is(":disabled") &&
								rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) &&
								(this.checked || !rcheckableType.test(type));
						})
						.map(function(i, elem) {
							var val = jQuery(this).val();
							
							if(val == null) {
								return null;
							}
							
							if(Array.isArray(val)) {
								return jQuery.map(val, function(val) {
									return {name: elem.name, value: val.replace(rCRLF, "\r\n")};
								});
							}
							
							return {name: elem.name, value: val.replace(rCRLF, "\r\n")};
						}).get();
				}
			});
			
			
			var
				r20 = /%20/g,
				rhash = /#.*$/,
				rantiCache = /([?&])_=[^&]*/,
				rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
				
				// #7653, #8125, #8152: local protocol detection
				rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
				rnoContent = /^(?:GET|HEAD)$/,
				rprotocol = /^\/\//,
				
				/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
				prefilters = {},
				
				/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
				transports = {},
				
				// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
				allTypes = "*/".concat("*"),
				
				// Anchor tag for parsing the document origin
				originAnchor = document.createElement("a");
			originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
			function addToPrefiltersOrTransports(structure) {
				
				// dataTypeExpression is optional and defaults to "*"
				return function(dataTypeExpression, func) {
					
					if(typeof dataTypeExpression !== "string") {
						func = dataTypeExpression;
						dataTypeExpression = "*";
					}
					
					var dataType,
						i = 0,
						dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
					
					if(isFunction(func)) {
						
						// For each dataType in the dataTypeExpression
						while((dataType = dataTypes[i++])) {
							
							// Prepend if requested
							if(dataType[0] === "+") {
								dataType = dataType.slice(1) || "*";
								(structure[dataType] = structure[dataType] || []).unshift(func);
								
								// Otherwise append
							} else {
								(structure[dataType] = structure[dataType] || []).push(func);
							}
						}
					}
				};
			}

// Base inspection function for prefilters and transports
			function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
				
				var inspected = {},
					seekingTransport = (structure === transports);
				
				function inspect(dataType) {
					var selected;
					inspected[dataType] = true;
					jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
						var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
						if(typeof dataTypeOrTransport === "string" &&
							!seekingTransport && !inspected[dataTypeOrTransport]) {
							
							options.dataTypes.unshift(dataTypeOrTransport);
							inspect(dataTypeOrTransport);
							return false;
						} else if(seekingTransport) {
							return !(selected = dataTypeOrTransport);
						}
					});
					return selected;
				}
				
				return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
			}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
			function ajaxExtend(target, src) {
				var key, deep,
					flatOptions = jQuery.ajaxSettings.flatOptions || {};
				
				for(key in src) {
					if(src[key] !== undefined) {
						(flatOptions[key] ? target : (deep || (deep = {})))[key] = src[key];
					}
				}
				if(deep) {
					jQuery.extend(true, target, deep);
				}
				
				return target;
			}
			
			/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
			function ajaxHandleResponses(s, jqXHR, responses) {
				
				var ct, type, finalDataType, firstDataType,
					contents = s.contents,
					dataTypes = s.dataTypes;
				
				// Remove auto dataType and get content-type in the process
				while(dataTypes[0] === "*") {
					dataTypes.shift();
					if(ct === undefined) {
						ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
					}
				}
				
				// Check if we're dealing with a known content-type
				if(ct) {
					for(type in contents) {
						if(contents[type] && contents[type].test(ct)) {
							dataTypes.unshift(type);
							break;
						}
					}
				}
				
				// Check to see if we have a response for the expected dataType
				if(dataTypes[0] in responses) {
					finalDataType = dataTypes[0];
				} else {
					
					// Try convertible dataTypes
					for(type in responses) {
						if(!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
							finalDataType = type;
							break;
						}
						if(!firstDataType) {
							firstDataType = type;
						}
					}
					
					// Or just use first one
					finalDataType = finalDataType || firstDataType;
				}
				
				// If we found a dataType
				// We add the dataType to the list if needed
				// and return the corresponding response
				if(finalDataType) {
					if(finalDataType !== dataTypes[0]) {
						dataTypes.unshift(finalDataType);
					}
					return responses[finalDataType];
				}
			}
			
			/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
			function ajaxConvert(s, response, jqXHR, isSuccess) {
				var conv2, current, conv, tmp, prev,
					converters = {},
					
					// Work with a copy of dataTypes in case we need to modify it for conversion
					dataTypes = s.dataTypes.slice();
				
				// Create converters map with lowercased keys
				if(dataTypes[1]) {
					for(conv in s.converters) {
						converters[conv.toLowerCase()] = s.converters[conv];
					}
				}
				
				current = dataTypes.shift();
				
				// Convert to each sequential dataType
				while(current) {
					
					if(s.responseFields[current]) {
						jqXHR[s.responseFields[current]] = response;
					}
					
					// Apply the dataFilter if provided
					if(!prev && isSuccess && s.dataFilter) {
						response = s.dataFilter(response, s.dataType);
					}
					
					prev = current;
					current = dataTypes.shift();
					
					if(current) {
						
						// There's only work to do if current dataType is non-auto
						if(current === "*") {
							
							current = prev;
							
							// Convert response if prev dataType is non-auto and differs from current
						} else if(prev !== "*" && prev !== current) {
							
							// Seek a direct converter
							conv = converters[prev + " " + current] || converters["* " + current];
							
							// If none found, seek a pair
							if(!conv) {
								for(conv2 in converters) {
									
									// If conv2 outputs current
									tmp = conv2.split(" ");
									if(tmp[1] === current) {
										
										// If prev can be converted to accepted input
										conv = converters[prev + " " + tmp[0]] ||
											converters["* " + tmp[0]];
										if(conv) {
											
											// Condense equivalence converters
											if(conv === true) {
												conv = converters[conv2];
												
												// Otherwise, insert the intermediate dataType
											} else if(converters[conv2] !== true) {
												current = tmp[0];
												dataTypes.unshift(tmp[1]);
											}
											break;
										}
									}
								}
							}
							
							// Apply converter (if not an equivalence)
							if(conv !== true) {
								
								// Unless errors are allowed to bubble, catch and return them
								if(conv && s.throws) {
									response = conv(response);
								} else {
									try {
										response = conv(response);
									} catch(e) {
										return {
											state: "parsererror",
											error: conv ? e : "No conversion from " + prev + " to " + current
										};
									}
								}
							}
						}
					}
				}
				
				return {state: "success", data: response};
			}
			
			jQuery.extend({
				
				// Counter for holding the number of active queries
				active: 0,
				
				// Last-Modified header cache for next request
				lastModified: {},
				etag: {},
				
				ajaxSettings: {
					url: location.href,
					type: "GET",
					isLocal: rlocalProtocol.test(location.protocol),
					global: true,
					processData: true,
					async: true,
					contentType: "application/x-www-form-urlencoded; charset=UTF-8",
					
					/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/
					
					accepts: {
						"*": allTypes,
						text: "text/plain",
						html: "text/html",
						xml: "application/xml, text/xml",
						json: "application/json, text/javascript"
					},
					
					contents: {
						xml: /\bxml\b/,
						html: /\bhtml/,
						json: /\bjson\b/
					},
					
					responseFields: {
						xml: "responseXML",
						text: "responseText",
						json: "responseJSON"
					},
					
					// Data converters
					// Keys separate source (or catchall "*") and destination types with a single space
					converters: {
						
						// Convert anything to text
						"* text": String,
						
						// Text to html (true = no transformation)
						"text html": true,
						
						// Evaluate text as a json expression
						"text json": JSON.parse,
						
						// Parse text as xml
						"text xml": jQuery.parseXML
					},
					
					// For options that shouldn't be deep extended:
					// you can add your own custom options here if
					// and when you create one that shouldn't be
					// deep extended (see ajaxExtend)
					flatOptions: {
						url: true,
						context: true
					}
				},
				
				// Creates a full fledged settings object into target
				// with both ajaxSettings and settings fields.
				// If target is omitted, writes into ajaxSettings.
				ajaxSetup: function(target, settings) {
					return settings ?
						
						// Building a settings object
						ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) :
						
						// Extending ajaxSettings
						ajaxExtend(jQuery.ajaxSettings, target);
				},
				
				ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
				ajaxTransport: addToPrefiltersOrTransports(transports),
				
				// Main method
				ajax: function(url, options) {
					
					// If url is an object, simulate pre-1.5 signature
					if(typeof url === "object") {
						options = url;
						url = undefined;
					}
					
					// Force options to be an object
					options = options || {};
					
					var transport,
						
						// URL without anti-cache param
						cacheURL,
						
						// Response headers
						responseHeadersString,
						responseHeaders,
						
						// timeout handle
						timeoutTimer,
						
						// Url cleanup var
						urlAnchor,
						
						// Request state (becomes false upon send and true upon completion)
						completed,
						
						// To know if global events are to be dispatched
						fireGlobals,
						
						// Loop variable
						i,
						
						// uncached part of the url
						uncached,
						
						// Create the final options object
						s = jQuery.ajaxSetup({}, options),
						
						// Callbacks context
						callbackContext = s.context || s,
						
						// Context for global events is callbackContext if it is a DOM node or jQuery collection
						globalEventContext = s.context &&
						(callbackContext.nodeType || callbackContext.jquery) ?
							jQuery(callbackContext) :
							jQuery.event,
						
						// Deferreds
						deferred = jQuery.Deferred(),
						completeDeferred = jQuery.Callbacks("once memory"),
						
						// Status-dependent callbacks
						statusCode = s.statusCode || {},
						
						// Headers (they are sent all at once)
						requestHeaders = {},
						requestHeadersNames = {},
						
						// Default abort message
						strAbort = "canceled",
						
						// Fake xhr
						jqXHR = {
							readyState: 0,
							
							// Builds headers hashtable if needed
							getResponseHeader: function(key) {
								var match;
								if(completed) {
									if(!responseHeaders) {
										responseHeaders = {};
										while((match = rheaders.exec(responseHeadersString))) {
											responseHeaders[match[1].toLowerCase()] = match[2];
										}
									}
									match = responseHeaders[key.toLowerCase()];
								}
								return match == null ? null : match;
							},
							
							// Raw string
							getAllResponseHeaders: function() {
								return completed ? responseHeadersString : null;
							},
							
							// Caches the header
							setRequestHeader: function(name, value) {
								if(completed == null) {
									name = requestHeadersNames[name.toLowerCase()] =
										requestHeadersNames[name.toLowerCase()] || name;
									requestHeaders[name] = value;
								}
								return this;
							},
							
							// Overrides response content-type header
							overrideMimeType: function(type) {
								if(completed == null) {
									s.mimeType = type;
								}
								return this;
							},
							
							// Status-dependent callbacks
							statusCode: function(map) {
								var code;
								if(map) {
									if(completed) {
										
										// Execute the appropriate callbacks
										jqXHR.always(map[jqXHR.status]);
									} else {
										
										// Lazy-add the new callbacks in a way that preserves old ones
										for(code in map) {
											statusCode[code] = [statusCode[code], map[code]];
										}
									}
								}
								return this;
							},
							
							// Cancel the request
							abort: function(statusText) {
								var finalText = statusText || strAbort;
								if(transport) {
									transport.abort(finalText);
								}
								done(0, finalText);
								return this;
							}
						};
					
					// Attach deferreds
					deferred.promise(jqXHR);
					
					// Add protocol if not provided (prefilters might expect it)
					// Handle falsy url in the settings object (#10093: consistency with old signature)
					// We also use the url parameter if available
					s.url = ((url || s.url || location.href) + "")
						.replace(rprotocol, location.protocol + "//");
					
					// Alias method option to type as per ticket #12004
					s.type = options.method || options.type || s.method || s.type;
					
					// Extract dataTypes list
					s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""];
					
					// A cross-domain request is in order when the origin doesn't match the current origin.
					if(s.crossDomain == null) {
						urlAnchor = document.createElement("a");
						
						// Support: IE <=8 - 11, Edge 12 - 15
						// IE throws exception on accessing the href property if url is malformed,
						// e.g. http://example.com:80x/
						try {
							urlAnchor.href = s.url;
							
							// Support: IE <=8 - 11 only
							// Anchor's host property isn't correctly set when s.url is relative
							urlAnchor.href = urlAnchor.href;
							s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
								urlAnchor.protocol + "//" + urlAnchor.host;
						} catch(e) {
							
							// If there is an error parsing the URL, assume it is crossDomain,
							// it can be rejected by the transport if it is invalid
							s.crossDomain = true;
						}
					}
					
					// Convert data if not already a string
					if(s.data && s.processData && typeof s.data !== "string") {
						s.data = jQuery.param(s.data, s.traditional);
					}
					
					// Apply prefilters
					inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
					
					// If request was aborted inside a prefilter, stop there
					if(completed) {
						return jqXHR;
					}
					
					// We can fire global events as of now if asked to
					// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
					fireGlobals = jQuery.event && s.global;
					
					// Watch for a new set of requests
					if(fireGlobals && jQuery.active++ === 0) {
						jQuery.event.trigger("ajaxStart");
					}
					
					// Uppercase the type
					s.type = s.type.toUpperCase();
					
					// Determine if request has content
					s.hasContent = !rnoContent.test(s.type);
					
					// Save the URL in case we're toying with the If-Modified-Since
					// and/or If-None-Match header later on
					// Remove hash to simplify url manipulation
					cacheURL = s.url.replace(rhash, "");
					
					// More options handling for requests with no content
					if(!s.hasContent) {
						
						// Remember the hash so we can put it back
						uncached = s.url.slice(cacheURL.length);
						
						// If data is available and should be processed, append data to url
						if(s.data && (s.processData || typeof s.data === "string")) {
							cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data;
							
							// #9682: remove data so that it's not used in an eventual retry
							delete s.data;
						}
						
						// Add or update anti-cache param if needed
						if(s.cache === false) {
							cacheURL = cacheURL.replace(rantiCache, "$1");
							uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + (nonce++) + uncached;
						}
						
						// Put hash and anti-cache on the URL that will be requested (gh-1732)
						s.url = cacheURL + uncached;
						
						// Change '%20' to '+' if this is encoded form body content (gh-2658)
					} else if(s.data && s.processData &&
						(s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
						s.data = s.data.replace(r20, "+");
					}
					
					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if(s.ifModified) {
						if(jQuery.lastModified[cacheURL]) {
							jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
						}
						if(jQuery.etag[cacheURL]) {
							jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
						}
					}
					
					// Set the correct header, if data is being sent
					if(s.data && s.hasContent && s.contentType !== false || options.contentType) {
						jqXHR.setRequestHeader("Content-Type", s.contentType);
					}
					
					// Set the Accepts header for the server, depending on the dataType
					jqXHR.setRequestHeader(
						"Accept",
						s.dataTypes[0] && s.accepts[s.dataTypes[0]] ?
							s.accepts[s.dataTypes[0]] +
							(s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") :
							s.accepts["*"]
					);
					
					// Check for headers option
					for(i in s.headers) {
						jqXHR.setRequestHeader(i, s.headers[i]);
					}
					
					// Allow custom headers/mimetypes and early abort
					if(s.beforeSend &&
						(s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {
						
						// Abort if not done already and return
						return jqXHR.abort();
					}
					
					// Aborting is no longer a cancellation
					strAbort = "abort";
					
					// Install callbacks on deferreds
					completeDeferred.add(s.complete);
					jqXHR.done(s.success);
					jqXHR.fail(s.error);
					
					// Get transport
					transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
					
					// If no transport, we auto-abort
					if(!transport) {
						done(-1, "No Transport");
					} else {
						jqXHR.readyState = 1;
						
						// Send global event
						if(fireGlobals) {
							globalEventContext.trigger("ajaxSend", [jqXHR, s]);
						}
						
						// If request was aborted inside ajaxSend, stop there
						if(completed) {
							return jqXHR;
						}
						
						// Timeout
						if(s.async && s.timeout > 0) {
							timeoutTimer = window.setTimeout(function() {
								jqXHR.abort("timeout");
							}, s.timeout);
						}
						
						try {
							completed = false;
							transport.send(requestHeaders, done);
						} catch(e) {
							
							// Rethrow post-completion exceptions
							if(completed) {
								throw e;
							}
							
							// Propagate others as results
							done(-1, e);
						}
					}
					
					// Callback for when everything is done
					function done(status, nativeStatusText, responses, headers) {
						var isSuccess, success, error, response, modified,
							statusText = nativeStatusText;
						
						// Ignore repeat invocations
						if(completed) {
							return;
						}
						
						completed = true;
						
						// Clear timeout if it exists
						if(timeoutTimer) {
							window.clearTimeout(timeoutTimer);
						}
						
						// Dereference transport for early garbage collection
						// (no matter how long the jqXHR object will be used)
						transport = undefined;
						
						// Cache response headers
						responseHeadersString = headers || "";
						
						// Set readyState
						jqXHR.readyState = status > 0 ? 4 : 0;
						
						// Determine if successful
						isSuccess = status >= 200 && status < 300 || status === 304;
						
						// Get response data
						if(responses) {
							response = ajaxHandleResponses(s, jqXHR, responses);
						}
						
						// Convert no matter what (that way responseXXX fields are always set)
						response = ajaxConvert(s, response, jqXHR, isSuccess);
						
						// If successful, handle type chaining
						if(isSuccess) {
							
							// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
							if(s.ifModified) {
								modified = jqXHR.getResponseHeader("Last-Modified");
								if(modified) {
									jQuery.lastModified[cacheURL] = modified;
								}
								modified = jqXHR.getResponseHeader("etag");
								if(modified) {
									jQuery.etag[cacheURL] = modified;
								}
							}
							
							// if no content
							if(status === 204 || s.type === "HEAD") {
								statusText = "nocontent";
								
								// if not modified
							} else if(status === 304) {
								statusText = "notmodified";
								
								// If we have data, let's convert it
							} else {
								statusText = response.state;
								success = response.data;
								error = response.error;
								isSuccess = !error;
							}
						} else {
							
							// Extract error from statusText and normalize for non-aborts
							error = statusText;
							if(status || !statusText) {
								statusText = "error";
								if(status < 0) {
									status = 0;
								}
							}
						}
						
						// Set data for the fake xhr object
						jqXHR.status = status;
						jqXHR.statusText = (nativeStatusText || statusText) + "";
						
						// Success/Error
						if(isSuccess) {
							deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
						} else {
							deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
						}
						
						// Status-dependent callbacks
						jqXHR.statusCode(statusCode);
						statusCode = undefined;
						
						if(fireGlobals) {
							globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError",
								[jqXHR, s, isSuccess ? success : error]);
						}
						
						// Complete
						completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
						
						if(fireGlobals) {
							globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
							
							// Handle the global AJAX counter
							if(!(--jQuery.active)) {
								jQuery.event.trigger("ajaxStop");
							}
						}
					}
					
					return jqXHR;
				},
				
				getJSON: function(url, data, callback) {
					return jQuery.get(url, data, callback, "json");
				},
				
				getScript: function(url, callback) {
					return jQuery.get(url, undefined, callback, "script");
				}
			});
			
			jQuery.each(["get", "post"], function(i, method) {
				jQuery[method] = function(url, data, callback, type) {
					
					// Shift arguments if data argument was omitted
					if(isFunction(data)) {
						type = type || callback;
						callback = data;
						data = undefined;
					}
					
					// The url can be an options object (which then must have .url)
					return jQuery.ajax(jQuery.extend({
						url: url,
						type: method,
						dataType: type,
						data: data,
						success: callback
					}, jQuery.isPlainObject(url) && url));
				};
			});
			
			
			jQuery._evalUrl = function(url) {
				return jQuery.ajax({
					url: url,
					
					// Make this explicit, since user can override this through ajaxSetup (#11264)
					type: "GET",
					dataType: "script",
					cache: true,
					async: false,
					global: false,
					"throws": true
				});
			};
			
			
			jQuery.fn.extend({
				wrapAll: function(html) {
					var wrap;
					
					if(this[0]) {
						if(isFunction(html)) {
							html = html.call(this[0]);
						}
						
						// The elements to wrap the target around
						wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
						
						if(this[0].parentNode) {
							wrap.insertBefore(this[0]);
						}
						
						wrap.map(function() {
							var elem = this;
							
							while(elem.firstElementChild) {
								elem = elem.firstElementChild;
							}
							
							return elem;
						}).append(this);
					}
					
					return this;
				},
				
				wrapInner: function(html) {
					if(isFunction(html)) {
						return this.each(function(i) {
							jQuery(this).wrapInner(html.call(this, i));
						});
					}
					
					return this.each(function() {
						var self = jQuery(this),
							contents = self.contents();
						
						if(contents.length) {
							contents.wrapAll(html);
							
						} else {
							self.append(html);
						}
					});
				},
				
				wrap: function(html) {
					var htmlIsFunction = isFunction(html);
					
					return this.each(function(i) {
						jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);
					});
				},
				
				unwrap: function(selector) {
					this.parent(selector).not("body").each(function() {
						jQuery(this).replaceWith(this.childNodes);
					});
					return this;
				}
			});
			
			
			jQuery.expr.pseudos.hidden = function(elem) {
				return !jQuery.expr.pseudos.visible(elem);
			};
			jQuery.expr.pseudos.visible = function(elem) {
				return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
			};
			
			
			jQuery.ajaxSettings.xhr = function() {
				try {
					return new window.XMLHttpRequest();
				} catch(e) {
				}
			};
			
			var xhrSuccessStatus = {
					
					// File protocol always yields status code 0, assume 200
					0: 200,
					
					// Support: IE <=9 only
					// #1450: sometimes IE returns 1223 when it should be 204
					1223: 204
				},
				xhrSupported = jQuery.ajaxSettings.xhr();
			
			support.cors = !!xhrSupported && ("withCredentials" in xhrSupported);
			support.ajax = xhrSupported = !!xhrSupported;
			
			jQuery.ajaxTransport(function(options) {
				var callback, errorCallback;
				
				// Cross domain only allowed if supported through XMLHttpRequest
				if(support.cors || xhrSupported && !options.crossDomain) {
					return {
						send: function(headers, complete) {
							var i,
								xhr = options.xhr();
							
							xhr.open(
								options.type,
								options.url,
								options.async,
								options.username,
								options.password
							);
							
							// Apply custom fields if provided
							if(options.xhrFields) {
								for(i in options.xhrFields) {
									xhr[i] = options.xhrFields[i];
								}
							}
							
							// Override mime type if needed
							if(options.mimeType && xhr.overrideMimeType) {
								xhr.overrideMimeType(options.mimeType);
							}
							
							// X-Requested-With header
							// For cross-domain requests, seeing as conditions for a preflight are
							// akin to a jigsaw puzzle, we simply never set it to be sure.
							// (it can always be set on a per-request basis or even using ajaxSetup)
							// For same-domain requests, won't change header if already provided.
							if(!options.crossDomain && !headers["X-Requested-With"]) {
								headers["X-Requested-With"] = "XMLHttpRequest";
							}
							
							// Set headers
							for(i in headers) {
								xhr.setRequestHeader(i, headers[i]);
							}
							
							// Callback
							callback = function(type) {
								return function() {
									if(callback) {
										callback = errorCallback = xhr.onload =
											xhr.onerror = xhr.onabort = xhr.ontimeout =
												xhr.onreadystatechange = null;
										
										if(type === "abort") {
											xhr.abort();
										} else if(type === "error") {
											
											// Support: IE <=9 only
											// On a manual native abort, IE9 throws
											// errors on any property access that is not readyState
											if(typeof xhr.status !== "number") {
												complete(0, "error");
											} else {
												complete(
													// File: protocol always yields status 0; see #8605, #14207
													xhr.status,
													xhr.statusText
												);
											}
										} else {
											complete(
												xhrSuccessStatus[xhr.status] || xhr.status,
												xhr.statusText,
												
												// Support: IE <=9 only
												// IE9 has no XHR2 but throws on binary (trac-11426)
												// For XHR2 non-text, let the caller handle it (gh-2498)
												(xhr.responseType || "text") !== "text" ||
												typeof xhr.responseText !== "string" ?
													{binary: xhr.response} :
													{text: xhr.responseText},
												xhr.getAllResponseHeaders()
											);
										}
									}
								};
							};
							
							// Listen to events
							xhr.onload = callback();
							errorCallback = xhr.onerror = xhr.ontimeout = callback("error");
							
							// Support: IE 9 only
							// Use onreadystatechange to replace onabort
							// to handle uncaught aborts
							if(xhr.onabort !== undefined) {
								xhr.onabort = errorCallback;
							} else {
								xhr.onreadystatechange = function() {
									
									// Check readyState before timeout as it changes
									if(xhr.readyState === 4) {
										
										// Allow onerror to be called first,
										// but that will not handle a native abort
										// Also, save errorCallback to a variable
										// as xhr.onerror cannot be accessed
										window.setTimeout(function() {
											if(callback) {
												errorCallback();
											}
										});
									}
								};
							}
							
							// Create the abort callback
							callback = callback("abort");
							
							try {
								
								// Do send the request (this may raise an exception)
								xhr.send(options.hasContent && options.data || null);
							} catch(e) {
								
								// #14683: Only rethrow if this hasn't been notified as an error yet
								if(callback) {
									throw e;
								}
							}
						},
						
						abort: function() {
							if(callback) {
								callback();
							}
						}
					};
				}
			});


// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
			jQuery.ajaxPrefilter(function(s) {
				if(s.crossDomain) {
					s.contents.script = false;
				}
			});

// Install script dataType
			jQuery.ajaxSetup({
				accepts: {
					script: "text/javascript, application/javascript, " +
						"application/ecmascript, application/x-ecmascript"
				},
				contents: {
					script: /\b(?:java|ecma)script\b/
				},
				converters: {
					"text script": function(text) {
						jQuery.globalEval(text);
						return text;
					}
				}
			});

// Handle cache's special case and crossDomain
			jQuery.ajaxPrefilter("script", function(s) {
				if(s.cache === undefined) {
					s.cache = false;
				}
				if(s.crossDomain) {
					s.type = "GET";
				}
			});

// Bind script tag hack transport
			jQuery.ajaxTransport("script", function(s) {
				
				// This transport only deals with cross domain requests
				if(s.crossDomain) {
					var script, callback;
					return {
						send: function(_, complete) {
							script = jQuery("<script>").prop({
								charset: s.scriptCharset,
								src: s.url
							}).on(
								"load error",
								callback = function(evt) {
									script.remove();
									callback = null;
									if(evt) {
										complete(evt.type === "error" ? 404 : 200, evt.type);
									}
								}
							);
							
							// Use native DOM manipulation to avoid our domManip AJAX trickery
							document.head.appendChild(script[0]);
						},
						abort: function() {
							if(callback) {
								callback();
							}
						}
					};
				}
			});
			
			
			var oldCallbacks = [],
				rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
			jQuery.ajaxSetup({
				jsonp: "callback",
				jsonpCallback: function() {
					var callback = oldCallbacks.pop() || (jQuery.expando + "_" + (nonce++));
					this[callback] = true;
					return callback;
				}
			});

// Detect, normalize options and install callbacks for jsonp requests
			jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
				
				var callbackName, overwritten, responseContainer,
					jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ?
							"url" :
							typeof s.data === "string" &&
							(s.contentType || "")
								.indexOf("application/x-www-form-urlencoded") === 0 &&
							rjsonp.test(s.data) && "data"
					);
				
				// Handle iff the expected data type is "jsonp" or we have a parameter to set
				if(jsonProp || s.dataTypes[0] === "jsonp") {
					
					// Get callback name, remembering preexisting value associated with it
					callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ?
						s.jsonpCallback() :
						s.jsonpCallback;
					
					// Insert callback into url or form data
					if(jsonProp) {
						s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
					} else if(s.jsonp !== false) {
						s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
					}
					
					// Use data converter to retrieve json after script execution
					s.converters["script json"] = function() {
						if(!responseContainer) {
							jQuery.error(callbackName + " was not called");
						}
						return responseContainer[0];
					};
					
					// Force json dataType
					s.dataTypes[0] = "json";
					
					// Install callback
					overwritten = window[callbackName];
					window[callbackName] = function() {
						responseContainer = arguments;
					};
					
					// Clean-up function (fires after converters)
					jqXHR.always(function() {
						
						// If previous value didn't exist - remove it
						if(overwritten === undefined) {
							jQuery(window).removeProp(callbackName);
							
							// Otherwise restore preexisting value
						} else {
							window[callbackName] = overwritten;
						}
						
						// Save back as free
						if(s[callbackName]) {
							
							// Make sure that re-using the options doesn't screw things around
							s.jsonpCallback = originalSettings.jsonpCallback;
							
							// Save the callback name for future use
							oldCallbacks.push(callbackName);
						}
						
						// Call if it was a function and we have a response
						if(responseContainer && isFunction(overwritten)) {
							overwritten(responseContainer[0]);
						}
						
						responseContainer = overwritten = undefined;
					});
					
					// Delegate to script
					return "script";
				}
			});


// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
			support.createHTMLDocument = (function() {
				var body = document.implementation.createHTMLDocument("").body;
				body.innerHTML = "<form></form><form></form>";
				return body.childNodes.length === 2;
			})();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
			jQuery.parseHTML = function(data, context, keepScripts) {
				if(typeof data !== "string") {
					return [];
				}
				if(typeof context === "boolean") {
					keepScripts = context;
					context = false;
				}
				
				var base, parsed, scripts;
				
				if(!context) {
					
					// Stop scripts or inline event handlers from being executed immediately
					// by using document.implementation
					if(support.createHTMLDocument) {
						context = document.implementation.createHTMLDocument("");
						
						// Set the base href for the created document
						// so any parsed elements with URLs
						// are based on the document's URL (gh-2965)
						base = context.createElement("base");
						base.href = document.location.href;
						context.head.appendChild(base);
					} else {
						context = document;
					}
				}
				
				parsed = rsingleTag.exec(data);
				scripts = !keepScripts && [];
				
				// Single tag
				if(parsed) {
					return [context.createElement(parsed[1])];
				}
				
				parsed = buildFragment([data], context, scripts);
				
				if(scripts && scripts.length) {
					jQuery(scripts).remove();
				}
				
				return jQuery.merge([], parsed.childNodes);
			};
			
			
			/**
			 * Load a url into a page
			 */
			jQuery.fn.load = function(url, params, callback) {
				var selector, type, response,
					self = this,
					off = url.indexOf(" ");
				
				if(off > -1) {
					selector = stripAndCollapse(url.slice(off));
					url = url.slice(0, off);
				}
				
				// If it's a function
				if(isFunction(params)) {
					
					// We assume that it's the callback
					callback = params;
					params = undefined;
					
					// Otherwise, build a param string
				} else if(params && typeof params === "object") {
					type = "POST";
				}
				
				// If we have elements to modify, make the request
				if(self.length > 0) {
					jQuery.ajax({
						url: url,
						
						// If "type" variable is undefined, then "GET" method will be used.
						// Make value of this field explicit since
						// user can override it through ajaxSetup method
						type: type || "GET",
						dataType: "html",
						data: params
					}).done(function(responseText) {
						
						// Save response for use in complete callback
						response = arguments;
						
						self.html(selector ?
							
							// If a selector was specified, locate the right elements in a dummy div
							// Exclude scripts to avoid IE 'Permission Denied' errors
							jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) :
							
							// Otherwise use the full result
							responseText);
						
						// If the request succeeds, this function gets "data", "status", "jqXHR"
						// but they are ignored because response was set above.
						// If it fails, this function gets "jqXHR", "status", "error"
					}).always(callback && function(jqXHR, status) {
						self.each(function() {
							callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
						});
					});
				}
				
				return this;
			};


// Attach a bunch of functions for handling common AJAX events
			jQuery.each([
				"ajaxStart",
				"ajaxStop",
				"ajaxComplete",
				"ajaxError",
				"ajaxSuccess",
				"ajaxSend"
			], function(i, type) {
				jQuery.fn[type] = function(fn) {
					return this.on(type, fn);
				};
			});
			
			
			jQuery.expr.pseudos.animated = function(elem) {
				return jQuery.grep(jQuery.timers, function(fn) {
					return elem === fn.elem;
				}).length;
			};
			
			
			jQuery.offset = {
				setOffset: function(elem, options, i) {
					var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
						position = jQuery.css(elem, "position"),
						curElem = jQuery(elem),
						props = {};
					
					// Set position first, in-case top/left are set even on static elem
					if(position === "static") {
						elem.style.position = "relative";
					}
					
					curOffset = curElem.offset();
					curCSSTop = jQuery.css(elem, "top");
					curCSSLeft = jQuery.css(elem, "left");
					calculatePosition = (position === "absolute" || position === "fixed") &&
						(curCSSTop + curCSSLeft).indexOf("auto") > -1;
					
					// Need to be able to calculate position if either
					// top or left is auto and position is either absolute or fixed
					if(calculatePosition) {
						curPosition = curElem.position();
						curTop = curPosition.top;
						curLeft = curPosition.left;
						
					} else {
						curTop = parseFloat(curCSSTop) || 0;
						curLeft = parseFloat(curCSSLeft) || 0;
					}
					
					if(isFunction(options)) {
						
						// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
						options = options.call(elem, i, jQuery.extend({}, curOffset));
					}
					
					if(options.top != null) {
						props.top = (options.top - curOffset.top) + curTop;
					}
					if(options.left != null) {
						props.left = (options.left - curOffset.left) + curLeft;
					}
					
					if("using" in options) {
						options.using.call(elem, props);
						
					} else {
						curElem.css(props);
					}
				}
			};
			
			jQuery.fn.extend({
				
				// offset() relates an element's border box to the document origin
				offset: function(options) {
					
					// Preserve chaining for setter
					if(arguments.length) {
						return options === undefined ?
							this :
							this.each(function(i) {
								jQuery.offset.setOffset(this, options, i);
							});
					}
					
					var rect, win,
						elem = this[0];
					
					if(!elem) {
						return;
					}
					
					// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
					// Support: IE <=11 only
					// Running getBoundingClientRect on a
					// disconnected node in IE throws an error
					if(!elem.getClientRects().length) {
						return {top: 0, left: 0};
					}
					
					// Get document-relative position by adding viewport scroll to viewport-relative gBCR
					rect = elem.getBoundingClientRect();
					win = elem.ownerDocument.defaultView;
					return {
						top: rect.top + win.pageYOffset,
						left: rect.left + win.pageXOffset
					};
				},
				
				// position() relates an element's margin box to its offset parent's padding box
				// This corresponds to the behavior of CSS absolute positioning
				position: function() {
					if(!this[0]) {
						return;
					}
					
					var offsetParent, offset, doc,
						elem = this[0],
						parentOffset = {top: 0, left: 0};
					
					// position:fixed elements are offset from the viewport, which itself always has zero offset
					if(jQuery.css(elem, "position") === "fixed") {
						
						// Assume position:fixed implies availability of getBoundingClientRect
						offset = elem.getBoundingClientRect();
						
					} else {
						offset = this.offset();
						
						// Account for the *real* offset parent, which can be the document or its root element
						// when a statically positioned element is identified
						doc = elem.ownerDocument;
						offsetParent = elem.offsetParent || doc.documentElement;
						while(offsetParent &&
						(offsetParent === doc.body || offsetParent === doc.documentElement) &&
						jQuery.css(offsetParent, "position") === "static") {
							
							offsetParent = offsetParent.parentNode;
						}
						if(offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
							
							// Incorporate borders into its offset, since they are outside its content origin
							parentOffset = jQuery(offsetParent).offset();
							parentOffset.top += jQuery.css(offsetParent, "borderTopWidth", true);
							parentOffset.left += jQuery.css(offsetParent, "borderLeftWidth", true);
						}
					}
					
					// Subtract parent offsets and element margins
					return {
						top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
						left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
					};
				},
				
				// This method will return documentElement in the following cases:
				// 1) For the element inside the iframe without offsetParent, this method will return
				//    documentElement of the parent window
				// 2) For the hidden or detached element
				// 3) For body or html element, i.e. in case of the html node - it will return itself
				//
				// but those exceptions were never presented as a real life use-cases
				// and might be considered as more preferable results.
				//
				// This logic, however, is not guaranteed and can change at any point in the future
				offsetParent: function() {
					return this.map(function() {
						var offsetParent = this.offsetParent;
						
						while(offsetParent && jQuery.css(offsetParent, "position") === "static") {
							offsetParent = offsetParent.offsetParent;
						}
						
						return offsetParent || documentElement;
					});
				}
			});

// Create scrollLeft and scrollTop methods
			jQuery.each({scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, function(method, prop) {
				var top = "pageYOffset" === prop;
				
				jQuery.fn[method] = function(val) {
					return access(this, function(elem, method, val) {
						
						// Coalesce documents and windows
						var win;
						if(isWindow(elem)) {
							win = elem;
						} else if(elem.nodeType === 9) {
							win = elem.defaultView;
						}
						
						if(val === undefined) {
							return win ? win[prop] : elem[method];
						}
						
						if(win) {
							win.scrollTo(
								!top ? val : win.pageXOffset,
								top ? val : win.pageYOffset
							);
							
						} else {
							elem[method] = val;
						}
					}, method, val, arguments.length);
				};
			});

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
			jQuery.each(["top", "left"], function(i, prop) {
				jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition,
					function(elem, computed) {
						if(computed) {
							computed = curCSS(elem, prop);
							
							// If curCSS returns percentage, fallback to offset
							return rnumnonpx.test(computed) ?
								jQuery(elem).position()[prop] + "px" :
								computed;
						}
					}
				);
			});


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
			jQuery.each({Height: "height", Width: "width"}, function(name, type) {
				jQuery.each({padding: "inner" + name, content: type, "": "outer" + name},
					function(defaultExtra, funcName) {
						
						// Margin is only for outerHeight, outerWidth
						jQuery.fn[funcName] = function(margin, value) {
							var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
								extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
							
							return access(this, function(elem, type, value) {
								var doc;
								
								if(isWindow(elem)) {
									
									// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
									return funcName.indexOf("outer") === 0 ?
										elem["inner" + name] :
										elem.document.documentElement["client" + name];
								}
								
								// Get document width or height
								if(elem.nodeType === 9) {
									doc = elem.documentElement;
									
									// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
									// whichever is greatest
									return Math.max(
										elem.body["scroll" + name], doc["scroll" + name],
										elem.body["offset" + name], doc["offset" + name],
										doc["client" + name]
									);
								}
								
								return value === undefined ?
									
									// Get width or height on the element, requesting but not forcing parseFloat
									jQuery.css(elem, type, extra) :
									
									// Set width or height on the element
									jQuery.style(elem, type, value, extra);
							}, type, chainable ? margin : undefined, chainable);
						};
					});
			});
			
			
			jQuery.each(("blur focus focusin focusout resize scroll click dblclick " +
				"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
				"change select submit keydown keypress keyup contextmenu").split(" "),
				function(i, name) {
					
					// Handle event binding
					jQuery.fn[name] = function(data, fn) {
						return arguments.length > 0 ?
							this.on(name, null, data, fn) :
							this.trigger(name);
					};
				});
			
			jQuery.fn.extend({
				hover: function(fnOver, fnOut) {
					return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
				}
			});
			
			
			jQuery.fn.extend({
				
				bind: function(types, data, fn) {
					return this.on(types, null, data, fn);
				},
				unbind: function(types, fn) {
					return this.off(types, null, fn);
				},
				
				delegate: function(selector, types, data, fn) {
					return this.on(types, selector, data, fn);
				},
				undelegate: function(selector, types, fn) {
					
					// ( namespace ) or ( selector, types [, fn] )
					return arguments.length === 1 ?
						this.off(selector, "**") :
						this.off(types, selector || "**", fn);
				}
			});

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
			jQuery.proxy = function(fn, context) {
				var tmp, args, proxy;
				
				if(typeof context === "string") {
					tmp = fn[context];
					context = fn;
					fn = tmp;
				}
				
				// Quick check to determine if target is callable, in the spec
				// this throws a TypeError, but we will just return undefined.
				if(!isFunction(fn)) {
					return undefined;
				}
				
				// Simulated bind
				args = slice.call(arguments, 2);
				proxy = function() {
					return fn.apply(context || this, args.concat(slice.call(arguments)));
				};
				
				// Set the guid of unique handler to the same of original handler, so it can be removed
				proxy.guid = fn.guid = fn.guid || jQuery.guid++;
				
				return proxy;
			};
			
			jQuery.holdReady = function(hold) {
				if(hold) {
					jQuery.readyWait++;
				} else {
					jQuery.ready(true);
				}
			};
			jQuery.isArray = Array.isArray;
			jQuery.parseJSON = JSON.parse;
			jQuery.nodeName = nodeName;
			jQuery.isFunction = isFunction;
			jQuery.isWindow = isWindow;
			jQuery.camelCase = camelCase;
			jQuery.type = toType;
			
			jQuery.now = Date.now;
			
			jQuery.isNumeric = function(obj) {
				
				// As of jQuery 3.0, isNumeric is limited to
				// strings and numbers (primitives or objects)
				// that can be coerced to finite numbers (gh-2662)
				var type = jQuery.type(obj);
				return (type === "number" || type === "string") &&
					
					// parseFloat NaNs numeric-cast false positives ("")
					// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
					// subtraction forces infinities to NaN
					!isNaN(obj - parseFloat(obj));
			};


// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon
			
			if(true) {
				!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
					return jQuery;
				}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
			}
			
			
			var
				
				// Map over jQuery in case of overwrite
				_jQuery = window.jQuery,
				
				// Map over the $ in case of overwrite
				_$ = window.$;
			
			jQuery.noConflict = function(deep) {
				if(window.$ === jQuery) {
					window.$ = _$;
				}
				
				if(deep && window.jQuery === jQuery) {
					window.jQuery = _jQuery;
				}
				
				return jQuery;
			};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
			if(!noGlobal) {
				window.jQuery = window.$ = jQuery;
			}
			
			
			return jQuery;
		});
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale sync recursive ^\\.\\/.*$":
	/*!**************************************************!*\
  !*** ./node_modules/moment/locale sync ^\.\/.*$ ***!
  \**************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		var map = {
			"./af": "./node_modules/moment/locale/af.js",
			"./af.js": "./node_modules/moment/locale/af.js",
			"./ar": "./node_modules/moment/locale/ar.js",
			"./ar-dz": "./node_modules/moment/locale/ar-dz.js",
			"./ar-dz.js": "./node_modules/moment/locale/ar-dz.js",
			"./ar-kw": "./node_modules/moment/locale/ar-kw.js",
			"./ar-kw.js": "./node_modules/moment/locale/ar-kw.js",
			"./ar-ly": "./node_modules/moment/locale/ar-ly.js",
			"./ar-ly.js": "./node_modules/moment/locale/ar-ly.js",
			"./ar-ma": "./node_modules/moment/locale/ar-ma.js",
			"./ar-ma.js": "./node_modules/moment/locale/ar-ma.js",
			"./ar-sa": "./node_modules/moment/locale/ar-sa.js",
			"./ar-sa.js": "./node_modules/moment/locale/ar-sa.js",
			"./ar-tn": "./node_modules/moment/locale/ar-tn.js",
			"./ar-tn.js": "./node_modules/moment/locale/ar-tn.js",
			"./ar.js": "./node_modules/moment/locale/ar.js",
			"./az": "./node_modules/moment/locale/az.js",
			"./az.js": "./node_modules/moment/locale/az.js",
			"./be": "./node_modules/moment/locale/be.js",
			"./be.js": "./node_modules/moment/locale/be.js",
			"./bg": "./node_modules/moment/locale/bg.js",
			"./bg.js": "./node_modules/moment/locale/bg.js",
			"./bm": "./node_modules/moment/locale/bm.js",
			"./bm.js": "./node_modules/moment/locale/bm.js",
			"./bn": "./node_modules/moment/locale/bn.js",
			"./bn.js": "./node_modules/moment/locale/bn.js",
			"./bo": "./node_modules/moment/locale/bo.js",
			"./bo.js": "./node_modules/moment/locale/bo.js",
			"./br": "./node_modules/moment/locale/br.js",
			"./br.js": "./node_modules/moment/locale/br.js",
			"./bs": "./node_modules/moment/locale/bs.js",
			"./bs.js": "./node_modules/moment/locale/bs.js",
			"./ca": "./node_modules/moment/locale/ca.js",
			"./ca.js": "./node_modules/moment/locale/ca.js",
			"./cs": "./node_modules/moment/locale/cs.js",
			"./cs.js": "./node_modules/moment/locale/cs.js",
			"./cv": "./node_modules/moment/locale/cv.js",
			"./cv.js": "./node_modules/moment/locale/cv.js",
			"./cy": "./node_modules/moment/locale/cy.js",
			"./cy.js": "./node_modules/moment/locale/cy.js",
			"./da": "./node_modules/moment/locale/da.js",
			"./da.js": "./node_modules/moment/locale/da.js",
			"./de": "./node_modules/moment/locale/de.js",
			"./de-at": "./node_modules/moment/locale/de-at.js",
			"./de-at.js": "./node_modules/moment/locale/de-at.js",
			"./de-ch": "./node_modules/moment/locale/de-ch.js",
			"./de-ch.js": "./node_modules/moment/locale/de-ch.js",
			"./de.js": "./node_modules/moment/locale/de.js",
			"./dv": "./node_modules/moment/locale/dv.js",
			"./dv.js": "./node_modules/moment/locale/dv.js",
			"./el": "./node_modules/moment/locale/el.js",
			"./el.js": "./node_modules/moment/locale/el.js",
			"./en-SG": "./node_modules/moment/locale/en-SG.js",
			"./en-SG.js": "./node_modules/moment/locale/en-SG.js",
			"./en-au": "./node_modules/moment/locale/en-au.js",
			"./en-au.js": "./node_modules/moment/locale/en-au.js",
			"./en-ca": "./node_modules/moment/locale/en-ca.js",
			"./en-ca.js": "./node_modules/moment/locale/en-ca.js",
			"./en-gb": "./node_modules/moment/locale/en-gb.js",
			"./en-gb.js": "./node_modules/moment/locale/en-gb.js",
			"./en-ie": "./node_modules/moment/locale/en-ie.js",
			"./en-ie.js": "./node_modules/moment/locale/en-ie.js",
			"./en-il": "./node_modules/moment/locale/en-il.js",
			"./en-il.js": "./node_modules/moment/locale/en-il.js",
			"./en-nz": "./node_modules/moment/locale/en-nz.js",
			"./en-nz.js": "./node_modules/moment/locale/en-nz.js",
			"./eo": "./node_modules/moment/locale/eo.js",
			"./eo.js": "./node_modules/moment/locale/eo.js",
			"./es": "./node_modules/moment/locale/es.js",
			"./es-do": "./node_modules/moment/locale/es-do.js",
			"./es-do.js": "./node_modules/moment/locale/es-do.js",
			"./es-us": "./node_modules/moment/locale/es-us.js",
			"./es-us.js": "./node_modules/moment/locale/es-us.js",
			"./es.js": "./node_modules/moment/locale/es.js",
			"./et": "./node_modules/moment/locale/et.js",
			"./et.js": "./node_modules/moment/locale/et.js",
			"./eu": "./node_modules/moment/locale/eu.js",
			"./eu.js": "./node_modules/moment/locale/eu.js",
			"./fa": "./node_modules/moment/locale/fa.js",
			"./fa.js": "./node_modules/moment/locale/fa.js",
			"./fi": "./node_modules/moment/locale/fi.js",
			"./fi.js": "./node_modules/moment/locale/fi.js",
			"./fo": "./node_modules/moment/locale/fo.js",
			"./fo.js": "./node_modules/moment/locale/fo.js",
			"./fr": "./node_modules/moment/locale/fr.js",
			"./fr-ca": "./node_modules/moment/locale/fr-ca.js",
			"./fr-ca.js": "./node_modules/moment/locale/fr-ca.js",
			"./fr-ch": "./node_modules/moment/locale/fr-ch.js",
			"./fr-ch.js": "./node_modules/moment/locale/fr-ch.js",
			"./fr.js": "./node_modules/moment/locale/fr.js",
			"./fy": "./node_modules/moment/locale/fy.js",
			"./fy.js": "./node_modules/moment/locale/fy.js",
			"./ga": "./node_modules/moment/locale/ga.js",
			"./ga.js": "./node_modules/moment/locale/ga.js",
			"./gd": "./node_modules/moment/locale/gd.js",
			"./gd.js": "./node_modules/moment/locale/gd.js",
			"./gl": "./node_modules/moment/locale/gl.js",
			"./gl.js": "./node_modules/moment/locale/gl.js",
			"./gom-latn": "./node_modules/moment/locale/gom-latn.js",
			"./gom-latn.js": "./node_modules/moment/locale/gom-latn.js",
			"./gu": "./node_modules/moment/locale/gu.js",
			"./gu.js": "./node_modules/moment/locale/gu.js",
			"./he": "./node_modules/moment/locale/he.js",
			"./he.js": "./node_modules/moment/locale/he.js",
			"./hi": "./node_modules/moment/locale/hi.js",
			"./hi.js": "./node_modules/moment/locale/hi.js",
			"./hr": "./node_modules/moment/locale/hr.js",
			"./hr.js": "./node_modules/moment/locale/hr.js",
			"./hu": "./node_modules/moment/locale/hu.js",
			"./hu.js": "./node_modules/moment/locale/hu.js",
			"./hy-am": "./node_modules/moment/locale/hy-am.js",
			"./hy-am.js": "./node_modules/moment/locale/hy-am.js",
			"./id": "./node_modules/moment/locale/id.js",
			"./id.js": "./node_modules/moment/locale/id.js",
			"./is": "./node_modules/moment/locale/is.js",
			"./is.js": "./node_modules/moment/locale/is.js",
			"./it": "./node_modules/moment/locale/it.js",
			"./it-ch": "./node_modules/moment/locale/it-ch.js",
			"./it-ch.js": "./node_modules/moment/locale/it-ch.js",
			"./it.js": "./node_modules/moment/locale/it.js",
			"./ja": "./node_modules/moment/locale/ja.js",
			"./ja.js": "./node_modules/moment/locale/ja.js",
			"./jv": "./node_modules/moment/locale/jv.js",
			"./jv.js": "./node_modules/moment/locale/jv.js",
			"./ka": "./node_modules/moment/locale/ka.js",
			"./ka.js": "./node_modules/moment/locale/ka.js",
			"./kk": "./node_modules/moment/locale/kk.js",
			"./kk.js": "./node_modules/moment/locale/kk.js",
			"./km": "./node_modules/moment/locale/km.js",
			"./km.js": "./node_modules/moment/locale/km.js",
			"./kn": "./node_modules/moment/locale/kn.js",
			"./kn.js": "./node_modules/moment/locale/kn.js",
			"./ko": "./node_modules/moment/locale/ko.js",
			"./ko.js": "./node_modules/moment/locale/ko.js",
			"./ku": "./node_modules/moment/locale/ku.js",
			"./ku.js": "./node_modules/moment/locale/ku.js",
			"./ky": "./node_modules/moment/locale/ky.js",
			"./ky.js": "./node_modules/moment/locale/ky.js",
			"./lb": "./node_modules/moment/locale/lb.js",
			"./lb.js": "./node_modules/moment/locale/lb.js",
			"./lo": "./node_modules/moment/locale/lo.js",
			"./lo.js": "./node_modules/moment/locale/lo.js",
			"./lt": "./node_modules/moment/locale/lt.js",
			"./lt.js": "./node_modules/moment/locale/lt.js",
			"./lv": "./node_modules/moment/locale/lv.js",
			"./lv.js": "./node_modules/moment/locale/lv.js",
			"./me": "./node_modules/moment/locale/me.js",
			"./me.js": "./node_modules/moment/locale/me.js",
			"./mi": "./node_modules/moment/locale/mi.js",
			"./mi.js": "./node_modules/moment/locale/mi.js",
			"./mk": "./node_modules/moment/locale/mk.js",
			"./mk.js": "./node_modules/moment/locale/mk.js",
			"./ml": "./node_modules/moment/locale/ml.js",
			"./ml.js": "./node_modules/moment/locale/ml.js",
			"./mn": "./node_modules/moment/locale/mn.js",
			"./mn.js": "./node_modules/moment/locale/mn.js",
			"./mr": "./node_modules/moment/locale/mr.js",
			"./mr.js": "./node_modules/moment/locale/mr.js",
			"./ms": "./node_modules/moment/locale/ms.js",
			"./ms-my": "./node_modules/moment/locale/ms-my.js",
			"./ms-my.js": "./node_modules/moment/locale/ms-my.js",
			"./ms.js": "./node_modules/moment/locale/ms.js",
			"./mt": "./node_modules/moment/locale/mt.js",
			"./mt.js": "./node_modules/moment/locale/mt.js",
			"./my": "./node_modules/moment/locale/my.js",
			"./my.js": "./node_modules/moment/locale/my.js",
			"./nb": "./node_modules/moment/locale/nb.js",
			"./nb.js": "./node_modules/moment/locale/nb.js",
			"./ne": "./node_modules/moment/locale/ne.js",
			"./ne.js": "./node_modules/moment/locale/ne.js",
			"./nl": "./node_modules/moment/locale/nl.js",
			"./nl-be": "./node_modules/moment/locale/nl-be.js",
			"./nl-be.js": "./node_modules/moment/locale/nl-be.js",
			"./nl.js": "./node_modules/moment/locale/nl.js",
			"./nn": "./node_modules/moment/locale/nn.js",
			"./nn.js": "./node_modules/moment/locale/nn.js",
			"./pa-in": "./node_modules/moment/locale/pa-in.js",
			"./pa-in.js": "./node_modules/moment/locale/pa-in.js",
			"./pl": "./node_modules/moment/locale/pl.js",
			"./pl.js": "./node_modules/moment/locale/pl.js",
			"./pt": "./node_modules/moment/locale/pt.js",
			"./pt-br": "./node_modules/moment/locale/pt-br.js",
			"./pt-br.js": "./node_modules/moment/locale/pt-br.js",
			"./pt.js": "./node_modules/moment/locale/pt.js",
			"./ro": "./node_modules/moment/locale/ro.js",
			"./ro.js": "./node_modules/moment/locale/ro.js",
			"./ru": "./node_modules/moment/locale/ru.js",
			"./ru.js": "./node_modules/moment/locale/ru.js",
			"./sd": "./node_modules/moment/locale/sd.js",
			"./sd.js": "./node_modules/moment/locale/sd.js",
			"./se": "./node_modules/moment/locale/se.js",
			"./se.js": "./node_modules/moment/locale/se.js",
			"./si": "./node_modules/moment/locale/si.js",
			"./si.js": "./node_modules/moment/locale/si.js",
			"./sk": "./node_modules/moment/locale/sk.js",
			"./sk.js": "./node_modules/moment/locale/sk.js",
			"./sl": "./node_modules/moment/locale/sl.js",
			"./sl.js": "./node_modules/moment/locale/sl.js",
			"./sq": "./node_modules/moment/locale/sq.js",
			"./sq.js": "./node_modules/moment/locale/sq.js",
			"./sr": "./node_modules/moment/locale/sr.js",
			"./sr-cyrl": "./node_modules/moment/locale/sr-cyrl.js",
			"./sr-cyrl.js": "./node_modules/moment/locale/sr-cyrl.js",
			"./sr.js": "./node_modules/moment/locale/sr.js",
			"./ss": "./node_modules/moment/locale/ss.js",
			"./ss.js": "./node_modules/moment/locale/ss.js",
			"./sv": "./node_modules/moment/locale/sv.js",
			"./sv.js": "./node_modules/moment/locale/sv.js",
			"./sw": "./node_modules/moment/locale/sw.js",
			"./sw.js": "./node_modules/moment/locale/sw.js",
			"./ta": "./node_modules/moment/locale/ta.js",
			"./ta.js": "./node_modules/moment/locale/ta.js",
			"./te": "./node_modules/moment/locale/te.js",
			"./te.js": "./node_modules/moment/locale/te.js",
			"./tet": "./node_modules/moment/locale/tet.js",
			"./tet.js": "./node_modules/moment/locale/tet.js",
			"./tg": "./node_modules/moment/locale/tg.js",
			"./tg.js": "./node_modules/moment/locale/tg.js",
			"./th": "./node_modules/moment/locale/th.js",
			"./th.js": "./node_modules/moment/locale/th.js",
			"./tl-ph": "./node_modules/moment/locale/tl-ph.js",
			"./tl-ph.js": "./node_modules/moment/locale/tl-ph.js",
			"./tlh": "./node_modules/moment/locale/tlh.js",
			"./tlh.js": "./node_modules/moment/locale/tlh.js",
			"./tr": "./node_modules/moment/locale/tr.js",
			"./tr.js": "./node_modules/moment/locale/tr.js",
			"./tzl": "./node_modules/moment/locale/tzl.js",
			"./tzl.js": "./node_modules/moment/locale/tzl.js",
			"./tzm": "./node_modules/moment/locale/tzm.js",
			"./tzm-latn": "./node_modules/moment/locale/tzm-latn.js",
			"./tzm-latn.js": "./node_modules/moment/locale/tzm-latn.js",
			"./tzm.js": "./node_modules/moment/locale/tzm.js",
			"./ug-cn": "./node_modules/moment/locale/ug-cn.js",
			"./ug-cn.js": "./node_modules/moment/locale/ug-cn.js",
			"./uk": "./node_modules/moment/locale/uk.js",
			"./uk.js": "./node_modules/moment/locale/uk.js",
			"./ur": "./node_modules/moment/locale/ur.js",
			"./ur.js": "./node_modules/moment/locale/ur.js",
			"./uz": "./node_modules/moment/locale/uz.js",
			"./uz-latn": "./node_modules/moment/locale/uz-latn.js",
			"./uz-latn.js": "./node_modules/moment/locale/uz-latn.js",
			"./uz.js": "./node_modules/moment/locale/uz.js",
			"./vi": "./node_modules/moment/locale/vi.js",
			"./vi.js": "./node_modules/moment/locale/vi.js",
			"./x-pseudo": "./node_modules/moment/locale/x-pseudo.js",
			"./x-pseudo.js": "./node_modules/moment/locale/x-pseudo.js",
			"./yo": "./node_modules/moment/locale/yo.js",
			"./yo.js": "./node_modules/moment/locale/yo.js",
			"./zh-cn": "./node_modules/moment/locale/zh-cn.js",
			"./zh-cn.js": "./node_modules/moment/locale/zh-cn.js",
			"./zh-hk": "./node_modules/moment/locale/zh-hk.js",
			"./zh-hk.js": "./node_modules/moment/locale/zh-hk.js",
			"./zh-tw": "./node_modules/moment/locale/zh-tw.js",
			"./zh-tw.js": "./node_modules/moment/locale/zh-tw.js"
		};
		
		
		function webpackContext(req) {
			var id = webpackContextResolve(req);
			return __webpack_require__(id);
		}
		
		function webpackContextResolve(req) {
			var id = map[req];
			if(!(id + 1)) { // check for number or string
				var e = new Error("Cannot find module '" + req + "'");
				e.code = 'MODULE_NOT_FOUND';
				throw e;
			}
			return id;
		}
		
		webpackContext.keys = function webpackContextKeys() {
			return Object.keys(map);
		};
		webpackContext.resolve = webpackContextResolve;
		module.exports = webpackContext;
		webpackContext.id = "./node_modules/moment/locale sync recursive ^\\.\\/.*$";
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/af.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/af.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var af = moment.defineLocale('af', {
				months: 'Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember'.split('_'),
				monthsShort: 'Jan_Feb_Mrt_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des'.split('_'),
				weekdays: 'Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag'.split('_'),
				weekdaysShort: 'Son_Maa_Din_Woe_Don_Vry_Sat'.split('_'),
				weekdaysMin: 'So_Ma_Di_Wo_Do_Vr_Sa'.split('_'),
				meridiemParse: /vm|nm/i,
				isPM: function(input) {
					return /^nm$/i.test(input);
				},
				meridiem: function(hours, minutes, isLower) {
					if(hours < 12) {
						return isLower ? 'vm' : 'VM';
					} else {
						return isLower ? 'nm' : 'NM';
					}
				},
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY HH:mm',
					LLLL: 'dddd, D MMMM YYYY HH:mm'
				},
				calendar: {
					sameDay: '[Vandag om] LT',
					nextDay: '[Mre om] LT',
					nextWeek: 'dddd [om] LT',
					lastDay: '[Gister om] LT',
					lastWeek: '[Laas] dddd [om] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: 'oor %s',
					past: '%s gelede',
					s: '\'n paar sekondes',
					ss: '%d sekondes',
					m: '\'n minuut',
					mm: '%d minute',
					h: '\'n uur',
					hh: '%d ure',
					d: '\'n dag',
					dd: '%d dae',
					M: '\'n maand',
					MM: '%d maande',
					y: '\'n jaar',
					yy: '%d jaar'
				},
				dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
				ordinal: function(number) {
					return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de'); // Thanks to Joris Rling : https://github.com/jjupiter
				},
				week: {
					dow: 1, // Maandag is die eerste dag van die week.
					doy: 4  // Die week wat die 4de Januarie bevat is die eerste week van die jaar.
				}
			});
			
			return af;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/ar-dz.js":
	/*!*********************************************!*\
  !*** ./node_modules/moment/locale/ar-dz.js ***!
  \*********************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var arDz = moment.defineLocale('ar-dz', {
				months: '___________'.split('_'),
				monthsShort: '___________'.split('_'),
				weekdays: '______'.split('_'),
				weekdaysShort: '______'.split('_'),
				weekdaysMin: '______'.split('_'),
				weekdaysParseExact: true,
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY HH:mm',
					LLLL: 'dddd D MMMM YYYY HH:mm'
				},
				calendar: {
					sameDay: '[  ] LT',
					nextDay: '[  ] LT',
					nextWeek: 'dddd [ ] LT',
					lastDay: '[  ] LT',
					lastWeek: 'dddd [ ] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: ' %s',
					past: ' %s',
					s: '',
					ss: '%d ',
					m: '',
					mm: '%d ',
					h: '',
					hh: '%d ',
					d: '',
					dd: '%d ',
					M: '',
					MM: '%d ',
					y: '',
					yy: '%d '
				},
				week: {
					dow: 0, // Sunday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return arDz;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/ar-kw.js":
	/*!*********************************************!*\
  !*** ./node_modules/moment/locale/ar-kw.js ***!
  \*********************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var arKw = moment.defineLocale('ar-kw', {
				months: '___________'.split('_'),
				monthsShort: '___________'.split('_'),
				weekdays: '______'.split('_'),
				weekdaysShort: '______'.split('_'),
				weekdaysMin: '______'.split('_'),
				weekdaysParseExact: true,
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY HH:mm',
					LLLL: 'dddd D MMMM YYYY HH:mm'
				},
				calendar: {
					sameDay: '[  ] LT',
					nextDay: '[  ] LT',
					nextWeek: 'dddd [ ] LT',
					lastDay: '[  ] LT',
					lastWeek: 'dddd [ ] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: ' %s',
					past: ' %s',
					s: '',
					ss: '%d ',
					m: '',
					mm: '%d ',
					h: '',
					hh: '%d ',
					d: '',
					dd: '%d ',
					M: '',
					MM: '%d ',
					y: '',
					yy: '%d '
				},
				week: {
					dow: 0, // Sunday is the first day of the week.
					doy: 12  // The week that contains Jan 12th is the first week of the year.
				}
			});
			
			return arKw;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/ar-ly.js":
	/*!*********************************************!*\
  !*** ./node_modules/moment/locale/ar-ly.js ***!
  \*********************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var symbolMap = {
				'1': '1',
				'2': '2',
				'3': '3',
				'4': '4',
				'5': '5',
				'6': '6',
				'7': '7',
				'8': '8',
				'9': '9',
				'0': '0'
			}, pluralForm = function(n) {
				return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
			}, plurals = {
				s: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
				m: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
				h: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
				d: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
				M: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
				y: ['  ', ' ', ['', ''], '%d ', '%d ', '%d ']
			}, pluralize = function(u) {
				return function(number, withoutSuffix, string, isFuture) {
					var f = pluralForm(number),
						str = plurals[u][pluralForm(number)];
					if(f === 2) {
						str = str[withoutSuffix ? 0 : 1];
					}
					return str.replace(/%d/i, number);
				};
			}, months = [
				'',
				'',
				'',
				'',
				'',
				'',
				'',
				'',
				'',
				'',
				'',
				''
			];
			
			var arLy = moment.defineLocale('ar-ly', {
				months: months,
				monthsShort: months,
				weekdays: '______'.split('_'),
				weekdaysShort: '______'.split('_'),
				weekdaysMin: '______'.split('_'),
				weekdaysParseExact: true,
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'D/\u200FM/\u200FYYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY HH:mm',
					LLLL: 'dddd D MMMM YYYY HH:mm'
				},
				meridiemParse: /|/,
				isPM: function(input) {
					return '' === input;
				},
				meridiem: function(hour, minute, isLower) {
					if(hour < 12) {
						return '';
					} else {
						return '';
					}
				},
				calendar: {
					sameDay: '[  ] LT',
					nextDay: '[  ] LT',
					nextWeek: 'dddd [ ] LT',
					lastDay: '[  ] LT',
					lastWeek: 'dddd [ ] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: ' %s',
					past: ' %s',
					s: pluralize('s'),
					ss: pluralize('s'),
					m: pluralize('m'),
					mm: pluralize('m'),
					h: pluralize('h'),
					hh: pluralize('h'),
					d: pluralize('d'),
					dd: pluralize('d'),
					M: pluralize('M'),
					MM: pluralize('M'),
					y: pluralize('y'),
					yy: pluralize('y')
				},
				preparse: function(string) {
					return string.replace(//g, ',');
				},
				postformat: function(string) {
					return string.replace(/\d/g, function(match) {
						return symbolMap[match];
					}).replace(/,/g, '');
				},
				week: {
					dow: 6, // Saturday is the first day of the week.
					doy: 12  // The week that contains Jan 12th is the first week of the year.
				}
			});
			
			return arLy;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/ar-ma.js":
	/*!*********************************************!*\
  !*** ./node_modules/moment/locale/ar-ma.js ***!
  \*********************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var arMa = moment.defineLocale('ar-ma', {
				months: '___________'.split('_'),
				monthsShort: '___________'.split('_'),
				weekdays: '______'.split('_'),
				weekdaysShort: '______'.split('_'),
				weekdaysMin: '______'.split('_'),
				weekdaysParseExact: true,
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY HH:mm',
					LLLL: 'dddd D MMMM YYYY HH:mm'
				},
				calendar: {
					sameDay: '[  ] LT',
					nextDay: '[  ] LT',
					nextWeek: 'dddd [ ] LT',
					lastDay: '[  ] LT',
					lastWeek: 'dddd [ ] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: ' %s',
					past: ' %s',
					s: '',
					ss: '%d ',
					m: '',
					mm: '%d ',
					h: '',
					hh: '%d ',
					d: '',
					dd: '%d ',
					M: '',
					MM: '%d ',
					y: '',
					yy: '%d '
				},
				week: {
					dow: 6, // Saturday is the first day of the week.
					doy: 12  // The week that contains Jan 12th is the first week of the year.
				}
			});
			
			return arMa;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/ar-sa.js":
	/*!*********************************************!*\
  !*** ./node_modules/moment/locale/ar-sa.js ***!
  \*********************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var symbolMap = {
				'1': '',
				'2': '',
				'3': '',
				'4': '',
				'5': '',
				'6': '',
				'7': '',
				'8': '',
				'9': '',
				'0': ''
			}, numberMap = {
				'': '1',
				'': '2',
				'': '3',
				'': '4',
				'': '5',
				'': '6',
				'': '7',
				'': '8',
				'': '9',
				'': '0'
			};
			
			var arSa = moment.defineLocale('ar-sa', {
				months: '___________'.split('_'),
				monthsShort: '___________'.split('_'),
				weekdays: '______'.split('_'),
				weekdaysShort: '______'.split('_'),
				weekdaysMin: '______'.split('_'),
				weekdaysParseExact: true,
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY HH:mm',
					LLLL: 'dddd D MMMM YYYY HH:mm'
				},
				meridiemParse: /|/,
				isPM: function(input) {
					return '' === input;
				},
				meridiem: function(hour, minute, isLower) {
					if(hour < 12) {
						return '';
					} else {
						return '';
					}
				},
				calendar: {
					sameDay: '[  ] LT',
					nextDay: '[  ] LT',
					nextWeek: 'dddd [ ] LT',
					lastDay: '[  ] LT',
					lastWeek: 'dddd [ ] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: ' %s',
					past: ' %s',
					s: '',
					ss: '%d ',
					m: '',
					mm: '%d ',
					h: '',
					hh: '%d ',
					d: '',
					dd: '%d ',
					M: '',
					MM: '%d ',
					y: '',
					yy: '%d '
				},
				preparse: function(string) {
					return string.replace(/[]/g, function(match) {
						return numberMap[match];
					}).replace(//g, ',');
				},
				postformat: function(string) {
					return string.replace(/\d/g, function(match) {
						return symbolMap[match];
					}).replace(/,/g, '');
				},
				week: {
					dow: 0, // Sunday is the first day of the week.
					doy: 6  // The week that contains Jan 6th is the first week of the year.
				}
			});
			
			return arSa;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/ar-tn.js":
	/*!*********************************************!*\
  !*** ./node_modules/moment/locale/ar-tn.js ***!
  \*********************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var arTn = moment.defineLocale('ar-tn', {
				months: '___________'.split('_'),
				monthsShort: '___________'.split('_'),
				weekdays: '______'.split('_'),
				weekdaysShort: '______'.split('_'),
				weekdaysMin: '______'.split('_'),
				weekdaysParseExact: true,
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY HH:mm',
					LLLL: 'dddd D MMMM YYYY HH:mm'
				},
				calendar: {
					sameDay: '[  ] LT',
					nextDay: '[  ] LT',
					nextWeek: 'dddd [ ] LT',
					lastDay: '[  ] LT',
					lastWeek: 'dddd [ ] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: ' %s',
					past: ' %s',
					s: '',
					ss: '%d ',
					m: '',
					mm: '%d ',
					h: '',
					hh: '%d ',
					d: '',
					dd: '%d ',
					M: '',
					MM: '%d ',
					y: '',
					yy: '%d '
				},
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4 // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return arTn;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/ar.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/ar.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var symbolMap = {
				'1': '',
				'2': '',
				'3': '',
				'4': '',
				'5': '',
				'6': '',
				'7': '',
				'8': '',
				'9': '',
				'0': ''
			}, numberMap = {
				'': '1',
				'': '2',
				'': '3',
				'': '4',
				'': '5',
				'': '6',
				'': '7',
				'': '8',
				'': '9',
				'': '0'
			}, pluralForm = function(n) {
				return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
			}, plurals = {
				s: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
				m: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
				h: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
				d: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
				M: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
				y: ['  ', ' ', ['', ''], '%d ', '%d ', '%d ']
			}, pluralize = function(u) {
				return function(number, withoutSuffix, string, isFuture) {
					var f = pluralForm(number),
						str = plurals[u][pluralForm(number)];
					if(f === 2) {
						str = str[withoutSuffix ? 0 : 1];
					}
					return str.replace(/%d/i, number);
				};
			}, months = [
				'',
				'',
				'',
				'',
				'',
				'',
				'',
				'',
				'',
				'',
				'',
				''
			];
			
			var ar = moment.defineLocale('ar', {
				months: months,
				monthsShort: months,
				weekdays: '______'.split('_'),
				weekdaysShort: '______'.split('_'),
				weekdaysMin: '______'.split('_'),
				weekdaysParseExact: true,
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'D/\u200FM/\u200FYYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY HH:mm',
					LLLL: 'dddd D MMMM YYYY HH:mm'
				},
				meridiemParse: /|/,
				isPM: function(input) {
					return '' === input;
				},
				meridiem: function(hour, minute, isLower) {
					if(hour < 12) {
						return '';
					} else {
						return '';
					}
				},
				calendar: {
					sameDay: '[  ] LT',
					nextDay: '[  ] LT',
					nextWeek: 'dddd [ ] LT',
					lastDay: '[  ] LT',
					lastWeek: 'dddd [ ] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: ' %s',
					past: ' %s',
					s: pluralize('s'),
					ss: pluralize('s'),
					m: pluralize('m'),
					mm: pluralize('m'),
					h: pluralize('h'),
					hh: pluralize('h'),
					d: pluralize('d'),
					dd: pluralize('d'),
					M: pluralize('M'),
					MM: pluralize('M'),
					y: pluralize('y'),
					yy: pluralize('y')
				},
				preparse: function(string) {
					return string.replace(/[]/g, function(match) {
						return numberMap[match];
					}).replace(//g, ',');
				},
				postformat: function(string) {
					return string.replace(/\d/g, function(match) {
						return symbolMap[match];
					}).replace(/,/g, '');
				},
				week: {
					dow: 6, // Saturday is the first day of the week.
					doy: 12  // The week that contains Jan 12th is the first week of the year.
				}
			});
			
			return ar;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/az.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/az.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var suffixes = {
				1: '-inci',
				5: '-inci',
				8: '-inci',
				70: '-inci',
				80: '-inci',
				2: '-nci',
				7: '-nci',
				20: '-nci',
				50: '-nci',
				3: '-nc',
				4: '-nc',
				100: '-nc',
				6: '-nc',
				9: '-uncu',
				10: '-uncu',
				30: '-uncu',
				60: '-nc',
				90: '-nc'
			};
			
			var az = moment.defineLocale('az', {
				months: 'yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr'.split('_'),
				monthsShort: 'yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek'.split('_'),
				weekdays: 'Bazar_Bazar ertsi_rnb axam_rnb_Cm axam_Cm_nb'.split('_'),
				weekdaysShort: 'Baz_BzE_Ax_r_CAx_Cm_n'.split('_'),
				weekdaysMin: 'Bz_BE_A__CA_C_'.split('_'),
				weekdaysParseExact: true,
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD.MM.YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY HH:mm',
					LLLL: 'dddd, D MMMM YYYY HH:mm'
				},
				calendar: {
					sameDay: '[bugn saat] LT',
					nextDay: '[sabah saat] LT',
					nextWeek: '[gln hft] dddd [saat] LT',
					lastDay: '[dnn] LT',
					lastWeek: '[ken hft] dddd [saat] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: '%s sonra',
					past: '%s vvl',
					s: 'birne saniy',
					ss: '%d saniy',
					m: 'bir dqiq',
					mm: '%d dqiq',
					h: 'bir saat',
					hh: '%d saat',
					d: 'bir gn',
					dd: '%d gn',
					M: 'bir ay',
					MM: '%d ay',
					y: 'bir il',
					yy: '%d il'
				},
				meridiemParse: /gec|shr|gndz|axam/,
				isPM: function(input) {
					return /^(gndz|axam)$/.test(input);
				},
				meridiem: function(hour, minute, isLower) {
					if(hour < 4) {
						return 'gec';
					} else if(hour < 12) {
						return 'shr';
					} else if(hour < 17) {
						return 'gndz';
					} else {
						return 'axam';
					}
				},
				dayOfMonthOrdinalParse: /\d{1,2}-(nc|inci|nci|nc|nc|uncu)/,
				ordinal: function(number) {
					if(number === 0) {  // special case for zero
						return number + '-nc';
					}
					var a = number % 10,
						b = number % 100 - a,
						c = number >= 100 ? 100 : null;
					return number + (suffixes[a] || suffixes[b] || suffixes[c]);
				},
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 7  // The week that contains Jan 7th is the first week of the year.
				}
			});
			
			return az;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/be.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/be.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			function plural(word, num) {
				var forms = word.split('_');
				return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
			}
			
			function relativeTimeWithPlural(number, withoutSuffix, key) {
				var format = {
					'ss': withoutSuffix ? '__' : '__',
					'mm': withoutSuffix ? '__' : '__',
					'hh': withoutSuffix ? '__' : '__',
					'dd': '__',
					'MM': '__',
					'yy': '__'
				};
				if(key === 'm') {
					return withoutSuffix ? '' : '';
				} else if(key === 'h') {
					return withoutSuffix ? '' : '';
				} else {
					return number + ' ' + plural(format[key], +number);
				}
			}
			
			var be = moment.defineLocale('be', {
				months: {
					format: '___________'.split('_'),
					standalone: '___________'.split('_')
				},
				monthsShort: '___________'.split('_'),
				weekdays: {
					format: '______'.split('_'),
					standalone: '______'.split('_'),
					isFormat: /\[ ?[] ?(?:|)? ?\] ?dddd/
				},
				weekdaysShort: '______'.split('_'),
				weekdaysMin: '______'.split('_'),
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD.MM.YYYY',
					LL: 'D MMMM YYYY .',
					LLL: 'D MMMM YYYY ., HH:mm',
					LLLL: 'dddd, D MMMM YYYY ., HH:mm'
				},
				calendar: {
					sameDay: '[ ] LT',
					nextDay: '[ ] LT',
					lastDay: '[ ] LT',
					nextWeek: function() {
						return '[] dddd [] LT';
					},
					lastWeek: function() {
						switch(this.day()) {
							case 0:
							case 3:
							case 5:
							case 6:
								return '[ ] dddd [] LT';
							case 1:
							case 2:
							case 4:
								return '[ ] dddd [] LT';
						}
					},
					sameElse: 'L'
				},
				relativeTime: {
					future: ' %s',
					past: '%s ',
					s: ' ',
					m: relativeTimeWithPlural,
					mm: relativeTimeWithPlural,
					h: relativeTimeWithPlural,
					hh: relativeTimeWithPlural,
					d: '',
					dd: relativeTimeWithPlural,
					M: '',
					MM: relativeTimeWithPlural,
					y: '',
					yy: relativeTimeWithPlural
				},
				meridiemParse: /|||/,
				isPM: function(input) {
					return /^(|)$/.test(input);
				},
				meridiem: function(hour, minute, isLower) {
					if(hour < 4) {
						return '';
					} else if(hour < 12) {
						return '';
					} else if(hour < 17) {
						return '';
					} else {
						return '';
					}
				},
				dayOfMonthOrdinalParse: /\d{1,2}-(||)/,
				ordinal: function(number, period) {
					switch(period) {
						case 'M':
						case 'd':
						case 'DDD':
						case 'w':
						case 'W':
							return (number % 10 === 2 || number % 10 === 3) && (number % 100 !== 12 && number % 100 !== 13) ? number + '-' : number + '-';
						case 'D':
							return number + '-';
						default:
							return number;
					}
				},
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 7  // The week that contains Jan 7th is the first week of the year.
				}
			});
			
			return be;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/bg.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/bg.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var bg = moment.defineLocale('bg', {
				months: '___________'.split('_'),
				monthsShort: '___________'.split('_'),
				weekdays: '______'.split('_'),
				weekdaysShort: '______'.split('_'),
				weekdaysMin: '______'.split('_'),
				longDateFormat: {
					LT: 'H:mm',
					LTS: 'H:mm:ss',
					L: 'D.MM.YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY H:mm',
					LLLL: 'dddd, D MMMM YYYY H:mm'
				},
				calendar: {
					sameDay: '[ ] LT',
					nextDay: '[ ] LT',
					nextWeek: 'dddd [] LT',
					lastDay: '[ ] LT',
					lastWeek: function() {
						switch(this.day()) {
							case 0:
							case 3:
							case 6:
								return '[ ] dddd [] LT';
							case 1:
							case 2:
							case 4:
							case 5:
								return '[ ] dddd [] LT';
						}
					},
					sameElse: 'L'
				},
				relativeTime: {
					future: ' %s',
					past: ' %s',
					s: ' ',
					ss: '%d ',
					m: '',
					mm: '%d ',
					h: '',
					hh: '%d ',
					d: '',
					dd: '%d ',
					M: '',
					MM: '%d ',
					y: '',
					yy: '%d '
				},
				dayOfMonthOrdinalParse: /\d{1,2}-(|||||)/,
				ordinal: function(number) {
					var lastDigit = number % 10,
						last2Digits = number % 100;
					if(number === 0) {
						return number + '-';
					} else if(last2Digits === 0) {
						return number + '-';
					} else if(last2Digits > 10 && last2Digits < 20) {
						return number + '-';
					} else if(lastDigit === 1) {
						return number + '-';
					} else if(lastDigit === 2) {
						return number + '-';
					} else if(lastDigit === 7 || lastDigit === 8) {
						return number + '-';
					} else {
						return number + '-';
					}
				},
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 7  // The week that contains Jan 7th is the first week of the year.
				}
			});
			
			return bg;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/bm.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/bm.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var bm = moment.defineLocale('bm', {
				months: 'Zanwuyekalo_Fewuruyekalo_Marisikalo_Awirilikalo_Mkalo_Zuwnkalo_Zuluyekalo_Utikalo_Stanburukalo_kutburukalo_Nowanburukalo_Desanburukalo'.split('_'),
				monthsShort: 'Zan_Few_Mar_Awi_M_Zuw_Zul_Uti_St_ku_Now_Des'.split('_'),
				weekdays: 'Kari_Ntnn_Tarata_Araba_Alamisa_Juma_Sibiri'.split('_'),
				weekdaysShort: 'Kar_Nt_Tar_Ara_Ala_Jum_Sib'.split('_'),
				weekdaysMin: 'Ka_Nt_Ta_Ar_Al_Ju_Si'.split('_'),
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD/MM/YYYY',
					LL: 'MMMM [tile] D [san] YYYY',
					LLL: 'MMMM [tile] D [san] YYYY [lr] HH:mm',
					LLLL: 'dddd MMMM [tile] D [san] YYYY [lr] HH:mm'
				},
				calendar: {
					sameDay: '[Bi lr] LT',
					nextDay: '[Sini lr] LT',
					nextWeek: 'dddd [don lr] LT',
					lastDay: '[Kunu lr] LT',
					lastWeek: 'dddd [tmnen lr] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: '%s kn',
					past: 'a b %s b',
					s: 'sanga dama dama',
					ss: 'sekondi %d',
					m: 'miniti kelen',
					mm: 'miniti %d',
					h: 'lr kelen',
					hh: 'lr %d',
					d: 'tile kelen',
					dd: 'tile %d',
					M: 'kalo kelen',
					MM: 'kalo %d',
					y: 'san kelen',
					yy: 'san %d'
				},
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return bm;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/bn.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/bn.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var symbolMap = {
					'1': '',
					'2': '',
					'3': '',
					'4': '',
					'5': '',
					'6': '',
					'7': '',
					'8': '',
					'9': '',
					'0': ''
				},
				numberMap = {
					'': '1',
					'': '2',
					'': '3',
					'': '4',
					'': '5',
					'': '6',
					'': '7',
					'': '8',
					'': '9',
					'': '0'
				};
			
			var bn = moment.defineLocale('bn', {
				months: '___________'.split('_'),
				monthsShort: '___________'.split('_'),
				weekdays: '______'.split('_'),
				weekdaysShort: '______'.split('_'),
				weekdaysMin: '______'.split('_'),
				longDateFormat: {
					LT: 'A h:mm ',
					LTS: 'A h:mm:ss ',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY, A h:mm ',
					LLLL: 'dddd, D MMMM YYYY, A h:mm '
				},
				calendar: {
					sameDay: '[] LT',
					nextDay: '[] LT',
					nextWeek: 'dddd, LT',
					lastDay: '[] LT',
					lastWeek: '[] dddd, LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: '%s ',
					past: '%s ',
					s: ' ',
					ss: '%d ',
					m: ' ',
					mm: '%d ',
					h: ' ',
					hh: '%d ',
					d: ' ',
					dd: '%d ',
					M: ' ',
					MM: '%d ',
					y: ' ',
					yy: '%d '
				},
				preparse: function(string) {
					return string.replace(/[]/g, function(match) {
						return numberMap[match];
					});
				},
				postformat: function(string) {
					return string.replace(/\d/g, function(match) {
						return symbolMap[match];
					});
				},
				meridiemParse: /||||/,
				meridiemHour: function(hour, meridiem) {
					if(hour === 12) {
						hour = 0;
					}
					if((meridiem === '' && hour >= 4) ||
						(meridiem === '' && hour < 5) ||
						meridiem === '') {
						return hour + 12;
					} else {
						return hour;
					}
				},
				meridiem: function(hour, minute, isLower) {
					if(hour < 4) {
						return '';
					} else if(hour < 10) {
						return '';
					} else if(hour < 17) {
						return '';
					} else if(hour < 20) {
						return '';
					} else {
						return '';
					}
				},
				week: {
					dow: 0, // Sunday is the first day of the week.
					doy: 6  // The week that contains Jan 6th is the first week of the year.
				}
			});
			
			return bn;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/bo.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/bo.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var symbolMap = {
					'1': '',
					'2': '',
					'3': '',
					'4': '',
					'5': '',
					'6': '',
					'7': '',
					'8': '',
					'9': '',
					'0': ''
				},
				numberMap = {
					'': '1',
					'': '2',
					'': '3',
					'': '4',
					'': '5',
					'': '6',
					'': '7',
					'': '8',
					'': '9',
					'': '0'
				};
			
			var bo = moment.defineLocale('bo', {
				months: '___________'.split('_'),
				monthsShort: '___________'.split('_'),
				weekdays: '______'.split('_'),
				weekdaysShort: '______'.split('_'),
				weekdaysMin: '______'.split('_'),
				longDateFormat: {
					LT: 'A h:mm',
					LTS: 'A h:mm:ss',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY, A h:mm',
					LLLL: 'dddd, D MMMM YYYY, A h:mm'
				},
				calendar: {
					sameDay: '[] LT',
					nextDay: '[] LT',
					nextWeek: '[], LT',
					lastDay: '[] LT',
					lastWeek: '[] dddd, LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: '%s ',
					past: '%s ',
					s: '',
					ss: '%d ',
					m: '',
					mm: '%d ',
					h: '',
					hh: '%d ',
					d: '',
					dd: '%d ',
					M: '',
					MM: '%d ',
					y: '',
					yy: '%d '
				},
				preparse: function(string) {
					return string.replace(/[]/g, function(match) {
						return numberMap[match];
					});
				},
				postformat: function(string) {
					return string.replace(/\d/g, function(match) {
						return symbolMap[match];
					});
				},
				meridiemParse: /||||/,
				meridiemHour: function(hour, meridiem) {
					if(hour === 12) {
						hour = 0;
					}
					if((meridiem === '' && hour >= 4) ||
						(meridiem === '' && hour < 5) ||
						meridiem === '') {
						return hour + 12;
					} else {
						return hour;
					}
				},
				meridiem: function(hour, minute, isLower) {
					if(hour < 4) {
						return '';
					} else if(hour < 10) {
						return '';
					} else if(hour < 17) {
						return '';
					} else if(hour < 20) {
						return '';
					} else {
						return '';
					}
				},
				week: {
					dow: 0, // Sunday is the first day of the week.
					doy: 6  // The week that contains Jan 6th is the first week of the year.
				}
			});
			
			return bo;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/br.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/br.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			function relativeTimeWithMutation(number, withoutSuffix, key) {
				var format = {
					'mm': 'munutenn',
					'MM': 'miz',
					'dd': 'devezh'
				};
				return number + ' ' + mutation(format[key], number);
			}
			
			function specialMutationForYears(number) {
				switch(lastNumber(number)) {
					case 1:
					case 3:
					case 4:
					case 5:
					case 9:
						return number + ' bloaz';
					default:
						return number + ' vloaz';
				}
			}
			
			function lastNumber(number) {
				if(number > 9) {
					return lastNumber(number % 10);
				}
				return number;
			}
			
			function mutation(text, number) {
				if(number === 2) {
					return softMutation(text);
				}
				return text;
			}
			
			function softMutation(text) {
				var mutationTable = {
					'm': 'v',
					'b': 'v',
					'd': 'z'
				};
				if(mutationTable[text.charAt(0)] === undefined) {
					return text;
				}
				return mutationTable[text.charAt(0)] + text.substring(1);
			}
			
			var br = moment.defineLocale('br', {
				months: 'Genver_C\'hwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu'.split('_'),
				monthsShort: 'Gen_C\'hwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker'.split('_'),
				weekdays: 'Sul_Lun_Meurzh_Merc\'her_Yaou_Gwener_Sadorn'.split('_'),
				weekdaysShort: 'Sul_Lun_Meu_Mer_Yao_Gwe_Sad'.split('_'),
				weekdaysMin: 'Su_Lu_Me_Mer_Ya_Gw_Sa'.split('_'),
				weekdaysParseExact: true,
				longDateFormat: {
					LT: 'h[e]mm A',
					LTS: 'h[e]mm:ss A',
					L: 'DD/MM/YYYY',
					LL: 'D [a viz] MMMM YYYY',
					LLL: 'D [a viz] MMMM YYYY h[e]mm A',
					LLLL: 'dddd, D [a viz] MMMM YYYY h[e]mm A'
				},
				calendar: {
					sameDay: '[Hiziv da] LT',
					nextDay: '[Warc\'hoazh da] LT',
					nextWeek: 'dddd [da] LT',
					lastDay: '[Dec\'h da] LT',
					lastWeek: 'dddd [paset da] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: 'a-benn %s',
					past: '%s \'zo',
					s: 'un nebeud segondenno',
					ss: '%d eilenn',
					m: 'ur vunutenn',
					mm: relativeTimeWithMutation,
					h: 'un eur',
					hh: '%d eur',
					d: 'un devezh',
					dd: relativeTimeWithMutation,
					M: 'ur miz',
					MM: relativeTimeWithMutation,
					y: 'ur bloaz',
					yy: specialMutationForYears
				},
				dayOfMonthOrdinalParse: /\d{1,2}(a|vet)/,
				ordinal: function(number) {
					var output = (number === 1) ? 'a' : 'vet';
					return number + output;
				},
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return br;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/bs.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/bs.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			function translate(number, withoutSuffix, key) {
				var result = number + ' ';
				switch(key) {
					case 'ss':
						if(number === 1) {
							result += 'sekunda';
						} else if(number === 2 || number === 3 || number === 4) {
							result += 'sekunde';
						} else {
							result += 'sekundi';
						}
						return result;
					case 'm':
						return withoutSuffix ? 'jedna minuta' : 'jedne minute';
					case 'mm':
						if(number === 1) {
							result += 'minuta';
						} else if(number === 2 || number === 3 || number === 4) {
							result += 'minute';
						} else {
							result += 'minuta';
						}
						return result;
					case 'h':
						return withoutSuffix ? 'jedan sat' : 'jednog sata';
					case 'hh':
						if(number === 1) {
							result += 'sat';
						} else if(number === 2 || number === 3 || number === 4) {
							result += 'sata';
						} else {
							result += 'sati';
						}
						return result;
					case 'dd':
						if(number === 1) {
							result += 'dan';
						} else {
							result += 'dana';
						}
						return result;
					case 'MM':
						if(number === 1) {
							result += 'mjesec';
						} else if(number === 2 || number === 3 || number === 4) {
							result += 'mjeseca';
						} else {
							result += 'mjeseci';
						}
						return result;
					case 'yy':
						if(number === 1) {
							result += 'godina';
						} else if(number === 2 || number === 3 || number === 4) {
							result += 'godine';
						} else {
							result += 'godina';
						}
						return result;
				}
			}
			
			var bs = moment.defineLocale('bs', {
				months: 'januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar'.split('_'),
				monthsShort: 'jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.'.split('_'),
				monthsParseExact: true,
				weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
				weekdaysShort: 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
				weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
				weekdaysParseExact: true,
				longDateFormat: {
					LT: 'H:mm',
					LTS: 'H:mm:ss',
					L: 'DD.MM.YYYY',
					LL: 'D. MMMM YYYY',
					LLL: 'D. MMMM YYYY H:mm',
					LLLL: 'dddd, D. MMMM YYYY H:mm'
				},
				calendar: {
					sameDay: '[danas u] LT',
					nextDay: '[sutra u] LT',
					nextWeek: function() {
						switch(this.day()) {
							case 0:
								return '[u] [nedjelju] [u] LT';
							case 3:
								return '[u] [srijedu] [u] LT';
							case 6:
								return '[u] [subotu] [u] LT';
							case 1:
							case 2:
							case 4:
							case 5:
								return '[u] dddd [u] LT';
						}
					},
					lastDay: '[juer u] LT',
					lastWeek: function() {
						switch(this.day()) {
							case 0:
							case 3:
								return '[prolu] dddd [u] LT';
							case 6:
								return '[prole] [subote] [u] LT';
							case 1:
							case 2:
							case 4:
							case 5:
								return '[proli] dddd [u] LT';
						}
					},
					sameElse: 'L'
				},
				relativeTime: {
					future: 'za %s',
					past: 'prije %s',
					s: 'par sekundi',
					ss: translate,
					m: translate,
					mm: translate,
					h: translate,
					hh: translate,
					d: 'dan',
					dd: translate,
					M: 'mjesec',
					MM: translate,
					y: 'godinu',
					yy: translate
				},
				dayOfMonthOrdinalParse: /\d{1,2}\./,
				ordinal: '%d.',
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 7  // The week that contains Jan 7th is the first week of the year.
				}
			});
			
			return bs;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/ca.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/ca.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var ca = moment.defineLocale('ca', {
				months: {
					standalone: 'gener_febrer_mar_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre'.split('_'),
					format: 'de gener_de febrer_de mar_d\'abril_de maig_de juny_de juliol_d\'agost_de setembre_d\'octubre_de novembre_de desembre'.split('_'),
					isFormat: /D[oD]?(\s)+MMMM/
				},
				monthsShort: 'gen._febr._mar_abr._maig_juny_jul._ag._set._oct._nov._des.'.split('_'),
				monthsParseExact: true,
				weekdays: 'diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte'.split('_'),
				weekdaysShort: 'dg._dl._dt._dc._dj._dv._ds.'.split('_'),
				weekdaysMin: 'dg_dl_dt_dc_dj_dv_ds'.split('_'),
				weekdaysParseExact: true,
				longDateFormat: {
					LT: 'H:mm',
					LTS: 'H:mm:ss',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM [de] YYYY',
					ll: 'D MMM YYYY',
					LLL: 'D MMMM [de] YYYY [a les] H:mm',
					lll: 'D MMM YYYY, H:mm',
					LLLL: 'dddd D MMMM [de] YYYY [a les] H:mm',
					llll: 'ddd D MMM YYYY, H:mm'
				},
				calendar: {
					sameDay: function() {
						return '[avui a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
					},
					nextDay: function() {
						return '[dem a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
					},
					nextWeek: function() {
						return 'dddd [a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
					},
					lastDay: function() {
						return '[ahir a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
					},
					lastWeek: function() {
						return '[el] dddd [passat a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
					},
					sameElse: 'L'
				},
				relativeTime: {
					future: 'd\'aqu %s',
					past: 'fa %s',
					s: 'uns segons',
					ss: '%d segons',
					m: 'un minut',
					mm: '%d minuts',
					h: 'una hora',
					hh: '%d hores',
					d: 'un dia',
					dd: '%d dies',
					M: 'un mes',
					MM: '%d mesos',
					y: 'un any',
					yy: '%d anys'
				},
				dayOfMonthOrdinalParse: /\d{1,2}(r|n|t||a)/,
				ordinal: function(number, period) {
					var output = (number === 1) ? 'r' :
						(number === 2) ? 'n' :
							(number === 3) ? 'r' :
								(number === 4) ? 't' : '';
					if(period === 'w' || period === 'W') {
						output = 'a';
					}
					return number + output;
				},
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return ca;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/cs.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/cs.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var months = 'leden_nor_bezen_duben_kvten_erven_ervenec_srpen_z_jen_listopad_prosinec'.split('_'),
				monthsShort = 'led_no_be_dub_kv_vn_vc_srp_z_j_lis_pro'.split('_');
			
			var monthsParse = [/^led/i, /^no/i, /^be/i, /^dub/i, /^kv/i, /^(vn|erven$|ervna)/i, /^(vc|ervenec|ervence)/i, /^srp/i, /^z/i, /^j/i, /^lis/i, /^pro/i];
			// NOTE: 'erven' is substring of 'ervenec'; therefore 'ervenec' must precede 'erven' in the regex to be fully matched.
			// Otherwise parser matches '1. ervenec' as '1. erven' + 'ec'.
			var monthsRegex = /^(leden|nor|bezen|duben|kvten|ervenec|ervence|erven|ervna|srpen|z|jen|listopad|prosinec|led|no|be|dub|kv|vn|vc|srp|z|j|lis|pro)/i;
			
			function plural(n) {
				return (n > 1) && (n < 5) && (~~(n / 10) !== 1);
			}
			
			function translate(number, withoutSuffix, key, isFuture) {
				var result = number + ' ';
				switch(key) {
					case 's':  // a few seconds / in a few seconds / a few seconds ago
						return (withoutSuffix || isFuture) ? 'pr sekund' : 'pr sekundami';
					case 'ss': // 9 seconds / in 9 seconds / 9 seconds ago
						if(withoutSuffix || isFuture) {
							return result + (plural(number) ? 'sekundy' : 'sekund');
						} else {
							return result + 'sekundami';
						}
						break;
					case 'm':  // a minute / in a minute / a minute ago
						return withoutSuffix ? 'minuta' : (isFuture ? 'minutu' : 'minutou');
					case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
						if(withoutSuffix || isFuture) {
							return result + (plural(number) ? 'minuty' : 'minut');
						} else {
							return result + 'minutami';
						}
						break;
					case 'h':  // an hour / in an hour / an hour ago
						return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
					case 'hh': // 9 hours / in 9 hours / 9 hours ago
						if(withoutSuffix || isFuture) {
							return result + (plural(number) ? 'hodiny' : 'hodin');
						} else {
							return result + 'hodinami';
						}
						break;
					case 'd':  // a day / in a day / a day ago
						return (withoutSuffix || isFuture) ? 'den' : 'dnem';
					case 'dd': // 9 days / in 9 days / 9 days ago
						if(withoutSuffix || isFuture) {
							return result + (plural(number) ? 'dny' : 'dn');
						} else {
							return result + 'dny';
						}
						break;
					case 'M':  // a month / in a month / a month ago
						return (withoutSuffix || isFuture) ? 'msc' : 'mscem';
					case 'MM': // 9 months / in 9 months / 9 months ago
						if(withoutSuffix || isFuture) {
							return result + (plural(number) ? 'msce' : 'msc');
						} else {
							return result + 'msci';
						}
						break;
					case 'y':  // a year / in a year / a year ago
						return (withoutSuffix || isFuture) ? 'rok' : 'rokem';
					case 'yy': // 9 years / in 9 years / 9 years ago
						if(withoutSuffix || isFuture) {
							return result + (plural(number) ? 'roky' : 'let');
						} else {
							return result + 'lety';
						}
						break;
				}
			}
			
			var cs = moment.defineLocale('cs', {
				months: months,
				monthsShort: monthsShort,
				monthsRegex: monthsRegex,
				monthsShortRegex: monthsRegex,
				// NOTE: 'erven' is substring of 'ervenec'; therefore 'ervenec' must precede 'erven' in the regex to be fully matched.
				// Otherwise parser matches '1. ervenec' as '1. erven' + 'ec'.
				monthsStrictRegex: /^(leden|ledna|nora|nor|bezen|bezna|duben|dubna|kvten|kvtna|ervenec|ervence|erven|ervna|srpen|srpna|z|jen|jna|listopadu|listopad|prosinec|prosince)/i,
				monthsShortStrictRegex: /^(led|no|be|dub|kv|vn|vc|srp|z|j|lis|pro)/i,
				monthsParse: monthsParse,
				longMonthsParse: monthsParse,
				shortMonthsParse: monthsParse,
				weekdays: 'nedle_pondl_ter_steda_tvrtek_ptek_sobota'.split('_'),
				weekdaysShort: 'ne_po_t_st_t_p_so'.split('_'),
				weekdaysMin: 'ne_po_t_st_t_p_so'.split('_'),
				longDateFormat: {
					LT: 'H:mm',
					LTS: 'H:mm:ss',
					L: 'DD.MM.YYYY',
					LL: 'D. MMMM YYYY',
					LLL: 'D. MMMM YYYY H:mm',
					LLLL: 'dddd D. MMMM YYYY H:mm',
					l: 'D. M. YYYY'
				},
				calendar: {
					sameDay: '[dnes v] LT',
					nextDay: '[ztra v] LT',
					nextWeek: function() {
						switch(this.day()) {
							case 0:
								return '[v nedli v] LT';
							case 1:
							case 2:
								return '[v] dddd [v] LT';
							case 3:
								return '[ve stedu v] LT';
							case 4:
								return '[ve tvrtek v] LT';
							case 5:
								return '[v ptek v] LT';
							case 6:
								return '[v sobotu v] LT';
						}
					},
					lastDay: '[vera v] LT',
					lastWeek: function() {
						switch(this.day()) {
							case 0:
								return '[minulou nedli v] LT';
							case 1:
							case 2:
								return '[minul] dddd [v] LT';
							case 3:
								return '[minulou stedu v] LT';
							case 4:
							case 5:
								return '[minul] dddd [v] LT';
							case 6:
								return '[minulou sobotu v] LT';
						}
					},
					sameElse: 'L'
				},
				relativeTime: {
					future: 'za %s',
					past: 'ped %s',
					s: translate,
					ss: translate,
					m: translate,
					mm: translate,
					h: translate,
					hh: translate,
					d: translate,
					dd: translate,
					M: translate,
					MM: translate,
					y: translate,
					yy: translate
				},
				dayOfMonthOrdinalParse: /\d{1,2}\./,
				ordinal: '%d.',
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return cs;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/cv.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/cv.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var cv = moment.defineLocale('cv', {
				months: '___________'.split('_'),
				monthsShort: '___________'.split('_'),
				weekdays: '______'.split('_'),
				weekdaysShort: '______'.split('_'),
				weekdaysMin: '______'.split('_'),
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD-MM-YYYY',
					LL: 'YYYY [] MMMM [] D[-]',
					LLL: 'YYYY [] MMMM [] D[-], HH:mm',
					LLLL: 'dddd, YYYY [] MMMM [] D[-], HH:mm'
				},
				calendar: {
					sameDay: '[] LT []',
					nextDay: '[] LT []',
					lastDay: '[] LT []',
					nextWeek: '[] dddd LT []',
					lastWeek: '[] dddd LT []',
					sameElse: 'L'
				},
				relativeTime: {
					future: function(output) {
						var affix = /$/i.exec(output) ? '' : /$/i.exec(output) ? '' : '';
						return output + affix;
					},
					past: '%s ',
					s: '- ',
					ss: '%d ',
					m: ' ',
					mm: '%d ',
					h: ' ',
					hh: '%d ',
					d: ' ',
					dd: '%d ',
					M: ' ',
					MM: '%d ',
					y: ' ',
					yy: '%d '
				},
				dayOfMonthOrdinalParse: /\d{1,2}-/,
				ordinal: '%d-',
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 7  // The week that contains Jan 7th is the first week of the year.
				}
			});
			
			return cv;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/cy.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/cy.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var cy = moment.defineLocale('cy', {
				months: 'Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr'.split('_'),
				monthsShort: 'Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag'.split('_'),
				weekdays: 'Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn'.split('_'),
				weekdaysShort: 'Sul_Llun_Maw_Mer_Iau_Gwe_Sad'.split('_'),
				weekdaysMin: 'Su_Ll_Ma_Me_Ia_Gw_Sa'.split('_'),
				weekdaysParseExact: true,
				// time formats are the same as en-gb
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY HH:mm',
					LLLL: 'dddd, D MMMM YYYY HH:mm'
				},
				calendar: {
					sameDay: '[Heddiw am] LT',
					nextDay: '[Yfory am] LT',
					nextWeek: 'dddd [am] LT',
					lastDay: '[Ddoe am] LT',
					lastWeek: 'dddd [diwethaf am] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: 'mewn %s',
					past: '%s yn l',
					s: 'ychydig eiliadau',
					ss: '%d eiliad',
					m: 'munud',
					mm: '%d munud',
					h: 'awr',
					hh: '%d awr',
					d: 'diwrnod',
					dd: '%d diwrnod',
					M: 'mis',
					MM: '%d mis',
					y: 'blwyddyn',
					yy: '%d flynedd'
				},
				dayOfMonthOrdinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
				// traditional ordinal numbers above 31 are not commonly used in colloquial Welsh
				ordinal: function(number) {
					var b = number,
						output = '',
						lookup = [
							'', 'af', 'il', 'ydd', 'ydd', 'ed', 'ed', 'ed', 'fed', 'fed', 'fed', // 1af to 10fed
							'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'fed' // 11eg to 20fed
						];
					if(b > 20) {
						if(b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {
							output = 'fed'; // not 30ain, 70ain or 90ain
						} else {
							output = 'ain';
						}
					} else if(b > 0) {
						output = lookup[b];
					}
					return number + output;
				},
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return cy;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/da.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/da.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var da = moment.defineLocale('da', {
				months: 'januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december'.split('_'),
				monthsShort: 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
				weekdays: 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),
				weekdaysShort: 'sn_man_tir_ons_tor_fre_lr'.split('_'),
				weekdaysMin: 's_ma_ti_on_to_fr_l'.split('_'),
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD.MM.YYYY',
					LL: 'D. MMMM YYYY',
					LLL: 'D. MMMM YYYY HH:mm',
					LLLL: 'dddd [d.] D. MMMM YYYY [kl.] HH:mm'
				},
				calendar: {
					sameDay: '[i dag kl.] LT',
					nextDay: '[i morgen kl.] LT',
					nextWeek: 'p dddd [kl.] LT',
					lastDay: '[i gr kl.] LT',
					lastWeek: '[i] dddd[s kl.] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: 'om %s',
					past: '%s siden',
					s: 'f sekunder',
					ss: '%d sekunder',
					m: 'et minut',
					mm: '%d minutter',
					h: 'en time',
					hh: '%d timer',
					d: 'en dag',
					dd: '%d dage',
					M: 'en mned',
					MM: '%d mneder',
					y: 'et r',
					yy: '%d r'
				},
				dayOfMonthOrdinalParse: /\d{1,2}\./,
				ordinal: '%d.',
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return da;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/de-at.js":
	/*!*********************************************!*\
  !*** ./node_modules/moment/locale/de-at.js ***!
  \*********************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			function processRelativeTime(number, withoutSuffix, key, isFuture) {
				var format = {
					'm': ['eine Minute', 'einer Minute'],
					'h': ['eine Stunde', 'einer Stunde'],
					'd': ['ein Tag', 'einem Tag'],
					'dd': [number + ' Tage', number + ' Tagen'],
					'M': ['ein Monat', 'einem Monat'],
					'MM': [number + ' Monate', number + ' Monaten'],
					'y': ['ein Jahr', 'einem Jahr'],
					'yy': [number + ' Jahre', number + ' Jahren']
				};
				return withoutSuffix ? format[key][0] : format[key][1];
			}
			
			var deAt = moment.defineLocale('de-at', {
				months: 'Jnner_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
				monthsShort: 'Jn._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),
				monthsParseExact: true,
				weekdays: 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
				weekdaysShort: 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
				weekdaysMin: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
				weekdaysParseExact: true,
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD.MM.YYYY',
					LL: 'D. MMMM YYYY',
					LLL: 'D. MMMM YYYY HH:mm',
					LLLL: 'dddd, D. MMMM YYYY HH:mm'
				},
				calendar: {
					sameDay: '[heute um] LT [Uhr]',
					sameElse: 'L',
					nextDay: '[morgen um] LT [Uhr]',
					nextWeek: 'dddd [um] LT [Uhr]',
					lastDay: '[gestern um] LT [Uhr]',
					lastWeek: '[letzten] dddd [um] LT [Uhr]'
				},
				relativeTime: {
					future: 'in %s',
					past: 'vor %s',
					s: 'ein paar Sekunden',
					ss: '%d Sekunden',
					m: processRelativeTime,
					mm: '%d Minuten',
					h: processRelativeTime,
					hh: '%d Stunden',
					d: processRelativeTime,
					dd: processRelativeTime,
					M: processRelativeTime,
					MM: processRelativeTime,
					y: processRelativeTime,
					yy: processRelativeTime
				},
				dayOfMonthOrdinalParse: /\d{1,2}\./,
				ordinal: '%d.',
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return deAt;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/de-ch.js":
	/*!*********************************************!*\
  !*** ./node_modules/moment/locale/de-ch.js ***!
  \*********************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			function processRelativeTime(number, withoutSuffix, key, isFuture) {
				var format = {
					'm': ['eine Minute', 'einer Minute'],
					'h': ['eine Stunde', 'einer Stunde'],
					'd': ['ein Tag', 'einem Tag'],
					'dd': [number + ' Tage', number + ' Tagen'],
					'M': ['ein Monat', 'einem Monat'],
					'MM': [number + ' Monate', number + ' Monaten'],
					'y': ['ein Jahr', 'einem Jahr'],
					'yy': [number + ' Jahre', number + ' Jahren']
				};
				return withoutSuffix ? format[key][0] : format[key][1];
			}
			
			var deCh = moment.defineLocale('de-ch', {
				months: 'Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
				monthsShort: 'Jan._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),
				monthsParseExact: true,
				weekdays: 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
				weekdaysShort: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
				weekdaysMin: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
				weekdaysParseExact: true,
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD.MM.YYYY',
					LL: 'D. MMMM YYYY',
					LLL: 'D. MMMM YYYY HH:mm',
					LLLL: 'dddd, D. MMMM YYYY HH:mm'
				},
				calendar: {
					sameDay: '[heute um] LT [Uhr]',
					sameElse: 'L',
					nextDay: '[morgen um] LT [Uhr]',
					nextWeek: 'dddd [um] LT [Uhr]',
					lastDay: '[gestern um] LT [Uhr]',
					lastWeek: '[letzten] dddd [um] LT [Uhr]'
				},
				relativeTime: {
					future: 'in %s',
					past: 'vor %s',
					s: 'ein paar Sekunden',
					ss: '%d Sekunden',
					m: processRelativeTime,
					mm: '%d Minuten',
					h: processRelativeTime,
					hh: '%d Stunden',
					d: processRelativeTime,
					dd: processRelativeTime,
					M: processRelativeTime,
					MM: processRelativeTime,
					y: processRelativeTime,
					yy: processRelativeTime
				},
				dayOfMonthOrdinalParse: /\d{1,2}\./,
				ordinal: '%d.',
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return deCh;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/de.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/de.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			function processRelativeTime(number, withoutSuffix, key, isFuture) {
				var format = {
					'm': ['eine Minute', 'einer Minute'],
					'h': ['eine Stunde', 'einer Stunde'],
					'd': ['ein Tag', 'einem Tag'],
					'dd': [number + ' Tage', number + ' Tagen'],
					'M': ['ein Monat', 'einem Monat'],
					'MM': [number + ' Monate', number + ' Monaten'],
					'y': ['ein Jahr', 'einem Jahr'],
					'yy': [number + ' Jahre', number + ' Jahren']
				};
				return withoutSuffix ? format[key][0] : format[key][1];
			}
			
			var de = moment.defineLocale('de', {
				months: 'Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
				monthsShort: 'Jan._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),
				monthsParseExact: true,
				weekdays: 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
				weekdaysShort: 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
				weekdaysMin: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
				weekdaysParseExact: true,
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD.MM.YYYY',
					LL: 'D. MMMM YYYY',
					LLL: 'D. MMMM YYYY HH:mm',
					LLLL: 'dddd, D. MMMM YYYY HH:mm'
				},
				calendar: {
					sameDay: '[heute um] LT [Uhr]',
					sameElse: 'L',
					nextDay: '[morgen um] LT [Uhr]',
					nextWeek: 'dddd [um] LT [Uhr]',
					lastDay: '[gestern um] LT [Uhr]',
					lastWeek: '[letzten] dddd [um] LT [Uhr]'
				},
				relativeTime: {
					future: 'in %s',
					past: 'vor %s',
					s: 'ein paar Sekunden',
					ss: '%d Sekunden',
					m: processRelativeTime,
					mm: '%d Minuten',
					h: processRelativeTime,
					hh: '%d Stunden',
					d: processRelativeTime,
					dd: processRelativeTime,
					M: processRelativeTime,
					MM: processRelativeTime,
					y: processRelativeTime,
					yy: processRelativeTime
				},
				dayOfMonthOrdinalParse: /\d{1,2}\./,
				ordinal: '%d.',
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return de;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/dv.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/dv.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var months = [
				'',
				'',
				'',
				'',
				'',
				'',
				'',
				'',
				'',
				'',
				'',
				''
			], weekdays = [
				'',
				'',
				'',
				'',
				'',
				'',
				''
			];
			
			var dv = moment.defineLocale('dv', {
				months: months,
				monthsShort: months,
				weekdays: weekdays,
				weekdaysShort: weekdays,
				weekdaysMin: '______'.split('_'),
				longDateFormat: {
					
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'D/M/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY HH:mm',
					LLLL: 'dddd D MMMM YYYY HH:mm'
				},
				meridiemParse: /|/,
				isPM: function(input) {
					return '' === input;
				},
				meridiem: function(hour, minute, isLower) {
					if(hour < 12) {
						return '';
					} else {
						return '';
					}
				},
				calendar: {
					sameDay: '[] LT',
					nextDay: '[] LT',
					nextWeek: 'dddd LT',
					lastDay: '[] LT',
					lastWeek: '[] dddd LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: ' %s',
					past: ' %s',
					s: '',
					ss: 'd% ',
					m: '',
					mm: ' %d',
					h: '',
					hh: ' %d',
					d: '',
					dd: ' %d',
					M: '',
					MM: ' %d',
					y: '',
					yy: ' %d'
				},
				preparse: function(string) {
					return string.replace(//g, ',');
				},
				postformat: function(string) {
					return string.replace(/,/g, '');
				},
				week: {
					dow: 7,  // Sunday is the first day of the week.
					doy: 12  // The week that contains Jan 12th is the first week of the year.
				}
			});
			
			return dv;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/el.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/el.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			function isFunction(input) {
				return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
			}
			
			
			var el = moment.defineLocale('el', {
				monthsNominativeEl: '___________'.split('_'),
				monthsGenitiveEl: '___________'.split('_'),
				months: function(momentToFormat, format) {
					if(!momentToFormat) {
						return this._monthsNominativeEl;
					} else if(typeof format === 'string' && /D/.test(format.substring(0, format.indexOf('MMMM')))) { // if there is a day number before 'MMMM'
						return this._monthsGenitiveEl[momentToFormat.month()];
					} else {
						return this._monthsNominativeEl[momentToFormat.month()];
					}
				},
				monthsShort: '___________'.split('_'),
				weekdays: '______'.split('_'),
				weekdaysShort: '______'.split('_'),
				weekdaysMin: '______'.split('_'),
				meridiem: function(hours, minutes, isLower) {
					if(hours > 11) {
						return isLower ? '' : '';
					} else {
						return isLower ? '' : '';
					}
				},
				isPM: function(input) {
					return ((input + '').toLowerCase()[0] === '');
				},
				meridiemParse: /[]\.??\.?/i,
				longDateFormat: {
					LT: 'h:mm A',
					LTS: 'h:mm:ss A',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY h:mm A',
					LLLL: 'dddd, D MMMM YYYY h:mm A'
				},
				calendarEl: {
					sameDay: '[ {}] LT',
					nextDay: '[ {}] LT',
					nextWeek: 'dddd [{}] LT',
					lastDay: '[ {}] LT',
					lastWeek: function() {
						switch(this.day()) {
							case 6:
								return '[ ] dddd [{}] LT';
							default:
								return '[ ] dddd [{}] LT';
						}
					},
					sameElse: 'L'
				},
				calendar: function(key, mom) {
					var output = this._calendarEl[key],
						hours = mom && mom.hours();
					if(isFunction(output)) {
						output = output.apply(mom);
					}
					return output.replace('{}', (hours % 12 === 1 ? '' : ''));
				},
				relativeTime: {
					future: ' %s',
					past: '%s ',
					s: ' ',
					ss: '%d ',
					m: ' ',
					mm: '%d ',
					h: ' ',
					hh: '%d ',
					d: ' ',
					dd: '%d ',
					M: ' ',
					MM: '%d ',
					y: ' ',
					yy: '%d '
				},
				dayOfMonthOrdinalParse: /\d{1,2}/,
				ordinal: '%d',
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4st is the first week of the year.
				}
			});
			
			return el;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/en-SG.js":
	/*!*********************************************!*\
  !*** ./node_modules/moment/locale/en-SG.js ***!
  \*********************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var enSG = moment.defineLocale('en-SG', {
				months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
				monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
				weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
				weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
				weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY HH:mm',
					LLLL: 'dddd, D MMMM YYYY HH:mm'
				},
				calendar: {
					sameDay: '[Today at] LT',
					nextDay: '[Tomorrow at] LT',
					nextWeek: 'dddd [at] LT',
					lastDay: '[Yesterday at] LT',
					lastWeek: '[Last] dddd [at] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: 'in %s',
					past: '%s ago',
					s: 'a few seconds',
					ss: '%d seconds',
					m: 'a minute',
					mm: '%d minutes',
					h: 'an hour',
					hh: '%d hours',
					d: 'a day',
					dd: '%d days',
					M: 'a month',
					MM: '%d months',
					y: 'a year',
					yy: '%d years'
				},
				dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
				ordinal: function(number) {
					var b = number % 10,
						output = (~~(number % 100 / 10) === 1) ? 'th' :
							(b === 1) ? 'st' :
								(b === 2) ? 'nd' :
									(b === 3) ? 'rd' : 'th';
					return number + output;
				},
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return enSG;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/en-au.js":
	/*!*********************************************!*\
  !*** ./node_modules/moment/locale/en-au.js ***!
  \*********************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var enAu = moment.defineLocale('en-au', {
				months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
				monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
				weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
				weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
				weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
				longDateFormat: {
					LT: 'h:mm A',
					LTS: 'h:mm:ss A',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY h:mm A',
					LLLL: 'dddd, D MMMM YYYY h:mm A'
				},
				calendar: {
					sameDay: '[Today at] LT',
					nextDay: '[Tomorrow at] LT',
					nextWeek: 'dddd [at] LT',
					lastDay: '[Yesterday at] LT',
					lastWeek: '[Last] dddd [at] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: 'in %s',
					past: '%s ago',
					s: 'a few seconds',
					ss: '%d seconds',
					m: 'a minute',
					mm: '%d minutes',
					h: 'an hour',
					hh: '%d hours',
					d: 'a day',
					dd: '%d days',
					M: 'a month',
					MM: '%d months',
					y: 'a year',
					yy: '%d years'
				},
				dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
				ordinal: function(number) {
					var b = number % 10,
						output = (~~(number % 100 / 10) === 1) ? 'th' :
							(b === 1) ? 'st' :
								(b === 2) ? 'nd' :
									(b === 3) ? 'rd' : 'th';
					return number + output;
				},
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return enAu;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/en-ca.js":
	/*!*********************************************!*\
  !*** ./node_modules/moment/locale/en-ca.js ***!
  \*********************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var enCa = moment.defineLocale('en-ca', {
				months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
				monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
				weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
				weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
				weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
				longDateFormat: {
					LT: 'h:mm A',
					LTS: 'h:mm:ss A',
					L: 'YYYY-MM-DD',
					LL: 'MMMM D, YYYY',
					LLL: 'MMMM D, YYYY h:mm A',
					LLLL: 'dddd, MMMM D, YYYY h:mm A'
				},
				calendar: {
					sameDay: '[Today at] LT',
					nextDay: '[Tomorrow at] LT',
					nextWeek: 'dddd [at] LT',
					lastDay: '[Yesterday at] LT',
					lastWeek: '[Last] dddd [at] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: 'in %s',
					past: '%s ago',
					s: 'a few seconds',
					ss: '%d seconds',
					m: 'a minute',
					mm: '%d minutes',
					h: 'an hour',
					hh: '%d hours',
					d: 'a day',
					dd: '%d days',
					M: 'a month',
					MM: '%d months',
					y: 'a year',
					yy: '%d years'
				},
				dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
				ordinal: function(number) {
					var b = number % 10,
						output = (~~(number % 100 / 10) === 1) ? 'th' :
							(b === 1) ? 'st' :
								(b === 2) ? 'nd' :
									(b === 3) ? 'rd' : 'th';
					return number + output;
				}
			});
			
			return enCa;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/en-gb.js":
	/*!*********************************************!*\
  !*** ./node_modules/moment/locale/en-gb.js ***!
  \*********************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var enGb = moment.defineLocale('en-gb', {
				months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
				monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
				weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
				weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
				weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY HH:mm',
					LLLL: 'dddd, D MMMM YYYY HH:mm'
				},
				calendar: {
					sameDay: '[Today at] LT',
					nextDay: '[Tomorrow at] LT',
					nextWeek: 'dddd [at] LT',
					lastDay: '[Yesterday at] LT',
					lastWeek: '[Last] dddd [at] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: 'in %s',
					past: '%s ago',
					s: 'a few seconds',
					ss: '%d seconds',
					m: 'a minute',
					mm: '%d minutes',
					h: 'an hour',
					hh: '%d hours',
					d: 'a day',
					dd: '%d days',
					M: 'a month',
					MM: '%d months',
					y: 'a year',
					yy: '%d years'
				},
				dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
				ordinal: function(number) {
					var b = number % 10,
						output = (~~(number % 100 / 10) === 1) ? 'th' :
							(b === 1) ? 'st' :
								(b === 2) ? 'nd' :
									(b === 3) ? 'rd' : 'th';
					return number + output;
				},
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return enGb;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/en-ie.js":
	/*!*********************************************!*\
  !*** ./node_modules/moment/locale/en-ie.js ***!
  \*********************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var enIe = moment.defineLocale('en-ie', {
				months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
				monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
				weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
				weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
				weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY HH:mm',
					LLLL: 'dddd D MMMM YYYY HH:mm'
				},
				calendar: {
					sameDay: '[Today at] LT',
					nextDay: '[Tomorrow at] LT',
					nextWeek: 'dddd [at] LT',
					lastDay: '[Yesterday at] LT',
					lastWeek: '[Last] dddd [at] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: 'in %s',
					past: '%s ago',
					s: 'a few seconds',
					ss: '%d seconds',
					m: 'a minute',
					mm: '%d minutes',
					h: 'an hour',
					hh: '%d hours',
					d: 'a day',
					dd: '%d days',
					M: 'a month',
					MM: '%d months',
					y: 'a year',
					yy: '%d years'
				},
				dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
				ordinal: function(number) {
					var b = number % 10,
						output = (~~(number % 100 / 10) === 1) ? 'th' :
							(b === 1) ? 'st' :
								(b === 2) ? 'nd' :
									(b === 3) ? 'rd' : 'th';
					return number + output;
				},
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return enIe;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/en-il.js":
	/*!*********************************************!*\
  !*** ./node_modules/moment/locale/en-il.js ***!
  \*********************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var enIl = moment.defineLocale('en-il', {
				months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
				monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
				weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
				weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
				weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY HH:mm',
					LLLL: 'dddd, D MMMM YYYY HH:mm'
				},
				calendar: {
					sameDay: '[Today at] LT',
					nextDay: '[Tomorrow at] LT',
					nextWeek: 'dddd [at] LT',
					lastDay: '[Yesterday at] LT',
					lastWeek: '[Last] dddd [at] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: 'in %s',
					past: '%s ago',
					s: 'a few seconds',
					m: 'a minute',
					mm: '%d minutes',
					h: 'an hour',
					hh: '%d hours',
					d: 'a day',
					dd: '%d days',
					M: 'a month',
					MM: '%d months',
					y: 'a year',
					yy: '%d years'
				},
				dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
				ordinal: function(number) {
					var b = number % 10,
						output = (~~(number % 100 / 10) === 1) ? 'th' :
							(b === 1) ? 'st' :
								(b === 2) ? 'nd' :
									(b === 3) ? 'rd' : 'th';
					return number + output;
				}
			});
			
			return enIl;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/en-nz.js":
	/*!*********************************************!*\
  !*** ./node_modules/moment/locale/en-nz.js ***!
  \*********************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var enNz = moment.defineLocale('en-nz', {
				months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
				monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
				weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
				weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
				weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
				longDateFormat: {
					LT: 'h:mm A',
					LTS: 'h:mm:ss A',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY h:mm A',
					LLLL: 'dddd, D MMMM YYYY h:mm A'
				},
				calendar: {
					sameDay: '[Today at] LT',
					nextDay: '[Tomorrow at] LT',
					nextWeek: 'dddd [at] LT',
					lastDay: '[Yesterday at] LT',
					lastWeek: '[Last] dddd [at] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: 'in %s',
					past: '%s ago',
					s: 'a few seconds',
					ss: '%d seconds',
					m: 'a minute',
					mm: '%d minutes',
					h: 'an hour',
					hh: '%d hours',
					d: 'a day',
					dd: '%d days',
					M: 'a month',
					MM: '%d months',
					y: 'a year',
					yy: '%d years'
				},
				dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
				ordinal: function(number) {
					var b = number % 10,
						output = (~~(number % 100 / 10) === 1) ? 'th' :
							(b === 1) ? 'st' :
								(b === 2) ? 'nd' :
									(b === 3) ? 'rd' : 'th';
					return number + output;
				},
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return enNz;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/eo.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/eo.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var eo = moment.defineLocale('eo', {
				months: 'januaro_februaro_marto_aprilo_majo_junio_julio_agusto_septembro_oktobro_novembro_decembro'.split('_'),
				monthsShort: 'jan_feb_mar_apr_maj_jun_jul_ag_sep_okt_nov_dec'.split('_'),
				weekdays: 'dimano_lundo_mardo_merkredo_ado_vendredo_sabato'.split('_'),
				weekdaysShort: 'dim_lun_mard_merk_a_ven_sab'.split('_'),
				weekdaysMin: 'di_lu_ma_me_a_ve_sa'.split('_'),
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'YYYY-MM-DD',
					LL: 'D[-a de] MMMM, YYYY',
					LLL: 'D[-a de] MMMM, YYYY HH:mm',
					LLLL: 'dddd, [la] D[-a de] MMMM, YYYY HH:mm'
				},
				meridiemParse: /[ap]\.t\.m/i,
				isPM: function(input) {
					return input.charAt(0).toLowerCase() === 'p';
				},
				meridiem: function(hours, minutes, isLower) {
					if(hours > 11) {
						return isLower ? 'p.t.m.' : 'P.T.M.';
					} else {
						return isLower ? 'a.t.m.' : 'A.T.M.';
					}
				},
				calendar: {
					sameDay: '[Hodia je] LT',
					nextDay: '[Morga je] LT',
					nextWeek: 'dddd [je] LT',
					lastDay: '[Hiera je] LT',
					lastWeek: '[pasinta] dddd [je] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: 'post %s',
					past: 'anta %s',
					s: 'sekundoj',
					ss: '%d sekundoj',
					m: 'minuto',
					mm: '%d minutoj',
					h: 'horo',
					hh: '%d horoj',
					d: 'tago',//ne 'diurno', ar estas uzita por proksimumo
					dd: '%d tagoj',
					M: 'monato',
					MM: '%d monatoj',
					y: 'jaro',
					yy: '%d jaroj'
				},
				dayOfMonthOrdinalParse: /\d{1,2}a/,
				ordinal: '%da',
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 7  // The week that contains Jan 7th is the first week of the year.
				}
			});
			
			return eo;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/es-do.js":
	/*!*********************************************!*\
  !*** ./node_modules/moment/locale/es-do.js ***!
  \*********************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),
				monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');
			
			var monthsParse = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i];
			var monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
			
			var esDo = moment.defineLocale('es-do', {
				months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
				monthsShort: function(m, format) {
					if(!m) {
						return monthsShortDot;
					} else if(/-MMM-/.test(format)) {
						return monthsShort[m.month()];
					} else {
						return monthsShortDot[m.month()];
					}
				},
				monthsRegex: monthsRegex,
				monthsShortRegex: monthsRegex,
				monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
				monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
				monthsParse: monthsParse,
				longMonthsParse: monthsParse,
				shortMonthsParse: monthsParse,
				weekdays: 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
				weekdaysShort: 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
				weekdaysMin: 'do_lu_ma_mi_ju_vi_s'.split('_'),
				weekdaysParseExact: true,
				longDateFormat: {
					LT: 'h:mm A',
					LTS: 'h:mm:ss A',
					L: 'DD/MM/YYYY',
					LL: 'D [de] MMMM [de] YYYY',
					LLL: 'D [de] MMMM [de] YYYY h:mm A',
					LLLL: 'dddd, D [de] MMMM [de] YYYY h:mm A'
				},
				calendar: {
					sameDay: function() {
						return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
					},
					nextDay: function() {
						return '[maana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
					},
					nextWeek: function() {
						return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
					},
					lastDay: function() {
						return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
					},
					lastWeek: function() {
						return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
					},
					sameElse: 'L'
				},
				relativeTime: {
					future: 'en %s',
					past: 'hace %s',
					s: 'unos segundos',
					ss: '%d segundos',
					m: 'un minuto',
					mm: '%d minutos',
					h: 'una hora',
					hh: '%d horas',
					d: 'un da',
					dd: '%d das',
					M: 'un mes',
					MM: '%d meses',
					y: 'un ao',
					yy: '%d aos'
				},
				dayOfMonthOrdinalParse: /\d{1,2}/,
				ordinal: '%d',
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return esDo;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/es-us.js":
	/*!*********************************************!*\
  !*** ./node_modules/moment/locale/es-us.js ***!
  \*********************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),
				monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');
			
			var monthsParse = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i];
			var monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
			
			var esUs = moment.defineLocale('es-us', {
				months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
				monthsShort: function(m, format) {
					if(!m) {
						return monthsShortDot;
					} else if(/-MMM-/.test(format)) {
						return monthsShort[m.month()];
					} else {
						return monthsShortDot[m.month()];
					}
				},
				monthsRegex: monthsRegex,
				monthsShortRegex: monthsRegex,
				monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
				monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
				monthsParse: monthsParse,
				longMonthsParse: monthsParse,
				shortMonthsParse: monthsParse,
				weekdays: 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
				weekdaysShort: 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
				weekdaysMin: 'do_lu_ma_mi_ju_vi_s'.split('_'),
				weekdaysParseExact: true,
				longDateFormat: {
					LT: 'h:mm A',
					LTS: 'h:mm:ss A',
					L: 'MM/DD/YYYY',
					LL: 'D [de] MMMM [de] YYYY',
					LLL: 'D [de] MMMM [de] YYYY h:mm A',
					LLLL: 'dddd, D [de] MMMM [de] YYYY h:mm A'
				},
				calendar: {
					sameDay: function() {
						return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
					},
					nextDay: function() {
						return '[maana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
					},
					nextWeek: function() {
						return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
					},
					lastDay: function() {
						return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
					},
					lastWeek: function() {
						return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
					},
					sameElse: 'L'
				},
				relativeTime: {
					future: 'en %s',
					past: 'hace %s',
					s: 'unos segundos',
					ss: '%d segundos',
					m: 'un minuto',
					mm: '%d minutos',
					h: 'una hora',
					hh: '%d horas',
					d: 'un da',
					dd: '%d das',
					M: 'un mes',
					MM: '%d meses',
					y: 'un ao',
					yy: '%d aos'
				},
				dayOfMonthOrdinalParse: /\d{1,2}/,
				ordinal: '%d',
				week: {
					dow: 0, // Sunday is the first day of the week.
					doy: 6  // The week that contains Jan 6th is the first week of the year.
				}
			});
			
			return esUs;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/es.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/es.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),
				monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');
			
			var monthsParse = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i];
			var monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
			
			var es = moment.defineLocale('es', {
				months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
				monthsShort: function(m, format) {
					if(!m) {
						return monthsShortDot;
					} else if(/-MMM-/.test(format)) {
						return monthsShort[m.month()];
					} else {
						return monthsShortDot[m.month()];
					}
				},
				monthsRegex: monthsRegex,
				monthsShortRegex: monthsRegex,
				monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
				monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
				monthsParse: monthsParse,
				longMonthsParse: monthsParse,
				shortMonthsParse: monthsParse,
				weekdays: 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
				weekdaysShort: 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
				weekdaysMin: 'do_lu_ma_mi_ju_vi_s'.split('_'),
				weekdaysParseExact: true,
				longDateFormat: {
					LT: 'H:mm',
					LTS: 'H:mm:ss',
					L: 'DD/MM/YYYY',
					LL: 'D [de] MMMM [de] YYYY',
					LLL: 'D [de] MMMM [de] YYYY H:mm',
					LLLL: 'dddd, D [de] MMMM [de] YYYY H:mm'
				},
				calendar: {
					sameDay: function() {
						return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
					},
					nextDay: function() {
						return '[maana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
					},
					nextWeek: function() {
						return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
					},
					lastDay: function() {
						return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
					},
					lastWeek: function() {
						return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
					},
					sameElse: 'L'
				},
				relativeTime: {
					future: 'en %s',
					past: 'hace %s',
					s: 'unos segundos',
					ss: '%d segundos',
					m: 'un minuto',
					mm: '%d minutos',
					h: 'una hora',
					hh: '%d horas',
					d: 'un da',
					dd: '%d das',
					M: 'un mes',
					MM: '%d meses',
					y: 'un ao',
					yy: '%d aos'
				},
				dayOfMonthOrdinalParse: /\d{1,2}/,
				ordinal: '%d',
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return es;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/et.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/et.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			function processRelativeTime(number, withoutSuffix, key, isFuture) {
				var format = {
					's': ['mne sekundi', 'mni sekund', 'paar sekundit'],
					'ss': [number + 'sekundi', number + 'sekundit'],
					'm': ['he minuti', 'ks minut'],
					'mm': [number + ' minuti', number + ' minutit'],
					'h': ['he tunni', 'tund aega', 'ks tund'],
					'hh': [number + ' tunni', number + ' tundi'],
					'd': ['he peva', 'ks pev'],
					'M': ['kuu aja', 'kuu aega', 'ks kuu'],
					'MM': [number + ' kuu', number + ' kuud'],
					'y': ['he aasta', 'aasta', 'ks aasta'],
					'yy': [number + ' aasta', number + ' aastat']
				};
				if(withoutSuffix) {
					return format[key][2] ? format[key][2] : format[key][1];
				}
				return isFuture ? format[key][0] : format[key][1];
			}
			
			var et = moment.defineLocale('et', {
				months: 'jaanuar_veebruar_mrts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember'.split('_'),
				monthsShort: 'jaan_veebr_mrts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets'.split('_'),
				weekdays: 'phapev_esmaspev_teisipev_kolmapev_neljapev_reede_laupev'.split('_'),
				weekdaysShort: 'P_E_T_K_N_R_L'.split('_'),
				weekdaysMin: 'P_E_T_K_N_R_L'.split('_'),
				longDateFormat: {
					LT: 'H:mm',
					LTS: 'H:mm:ss',
					L: 'DD.MM.YYYY',
					LL: 'D. MMMM YYYY',
					LLL: 'D. MMMM YYYY H:mm',
					LLLL: 'dddd, D. MMMM YYYY H:mm'
				},
				calendar: {
					sameDay: '[Tna,] LT',
					nextDay: '[Homme,] LT',
					nextWeek: '[Jrgmine] dddd LT',
					lastDay: '[Eile,] LT',
					lastWeek: '[Eelmine] dddd LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: '%s prast',
					past: '%s tagasi',
					s: processRelativeTime,
					ss: processRelativeTime,
					m: processRelativeTime,
					mm: processRelativeTime,
					h: processRelativeTime,
					hh: processRelativeTime,
					d: processRelativeTime,
					dd: '%d peva',
					M: processRelativeTime,
					MM: processRelativeTime,
					y: processRelativeTime,
					yy: processRelativeTime
				},
				dayOfMonthOrdinalParse: /\d{1,2}\./,
				ordinal: '%d.',
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return et;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/eu.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/eu.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var eu = moment.defineLocale('eu', {
				months: 'urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua'.split('_'),
				monthsShort: 'urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.'.split('_'),
				monthsParseExact: true,
				weekdays: 'igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata'.split('_'),
				weekdaysShort: 'ig._al._ar._az._og._ol._lr.'.split('_'),
				weekdaysMin: 'ig_al_ar_az_og_ol_lr'.split('_'),
				weekdaysParseExact: true,
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'YYYY-MM-DD',
					LL: 'YYYY[ko] MMMM[ren] D[a]',
					LLL: 'YYYY[ko] MMMM[ren] D[a] HH:mm',
					LLLL: 'dddd, YYYY[ko] MMMM[ren] D[a] HH:mm',
					l: 'YYYY-M-D',
					ll: 'YYYY[ko] MMM D[a]',
					lll: 'YYYY[ko] MMM D[a] HH:mm',
					llll: 'ddd, YYYY[ko] MMM D[a] HH:mm'
				},
				calendar: {
					sameDay: '[gaur] LT[etan]',
					nextDay: '[bihar] LT[etan]',
					nextWeek: 'dddd LT[etan]',
					lastDay: '[atzo] LT[etan]',
					lastWeek: '[aurreko] dddd LT[etan]',
					sameElse: 'L'
				},
				relativeTime: {
					future: '%s barru',
					past: 'duela %s',
					s: 'segundo batzuk',
					ss: '%d segundo',
					m: 'minutu bat',
					mm: '%d minutu',
					h: 'ordu bat',
					hh: '%d ordu',
					d: 'egun bat',
					dd: '%d egun',
					M: 'hilabete bat',
					MM: '%d hilabete',
					y: 'urte bat',
					yy: '%d urte'
				},
				dayOfMonthOrdinalParse: /\d{1,2}\./,
				ordinal: '%d.',
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 7  // The week that contains Jan 7th is the first week of the year.
				}
			});
			
			return eu;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/fa.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/fa.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var symbolMap = {
				'1': '',
				'2': '',
				'3': '',
				'4': '',
				'5': '',
				'6': '',
				'7': '',
				'8': '',
				'9': '',
				'0': ''
			}, numberMap = {
				'': '1',
				'': '2',
				'': '3',
				'': '4',
				'': '5',
				'': '6',
				'': '7',
				'': '8',
				'': '9',
				'': '0'
			};
			
			var fa = moment.defineLocale('fa', {
				months: '___________'.split('_'),
				monthsShort: '___________'.split('_'),
				weekdays: '\u200c__\u200c__\u200c__'.split('_'),
				weekdaysShort: '\u200c__\u200c__\u200c__'.split('_'),
				weekdaysMin: '______'.split('_'),
				weekdaysParseExact: true,
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY HH:mm',
					LLLL: 'dddd, D MMMM YYYY HH:mm'
				},
				meridiemParse: /  |  /,
				isPM: function(input) {
					return /  /.test(input);
				},
				meridiem: function(hour, minute, isLower) {
					if(hour < 12) {
						return '  ';
					} else {
						return '  ';
					}
				},
				calendar: {
					sameDay: '[ ] LT',
					nextDay: '[ ] LT',
					nextWeek: 'dddd [] LT',
					lastDay: '[ ] LT',
					lastWeek: 'dddd [] [] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: ' %s',
					past: '%s ',
					s: ' ',
					ss: ' d%',
					m: ' ',
					mm: '%d ',
					h: ' ',
					hh: '%d ',
					d: ' ',
					dd: '%d ',
					M: ' ',
					MM: '%d ',
					y: ' ',
					yy: '%d '
				},
				preparse: function(string) {
					return string.replace(/[-]/g, function(match) {
						return numberMap[match];
					}).replace(//g, ',');
				},
				postformat: function(string) {
					return string.replace(/\d/g, function(match) {
						return symbolMap[match];
					}).replace(/,/g, '');
				},
				dayOfMonthOrdinalParse: /\d{1,2}/,
				ordinal: '%d',
				week: {
					dow: 6, // Saturday is the first day of the week.
					doy: 12 // The week that contains Jan 12th is the first week of the year.
				}
			});
			
			return fa;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/fi.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/fi.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var numbersPast = 'nolla yksi kaksi kolme nelj viisi kuusi seitsemn kahdeksan yhdeksn'.split(' '),
				numbersFuture = [
					'nolla', 'yhden', 'kahden', 'kolmen', 'neljn', 'viiden', 'kuuden',
					numbersPast[7], numbersPast[8], numbersPast[9]
				];
			
			function translate(number, withoutSuffix, key, isFuture) {
				var result = '';
				switch(key) {
					case 's':
						return isFuture ? 'muutaman sekunnin' : 'muutama sekunti';
					case 'ss':
						return isFuture ? 'sekunnin' : 'sekuntia';
					case 'm':
						return isFuture ? 'minuutin' : 'minuutti';
					case 'mm':
						result = isFuture ? 'minuutin' : 'minuuttia';
						break;
					case 'h':
						return isFuture ? 'tunnin' : 'tunti';
					case 'hh':
						result = isFuture ? 'tunnin' : 'tuntia';
						break;
					case 'd':
						return isFuture ? 'pivn' : 'piv';
					case 'dd':
						result = isFuture ? 'pivn' : 'piv';
						break;
					case 'M':
						return isFuture ? 'kuukauden' : 'kuukausi';
					case 'MM':
						result = isFuture ? 'kuukauden' : 'kuukautta';
						break;
					case 'y':
						return isFuture ? 'vuoden' : 'vuosi';
					case 'yy':
						result = isFuture ? 'vuoden' : 'vuotta';
						break;
				}
				result = verbalNumber(number, isFuture) + ' ' + result;
				return result;
			}
			
			function verbalNumber(number, isFuture) {
				return number < 10 ? (isFuture ? numbersFuture[number] : numbersPast[number]) : number;
			}
			
			var fi = moment.defineLocale('fi', {
				months: 'tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_keskuu_heinkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu'.split('_'),
				monthsShort: 'tammi_helmi_maalis_huhti_touko_kes_hein_elo_syys_loka_marras_joulu'.split('_'),
				weekdays: 'sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai'.split('_'),
				weekdaysShort: 'su_ma_ti_ke_to_pe_la'.split('_'),
				weekdaysMin: 'su_ma_ti_ke_to_pe_la'.split('_'),
				longDateFormat: {
					LT: 'HH.mm',
					LTS: 'HH.mm.ss',
					L: 'DD.MM.YYYY',
					LL: 'Do MMMM[ta] YYYY',
					LLL: 'Do MMMM[ta] YYYY, [klo] HH.mm',
					LLLL: 'dddd, Do MMMM[ta] YYYY, [klo] HH.mm',
					l: 'D.M.YYYY',
					ll: 'Do MMM YYYY',
					lll: 'Do MMM YYYY, [klo] HH.mm',
					llll: 'ddd, Do MMM YYYY, [klo] HH.mm'
				},
				calendar: {
					sameDay: '[tnn] [klo] LT',
					nextDay: '[huomenna] [klo] LT',
					nextWeek: 'dddd [klo] LT',
					lastDay: '[eilen] [klo] LT',
					lastWeek: '[viime] dddd[na] [klo] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: '%s pst',
					past: '%s sitten',
					s: translate,
					ss: translate,
					m: translate,
					mm: translate,
					h: translate,
					hh: translate,
					d: translate,
					dd: translate,
					M: translate,
					MM: translate,
					y: translate,
					yy: translate
				},
				dayOfMonthOrdinalParse: /\d{1,2}\./,
				ordinal: '%d.',
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return fi;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/fo.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/fo.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var fo = moment.defineLocale('fo', {
				months: 'januar_februar_mars_aprl_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
				monthsShort: 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
				weekdays: 'sunnudagur_mnadagur_tsdagur_mikudagur_hsdagur_frggjadagur_leygardagur'.split('_'),
				weekdaysShort: 'sun_mn_ts_mik_hs_fr_ley'.split('_'),
				weekdaysMin: 'su_m_t_mi_h_fr_le'.split('_'),
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY HH:mm',
					LLLL: 'dddd D. MMMM, YYYY HH:mm'
				},
				calendar: {
					sameDay: '[ dag kl.] LT',
					nextDay: '[ morgin kl.] LT',
					nextWeek: 'dddd [kl.] LT',
					lastDay: '[ gjr kl.] LT',
					lastWeek: '[sstu] dddd [kl] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: 'um %s',
					past: '%s sani',
					s: 'f sekund',
					ss: '%d sekundir',
					m: 'ein minuttur',
					mm: '%d minuttir',
					h: 'ein tmi',
					hh: '%d tmar',
					d: 'ein dagur',
					dd: '%d dagar',
					M: 'ein mnaur',
					MM: '%d mnair',
					y: 'eitt r',
					yy: '%d r'
				},
				dayOfMonthOrdinalParse: /\d{1,2}\./,
				ordinal: '%d.',
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return fo;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/fr-ca.js":
	/*!*********************************************!*\
  !*** ./node_modules/moment/locale/fr-ca.js ***!
  \*********************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var frCa = moment.defineLocale('fr-ca', {
				months: 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
				monthsShort: 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
				monthsParseExact: true,
				weekdays: 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
				weekdaysShort: 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
				weekdaysMin: 'di_lu_ma_me_je_ve_sa'.split('_'),
				weekdaysParseExact: true,
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'YYYY-MM-DD',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY HH:mm',
					LLLL: 'dddd D MMMM YYYY HH:mm'
				},
				calendar: {
					sameDay: '[Aujourdhui ] LT',
					nextDay: '[Demain ] LT',
					nextWeek: 'dddd [] LT',
					lastDay: '[Hier ] LT',
					lastWeek: 'dddd [dernier ] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: 'dans %s',
					past: 'il y a %s',
					s: 'quelques secondes',
					ss: '%d secondes',
					m: 'une minute',
					mm: '%d minutes',
					h: 'une heure',
					hh: '%d heures',
					d: 'un jour',
					dd: '%d jours',
					M: 'un mois',
					MM: '%d mois',
					y: 'un an',
					yy: '%d ans'
				},
				dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
				ordinal: function(number, period) {
					switch(period) {
						// Words with masculine grammatical gender: mois, trimestre, jour
						default:
						case 'M':
						case 'Q':
						case 'D':
						case 'DDD':
						case 'd':
							return number + (number === 1 ? 'er' : 'e');
						
						// Words with feminine grammatical gender: semaine
						case 'w':
						case 'W':
							return number + (number === 1 ? 're' : 'e');
					}
				}
			});
			
			return frCa;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/fr-ch.js":
	/*!*********************************************!*\
  !*** ./node_modules/moment/locale/fr-ch.js ***!
  \*********************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var frCh = moment.defineLocale('fr-ch', {
				months: 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
				monthsShort: 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
				monthsParseExact: true,
				weekdays: 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
				weekdaysShort: 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
				weekdaysMin: 'di_lu_ma_me_je_ve_sa'.split('_'),
				weekdaysParseExact: true,
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD.MM.YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY HH:mm',
					LLLL: 'dddd D MMMM YYYY HH:mm'
				},
				calendar: {
					sameDay: '[Aujourdhui ] LT',
					nextDay: '[Demain ] LT',
					nextWeek: 'dddd [] LT',
					lastDay: '[Hier ] LT',
					lastWeek: 'dddd [dernier ] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: 'dans %s',
					past: 'il y a %s',
					s: 'quelques secondes',
					ss: '%d secondes',
					m: 'une minute',
					mm: '%d minutes',
					h: 'une heure',
					hh: '%d heures',
					d: 'un jour',
					dd: '%d jours',
					M: 'un mois',
					MM: '%d mois',
					y: 'un an',
					yy: '%d ans'
				},
				dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
				ordinal: function(number, period) {
					switch(period) {
						// Words with masculine grammatical gender: mois, trimestre, jour
						default:
						case 'M':
						case 'Q':
						case 'D':
						case 'DDD':
						case 'd':
							return number + (number === 1 ? 'er' : 'e');
						
						// Words with feminine grammatical gender: semaine
						case 'w':
						case 'W':
							return number + (number === 1 ? 're' : 'e');
					}
				},
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return frCh;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/fr.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/fr.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var fr = moment.defineLocale('fr', {
				months: 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
				monthsShort: 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
				monthsParseExact: true,
				weekdays: 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
				weekdaysShort: 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
				weekdaysMin: 'di_lu_ma_me_je_ve_sa'.split('_'),
				weekdaysParseExact: true,
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY HH:mm',
					LLLL: 'dddd D MMMM YYYY HH:mm'
				},
				calendar: {
					sameDay: '[Aujourdhui ] LT',
					nextDay: '[Demain ] LT',
					nextWeek: 'dddd [] LT',
					lastDay: '[Hier ] LT',
					lastWeek: 'dddd [dernier ] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: 'dans %s',
					past: 'il y a %s',
					s: 'quelques secondes',
					ss: '%d secondes',
					m: 'une minute',
					mm: '%d minutes',
					h: 'une heure',
					hh: '%d heures',
					d: 'un jour',
					dd: '%d jours',
					M: 'un mois',
					MM: '%d mois',
					y: 'un an',
					yy: '%d ans'
				},
				dayOfMonthOrdinalParse: /\d{1,2}(er|)/,
				ordinal: function(number, period) {
					switch(period) {
						// TODO: Return 'e' when day of month > 1. Move this case inside
						// block for masculine words below.
						// See https://github.com/moment/moment/issues/3375
						case 'D':
							return number + (number === 1 ? 'er' : '');
						
						// Words with masculine grammatical gender: mois, trimestre, jour
						default:
						case 'M':
						case 'Q':
						case 'DDD':
						case 'd':
							return number + (number === 1 ? 'er' : 'e');
						
						// Words with feminine grammatical gender: semaine
						case 'w':
						case 'W':
							return number + (number === 1 ? 're' : 'e');
					}
				},
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return fr;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/fy.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/fy.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var monthsShortWithDots = 'jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.'.split('_'),
				monthsShortWithoutDots = 'jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_');
			
			var fy = moment.defineLocale('fy', {
				months: 'jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber'.split('_'),
				monthsShort: function(m, format) {
					if(!m) {
						return monthsShortWithDots;
					} else if(/-MMM-/.test(format)) {
						return monthsShortWithoutDots[m.month()];
					} else {
						return monthsShortWithDots[m.month()];
					}
				},
				monthsParseExact: true,
				weekdays: 'snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon'.split('_'),
				weekdaysShort: 'si._mo._ti._wo._to._fr._so.'.split('_'),
				weekdaysMin: 'Si_Mo_Ti_Wo_To_Fr_So'.split('_'),
				weekdaysParseExact: true,
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD-MM-YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY HH:mm',
					LLLL: 'dddd D MMMM YYYY HH:mm'
				},
				calendar: {
					sameDay: '[hjoed om] LT',
					nextDay: '[moarn om] LT',
					nextWeek: 'dddd [om] LT',
					lastDay: '[juster om] LT',
					lastWeek: '[frne] dddd [om] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: 'oer %s',
					past: '%s lyn',
					s: 'in pear sekonden',
					ss: '%d sekonden',
					m: 'ien mint',
					mm: '%d minuten',
					h: 'ien oere',
					hh: '%d oeren',
					d: 'ien dei',
					dd: '%d dagen',
					M: 'ien moanne',
					MM: '%d moannen',
					y: 'ien jier',
					yy: '%d jierren'
				},
				dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
				ordinal: function(number) {
					return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
				},
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return fy;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/ga.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/ga.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var months = [
				'Eanir', 'Feabhra', 'Mrta', 'Aibren', 'Bealtaine', 'Mitheamh', 'Iil', 'Lnasa', 'Men Fmhair', 'Deaireadh Fmhair', 'Samhain', 'Nollaig'
			];
			
			var monthsShort = ['Ean', 'Feab', 'Mrt', 'Aibr', 'Beal', 'Mit', 'Iil', 'Lna', 'Men', 'Deai', 'Samh', 'Noll'];
			
			var weekdays = ['D Domhnaigh', 'D Luain', 'D Mirt', 'D Cadaoin', 'Dardaoin', 'D hAoine', 'D Satharn'];
			
			var weekdaysShort = ['Dom', 'Lua', 'Mi', 'Ca', 'Da', 'hAo', 'Sat'];
			
			var weekdaysMin = ['Do', 'Lu', 'M', 'Ce', 'D', 'hA', 'Sa'];
			
			var ga = moment.defineLocale('ga', {
				months: months,
				monthsShort: monthsShort,
				monthsParseExact: true,
				weekdays: weekdays,
				weekdaysShort: weekdaysShort,
				weekdaysMin: weekdaysMin,
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY HH:mm',
					LLLL: 'dddd, D MMMM YYYY HH:mm'
				},
				calendar: {
					sameDay: '[Inniu ag] LT',
					nextDay: '[Amrach ag] LT',
					nextWeek: 'dddd [ag] LT',
					lastDay: '[Inn aig] LT',
					lastWeek: 'dddd [seo caite] [ag] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: 'i %s',
					past: '%s  shin',
					s: 'cpla soicind',
					ss: '%d soicind',
					m: 'nimad',
					mm: '%d nimad',
					h: 'uair an chloig',
					hh: '%d uair an chloig',
					d: 'l',
					dd: '%d l',
					M: 'm',
					MM: '%d m',
					y: 'bliain',
					yy: '%d bliain'
				},
				dayOfMonthOrdinalParse: /\d{1,2}(d|na|mh)/,
				ordinal: function(number) {
					var output = number === 1 ? 'd' : number % 10 === 2 ? 'na' : 'mh';
					return number + output;
				},
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return ga;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/gd.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/gd.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var months = [
				'Am Faoilleach', 'An Gearran', 'Am Mrt', 'An Giblean', 'An Citean', 'An t-gmhios', 'An t-Iuchar', 'An Lnastal', 'An t-Sultain', 'An Dmhair', 'An t-Samhain', 'An Dbhlachd'
			];
			
			var monthsShort = ['Faoi', 'Gear', 'Mrt', 'Gibl', 'Cit', 'gmh', 'Iuch', 'Ln', 'Sult', 'Dmh', 'Samh', 'Dbh'];
			
			var weekdays = ['Didmhnaich', 'Diluain', 'Dimirt', 'Diciadain', 'Diardaoin', 'Dihaoine', 'Disathairne'];
			
			var weekdaysShort = ['Did', 'Dil', 'Dim', 'Dic', 'Dia', 'Dih', 'Dis'];
			
			var weekdaysMin = ['D', 'Lu', 'M', 'Ci', 'Ar', 'Ha', 'Sa'];
			
			var gd = moment.defineLocale('gd', {
				months: months,
				monthsShort: monthsShort,
				monthsParseExact: true,
				weekdays: weekdays,
				weekdaysShort: weekdaysShort,
				weekdaysMin: weekdaysMin,
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY HH:mm',
					LLLL: 'dddd, D MMMM YYYY HH:mm'
				},
				calendar: {
					sameDay: '[An-diugh aig] LT',
					nextDay: '[A-mireach aig] LT',
					nextWeek: 'dddd [aig] LT',
					lastDay: '[An-d aig] LT',
					lastWeek: 'dddd [seo chaidh] [aig] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: 'ann an %s',
					past: 'bho chionn %s',
					s: 'beagan diogan',
					ss: '%d diogan',
					m: 'mionaid',
					mm: '%d mionaidean',
					h: 'uair',
					hh: '%d uairean',
					d: 'latha',
					dd: '%d latha',
					M: 'mos',
					MM: '%d mosan',
					y: 'bliadhna',
					yy: '%d bliadhna'
				},
				dayOfMonthOrdinalParse: /\d{1,2}(d|na|mh)/,
				ordinal: function(number) {
					var output = number === 1 ? 'd' : number % 10 === 2 ? 'na' : 'mh';
					return number + output;
				},
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return gd;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/gl.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/gl.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var gl = moment.defineLocale('gl', {
				months: 'xaneiro_febreiro_marzo_abril_maio_xuo_xullo_agosto_setembro_outubro_novembro_decembro'.split('_'),
				monthsShort: 'xan._feb._mar._abr._mai._xu._xul._ago._set._out._nov._dec.'.split('_'),
				monthsParseExact: true,
				weekdays: 'domingo_luns_martes_mrcores_xoves_venres_sbado'.split('_'),
				weekdaysShort: 'dom._lun._mar._mr._xov._ven._sb.'.split('_'),
				weekdaysMin: 'do_lu_ma_m_xo_ve_s'.split('_'),
				weekdaysParseExact: true,
				longDateFormat: {
					LT: 'H:mm',
					LTS: 'H:mm:ss',
					L: 'DD/MM/YYYY',
					LL: 'D [de] MMMM [de] YYYY',
					LLL: 'D [de] MMMM [de] YYYY H:mm',
					LLLL: 'dddd, D [de] MMMM [de] YYYY H:mm'
				},
				calendar: {
					sameDay: function() {
						return '[hoxe ' + ((this.hours() !== 1) ? 's' : '') + '] LT';
					},
					nextDay: function() {
						return '[ma ' + ((this.hours() !== 1) ? 's' : '') + '] LT';
					},
					nextWeek: function() {
						return 'dddd [' + ((this.hours() !== 1) ? 's' : 'a') + '] LT';
					},
					lastDay: function() {
						return '[onte ' + ((this.hours() !== 1) ? '' : 'a') + '] LT';
					},
					lastWeek: function() {
						return '[o] dddd [pasado ' + ((this.hours() !== 1) ? 's' : 'a') + '] LT';
					},
					sameElse: 'L'
				},
				relativeTime: {
					future: function(str) {
						if(str.indexOf('un') === 0) {
							return 'n' + str;
						}
						return 'en ' + str;
					},
					past: 'hai %s',
					s: 'uns segundos',
					ss: '%d segundos',
					m: 'un minuto',
					mm: '%d minutos',
					h: 'unha hora',
					hh: '%d horas',
					d: 'un da',
					dd: '%d das',
					M: 'un mes',
					MM: '%d meses',
					y: 'un ano',
					yy: '%d anos'
				},
				dayOfMonthOrdinalParse: /\d{1,2}/,
				ordinal: '%d',
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return gl;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/gom-latn.js":
	/*!************************************************!*\
  !*** ./node_modules/moment/locale/gom-latn.js ***!
  \************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			function processRelativeTime(number, withoutSuffix, key, isFuture) {
				var format = {
					's': ['thodde secondanim', 'thodde second'],
					'ss': [number + ' secondanim', number + ' second'],
					'm': ['eka mintan', 'ek minute'],
					'mm': [number + ' mintanim', number + ' mintam'],
					'h': ['eka voran', 'ek vor'],
					'hh': [number + ' voranim', number + ' voram'],
					'd': ['eka disan', 'ek dis'],
					'dd': [number + ' disanim', number + ' dis'],
					'M': ['eka mhoinean', 'ek mhoino'],
					'MM': [number + ' mhoineanim', number + ' mhoine'],
					'y': ['eka vorsan', 'ek voros'],
					'yy': [number + ' vorsanim', number + ' vorsam']
				};
				return withoutSuffix ? format[key][0] : format[key][1];
			}
			
			var gomLatn = moment.defineLocale('gom-latn', {
				months: 'Janer_Febrer_Mars_Abril_Mai_Jun_Julai_Agost_Setembr_Otubr_Novembr_Dezembr'.split('_'),
				monthsShort: 'Jan._Feb._Mars_Abr._Mai_Jun_Jul._Ago._Set._Otu._Nov._Dez.'.split('_'),
				monthsParseExact: true,
				weekdays: 'Aitar_Somar_Mongllar_Budvar_Brestar_Sukrar_Son\'var'.split('_'),
				weekdaysShort: 'Ait._Som._Mon._Bud._Bre._Suk._Son.'.split('_'),
				weekdaysMin: 'Ai_Sm_Mo_Bu_Br_Su_Sn'.split('_'),
				weekdaysParseExact: true,
				longDateFormat: {
					LT: 'A h:mm [vazta]',
					LTS: 'A h:mm:ss [vazta]',
					L: 'DD-MM-YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY A h:mm [vazta]',
					LLLL: 'dddd, MMMM[achea] Do, YYYY, A h:mm [vazta]',
					llll: 'ddd, D MMM YYYY, A h:mm [vazta]'
				},
				calendar: {
					sameDay: '[Aiz] LT',
					nextDay: '[Faleam] LT',
					nextWeek: '[Ieta to] dddd[,] LT',
					lastDay: '[Kal] LT',
					lastWeek: '[Fatlo] dddd[,] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: '%s',
					past: '%s adim',
					s: processRelativeTime,
					ss: processRelativeTime,
					m: processRelativeTime,
					mm: processRelativeTime,
					h: processRelativeTime,
					hh: processRelativeTime,
					d: processRelativeTime,
					dd: processRelativeTime,
					M: processRelativeTime,
					MM: processRelativeTime,
					y: processRelativeTime,
					yy: processRelativeTime
				},
				dayOfMonthOrdinalParse: /\d{1,2}(er)/,
				ordinal: function(number, period) {
					switch(period) {
						// the ordinal 'er' only applies to day of the month
						case 'D':
							return number + 'er';
						default:
						case 'M':
						case 'Q':
						case 'DDD':
						case 'd':
						case 'w':
						case 'W':
							return number;
					}
				},
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				},
				meridiemParse: /rati|sokalli|donparam|sanje/,
				meridiemHour: function(hour, meridiem) {
					if(hour === 12) {
						hour = 0;
					}
					if(meridiem === 'rati') {
						return hour < 4 ? hour : hour + 12;
					} else if(meridiem === 'sokalli') {
						return hour;
					} else if(meridiem === 'donparam') {
						return hour > 12 ? hour : hour + 12;
					} else if(meridiem === 'sanje') {
						return hour + 12;
					}
				},
				meridiem: function(hour, minute, isLower) {
					if(hour < 4) {
						return 'rati';
					} else if(hour < 12) {
						return 'sokalli';
					} else if(hour < 16) {
						return 'donparam';
					} else if(hour < 20) {
						return 'sanje';
					} else {
						return 'rati';
					}
				}
			});
			
			return gomLatn;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/gu.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/gu.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var symbolMap = {
					'1': '',
					'2': '',
					'3': '',
					'4': '',
					'5': '',
					'6': '',
					'7': '',
					'8': '',
					'9': '',
					'0': ''
				},
				numberMap = {
					'': '1',
					'': '2',
					'': '3',
					'': '4',
					'': '5',
					'': '6',
					'': '7',
					'': '8',
					'': '9',
					'': '0'
				};
			
			var gu = moment.defineLocale('gu', {
				months: '___________'.split('_'),
				monthsShort: '._.__.___._._._._._.'.split('_'),
				monthsParseExact: true,
				weekdays: '______'.split('_'),
				weekdaysShort: '______'.split('_'),
				weekdaysMin: '______'.split('_'),
				longDateFormat: {
					LT: 'A h:mm ',
					LTS: 'A h:mm:ss ',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY, A h:mm ',
					LLLL: 'dddd, D MMMM YYYY, A h:mm '
				},
				calendar: {
					sameDay: '[] LT',
					nextDay: '[] LT',
					nextWeek: 'dddd, LT',
					lastDay: '[] LT',
					lastWeek: '[] dddd, LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: '%s ',
					past: '%s ',
					s: ' ',
					ss: '%d ',
					m: ' ',
					mm: '%d ',
					h: ' ',
					hh: '%d ',
					d: ' ',
					dd: '%d ',
					M: ' ',
					MM: '%d ',
					y: ' ',
					yy: '%d '
				},
				preparse: function(string) {
					return string.replace(/[]/g, function(match) {
						return numberMap[match];
					});
				},
				postformat: function(string) {
					return string.replace(/\d/g, function(match) {
						return symbolMap[match];
					});
				},
				// Gujarati notation for meridiems are quite fuzzy in practice. While there exists
				// a rigid notion of a 'Pahar' it is not used as rigidly in modern Gujarati.
				meridiemParse: /|||/,
				meridiemHour: function(hour, meridiem) {
					if(hour === 12) {
						hour = 0;
					}
					if(meridiem === '') {
						return hour < 4 ? hour : hour + 12;
					} else if(meridiem === '') {
						return hour;
					} else if(meridiem === '') {
						return hour >= 10 ? hour : hour + 12;
					} else if(meridiem === '') {
						return hour + 12;
					}
				},
				meridiem: function(hour, minute, isLower) {
					if(hour < 4) {
						return '';
					} else if(hour < 10) {
						return '';
					} else if(hour < 17) {
						return '';
					} else if(hour < 20) {
						return '';
					} else {
						return '';
					}
				},
				week: {
					dow: 0, // Sunday is the first day of the week.
					doy: 6 // The week that contains Jan 6th is the first week of the year.
				}
			});
			
			return gu;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/he.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/he.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var he = moment.defineLocale('he', {
				months: '___________'.split('_'),
				monthsShort: '___________'.split('_'),
				weekdays: '______'.split('_'),
				weekdaysShort: '______'.split('_'),
				weekdaysMin: '______'.split('_'),
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD/MM/YYYY',
					LL: 'D []MMMM YYYY',
					LLL: 'D []MMMM YYYY HH:mm',
					LLLL: 'dddd, D []MMMM YYYY HH:mm',
					l: 'D/M/YYYY',
					ll: 'D MMM YYYY',
					lll: 'D MMM YYYY HH:mm',
					llll: 'ddd, D MMM YYYY HH:mm'
				},
				calendar: {
					sameDay: '[ ]LT',
					nextDay: '[ ]LT',
					nextWeek: 'dddd [] LT',
					lastDay: '[ ]LT',
					lastWeek: '[] dddd [ ] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: ' %s',
					past: ' %s',
					s: ' ',
					ss: '%d ',
					m: '',
					mm: '%d ',
					h: '',
					hh: function(number) {
						if(number === 2) {
							return '';
						}
						return number + ' ';
					},
					d: '',
					dd: function(number) {
						if(number === 2) {
							return '';
						}
						return number + ' ';
					},
					M: '',
					MM: function(number) {
						if(number === 2) {
							return '';
						}
						return number + ' ';
					},
					y: '',
					yy: function(number) {
						if(number === 2) {
							return '';
						} else if(number % 10 === 0 && number !== 10) {
							return number + ' ';
						}
						return number + ' ';
					}
				},
				meridiemParse: /"|"| | | ||/i,
				isPM: function(input) {
					return /^("| |)$/.test(input);
				},
				meridiem: function(hour, minute, isLower) {
					if(hour < 5) {
						return ' ';
					} else if(hour < 10) {
						return '';
					} else if(hour < 12) {
						return isLower ? '"' : ' ';
					} else if(hour < 18) {
						return isLower ? '"' : ' ';
					} else {
						return '';
					}
				}
			});
			
			return he;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/hi.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/hi.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var symbolMap = {
					'1': '',
					'2': '',
					'3': '',
					'4': '',
					'5': '',
					'6': '',
					'7': '',
					'8': '',
					'9': '',
					'0': ''
				},
				numberMap = {
					'': '1',
					'': '2',
					'': '3',
					'': '4',
					'': '5',
					'': '6',
					'': '7',
					'': '8',
					'': '9',
					'': '0'
				};
			
			var hi = moment.defineLocale('hi', {
				months: '___________'.split('_'),
				monthsShort: '._.__.___._._._._._.'.split('_'),
				monthsParseExact: true,
				weekdays: '______'.split('_'),
				weekdaysShort: '______'.split('_'),
				weekdaysMin: '______'.split('_'),
				longDateFormat: {
					LT: 'A h:mm ',
					LTS: 'A h:mm:ss ',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY, A h:mm ',
					LLLL: 'dddd, D MMMM YYYY, A h:mm '
				},
				calendar: {
					sameDay: '[] LT',
					nextDay: '[] LT',
					nextWeek: 'dddd, LT',
					lastDay: '[] LT',
					lastWeek: '[] dddd, LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: '%s ',
					past: '%s ',
					s: '  ',
					ss: '%d ',
					m: ' ',
					mm: '%d ',
					h: ' ',
					hh: '%d ',
					d: ' ',
					dd: '%d ',
					M: ' ',
					MM: '%d ',
					y: ' ',
					yy: '%d '
				},
				preparse: function(string) {
					return string.replace(/[]/g, function(match) {
						return numberMap[match];
					});
				},
				postformat: function(string) {
					return string.replace(/\d/g, function(match) {
						return symbolMap[match];
					});
				},
				// Hindi notation for meridiems are quite fuzzy in practice. While there exists
				// a rigid notion of a 'Pahar' it is not used as rigidly in modern Hindi.
				meridiemParse: /|||/,
				meridiemHour: function(hour, meridiem) {
					if(hour === 12) {
						hour = 0;
					}
					if(meridiem === '') {
						return hour < 4 ? hour : hour + 12;
					} else if(meridiem === '') {
						return hour;
					} else if(meridiem === '') {
						return hour >= 10 ? hour : hour + 12;
					} else if(meridiem === '') {
						return hour + 12;
					}
				},
				meridiem: function(hour, minute, isLower) {
					if(hour < 4) {
						return '';
					} else if(hour < 10) {
						return '';
					} else if(hour < 17) {
						return '';
					} else if(hour < 20) {
						return '';
					} else {
						return '';
					}
				},
				week: {
					dow: 0, // Sunday is the first day of the week.
					doy: 6  // The week that contains Jan 6th is the first week of the year.
				}
			});
			
			return hi;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/hr.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/hr.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			function translate(number, withoutSuffix, key) {
				var result = number + ' ';
				switch(key) {
					case 'ss':
						if(number === 1) {
							result += 'sekunda';
						} else if(number === 2 || number === 3 || number === 4) {
							result += 'sekunde';
						} else {
							result += 'sekundi';
						}
						return result;
					case 'm':
						return withoutSuffix ? 'jedna minuta' : 'jedne minute';
					case 'mm':
						if(number === 1) {
							result += 'minuta';
						} else if(number === 2 || number === 3 || number === 4) {
							result += 'minute';
						} else {
							result += 'minuta';
						}
						return result;
					case 'h':
						return withoutSuffix ? 'jedan sat' : 'jednog sata';
					case 'hh':
						if(number === 1) {
							result += 'sat';
						} else if(number === 2 || number === 3 || number === 4) {
							result += 'sata';
						} else {
							result += 'sati';
						}
						return result;
					case 'dd':
						if(number === 1) {
							result += 'dan';
						} else {
							result += 'dana';
						}
						return result;
					case 'MM':
						if(number === 1) {
							result += 'mjesec';
						} else if(number === 2 || number === 3 || number === 4) {
							result += 'mjeseca';
						} else {
							result += 'mjeseci';
						}
						return result;
					case 'yy':
						if(number === 1) {
							result += 'godina';
						} else if(number === 2 || number === 3 || number === 4) {
							result += 'godine';
						} else {
							result += 'godina';
						}
						return result;
				}
			}
			
			var hr = moment.defineLocale('hr', {
				months: {
					format: 'sijenja_veljae_oujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca'.split('_'),
					standalone: 'sijeanj_veljaa_oujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac'.split('_')
				},
				monthsShort: 'sij._velj._ou._tra._svi._lip._srp._kol._ruj._lis._stu._pro.'.split('_'),
				monthsParseExact: true,
				weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
				weekdaysShort: 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
				weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
				weekdaysParseExact: true,
				longDateFormat: {
					LT: 'H:mm',
					LTS: 'H:mm:ss',
					L: 'DD.MM.YYYY',
					LL: 'D. MMMM YYYY',
					LLL: 'D. MMMM YYYY H:mm',
					LLLL: 'dddd, D. MMMM YYYY H:mm'
				},
				calendar: {
					sameDay: '[danas u] LT',
					nextDay: '[sutra u] LT',
					nextWeek: function() {
						switch(this.day()) {
							case 0:
								return '[u] [nedjelju] [u] LT';
							case 3:
								return '[u] [srijedu] [u] LT';
							case 6:
								return '[u] [subotu] [u] LT';
							case 1:
							case 2:
							case 4:
							case 5:
								return '[u] dddd [u] LT';
						}
					},
					lastDay: '[juer u] LT',
					lastWeek: function() {
						switch(this.day()) {
							case 0:
							case 3:
								return '[prolu] dddd [u] LT';
							case 6:
								return '[prole] [subote] [u] LT';
							case 1:
							case 2:
							case 4:
							case 5:
								return '[proli] dddd [u] LT';
						}
					},
					sameElse: 'L'
				},
				relativeTime: {
					future: 'za %s',
					past: 'prije %s',
					s: 'par sekundi',
					ss: translate,
					m: translate,
					mm: translate,
					h: translate,
					hh: translate,
					d: 'dan',
					dd: translate,
					M: 'mjesec',
					MM: translate,
					y: 'godinu',
					yy: translate
				},
				dayOfMonthOrdinalParse: /\d{1,2}\./,
				ordinal: '%d.',
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 7  // The week that contains Jan 7th is the first week of the year.
				}
			});
			
			return hr;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/hu.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/hu.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var weekEndings = 'vasrnap htfn kedden szerdn cstrtkn pnteken szombaton'.split(' ');
			
			function translate(number, withoutSuffix, key, isFuture) {
				var num = number;
				switch(key) {
					case 's':
						return (isFuture || withoutSuffix) ? 'nhny msodperc' : 'nhny msodperce';
					case 'ss':
						return num + (isFuture || withoutSuffix) ? ' msodperc' : ' msodperce';
					case 'm':
						return 'egy' + (isFuture || withoutSuffix ? ' perc' : ' perce');
					case 'mm':
						return num + (isFuture || withoutSuffix ? ' perc' : ' perce');
					case 'h':
						return 'egy' + (isFuture || withoutSuffix ? ' ra' : ' rja');
					case 'hh':
						return num + (isFuture || withoutSuffix ? ' ra' : ' rja');
					case 'd':
						return 'egy' + (isFuture || withoutSuffix ? ' nap' : ' napja');
					case 'dd':
						return num + (isFuture || withoutSuffix ? ' nap' : ' napja');
					case 'M':
						return 'egy' + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');
					case 'MM':
						return num + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');
					case 'y':
						return 'egy' + (isFuture || withoutSuffix ? ' v' : ' ve');
					case 'yy':
						return num + (isFuture || withoutSuffix ? ' v' : ' ve');
				}
				return '';
			}
			
			function week(isFuture) {
				return (isFuture ? '' : '[mlt] ') + '[' + weekEndings[this.day()] + '] LT[-kor]';
			}
			
			var hu = moment.defineLocale('hu', {
				months: 'janur_februr_mrcius_prilis_mjus_jnius_jlius_augusztus_szeptember_oktber_november_december'.split('_'),
				monthsShort: 'jan_feb_mrc_pr_mj_jn_jl_aug_szept_okt_nov_dec'.split('_'),
				weekdays: 'vasrnap_htf_kedd_szerda_cstrtk_pntek_szombat'.split('_'),
				weekdaysShort: 'vas_ht_kedd_sze_cst_pn_szo'.split('_'),
				weekdaysMin: 'v_h_k_sze_cs_p_szo'.split('_'),
				longDateFormat: {
					LT: 'H:mm',
					LTS: 'H:mm:ss',
					L: 'YYYY.MM.DD.',
					LL: 'YYYY. MMMM D.',
					LLL: 'YYYY. MMMM D. H:mm',
					LLLL: 'YYYY. MMMM D., dddd H:mm'
				},
				meridiemParse: /de|du/i,
				isPM: function(input) {
					return input.charAt(1).toLowerCase() === 'u';
				},
				meridiem: function(hours, minutes, isLower) {
					if(hours < 12) {
						return isLower === true ? 'de' : 'DE';
					} else {
						return isLower === true ? 'du' : 'DU';
					}
				},
				calendar: {
					sameDay: '[ma] LT[-kor]',
					nextDay: '[holnap] LT[-kor]',
					nextWeek: function() {
						return week.call(this, true);
					},
					lastDay: '[tegnap] LT[-kor]',
					lastWeek: function() {
						return week.call(this, false);
					},
					sameElse: 'L'
				},
				relativeTime: {
					future: '%s mlva',
					past: '%s',
					s: translate,
					ss: translate,
					m: translate,
					mm: translate,
					h: translate,
					hh: translate,
					d: translate,
					dd: translate,
					M: translate,
					MM: translate,
					y: translate,
					yy: translate
				},
				dayOfMonthOrdinalParse: /\d{1,2}\./,
				ordinal: '%d.',
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return hu;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/hy-am.js":
	/*!*********************************************!*\
  !*** ./node_modules/moment/locale/hy-am.js ***!
  \*********************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var hyAm = moment.defineLocale('hy-am', {
				months: {
					format: '___________'.split('_'),
					standalone: '___________'.split('_')
				},
				monthsShort: '___________'.split('_'),
				weekdays: '______'.split('_'),
				weekdaysShort: '______'.split('_'),
				weekdaysMin: '______'.split('_'),
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD.MM.YYYY',
					LL: 'D MMMM YYYY .',
					LLL: 'D MMMM YYYY ., HH:mm',
					LLLL: 'dddd, D MMMM YYYY ., HH:mm'
				},
				calendar: {
					sameDay: '[] LT',
					nextDay: '[] LT',
					lastDay: '[] LT',
					nextWeek: function() {
						return 'dddd [ ] LT';
					},
					lastWeek: function() {
						return '[] dddd [ ] LT';
					},
					sameElse: 'L'
				},
				relativeTime: {
					future: '%s ',
					past: '%s ',
					s: '  ',
					ss: '%d ',
					m: '',
					mm: '%d ',
					h: '',
					hh: '%d ',
					d: '',
					dd: '%d ',
					M: '',
					MM: '%d ',
					y: '',
					yy: '%d '
				},
				meridiemParse: /|||/,
				isPM: function(input) {
					return /^(|)$/.test(input);
				},
				meridiem: function(hour) {
					if(hour < 4) {
						return '';
					} else if(hour < 12) {
						return '';
					} else if(hour < 17) {
						return '';
					} else {
						return '';
					}
				},
				dayOfMonthOrdinalParse: /\d{1,2}|\d{1,2}-(|)/,
				ordinal: function(number, period) {
					switch(period) {
						case 'DDD':
						case 'w':
						case 'W':
						case 'DDDo':
							if(number === 1) {
								return number + '-';
							}
							return number + '-';
						default:
							return number;
					}
				},
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 7  // The week that contains Jan 7th is the first week of the year.
				}
			});
			
			return hyAm;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/id.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/id.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var id = moment.defineLocale('id', {
				months: 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember'.split('_'),
				monthsShort: 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Agt_Sep_Okt_Nov_Des'.split('_'),
				weekdays: 'Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu'.split('_'),
				weekdaysShort: 'Min_Sen_Sel_Rab_Kam_Jum_Sab'.split('_'),
				weekdaysMin: 'Mg_Sn_Sl_Rb_Km_Jm_Sb'.split('_'),
				longDateFormat: {
					LT: 'HH.mm',
					LTS: 'HH.mm.ss',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY [pukul] HH.mm',
					LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm'
				},
				meridiemParse: /pagi|siang|sore|malam/,
				meridiemHour: function(hour, meridiem) {
					if(hour === 12) {
						hour = 0;
					}
					if(meridiem === 'pagi') {
						return hour;
					} else if(meridiem === 'siang') {
						return hour >= 11 ? hour : hour + 12;
					} else if(meridiem === 'sore' || meridiem === 'malam') {
						return hour + 12;
					}
				},
				meridiem: function(hours, minutes, isLower) {
					if(hours < 11) {
						return 'pagi';
					} else if(hours < 15) {
						return 'siang';
					} else if(hours < 19) {
						return 'sore';
					} else {
						return 'malam';
					}
				},
				calendar: {
					sameDay: '[Hari ini pukul] LT',
					nextDay: '[Besok pukul] LT',
					nextWeek: 'dddd [pukul] LT',
					lastDay: '[Kemarin pukul] LT',
					lastWeek: 'dddd [lalu pukul] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: 'dalam %s',
					past: '%s yang lalu',
					s: 'beberapa detik',
					ss: '%d detik',
					m: 'semenit',
					mm: '%d menit',
					h: 'sejam',
					hh: '%d jam',
					d: 'sehari',
					dd: '%d hari',
					M: 'sebulan',
					MM: '%d bulan',
					y: 'setahun',
					yy: '%d tahun'
				},
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 7  // The week that contains Jan 7th is the first week of the year.
				}
			});
			
			return id;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/is.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/is.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			function plural(n) {
				if(n % 100 === 11) {
					return true;
				} else if(n % 10 === 1) {
					return false;
				}
				return true;
			}
			
			function translate(number, withoutSuffix, key, isFuture) {
				var result = number + ' ';
				switch(key) {
					case 's':
						return withoutSuffix || isFuture ? 'nokkrar sekndur' : 'nokkrum sekndum';
					case 'ss':
						if(plural(number)) {
							return result + (withoutSuffix || isFuture ? 'sekndur' : 'sekndum');
						}
						return result + 'seknda';
					case 'm':
						return withoutSuffix ? 'mnta' : 'mntu';
					case 'mm':
						if(plural(number)) {
							return result + (withoutSuffix || isFuture ? 'mntur' : 'mntum');
						} else if(withoutSuffix) {
							return result + 'mnta';
						}
						return result + 'mntu';
					case 'hh':
						if(plural(number)) {
							return result + (withoutSuffix || isFuture ? 'klukkustundir' : 'klukkustundum');
						}
						return result + 'klukkustund';
					case 'd':
						if(withoutSuffix) {
							return 'dagur';
						}
						return isFuture ? 'dag' : 'degi';
					case 'dd':
						if(plural(number)) {
							if(withoutSuffix) {
								return result + 'dagar';
							}
							return result + (isFuture ? 'daga' : 'dgum');
						} else if(withoutSuffix) {
							return result + 'dagur';
						}
						return result + (isFuture ? 'dag' : 'degi');
					case 'M':
						if(withoutSuffix) {
							return 'mnuur';
						}
						return isFuture ? 'mnu' : 'mnui';
					case 'MM':
						if(plural(number)) {
							if(withoutSuffix) {
								return result + 'mnuir';
							}
							return result + (isFuture ? 'mnui' : 'mnuum');
						} else if(withoutSuffix) {
							return result + 'mnuur';
						}
						return result + (isFuture ? 'mnu' : 'mnui');
					case 'y':
						return withoutSuffix || isFuture ? 'r' : 'ri';
					case 'yy':
						if(plural(number)) {
							return result + (withoutSuffix || isFuture ? 'r' : 'rum');
						}
						return result + (withoutSuffix || isFuture ? 'r' : 'ri');
				}
			}
			
			var is = moment.defineLocale('is', {
				months: 'janar_febrar_mars_aprl_ma_jn_jl_gst_september_oktber_nvember_desember'.split('_'),
				monthsShort: 'jan_feb_mar_apr_ma_jn_jl_g_sep_okt_nv_des'.split('_'),
				weekdays: 'sunnudagur_mnudagur_rijudagur_mivikudagur_fimmtudagur_fstudagur_laugardagur'.split('_'),
				weekdaysShort: 'sun_mn_ri_mi_fim_fs_lau'.split('_'),
				weekdaysMin: 'Su_M_r_Mi_Fi_F_La'.split('_'),
				longDateFormat: {
					LT: 'H:mm',
					LTS: 'H:mm:ss',
					L: 'DD.MM.YYYY',
					LL: 'D. MMMM YYYY',
					LLL: 'D. MMMM YYYY [kl.] H:mm',
					LLLL: 'dddd, D. MMMM YYYY [kl.] H:mm'
				},
				calendar: {
					sameDay: '[ dag kl.] LT',
					nextDay: '[ morgun kl.] LT',
					nextWeek: 'dddd [kl.] LT',
					lastDay: '[ gr kl.] LT',
					lastWeek: '[sasta] dddd [kl.] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: 'eftir %s',
					past: 'fyrir %s san',
					s: translate,
					ss: translate,
					m: translate,
					mm: translate,
					h: 'klukkustund',
					hh: translate,
					d: translate,
					dd: translate,
					M: translate,
					MM: translate,
					y: translate,
					yy: translate
				},
				dayOfMonthOrdinalParse: /\d{1,2}\./,
				ordinal: '%d.',
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return is;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/it-ch.js":
	/*!*********************************************!*\
  !*** ./node_modules/moment/locale/it-ch.js ***!
  \*********************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var itCh = moment.defineLocale('it-ch', {
				months: 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),
				monthsShort: 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
				weekdays: 'domenica_luned_marted_mercoled_gioved_venerd_sabato'.split('_'),
				weekdaysShort: 'dom_lun_mar_mer_gio_ven_sab'.split('_'),
				weekdaysMin: 'do_lu_ma_me_gi_ve_sa'.split('_'),
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD.MM.YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY HH:mm',
					LLLL: 'dddd D MMMM YYYY HH:mm'
				},
				calendar: {
					sameDay: '[Oggi alle] LT',
					nextDay: '[Domani alle] LT',
					nextWeek: 'dddd [alle] LT',
					lastDay: '[Ieri alle] LT',
					lastWeek: function() {
						switch(this.day()) {
							case 0:
								return '[la scorsa] dddd [alle] LT';
							default:
								return '[lo scorso] dddd [alle] LT';
						}
					},
					sameElse: 'L'
				},
				relativeTime: {
					future: function(s) {
						return ((/^[0-9].+$/).test(s) ? 'tra' : 'in') + ' ' + s;
					},
					past: '%s fa',
					s: 'alcuni secondi',
					ss: '%d secondi',
					m: 'un minuto',
					mm: '%d minuti',
					h: 'un\'ora',
					hh: '%d ore',
					d: 'un giorno',
					dd: '%d giorni',
					M: 'un mese',
					MM: '%d mesi',
					y: 'un anno',
					yy: '%d anni'
				},
				dayOfMonthOrdinalParse: /\d{1,2}/,
				ordinal: '%d',
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return itCh;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/it.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/it.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var it = moment.defineLocale('it', {
				months: 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),
				monthsShort: 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
				weekdays: 'domenica_luned_marted_mercoled_gioved_venerd_sabato'.split('_'),
				weekdaysShort: 'dom_lun_mar_mer_gio_ven_sab'.split('_'),
				weekdaysMin: 'do_lu_ma_me_gi_ve_sa'.split('_'),
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY HH:mm',
					LLLL: 'dddd D MMMM YYYY HH:mm'
				},
				calendar: {
					sameDay: '[Oggi alle] LT',
					nextDay: '[Domani alle] LT',
					nextWeek: 'dddd [alle] LT',
					lastDay: '[Ieri alle] LT',
					lastWeek: function() {
						switch(this.day()) {
							case 0:
								return '[la scorsa] dddd [alle] LT';
							default:
								return '[lo scorso] dddd [alle] LT';
						}
					},
					sameElse: 'L'
				},
				relativeTime: {
					future: function(s) {
						return ((/^[0-9].+$/).test(s) ? 'tra' : 'in') + ' ' + s;
					},
					past: '%s fa',
					s: 'alcuni secondi',
					ss: '%d secondi',
					m: 'un minuto',
					mm: '%d minuti',
					h: 'un\'ora',
					hh: '%d ore',
					d: 'un giorno',
					dd: '%d giorni',
					M: 'un mese',
					MM: '%d mesi',
					y: 'un anno',
					yy: '%d anni'
				},
				dayOfMonthOrdinalParse: /\d{1,2}/,
				ordinal: '%d',
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return it;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/ja.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/ja.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var ja = moment.defineLocale('ja', {
				months: '___________'.split('_'),
				monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
				weekdays: '______'.split('_'),
				weekdaysShort: '______'.split('_'),
				weekdaysMin: '______'.split('_'),
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'YYYY/MM/DD',
					LL: 'YYYYMD',
					LLL: 'YYYYMD HH:mm',
					LLLL: 'YYYYMD dddd HH:mm',
					l: 'YYYY/MM/DD',
					ll: 'YYYYMD',
					lll: 'YYYYMD HH:mm',
					llll: 'YYYYMD(ddd) HH:mm'
				},
				meridiemParse: /|/i,
				isPM: function(input) {
					return input === '';
				},
				meridiem: function(hour, minute, isLower) {
					if(hour < 12) {
						return '';
					} else {
						return '';
					}
				},
				calendar: {
					sameDay: '[] LT',
					nextDay: '[] LT',
					nextWeek: function(now) {
						if(now.week() < this.week()) {
							return '[]dddd LT';
						} else {
							return 'dddd LT';
						}
					},
					lastDay: '[] LT',
					lastWeek: function(now) {
						if(this.week() < now.week()) {
							return '[]dddd LT';
						} else {
							return 'dddd LT';
						}
					},
					sameElse: 'L'
				},
				dayOfMonthOrdinalParse: /\d{1,2}/,
				ordinal: function(number, period) {
					switch(period) {
						case 'd':
						case 'D':
						case 'DDD':
							return number + '';
						default:
							return number;
					}
				},
				relativeTime: {
					future: '%s',
					past: '%s',
					s: '',
					ss: '%d',
					m: '1',
					mm: '%d',
					h: '1',
					hh: '%d',
					d: '1',
					dd: '%d',
					M: '1',
					MM: '%d',
					y: '1',
					yy: '%d'
				}
			});
			
			return ja;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/jv.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/jv.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var jv = moment.defineLocale('jv', {
				months: 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember'.split('_'),
				monthsShort: 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des'.split('_'),
				weekdays: 'Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu'.split('_'),
				weekdaysShort: 'Min_Sen_Sel_Reb_Kem_Jem_Sep'.split('_'),
				weekdaysMin: 'Mg_Sn_Sl_Rb_Km_Jm_Sp'.split('_'),
				longDateFormat: {
					LT: 'HH.mm',
					LTS: 'HH.mm.ss',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY [pukul] HH.mm',
					LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm'
				},
				meridiemParse: /enjing|siyang|sonten|ndalu/,
				meridiemHour: function(hour, meridiem) {
					if(hour === 12) {
						hour = 0;
					}
					if(meridiem === 'enjing') {
						return hour;
					} else if(meridiem === 'siyang') {
						return hour >= 11 ? hour : hour + 12;
					} else if(meridiem === 'sonten' || meridiem === 'ndalu') {
						return hour + 12;
					}
				},
				meridiem: function(hours, minutes, isLower) {
					if(hours < 11) {
						return 'enjing';
					} else if(hours < 15) {
						return 'siyang';
					} else if(hours < 19) {
						return 'sonten';
					} else {
						return 'ndalu';
					}
				},
				calendar: {
					sameDay: '[Dinten puniko pukul] LT',
					nextDay: '[Mbenjang pukul] LT',
					nextWeek: 'dddd [pukul] LT',
					lastDay: '[Kala wingi pukul] LT',
					lastWeek: 'dddd [kepengker pukul] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: 'wonten ing %s',
					past: '%s ingkang kepengker',
					s: 'sawetawis detik',
					ss: '%d detik',
					m: 'setunggal menit',
					mm: '%d menit',
					h: 'setunggal jam',
					hh: '%d jam',
					d: 'sedinten',
					dd: '%d dinten',
					M: 'sewulan',
					MM: '%d wulan',
					y: 'setaun',
					yy: '%d taun'
				},
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 7  // The week that contains Jan 7th is the first week of the year.
				}
			});
			
			return jv;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/ka.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/ka.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var ka = moment.defineLocale('ka', {
				months: {
					standalone: '___________'.split('_'),
					format: '___________'.split('_')
				},
				monthsShort: '___________'.split('_'),
				weekdays: {
					standalone: '______'.split('_'),
					format: '______'.split('_'),
					isFormat: /(|)/
				},
				weekdaysShort: '______'.split('_'),
				weekdaysMin: '______'.split('_'),
				longDateFormat: {
					LT: 'h:mm A',
					LTS: 'h:mm:ss A',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY h:mm A',
					LLLL: 'dddd, D MMMM YYYY h:mm A'
				},
				calendar: {
					sameDay: '[] LT[-]',
					nextDay: '[] LT[-]',
					lastDay: '[] LT[-]',
					nextWeek: '[] dddd LT[-]',
					lastWeek: '[] dddd LT-',
					sameElse: 'L'
				},
				relativeTime: {
					future: function(s) {
						return (/(|||)/).test(s) ?
							s.replace(/$/, '') :
							s + '';
					},
					past: function(s) {
						if((/(||||)/).test(s)) {
							return s.replace(/(|)$/, ' ');
						}
						if((//).test(s)) {
							return s.replace(/$/, ' ');
						}
					},
					s: ' ',
					ss: '%d ',
					m: '',
					mm: '%d ',
					h: '',
					hh: '%d ',
					d: '',
					dd: '%d ',
					M: '',
					MM: '%d ',
					y: '',
					yy: '%d '
				},
				dayOfMonthOrdinalParse: /0|1-|-\d{1,2}|\d{1,2}-/,
				ordinal: function(number) {
					if(number === 0) {
						return number;
					}
					if(number === 1) {
						return number + '-';
					}
					if((number < 20) || (number <= 100 && (number % 20 === 0)) || (number % 100 === 0)) {
						return '-' + number;
					}
					return number + '-';
				},
				week: {
					dow: 1,
					doy: 7
				}
			});
			
			return ka;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/kk.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/kk.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var suffixes = {
				0: '-',
				1: '-',
				2: '-',
				3: '-',
				4: '-',
				5: '-',
				6: '-',
				7: '-',
				8: '-',
				9: '-',
				10: '-',
				20: '-',
				30: '-',
				40: '-',
				50: '-',
				60: '-',
				70: '-',
				80: '-',
				90: '-',
				100: '-'
			};
			
			var kk = moment.defineLocale('kk', {
				months: '___________'.split('_'),
				monthsShort: '___________'.split('_'),
				weekdays: '______'.split('_'),
				weekdaysShort: '______'.split('_'),
				weekdaysMin: '______'.split('_'),
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD.MM.YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY HH:mm',
					LLLL: 'dddd, D MMMM YYYY HH:mm'
				},
				calendar: {
					sameDay: '[ ] LT',
					nextDay: '[ ] LT',
					nextWeek: 'dddd [] LT',
					lastDay: '[ ] LT',
					lastWeek: '[ ] dddd [] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: '%s ',
					past: '%s ',
					s: ' ',
					ss: '%d ',
					m: ' ',
					mm: '%d ',
					h: ' ',
					hh: '%d ',
					d: ' ',
					dd: '%d ',
					M: ' ',
					MM: '%d ',
					y: ' ',
					yy: '%d '
				},
				dayOfMonthOrdinalParse: /\d{1,2}-(|)/,
				ordinal: function(number) {
					var a = number % 10,
						b = number >= 100 ? 100 : null;
					return number + (suffixes[number] || suffixes[a] || suffixes[b]);
				},
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 7  // The week that contains Jan 7th is the first week of the year.
				}
			});
			
			return kk;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/km.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/km.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var symbolMap = {
				'1': '',
				'2': '',
				'3': '',
				'4': '',
				'5': '',
				'6': '',
				'7': '',
				'8': '',
				'9': '',
				'0': ''
			}, numberMap = {
				'': '1',
				'': '2',
				'': '3',
				'': '4',
				'': '5',
				'': '6',
				'': '7',
				'': '8',
				'': '9',
				'': '0'
			};
			
			var km = moment.defineLocale('km', {
				months: '___________'.split(
					'_'
				),
				monthsShort: '___________'.split(
					'_'
				),
				weekdays: '______'.split('_'),
				weekdaysShort: '______'.split('_'),
				weekdaysMin: '______'.split('_'),
				weekdaysParseExact: true,
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY HH:mm',
					LLLL: 'dddd, D MMMM YYYY HH:mm'
				},
				meridiemParse: /|/,
				isPM: function(input) {
					return input === '';
				},
				meridiem: function(hour, minute, isLower) {
					if(hour < 12) {
						return '';
					} else {
						return '';
					}
				},
				calendar: {
					sameDay: '[ ] LT',
					nextDay: '[ ] LT',
					nextWeek: 'dddd [] LT',
					lastDay: '[ ] LT',
					lastWeek: 'dddd [] [] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: '%s',
					past: '%s',
					s: '',
					ss: '%d ',
					m: '',
					mm: '%d ',
					h: '',
					hh: '%d ',
					d: '',
					dd: '%d ',
					M: '',
					MM: '%d ',
					y: '',
					yy: '%d '
				},
				dayOfMonthOrdinalParse: /\d{1,2}/,
				ordinal: '%d',
				preparse: function(string) {
					return string.replace(/[]/g, function(match) {
						return numberMap[match];
					});
				},
				postformat: function(string) {
					return string.replace(/\d/g, function(match) {
						return symbolMap[match];
					});
				},
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4 // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return km;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/kn.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/kn.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var symbolMap = {
					'1': '',
					'2': '',
					'3': '',
					'4': '',
					'5': '',
					'6': '',
					'7': '',
					'8': '',
					'9': '',
					'0': ''
				},
				numberMap = {
					'': '1',
					'': '2',
					'': '3',
					'': '4',
					'': '5',
					'': '6',
					'': '7',
					'': '8',
					'': '9',
					'': '0'
				};
			
			var kn = moment.defineLocale('kn', {
				months: '___________'.split('_'),
				monthsShort: '___________'.split('_'),
				monthsParseExact: true,
				weekdays: '______'.split('_'),
				weekdaysShort: '______'.split('_'),
				weekdaysMin: '______'.split('_'),
				longDateFormat: {
					LT: 'A h:mm',
					LTS: 'A h:mm:ss',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY, A h:mm',
					LLLL: 'dddd, D MMMM YYYY, A h:mm'
				},
				calendar: {
					sameDay: '[] LT',
					nextDay: '[] LT',
					nextWeek: 'dddd, LT',
					lastDay: '[] LT',
					lastWeek: '[] dddd, LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: '%s ',
					past: '%s ',
					s: ' ',
					ss: '%d ',
					m: ' ',
					mm: '%d ',
					h: ' ',
					hh: '%d ',
					d: ' ',
					dd: '%d ',
					M: ' ',
					MM: '%d ',
					y: ' ',
					yy: '%d '
				},
				preparse: function(string) {
					return string.replace(/[]/g, function(match) {
						return numberMap[match];
					});
				},
				postformat: function(string) {
					return string.replace(/\d/g, function(match) {
						return symbolMap[match];
					});
				},
				meridiemParse: /|||/,
				meridiemHour: function(hour, meridiem) {
					if(hour === 12) {
						hour = 0;
					}
					if(meridiem === '') {
						return hour < 4 ? hour : hour + 12;
					} else if(meridiem === '') {
						return hour;
					} else if(meridiem === '') {
						return hour >= 10 ? hour : hour + 12;
					} else if(meridiem === '') {
						return hour + 12;
					}
				},
				meridiem: function(hour, minute, isLower) {
					if(hour < 4) {
						return '';
					} else if(hour < 10) {
						return '';
					} else if(hour < 17) {
						return '';
					} else if(hour < 20) {
						return '';
					} else {
						return '';
					}
				},
				dayOfMonthOrdinalParse: /\d{1,2}()/,
				ordinal: function(number) {
					return number + '';
				},
				week: {
					dow: 0, // Sunday is the first day of the week.
					doy: 6  // The week that contains Jan 6th is the first week of the year.
				}
			});
			
			return kn;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/ko.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/ko.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var ko = moment.defineLocale('ko', {
				months: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
				monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
				weekdays: '______'.split('_'),
				weekdaysShort: '______'.split('_'),
				weekdaysMin: '______'.split('_'),
				longDateFormat: {
					LT: 'A h:mm',
					LTS: 'A h:mm:ss',
					L: 'YYYY.MM.DD.',
					LL: 'YYYY MMMM D',
					LLL: 'YYYY MMMM D A h:mm',
					LLLL: 'YYYY MMMM D dddd A h:mm',
					l: 'YYYY.MM.DD.',
					ll: 'YYYY MMMM D',
					lll: 'YYYY MMMM D A h:mm',
					llll: 'YYYY MMMM D dddd A h:mm'
				},
				calendar: {
					sameDay: ' LT',
					nextDay: ' LT',
					nextWeek: 'dddd LT',
					lastDay: ' LT',
					lastWeek: ' dddd LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: '%s ',
					past: '%s ',
					s: ' ',
					ss: '%d',
					m: '1',
					mm: '%d',
					h: ' ',
					hh: '%d',
					d: '',
					dd: '%d',
					M: ' ',
					MM: '%d',
					y: ' ',
					yy: '%d'
				},
				dayOfMonthOrdinalParse: /\d{1,2}(||)/,
				ordinal: function(number, period) {
					switch(period) {
						case 'd':
						case 'D':
						case 'DDD':
							return number + '';
						case 'M':
							return number + '';
						case 'w':
						case 'W':
							return number + '';
						default:
							return number;
					}
				},
				meridiemParse: /|/,
				isPM: function(token) {
					return token === '';
				},
				meridiem: function(hour, minute, isUpper) {
					return hour < 12 ? '' : '';
				}
			});
			
			return ko;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/ku.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/ku.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var symbolMap = {
					'1': '',
					'2': '',
					'3': '',
					'4': '',
					'5': '',
					'6': '',
					'7': '',
					'8': '',
					'9': '',
					'0': ''
				}, numberMap = {
					'': '1',
					'': '2',
					'': '3',
					'': '4',
					'': '5',
					'': '6',
					'': '7',
					'': '8',
					'': '9',
					'': '0'
				},
				months = [
					' ',
					'',
					'',
					'',
					'',
					'',
					'',
					'',
					'',
					' ',
					' ',
					' '
				];
			
			
			var ku = moment.defineLocale('ku', {
				months: months,
				monthsShort: months,
				weekdays: '______'.split('_'),
				weekdaysShort: '______'.split('_'),
				weekdaysMin: '______'.split('_'),
				weekdaysParseExact: true,
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY HH:mm',
					LLLL: 'dddd, D MMMM YYYY HH:mm'
				},
				meridiemParse: /|/,
				isPM: function(input) {
					return //.test(input);
				},
				meridiem: function(hour, minute, isLower) {
					if(hour < 12) {
						return '';
					} else {
						return '';
					}
				},
				calendar: {
					sameDay: '[ ] LT',
					nextDay: '[ ] LT',
					nextWeek: 'dddd [] LT',
					lastDay: '[ ] LT',
					lastWeek: 'dddd [] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: ' %s',
					past: '%s',
					s: ' ',
					ss: ' %d',
					m: ' ',
					mm: '%d ',
					h: ' ',
					hh: '%d ',
					d: ' ',
					dd: '%d ',
					M: ' ',
					MM: '%d ',
					y: ' ',
					yy: '%d '
				},
				preparse: function(string) {
					return string.replace(/[]/g, function(match) {
						return numberMap[match];
					}).replace(//g, ',');
				},
				postformat: function(string) {
					return string.replace(/\d/g, function(match) {
						return symbolMap[match];
					}).replace(/,/g, '');
				},
				week: {
					dow: 6, // Saturday is the first day of the week.
					doy: 12 // The week that contains Jan 12th is the first week of the year.
				}
			});
			
			return ku;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/ky.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/ky.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var suffixes = {
				0: '-',
				1: '-',
				2: '-',
				3: '-',
				4: '-',
				5: '-',
				6: '-',
				7: '-',
				8: '-',
				9: '-',
				10: '-',
				20: '-',
				30: '-',
				40: '-',
				50: '-',
				60: '-',
				70: '-',
				80: '-',
				90: '-',
				100: '-'
			};
			
			var ky = moment.defineLocale('ky', {
				months: '___________'.split('_'),
				monthsShort: '___________'.split('_'),
				weekdays: '______'.split('_'),
				weekdaysShort: '______'.split('_'),
				weekdaysMin: '______'.split('_'),
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD.MM.YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY HH:mm',
					LLLL: 'dddd, D MMMM YYYY HH:mm'
				},
				calendar: {
					sameDay: '[ ] LT',
					nextDay: '[ ] LT',
					nextWeek: 'dddd [] LT',
					lastDay: '[ ] LT',
					lastWeek: '[ ] dddd [] [] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: '%s ',
					past: '%s ',
					s: ' ',
					ss: '%d ',
					m: ' ',
					mm: '%d ',
					h: ' ',
					hh: '%d ',
					d: ' ',
					dd: '%d ',
					M: ' ',
					MM: '%d ',
					y: ' ',
					yy: '%d '
				},
				dayOfMonthOrdinalParse: /\d{1,2}-(|||)/,
				ordinal: function(number) {
					var a = number % 10,
						b = number >= 100 ? 100 : null;
					return number + (suffixes[number] || suffixes[a] || suffixes[b]);
				},
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 7  // The week that contains Jan 7th is the first week of the year.
				}
			});
			
			return ky;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/lb.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/lb.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			function processRelativeTime(number, withoutSuffix, key, isFuture) {
				var format = {
					'm': ['eng Minutt', 'enger Minutt'],
					'h': ['eng Stonn', 'enger Stonn'],
					'd': ['een Dag', 'engem Dag'],
					'M': ['ee Mount', 'engem Mount'],
					'y': ['ee Joer', 'engem Joer']
				};
				return withoutSuffix ? format[key][0] : format[key][1];
			}
			
			function processFutureTime(string) {
				var number = string.substr(0, string.indexOf(' '));
				if(eifelerRegelAppliesToNumber(number)) {
					return 'a ' + string;
				}
				return 'an ' + string;
			}
			
			function processPastTime(string) {
				var number = string.substr(0, string.indexOf(' '));
				if(eifelerRegelAppliesToNumber(number)) {
					return 'viru ' + string;
				}
				return 'virun ' + string;
			}
			
			/**
			 * Returns true if the word before the given number loses the '-n' ending.
			 * e.g. 'an 10 Deeg' but 'a 5 Deeg'
			 *
			 * @param number {integer}
			 * @returns {boolean}
			 */
			function eifelerRegelAppliesToNumber(number) {
				number = parseInt(number, 10);
				if(isNaN(number)) {
					return false;
				}
				if(number < 0) {
					// Negative Number --> always true
					return true;
				} else if(number < 10) {
					// Only 1 digit
					if(4 <= number && number <= 7) {
						return true;
					}
					return false;
				} else if(number < 100) {
					// 2 digits
					var lastDigit = number % 10, firstDigit = number / 10;
					if(lastDigit === 0) {
						return eifelerRegelAppliesToNumber(firstDigit);
					}
					return eifelerRegelAppliesToNumber(lastDigit);
				} else if(number < 10000) {
					// 3 or 4 digits --> recursively check first digit
					while(number >= 10) {
						number = number / 10;
					}
					return eifelerRegelAppliesToNumber(number);
				} else {
					// Anything larger than 4 digits: recursively check first n-3 digits
					number = number / 1000;
					return eifelerRegelAppliesToNumber(number);
				}
			}
			
			var lb = moment.defineLocale('lb', {
				months: 'Januar_Februar_Merz_Abrll_Mee_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
				monthsShort: 'Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
				monthsParseExact: true,
				weekdays: 'Sonndeg_Mindeg_Dnschdeg_Mttwoch_Donneschdeg_Freideg_Samschdeg'.split('_'),
				weekdaysShort: 'So._M._D._M._Do._Fr._Sa.'.split('_'),
				weekdaysMin: 'So_M_D_M_Do_Fr_Sa'.split('_'),
				weekdaysParseExact: true,
				longDateFormat: {
					LT: 'H:mm [Auer]',
					LTS: 'H:mm:ss [Auer]',
					L: 'DD.MM.YYYY',
					LL: 'D. MMMM YYYY',
					LLL: 'D. MMMM YYYY H:mm [Auer]',
					LLLL: 'dddd, D. MMMM YYYY H:mm [Auer]'
				},
				calendar: {
					sameDay: '[Haut um] LT',
					sameElse: 'L',
					nextDay: '[Muer um] LT',
					nextWeek: 'dddd [um] LT',
					lastDay: '[Gschter um] LT',
					lastWeek: function() {
						// Different date string for 'Dnschdeg' (Tuesday) and 'Donneschdeg' (Thursday) due to phonological rule
						switch(this.day()) {
							case 2:
							case 4:
								return '[Leschten] dddd [um] LT';
							default:
								return '[Leschte] dddd [um] LT';
						}
					}
				},
				relativeTime: {
					future: processFutureTime,
					past: processPastTime,
					s: 'e puer Sekonnen',
					ss: '%d Sekonnen',
					m: processRelativeTime,
					mm: '%d Minutten',
					h: processRelativeTime,
					hh: '%d Stonnen',
					d: processRelativeTime,
					dd: '%d Deeg',
					M: processRelativeTime,
					MM: '%d Mint',
					y: processRelativeTime,
					yy: '%d Joer'
				},
				dayOfMonthOrdinalParse: /\d{1,2}\./,
				ordinal: '%d.',
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return lb;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/lo.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/lo.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var lo = moment.defineLocale('lo', {
				months: '___________'.split('_'),
				monthsShort: '___________'.split('_'),
				weekdays: '______'.split('_'),
				weekdaysShort: '______'.split('_'),
				weekdaysMin: '______'.split('_'),
				weekdaysParseExact: true,
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY HH:mm',
					LLLL: 'dddd D MMMM YYYY HH:mm'
				},
				meridiemParse: /|/,
				isPM: function(input) {
					return input === '';
				},
				meridiem: function(hour, minute, isLower) {
					if(hour < 12) {
						return '';
					} else {
						return '';
					}
				},
				calendar: {
					sameDay: '[] LT',
					nextDay: '[] LT',
					nextWeek: '[]dddd[] LT',
					lastDay: '[] LT',
					lastWeek: '[]dddd[] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: ' %s',
					past: '%s',
					s: '',
					ss: '%d ',
					m: '1 ',
					mm: '%d ',
					h: '1 ',
					hh: '%d ',
					d: '1 ',
					dd: '%d ',
					M: '1 ',
					MM: '%d ',
					y: '1 ',
					yy: '%d '
				},
				dayOfMonthOrdinalParse: /()\d{1,2}/,
				ordinal: function(number) {
					return '' + number;
				}
			});
			
			return lo;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/lt.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/lt.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var units = {
				'ss': 'sekund_sekundi_sekundes',
				'm': 'minut_minuts_minut',
				'mm': 'minuts_minui_minutes',
				'h': 'valanda_valandos_valand',
				'hh': 'valandos_valand_valandas',
				'd': 'diena_dienos_dien',
				'dd': 'dienos_dien_dienas',
				'M': 'mnuo_mnesio_mnes',
				'MM': 'mnesiai_mnesi_mnesius',
				'y': 'metai_met_metus',
				'yy': 'metai_met_metus'
			};
			
			function translateSeconds(number, withoutSuffix, key, isFuture) {
				if(withoutSuffix) {
					return 'kelios sekunds';
				} else {
					return isFuture ? 'keli sekundi' : 'kelias sekundes';
				}
			}
			
			function translateSingular(number, withoutSuffix, key, isFuture) {
				return withoutSuffix ? forms(key)[0] : (isFuture ? forms(key)[1] : forms(key)[2]);
			}
			
			function special(number) {
				return number % 10 === 0 || (number > 10 && number < 20);
			}
			
			function forms(key) {
				return units[key].split('_');
			}
			
			function translate(number, withoutSuffix, key, isFuture) {
				var result = number + ' ';
				if(number === 1) {
					return result + translateSingular(number, withoutSuffix, key[0], isFuture);
				} else if(withoutSuffix) {
					return result + (special(number) ? forms(key)[1] : forms(key)[0]);
				} else {
					if(isFuture) {
						return result + forms(key)[1];
					} else {
						return result + (special(number) ? forms(key)[1] : forms(key)[2]);
					}
				}
			}
			
			var lt = moment.defineLocale('lt', {
				months: {
					format: 'sausio_vasario_kovo_balandio_gegus_birelio_liepos_rugpjio_rugsjo_spalio_lapkriio_gruodio'.split('_'),
					standalone: 'sausis_vasaris_kovas_balandis_gegu_birelis_liepa_rugpjtis_rugsjis_spalis_lapkritis_gruodis'.split('_'),
					isFormat: /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?|MMMM?(\[[^\[\]]*\]|\s)+D[oD]?/
				},
				monthsShort: 'sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd'.split('_'),
				weekdays: {
					format: 'sekmadien_pirmadien_antradien_treiadien_ketvirtadien_penktadien_etadien'.split('_'),
					standalone: 'sekmadienis_pirmadienis_antradienis_treiadienis_ketvirtadienis_penktadienis_etadienis'.split('_'),
					isFormat: /dddd HH:mm/
				},
				weekdaysShort: 'Sek_Pir_Ant_Tre_Ket_Pen_e'.split('_'),
				weekdaysMin: 'S_P_A_T_K_Pn_'.split('_'),
				weekdaysParseExact: true,
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'YYYY-MM-DD',
					LL: 'YYYY [m.] MMMM D [d.]',
					LLL: 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
					LLLL: 'YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]',
					l: 'YYYY-MM-DD',
					ll: 'YYYY [m.] MMMM D [d.]',
					lll: 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
					llll: 'YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]'
				},
				calendar: {
					sameDay: '[iandien] LT',
					nextDay: '[Rytoj] LT',
					nextWeek: 'dddd LT',
					lastDay: '[Vakar] LT',
					lastWeek: '[Prajus] dddd LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: 'po %s',
					past: 'prie %s',
					s: translateSeconds,
					ss: translate,
					m: translateSingular,
					mm: translate,
					h: translateSingular,
					hh: translate,
					d: translateSingular,
					dd: translate,
					M: translateSingular,
					MM: translate,
					y: translateSingular,
					yy: translate
				},
				dayOfMonthOrdinalParse: /\d{1,2}-oji/,
				ordinal: function(number) {
					return number + '-oji';
				},
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return lt;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/lv.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/lv.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var units = {
				'ss': 'sekundes_sekundm_sekunde_sekundes'.split('_'),
				'm': 'mintes_mintm_minte_mintes'.split('_'),
				'mm': 'mintes_mintm_minte_mintes'.split('_'),
				'h': 'stundas_stundm_stunda_stundas'.split('_'),
				'hh': 'stundas_stundm_stunda_stundas'.split('_'),
				'd': 'dienas_dienm_diena_dienas'.split('_'),
				'dd': 'dienas_dienm_diena_dienas'.split('_'),
				'M': 'mnea_mneiem_mnesis_mnei'.split('_'),
				'MM': 'mnea_mneiem_mnesis_mnei'.split('_'),
				'y': 'gada_gadiem_gads_gadi'.split('_'),
				'yy': 'gada_gadiem_gads_gadi'.split('_')
			};
			
			/**
			 * @param withoutSuffix boolean true = a length of time; false = before/after a period of time.
			 */
			function format(forms, number, withoutSuffix) {
				if(withoutSuffix) {
					// E.g. "21 minte", "3 mintes".
					return number % 10 === 1 && number % 100 !== 11 ? forms[2] : forms[3];
				} else {
					// E.g. "21 mintes" as in "pc 21 mintes".
					// E.g. "3 mintm" as in "pc 3 mintm".
					return number % 10 === 1 && number % 100 !== 11 ? forms[0] : forms[1];
				}
			}
			
			function relativeTimeWithPlural(number, withoutSuffix, key) {
				return number + ' ' + format(units[key], number, withoutSuffix);
			}
			
			function relativeTimeWithSingular(number, withoutSuffix, key) {
				return format(units[key], number, withoutSuffix);
			}
			
			function relativeSeconds(number, withoutSuffix) {
				return withoutSuffix ? 'daas sekundes' : 'dam sekundm';
			}
			
			var lv = moment.defineLocale('lv', {
				months: 'janvris_februris_marts_aprlis_maijs_jnijs_jlijs_augusts_septembris_oktobris_novembris_decembris'.split('_'),
				monthsShort: 'jan_feb_mar_apr_mai_jn_jl_aug_sep_okt_nov_dec'.split('_'),
				weekdays: 'svtdiena_pirmdiena_otrdiena_trediena_ceturtdiena_piektdiena_sestdiena'.split('_'),
				weekdaysShort: 'Sv_P_O_T_C_Pk_S'.split('_'),
				weekdaysMin: 'Sv_P_O_T_C_Pk_S'.split('_'),
				weekdaysParseExact: true,
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD.MM.YYYY.',
					LL: 'YYYY. [gada] D. MMMM',
					LLL: 'YYYY. [gada] D. MMMM, HH:mm',
					LLLL: 'YYYY. [gada] D. MMMM, dddd, HH:mm'
				},
				calendar: {
					sameDay: '[odien pulksten] LT',
					nextDay: '[Rt pulksten] LT',
					nextWeek: 'dddd [pulksten] LT',
					lastDay: '[Vakar pulksten] LT',
					lastWeek: '[Pagju] dddd [pulksten] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: 'pc %s',
					past: 'pirms %s',
					s: relativeSeconds,
					ss: relativeTimeWithPlural,
					m: relativeTimeWithSingular,
					mm: relativeTimeWithPlural,
					h: relativeTimeWithSingular,
					hh: relativeTimeWithPlural,
					d: relativeTimeWithSingular,
					dd: relativeTimeWithPlural,
					M: relativeTimeWithSingular,
					MM: relativeTimeWithPlural,
					y: relativeTimeWithSingular,
					yy: relativeTimeWithPlural
				},
				dayOfMonthOrdinalParse: /\d{1,2}\./,
				ordinal: '%d.',
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return lv;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/me.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/me.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var translator = {
				words: { //Different grammatical cases
					ss: ['sekund', 'sekunda', 'sekundi'],
					m: ['jedan minut', 'jednog minuta'],
					mm: ['minut', 'minuta', 'minuta'],
					h: ['jedan sat', 'jednog sata'],
					hh: ['sat', 'sata', 'sati'],
					dd: ['dan', 'dana', 'dana'],
					MM: ['mjesec', 'mjeseca', 'mjeseci'],
					yy: ['godina', 'godine', 'godina']
				},
				correctGrammaticalCase: function(number, wordKey) {
					return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
				},
				translate: function(number, withoutSuffix, key) {
					var wordKey = translator.words[key];
					if(key.length === 1) {
						return withoutSuffix ? wordKey[0] : wordKey[1];
					} else {
						return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
					}
				}
			};
			
			var me = moment.defineLocale('me', {
				months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
				monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
				monthsParseExact: true,
				weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
				weekdaysShort: 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
				weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
				weekdaysParseExact: true,
				longDateFormat: {
					LT: 'H:mm',
					LTS: 'H:mm:ss',
					L: 'DD.MM.YYYY',
					LL: 'D. MMMM YYYY',
					LLL: 'D. MMMM YYYY H:mm',
					LLLL: 'dddd, D. MMMM YYYY H:mm'
				},
				calendar: {
					sameDay: '[danas u] LT',
					nextDay: '[sjutra u] LT',
					
					nextWeek: function() {
						switch(this.day()) {
							case 0:
								return '[u] [nedjelju] [u] LT';
							case 3:
								return '[u] [srijedu] [u] LT';
							case 6:
								return '[u] [subotu] [u] LT';
							case 1:
							case 2:
							case 4:
							case 5:
								return '[u] dddd [u] LT';
						}
					},
					lastDay: '[jue u] LT',
					lastWeek: function() {
						var lastWeekDays = [
							'[prole] [nedjelje] [u] LT',
							'[prolog] [ponedjeljka] [u] LT',
							'[prolog] [utorka] [u] LT',
							'[prole] [srijede] [u] LT',
							'[prolog] [etvrtka] [u] LT',
							'[prolog] [petka] [u] LT',
							'[prole] [subote] [u] LT'
						];
						return lastWeekDays[this.day()];
					},
					sameElse: 'L'
				},
				relativeTime: {
					future: 'za %s',
					past: 'prije %s',
					s: 'nekoliko sekundi',
					ss: translator.translate,
					m: translator.translate,
					mm: translator.translate,
					h: translator.translate,
					hh: translator.translate,
					d: 'dan',
					dd: translator.translate,
					M: 'mjesec',
					MM: translator.translate,
					y: 'godinu',
					yy: translator.translate
				},
				dayOfMonthOrdinalParse: /\d{1,2}\./,
				ordinal: '%d.',
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 7  // The week that contains Jan 7th is the first week of the year.
				}
			});
			
			return me;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/mi.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/mi.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var mi = moment.defineLocale('mi', {
				months: 'Kohi-tte_Hui-tanguru_Pout-te-rangi_Paenga-whwh_Haratua_Pipiri_Hngoingoi_Here-turi-kk_Mahuru_Whiringa--nuku_Whiringa--rangi_Hakihea'.split('_'),
				monthsShort: 'Kohi_Hui_Pou_Pae_Hara_Pipi_Hngoi_Here_Mahu_Whi-nu_Whi-ra_Haki'.split('_'),
				monthsRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
				monthsStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
				monthsShortRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
				monthsShortStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,2}/i,
				weekdays: 'Rtapu_Mane_Trei_Wenerei_Tite_Paraire_Htarei'.split('_'),
				weekdaysShort: 'Ta_Ma_T_We_Ti_Pa_H'.split('_'),
				weekdaysMin: 'Ta_Ma_T_We_Ti_Pa_H'.split('_'),
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY [i] HH:mm',
					LLLL: 'dddd, D MMMM YYYY [i] HH:mm'
				},
				calendar: {
					sameDay: '[i teie mahana, i] LT',
					nextDay: '[apopo i] LT',
					nextWeek: 'dddd [i] LT',
					lastDay: '[inanahi i] LT',
					lastWeek: 'dddd [whakamutunga i] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: 'i roto i %s',
					past: '%s i mua',
					s: 'te hkona ruarua',
					ss: '%d hkona',
					m: 'he meneti',
					mm: '%d meneti',
					h: 'te haora',
					hh: '%d haora',
					d: 'he ra',
					dd: '%d ra',
					M: 'he marama',
					MM: '%d marama',
					y: 'he tau',
					yy: '%d tau'
				},
				dayOfMonthOrdinalParse: /\d{1,2}/,
				ordinal: '%d',
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return mi;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/mk.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/mk.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var mk = moment.defineLocale('mk', {
				months: '___________'.split('_'),
				monthsShort: '___________'.split('_'),
				weekdays: '______'.split('_'),
				weekdaysShort: '______'.split('_'),
				weekdaysMin: 'e_o_____a'.split('_'),
				longDateFormat: {
					LT: 'H:mm',
					LTS: 'H:mm:ss',
					L: 'D.MM.YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY H:mm',
					LLLL: 'dddd, D MMMM YYYY H:mm'
				},
				calendar: {
					sameDay: '[ ] LT',
					nextDay: '[ ] LT',
					nextWeek: '[] dddd [] LT',
					lastDay: '[ ] LT',
					lastWeek: function() {
						switch(this.day()) {
							case 0:
							case 3:
							case 6:
								return '[] dddd [] LT';
							case 1:
							case 2:
							case 4:
							case 5:
								return '[] dddd [] LT';
						}
					},
					sameElse: 'L'
				},
				relativeTime: {
					future: ' %s',
					past: ' %s',
					s: ' ',
					ss: '%d ',
					m: '',
					mm: '%d ',
					h: '',
					hh: '%d ',
					d: '',
					dd: '%d ',
					M: '',
					MM: '%d ',
					y: '',
					yy: '%d '
				},
				dayOfMonthOrdinalParse: /\d{1,2}-(|||||)/,
				ordinal: function(number) {
					var lastDigit = number % 10,
						last2Digits = number % 100;
					if(number === 0) {
						return number + '-';
					} else if(last2Digits === 0) {
						return number + '-';
					} else if(last2Digits > 10 && last2Digits < 20) {
						return number + '-';
					} else if(lastDigit === 1) {
						return number + '-';
					} else if(lastDigit === 2) {
						return number + '-';
					} else if(lastDigit === 7 || lastDigit === 8) {
						return number + '-';
					} else {
						return number + '-';
					}
				},
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 7  // The week that contains Jan 7th is the first week of the year.
				}
			});
			
			return mk;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/ml.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/ml.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var ml = moment.defineLocale('ml', {
				months: '___________'.split('_'),
				monthsShort: '._._._.___._._._._._.'.split('_'),
				monthsParseExact: true,
				weekdays: '______'.split('_'),
				weekdaysShort: '______'.split('_'),
				weekdaysMin: '______'.split('_'),
				longDateFormat: {
					LT: 'A h:mm -',
					LTS: 'A h:mm:ss -',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY, A h:mm -',
					LLLL: 'dddd, D MMMM YYYY, A h:mm -'
				},
				calendar: {
					sameDay: '[] LT',
					nextDay: '[] LT',
					nextWeek: 'dddd, LT',
					lastDay: '[] LT',
					lastWeek: '[] dddd, LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: '%s ',
					past: '%s ',
					s: ' ',
					ss: '%d ',
					m: ' ',
					mm: '%d ',
					h: ' ',
					hh: '%d ',
					d: ' ',
					dd: '%d ',
					M: ' ',
					MM: '%d ',
					y: ' ',
					yy: '%d '
				},
				meridiemParse: /|| ||/i,
				meridiemHour: function(hour, meridiem) {
					if(hour === 12) {
						hour = 0;
					}
					if((meridiem === '' && hour >= 4) ||
						meridiem === ' ' ||
						meridiem === '') {
						return hour + 12;
					} else {
						return hour;
					}
				},
				meridiem: function(hour, minute, isLower) {
					if(hour < 4) {
						return '';
					} else if(hour < 12) {
						return '';
					} else if(hour < 17) {
						return ' ';
					} else if(hour < 20) {
						return '';
					} else {
						return '';
					}
				}
			});
			
			return ml;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/mn.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/mn.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			function translate(number, withoutSuffix, key, isFuture) {
				switch(key) {
					case 's':
						return withoutSuffix ? ' ' : ' ';
					case 'ss':
						return number + (withoutSuffix ? ' ' : ' ');
					case 'm':
					case 'mm':
						return number + (withoutSuffix ? ' ' : ' ');
					case 'h':
					case 'hh':
						return number + (withoutSuffix ? ' ' : ' ');
					case 'd':
					case 'dd':
						return number + (withoutSuffix ? ' ' : ' ');
					case 'M':
					case 'MM':
						return number + (withoutSuffix ? ' ' : ' ');
					case 'y':
					case 'yy':
						return number + (withoutSuffix ? ' ' : ' ');
					default:
						return number;
				}
			}
			
			var mn = moment.defineLocale('mn', {
				months: ' _ _ _ _ _ _ _ _ _ _  _  '.split('_'),
				monthsShort: '1 _2 _3 _4 _5 _6 _7 _8 _9 _10 _11 _12 '.split('_'),
				monthsParseExact: true,
				weekdays: '______'.split('_'),
				weekdaysShort: '______'.split('_'),
				weekdaysMin: '______'.split('_'),
				weekdaysParseExact: true,
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'YYYY-MM-DD',
					LL: 'YYYY  MMMM D',
					LLL: 'YYYY  MMMM D HH:mm',
					LLLL: 'dddd, YYYY  MMMM D HH:mm'
				},
				meridiemParse: /|/i,
				isPM: function(input) {
					return input === '';
				},
				meridiem: function(hour, minute, isLower) {
					if(hour < 12) {
						return '';
					} else {
						return '';
					}
				},
				calendar: {
					sameDay: '[] LT',
					nextDay: '[] LT',
					nextWeek: '[] dddd LT',
					lastDay: '[] LT',
					lastWeek: '[] dddd LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: '%s ',
					past: '%s ',
					s: translate,
					ss: translate,
					m: translate,
					mm: translate,
					h: translate,
					hh: translate,
					d: translate,
					dd: translate,
					M: translate,
					MM: translate,
					y: translate,
					yy: translate
				},
				dayOfMonthOrdinalParse: /\d{1,2} /,
				ordinal: function(number, period) {
					switch(period) {
						case 'd':
						case 'D':
						case 'DDD':
							return number + ' ';
						default:
							return number;
					}
				}
			});
			
			return mn;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/mr.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/mr.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var symbolMap = {
					'1': '',
					'2': '',
					'3': '',
					'4': '',
					'5': '',
					'6': '',
					'7': '',
					'8': '',
					'9': '',
					'0': ''
				},
				numberMap = {
					'': '1',
					'': '2',
					'': '3',
					'': '4',
					'': '5',
					'': '6',
					'': '7',
					'': '8',
					'': '9',
					'': '0'
				};
			
			function relativeTimeMr(number, withoutSuffix, string, isFuture) {
				var output = '';
				if(withoutSuffix) {
					switch(string) {
						case 's':
							output = ' ';
							break;
						case 'ss':
							output = '%d ';
							break;
						case 'm':
							output = ' ';
							break;
						case 'mm':
							output = '%d ';
							break;
						case 'h':
							output = ' ';
							break;
						case 'hh':
							output = '%d ';
							break;
						case 'd':
							output = ' ';
							break;
						case 'dd':
							output = '%d ';
							break;
						case 'M':
							output = ' ';
							break;
						case 'MM':
							output = '%d ';
							break;
						case 'y':
							output = ' ';
							break;
						case 'yy':
							output = '%d ';
							break;
					}
				} else {
					switch(string) {
						case 's':
							output = ' ';
							break;
						case 'ss':
							output = '%d ';
							break;
						case 'm':
							output = ' ';
							break;
						case 'mm':
							output = '%d ';
							break;
						case 'h':
							output = ' ';
							break;
						case 'hh':
							output = '%d ';
							break;
						case 'd':
							output = ' ';
							break;
						case 'dd':
							output = '%d ';
							break;
						case 'M':
							output = ' ';
							break;
						case 'MM':
							output = '%d ';
							break;
						case 'y':
							output = ' ';
							break;
						case 'yy':
							output = '%d ';
							break;
					}
				}
				return output.replace(/%d/i, number);
			}
			
			var mr = moment.defineLocale('mr', {
				months: '___________'.split('_'),
				monthsShort: '._._._._._._._._._._._.'.split('_'),
				monthsParseExact: true,
				weekdays: '______'.split('_'),
				weekdaysShort: '______'.split('_'),
				weekdaysMin: '______'.split('_'),
				longDateFormat: {
					LT: 'A h:mm ',
					LTS: 'A h:mm:ss ',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY, A h:mm ',
					LLLL: 'dddd, D MMMM YYYY, A h:mm '
				},
				calendar: {
					sameDay: '[] LT',
					nextDay: '[] LT',
					nextWeek: 'dddd, LT',
					lastDay: '[] LT',
					lastWeek: '[] dddd, LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: '%s',
					past: '%s',
					s: relativeTimeMr,
					ss: relativeTimeMr,
					m: relativeTimeMr,
					mm: relativeTimeMr,
					h: relativeTimeMr,
					hh: relativeTimeMr,
					d: relativeTimeMr,
					dd: relativeTimeMr,
					M: relativeTimeMr,
					MM: relativeTimeMr,
					y: relativeTimeMr,
					yy: relativeTimeMr
				},
				preparse: function(string) {
					return string.replace(/[]/g, function(match) {
						return numberMap[match];
					});
				},
				postformat: function(string) {
					return string.replace(/\d/g, function(match) {
						return symbolMap[match];
					});
				},
				meridiemParse: /|||/,
				meridiemHour: function(hour, meridiem) {
					if(hour === 12) {
						hour = 0;
					}
					if(meridiem === '') {
						return hour < 4 ? hour : hour + 12;
					} else if(meridiem === '') {
						return hour;
					} else if(meridiem === '') {
						return hour >= 10 ? hour : hour + 12;
					} else if(meridiem === '') {
						return hour + 12;
					}
				},
				meridiem: function(hour, minute, isLower) {
					if(hour < 4) {
						return '';
					} else if(hour < 10) {
						return '';
					} else if(hour < 17) {
						return '';
					} else if(hour < 20) {
						return '';
					} else {
						return '';
					}
				},
				week: {
					dow: 0, // Sunday is the first day of the week.
					doy: 6  // The week that contains Jan 6th is the first week of the year.
				}
			});
			
			return mr;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/ms-my.js":
	/*!*********************************************!*\
  !*** ./node_modules/moment/locale/ms-my.js ***!
  \*********************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var msMy = moment.defineLocale('ms-my', {
				months: 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
				monthsShort: 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
				weekdays: 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
				weekdaysShort: 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
				weekdaysMin: 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
				longDateFormat: {
					LT: 'HH.mm',
					LTS: 'HH.mm.ss',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY [pukul] HH.mm',
					LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm'
				},
				meridiemParse: /pagi|tengahari|petang|malam/,
				meridiemHour: function(hour, meridiem) {
					if(hour === 12) {
						hour = 0;
					}
					if(meridiem === 'pagi') {
						return hour;
					} else if(meridiem === 'tengahari') {
						return hour >= 11 ? hour : hour + 12;
					} else if(meridiem === 'petang' || meridiem === 'malam') {
						return hour + 12;
					}
				},
				meridiem: function(hours, minutes, isLower) {
					if(hours < 11) {
						return 'pagi';
					} else if(hours < 15) {
						return 'tengahari';
					} else if(hours < 19) {
						return 'petang';
					} else {
						return 'malam';
					}
				},
				calendar: {
					sameDay: '[Hari ini pukul] LT',
					nextDay: '[Esok pukul] LT',
					nextWeek: 'dddd [pukul] LT',
					lastDay: '[Kelmarin pukul] LT',
					lastWeek: 'dddd [lepas pukul] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: 'dalam %s',
					past: '%s yang lepas',
					s: 'beberapa saat',
					ss: '%d saat',
					m: 'seminit',
					mm: '%d minit',
					h: 'sejam',
					hh: '%d jam',
					d: 'sehari',
					dd: '%d hari',
					M: 'sebulan',
					MM: '%d bulan',
					y: 'setahun',
					yy: '%d tahun'
				},
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 7  // The week that contains Jan 7th is the first week of the year.
				}
			});
			
			return msMy;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/ms.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/ms.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var ms = moment.defineLocale('ms', {
				months: 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
				monthsShort: 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
				weekdays: 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
				weekdaysShort: 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
				weekdaysMin: 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
				longDateFormat: {
					LT: 'HH.mm',
					LTS: 'HH.mm.ss',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY [pukul] HH.mm',
					LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm'
				},
				meridiemParse: /pagi|tengahari|petang|malam/,
				meridiemHour: function(hour, meridiem) {
					if(hour === 12) {
						hour = 0;
					}
					if(meridiem === 'pagi') {
						return hour;
					} else if(meridiem === 'tengahari') {
						return hour >= 11 ? hour : hour + 12;
					} else if(meridiem === 'petang' || meridiem === 'malam') {
						return hour + 12;
					}
				},
				meridiem: function(hours, minutes, isLower) {
					if(hours < 11) {
						return 'pagi';
					} else if(hours < 15) {
						return 'tengahari';
					} else if(hours < 19) {
						return 'petang';
					} else {
						return 'malam';
					}
				},
				calendar: {
					sameDay: '[Hari ini pukul] LT',
					nextDay: '[Esok pukul] LT',
					nextWeek: 'dddd [pukul] LT',
					lastDay: '[Kelmarin pukul] LT',
					lastWeek: 'dddd [lepas pukul] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: 'dalam %s',
					past: '%s yang lepas',
					s: 'beberapa saat',
					ss: '%d saat',
					m: 'seminit',
					mm: '%d minit',
					h: 'sejam',
					hh: '%d jam',
					d: 'sehari',
					dd: '%d hari',
					M: 'sebulan',
					MM: '%d bulan',
					y: 'setahun',
					yy: '%d tahun'
				},
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 7  // The week that contains Jan 7th is the first week of the year.
				}
			});
			
			return ms;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/mt.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/mt.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var mt = moment.defineLocale('mt', {
				months: 'Jannar_Frar_Marzu_April_Mejju_unju_Lulju_Awwissu_Settembru_Ottubru_Novembru_Diembru'.split('_'),
				monthsShort: 'Jan_Fra_Mar_Apr_Mej_un_Lul_Aww_Set_Ott_Nov_Di'.split('_'),
				weekdays: 'Il-add_It-Tnejn_It-Tlieta_L-Erbga_Il-amis_Il-imga_Is-Sibt'.split('_'),
				weekdaysShort: 'ad_Tne_Tli_Erb_am_im_Sib'.split('_'),
				weekdaysMin: 'a_Tn_Tl_Er_a_i_Si'.split('_'),
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY HH:mm',
					LLLL: 'dddd, D MMMM YYYY HH:mm'
				},
				calendar: {
					sameDay: '[Illum fil-]LT',
					nextDay: '[Gada fil-]LT',
					nextWeek: 'dddd [fil-]LT',
					lastDay: '[Il-biera fil-]LT',
					lastWeek: 'dddd [li gadda] [fil-]LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: 'f %s',
					past: '%s ilu',
					s: 'ftit sekondi',
					ss: '%d sekondi',
					m: 'minuta',
					mm: '%d minuti',
					h: 'siega',
					hh: '%d siegat',
					d: 'urnata',
					dd: '%d ranet',
					M: 'xahar',
					MM: '%d xhur',
					y: 'sena',
					yy: '%d sni'
				},
				dayOfMonthOrdinalParse: /\d{1,2}/,
				ordinal: '%d',
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return mt;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/my.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/my.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var symbolMap = {
				'1': '',
				'2': '',
				'3': '',
				'4': '',
				'5': '',
				'6': '',
				'7': '',
				'8': '',
				'9': '',
				'0': ''
			}, numberMap = {
				'': '1',
				'': '2',
				'': '3',
				'': '4',
				'': '5',
				'': '6',
				'': '7',
				'': '8',
				'': '9',
				'': '0'
			};
			
			var my = moment.defineLocale('my', {
				months: '___________'.split('_'),
				monthsShort: '___________'.split('_'),
				weekdays: '______'.split('_'),
				weekdaysShort: '______'.split('_'),
				weekdaysMin: '______'.split('_'),
				
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY HH:mm',
					LLLL: 'dddd D MMMM YYYY HH:mm'
				},
				calendar: {
					sameDay: '[.] LT []',
					nextDay: '[] LT []',
					nextWeek: 'dddd LT []',
					lastDay: '[.] LT []',
					lastWeek: '[] dddd LT []',
					sameElse: 'L'
				},
				relativeTime: {
					future: ' %s ',
					past: ' %s ',
					s: '.',
					ss: '%d ',
					m: '',
					mm: '%d ',
					h: '',
					hh: '%d ',
					d: '',
					dd: '%d ',
					M: '',
					MM: '%d ',
					y: '',
					yy: '%d '
				},
				preparse: function(string) {
					return string.replace(/[]/g, function(match) {
						return numberMap[match];
					});
				},
				postformat: function(string) {
					return string.replace(/\d/g, function(match) {
						return symbolMap[match];
					});
				},
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4 // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return my;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/nb.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/nb.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var nb = moment.defineLocale('nb', {
				months: 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
				monthsShort: 'jan._feb._mars_april_mai_juni_juli_aug._sep._okt._nov._des.'.split('_'),
				monthsParseExact: true,
				weekdays: 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),
				weekdaysShort: 's._ma._ti._on._to._fr._l.'.split('_'),
				weekdaysMin: 's_ma_ti_on_to_fr_l'.split('_'),
				weekdaysParseExact: true,
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD.MM.YYYY',
					LL: 'D. MMMM YYYY',
					LLL: 'D. MMMM YYYY [kl.] HH:mm',
					LLLL: 'dddd D. MMMM YYYY [kl.] HH:mm'
				},
				calendar: {
					sameDay: '[i dag kl.] LT',
					nextDay: '[i morgen kl.] LT',
					nextWeek: 'dddd [kl.] LT',
					lastDay: '[i gr kl.] LT',
					lastWeek: '[forrige] dddd [kl.] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: 'om %s',
					past: '%s siden',
					s: 'noen sekunder',
					ss: '%d sekunder',
					m: 'ett minutt',
					mm: '%d minutter',
					h: 'en time',
					hh: '%d timer',
					d: 'en dag',
					dd: '%d dager',
					M: 'en mned',
					MM: '%d mneder',
					y: 'ett r',
					yy: '%d r'
				},
				dayOfMonthOrdinalParse: /\d{1,2}\./,
				ordinal: '%d.',
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return nb;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/ne.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/ne.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var symbolMap = {
					'1': '',
					'2': '',
					'3': '',
					'4': '',
					'5': '',
					'6': '',
					'7': '',
					'8': '',
					'9': '',
					'0': ''
				},
				numberMap = {
					'': '1',
					'': '2',
					'': '3',
					'': '4',
					'': '5',
					'': '6',
					'': '7',
					'': '8',
					'': '9',
					'': '0'
				};
			
			var ne = moment.defineLocale('ne', {
				months: '___________'.split('_'),
				monthsShort: '._.__.___._._._._._.'.split('_'),
				monthsParseExact: true,
				weekdays: '______'.split('_'),
				weekdaysShort: '._._._._._._.'.split('_'),
				weekdaysMin: '._._._._._._.'.split('_'),
				weekdaysParseExact: true,
				longDateFormat: {
					LT: 'A h:mm ',
					LTS: 'A h:mm:ss ',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY, A h:mm ',
					LLLL: 'dddd, D MMMM YYYY, A h:mm '
				},
				preparse: function(string) {
					return string.replace(/[]/g, function(match) {
						return numberMap[match];
					});
				},
				postformat: function(string) {
					return string.replace(/\d/g, function(match) {
						return symbolMap[match];
					});
				},
				meridiemParse: /|||/,
				meridiemHour: function(hour, meridiem) {
					if(hour === 12) {
						hour = 0;
					}
					if(meridiem === '') {
						return hour < 4 ? hour : hour + 12;
					} else if(meridiem === '') {
						return hour;
					} else if(meridiem === '') {
						return hour >= 10 ? hour : hour + 12;
					} else if(meridiem === '') {
						return hour + 12;
					}
				},
				meridiem: function(hour, minute, isLower) {
					if(hour < 3) {
						return '';
					} else if(hour < 12) {
						return '';
					} else if(hour < 16) {
						return '';
					} else if(hour < 20) {
						return '';
					} else {
						return '';
					}
				},
				calendar: {
					sameDay: '[] LT',
					nextDay: '[] LT',
					nextWeek: '[] dddd[,] LT',
					lastDay: '[] LT',
					lastWeek: '[] dddd[,] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: '%s',
					past: '%s ',
					s: ' ',
					ss: '%d ',
					m: ' ',
					mm: '%d ',
					h: ' ',
					hh: '%d ',
					d: ' ',
					dd: '%d ',
					M: ' ',
					MM: '%d ',
					y: ' ',
					yy: '%d '
				},
				week: {
					dow: 0, // Sunday is the first day of the week.
					doy: 6  // The week that contains Jan 6th is the first week of the year.
				}
			});
			
			return ne;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/nl-be.js":
	/*!*********************************************!*\
  !*** ./node_modules/moment/locale/nl-be.js ***!
  \*********************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_'),
				monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');
			
			var monthsParse = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i];
			var monthsRegex = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;
			
			var nlBe = moment.defineLocale('nl-be', {
				months: 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
				monthsShort: function(m, format) {
					if(!m) {
						return monthsShortWithDots;
					} else if(/-MMM-/.test(format)) {
						return monthsShortWithoutDots[m.month()];
					} else {
						return monthsShortWithDots[m.month()];
					}
				},
				
				monthsRegex: monthsRegex,
				monthsShortRegex: monthsRegex,
				monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,
				monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,
				
				monthsParse: monthsParse,
				longMonthsParse: monthsParse,
				shortMonthsParse: monthsParse,
				
				weekdays: 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
				weekdaysShort: 'zo._ma._di._wo._do._vr._za.'.split('_'),
				weekdaysMin: 'zo_ma_di_wo_do_vr_za'.split('_'),
				weekdaysParseExact: true,
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY HH:mm',
					LLLL: 'dddd D MMMM YYYY HH:mm'
				},
				calendar: {
					sameDay: '[vandaag om] LT',
					nextDay: '[morgen om] LT',
					nextWeek: 'dddd [om] LT',
					lastDay: '[gisteren om] LT',
					lastWeek: '[afgelopen] dddd [om] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: 'over %s',
					past: '%s geleden',
					s: 'een paar seconden',
					ss: '%d seconden',
					m: 'n minuut',
					mm: '%d minuten',
					h: 'n uur',
					hh: '%d uur',
					d: 'n dag',
					dd: '%d dagen',
					M: 'n maand',
					MM: '%d maanden',
					y: 'n jaar',
					yy: '%d jaar'
				},
				dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
				ordinal: function(number) {
					return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
				},
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return nlBe;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/nl.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/nl.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_'),
				monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');
			
			var monthsParse = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i];
			var monthsRegex = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;
			
			var nl = moment.defineLocale('nl', {
				months: 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
				monthsShort: function(m, format) {
					if(!m) {
						return monthsShortWithDots;
					} else if(/-MMM-/.test(format)) {
						return monthsShortWithoutDots[m.month()];
					} else {
						return monthsShortWithDots[m.month()];
					}
				},
				
				monthsRegex: monthsRegex,
				monthsShortRegex: monthsRegex,
				monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,
				monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,
				
				monthsParse: monthsParse,
				longMonthsParse: monthsParse,
				shortMonthsParse: monthsParse,
				
				weekdays: 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
				weekdaysShort: 'zo._ma._di._wo._do._vr._za.'.split('_'),
				weekdaysMin: 'zo_ma_di_wo_do_vr_za'.split('_'),
				weekdaysParseExact: true,
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD-MM-YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY HH:mm',
					LLLL: 'dddd D MMMM YYYY HH:mm'
				},
				calendar: {
					sameDay: '[vandaag om] LT',
					nextDay: '[morgen om] LT',
					nextWeek: 'dddd [om] LT',
					lastDay: '[gisteren om] LT',
					lastWeek: '[afgelopen] dddd [om] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: 'over %s',
					past: '%s geleden',
					s: 'een paar seconden',
					ss: '%d seconden',
					m: 'n minuut',
					mm: '%d minuten',
					h: 'n uur',
					hh: '%d uur',
					d: 'n dag',
					dd: '%d dagen',
					M: 'n maand',
					MM: '%d maanden',
					y: 'n jaar',
					yy: '%d jaar'
				},
				dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
				ordinal: function(number) {
					return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
				},
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return nl;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/nn.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/nn.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var nn = moment.defineLocale('nn', {
				months: 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
				monthsShort: 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
				weekdays: 'sundag_mndag_tysdag_onsdag_torsdag_fredag_laurdag'.split('_'),
				weekdaysShort: 'sun_mn_tys_ons_tor_fre_lau'.split('_'),
				weekdaysMin: 'su_m_ty_on_to_fr_l'.split('_'),
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD.MM.YYYY',
					LL: 'D. MMMM YYYY',
					LLL: 'D. MMMM YYYY [kl.] H:mm',
					LLLL: 'dddd D. MMMM YYYY [kl.] HH:mm'
				},
				calendar: {
					sameDay: '[I dag klokka] LT',
					nextDay: '[I morgon klokka] LT',
					nextWeek: 'dddd [klokka] LT',
					lastDay: '[I gr klokka] LT',
					lastWeek: '[Fregande] dddd [klokka] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: 'om %s',
					past: '%s sidan',
					s: 'nokre sekund',
					ss: '%d sekund',
					m: 'eit minutt',
					mm: '%d minutt',
					h: 'ein time',
					hh: '%d timar',
					d: 'ein dag',
					dd: '%d dagar',
					M: 'ein mnad',
					MM: '%d mnader',
					y: 'eit r',
					yy: '%d r'
				},
				dayOfMonthOrdinalParse: /\d{1,2}\./,
				ordinal: '%d.',
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return nn;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/pa-in.js":
	/*!*********************************************!*\
  !*** ./node_modules/moment/locale/pa-in.js ***!
  \*********************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var symbolMap = {
					'1': '',
					'2': '',
					'3': '',
					'4': '',
					'5': '',
					'6': '',
					'7': '',
					'8': '',
					'9': '',
					'0': ''
				},
				numberMap = {
					'': '1',
					'': '2',
					'': '3',
					'': '4',
					'': '5',
					'': '6',
					'': '7',
					'': '8',
					'': '9',
					'': '0'
				};
			
			var paIn = moment.defineLocale('pa-in', {
				// There are months name as per Nanakshahi Calendar but they are not used as rigidly in modern Punjabi.
				months: '___________'.split('_'),
				monthsShort: '___________'.split('_'),
				weekdays: '______'.split('_'),
				weekdaysShort: '______'.split('_'),
				weekdaysMin: '______'.split('_'),
				longDateFormat: {
					LT: 'A h:mm ',
					LTS: 'A h:mm:ss ',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY, A h:mm ',
					LLLL: 'dddd, D MMMM YYYY, A h:mm '
				},
				calendar: {
					sameDay: '[] LT',
					nextDay: '[] LT',
					nextWeek: '[] dddd, LT',
					lastDay: '[] LT',
					lastWeek: '[] dddd, LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: '%s ',
					past: '%s ',
					s: ' ',
					ss: '%d ',
					m: ' ',
					mm: '%d ',
					h: ' ',
					hh: '%d ',
					d: ' ',
					dd: '%d ',
					M: ' ',
					MM: '%d ',
					y: ' ',
					yy: '%d '
				},
				preparse: function(string) {
					return string.replace(/[]/g, function(match) {
						return numberMap[match];
					});
				},
				postformat: function(string) {
					return string.replace(/\d/g, function(match) {
						return symbolMap[match];
					});
				},
				// Punjabi notation for meridiems are quite fuzzy in practice. While there exists
				// a rigid notion of a 'Pahar' it is not used as rigidly in modern Punjabi.
				meridiemParse: /|||/,
				meridiemHour: function(hour, meridiem) {
					if(hour === 12) {
						hour = 0;
					}
					if(meridiem === '') {
						return hour < 4 ? hour : hour + 12;
					} else if(meridiem === '') {
						return hour;
					} else if(meridiem === '') {
						return hour >= 10 ? hour : hour + 12;
					} else if(meridiem === '') {
						return hour + 12;
					}
				},
				meridiem: function(hour, minute, isLower) {
					if(hour < 4) {
						return '';
					} else if(hour < 10) {
						return '';
					} else if(hour < 17) {
						return '';
					} else if(hour < 20) {
						return '';
					} else {
						return '';
					}
				},
				week: {
					dow: 0, // Sunday is the first day of the week.
					doy: 6  // The week that contains Jan 6th is the first week of the year.
				}
			});
			
			return paIn;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/pl.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/pl.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var monthsNominative = 'stycze_luty_marzec_kwiecie_maj_czerwiec_lipiec_sierpie_wrzesie_padziernik_listopad_grudzie'.split('_'),
				monthsSubjective = 'stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_wrzenia_padziernika_listopada_grudnia'.split('_');
			
			function plural(n) {
				return (n % 10 < 5) && (n % 10 > 1) && ((~~(n / 10) % 10) !== 1);
			}
			
			function translate(number, withoutSuffix, key) {
				var result = number + ' ';
				switch(key) {
					case 'ss':
						return result + (plural(number) ? 'sekundy' : 'sekund');
					case 'm':
						return withoutSuffix ? 'minuta' : 'minut';
					case 'mm':
						return result + (plural(number) ? 'minuty' : 'minut');
					case 'h':
						return withoutSuffix ? 'godzina' : 'godzin';
					case 'hh':
						return result + (plural(number) ? 'godziny' : 'godzin');
					case 'MM':
						return result + (plural(number) ? 'miesice' : 'miesicy');
					case 'yy':
						return result + (plural(number) ? 'lata' : 'lat');
				}
			}
			
			var pl = moment.defineLocale('pl', {
				months: function(momentToFormat, format) {
					if(!momentToFormat) {
						return monthsNominative;
					} else if(format === '') {
						// Hack: if format empty we know this is used to generate
						// RegExp by moment. Give then back both valid forms of months
						// in RegExp ready format.
						return '(' + monthsSubjective[momentToFormat.month()] + '|' + monthsNominative[momentToFormat.month()] + ')';
					} else if(/D MMMM/.test(format)) {
						return monthsSubjective[momentToFormat.month()];
					} else {
						return monthsNominative[momentToFormat.month()];
					}
				},
				monthsShort: 'sty_lut_mar_kwi_maj_cze_lip_sie_wrz_pa_lis_gru'.split('_'),
				weekdays: 'niedziela_poniedziaek_wtorek_roda_czwartek_pitek_sobota'.split('_'),
				weekdaysShort: 'ndz_pon_wt_r_czw_pt_sob'.split('_'),
				weekdaysMin: 'Nd_Pn_Wt_r_Cz_Pt_So'.split('_'),
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD.MM.YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY HH:mm',
					LLLL: 'dddd, D MMMM YYYY HH:mm'
				},
				calendar: {
					sameDay: '[Dzi o] LT',
					nextDay: '[Jutro o] LT',
					nextWeek: function() {
						switch(this.day()) {
							case 0:
								return '[W niedziel o] LT';
							
							case 2:
								return '[We wtorek o] LT';
							
							case 3:
								return '[W rod o] LT';
							
							case 6:
								return '[W sobot o] LT';
							
							default:
								return '[W] dddd [o] LT';
						}
					},
					lastDay: '[Wczoraj o] LT',
					lastWeek: function() {
						switch(this.day()) {
							case 0:
								return '[W zesz niedziel o] LT';
							case 3:
								return '[W zesz rod o] LT';
							case 6:
								return '[W zesz sobot o] LT';
							default:
								return '[W zeszy] dddd [o] LT';
						}
					},
					sameElse: 'L'
				},
				relativeTime: {
					future: 'za %s',
					past: '%s temu',
					s: 'kilka sekund',
					ss: translate,
					m: translate,
					mm: translate,
					h: translate,
					hh: translate,
					d: '1 dzie',
					dd: '%d dni',
					M: 'miesic',
					MM: translate,
					y: 'rok',
					yy: translate
				},
				dayOfMonthOrdinalParse: /\d{1,2}\./,
				ordinal: '%d.',
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return pl;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/pt-br.js":
	/*!*********************************************!*\
  !*** ./node_modules/moment/locale/pt-br.js ***!
  \*********************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var ptBr = moment.defineLocale('pt-br', {
				months: 'Janeiro_Fevereiro_Maro_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
				monthsShort: 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
				weekdays: 'Domingo_Segunda-feira_Tera-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sbado'.split('_'),
				weekdaysShort: 'Dom_Seg_Ter_Qua_Qui_Sex_Sb'.split('_'),
				weekdaysMin: 'Do_2_3_4_5_6_S'.split('_'),
				weekdaysParseExact: true,
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD/MM/YYYY',
					LL: 'D [de] MMMM [de] YYYY',
					LLL: 'D [de] MMMM [de] YYYY [s] HH:mm',
					LLLL: 'dddd, D [de] MMMM [de] YYYY [s] HH:mm'
				},
				calendar: {
					sameDay: '[Hoje s] LT',
					nextDay: '[Amanh s] LT',
					nextWeek: 'dddd [s] LT',
					lastDay: '[Ontem s] LT',
					lastWeek: function() {
						return (this.day() === 0 || this.day() === 6) ?
							'[ltimo] dddd [s] LT' : // Saturday + Sunday
							'[ltima] dddd [s] LT'; // Monday - Friday
					},
					sameElse: 'L'
				},
				relativeTime: {
					future: 'em %s',
					past: 'h %s',
					s: 'poucos segundos',
					ss: '%d segundos',
					m: 'um minuto',
					mm: '%d minutos',
					h: 'uma hora',
					hh: '%d horas',
					d: 'um dia',
					dd: '%d dias',
					M: 'um ms',
					MM: '%d meses',
					y: 'um ano',
					yy: '%d anos'
				},
				dayOfMonthOrdinalParse: /\d{1,2}/,
				ordinal: '%d'
			});
			
			return ptBr;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/pt.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/pt.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var pt = moment.defineLocale('pt', {
				months: 'Janeiro_Fevereiro_Maro_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
				monthsShort: 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
				weekdays: 'Domingo_Segunda-feira_Tera-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sbado'.split('_'),
				weekdaysShort: 'Dom_Seg_Ter_Qua_Qui_Sex_Sb'.split('_'),
				weekdaysMin: 'Do_2_3_4_5_6_S'.split('_'),
				weekdaysParseExact: true,
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD/MM/YYYY',
					LL: 'D [de] MMMM [de] YYYY',
					LLL: 'D [de] MMMM [de] YYYY HH:mm',
					LLLL: 'dddd, D [de] MMMM [de] YYYY HH:mm'
				},
				calendar: {
					sameDay: '[Hoje s] LT',
					nextDay: '[Amanh s] LT',
					nextWeek: 'dddd [s] LT',
					lastDay: '[Ontem s] LT',
					lastWeek: function() {
						return (this.day() === 0 || this.day() === 6) ?
							'[ltimo] dddd [s] LT' : // Saturday + Sunday
							'[ltima] dddd [s] LT'; // Monday - Friday
					},
					sameElse: 'L'
				},
				relativeTime: {
					future: 'em %s',
					past: 'h %s',
					s: 'segundos',
					ss: '%d segundos',
					m: 'um minuto',
					mm: '%d minutos',
					h: 'uma hora',
					hh: '%d horas',
					d: 'um dia',
					dd: '%d dias',
					M: 'um ms',
					MM: '%d meses',
					y: 'um ano',
					yy: '%d anos'
				},
				dayOfMonthOrdinalParse: /\d{1,2}/,
				ordinal: '%d',
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return pt;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/ro.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/ro.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			function relativeTimeWithPlural(number, withoutSuffix, key) {
				var format = {
						'ss': 'secunde',
						'mm': 'minute',
						'hh': 'ore',
						'dd': 'zile',
						'MM': 'luni',
						'yy': 'ani'
					},
					separator = ' ';
				if(number % 100 >= 20 || (number >= 100 && number % 100 === 0)) {
					separator = ' de ';
				}
				return number + separator + format[key];
			}
			
			var ro = moment.defineLocale('ro', {
				months: 'ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie'.split('_'),
				monthsShort: 'ian._febr._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.'.split('_'),
				monthsParseExact: true,
				weekdays: 'duminic_luni_mari_miercuri_joi_vineri_smbt'.split('_'),
				weekdaysShort: 'Dum_Lun_Mar_Mie_Joi_Vin_Sm'.split('_'),
				weekdaysMin: 'Du_Lu_Ma_Mi_Jo_Vi_S'.split('_'),
				longDateFormat: {
					LT: 'H:mm',
					LTS: 'H:mm:ss',
					L: 'DD.MM.YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY H:mm',
					LLLL: 'dddd, D MMMM YYYY H:mm'
				},
				calendar: {
					sameDay: '[azi la] LT',
					nextDay: '[mine la] LT',
					nextWeek: 'dddd [la] LT',
					lastDay: '[ieri la] LT',
					lastWeek: '[fosta] dddd [la] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: 'peste %s',
					past: '%s n urm',
					s: 'cteva secunde',
					ss: relativeTimeWithPlural,
					m: 'un minut',
					mm: relativeTimeWithPlural,
					h: 'o or',
					hh: relativeTimeWithPlural,
					d: 'o zi',
					dd: relativeTimeWithPlural,
					M: 'o lun',
					MM: relativeTimeWithPlural,
					y: 'un an',
					yy: relativeTimeWithPlural
				},
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 7  // The week that contains Jan 7th is the first week of the year.
				}
			});
			
			return ro;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/ru.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/ru.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			function plural(word, num) {
				var forms = word.split('_');
				return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
			}
			
			function relativeTimeWithPlural(number, withoutSuffix, key) {
				var format = {
					'ss': withoutSuffix ? '__' : '__',
					'mm': withoutSuffix ? '__' : '__',
					'hh': '__',
					'dd': '__',
					'MM': '__',
					'yy': '__'
				};
				if(key === 'm') {
					return withoutSuffix ? '' : '';
				} else {
					return number + ' ' + plural(format[key], +number);
				}
			}
			
			var monthsParse = [/^/i, /^/i, /^/i, /^/i, /^[]/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i];
			
			// http://new.gramota.ru/spravka/rules/139-prop :  103
			//  : http://new.gramota.ru/spravka/buro/search-answer?s=242637
			// CLDR data:          http://www.unicode.org/cldr/charts/28/summary/ru.html#1753
			var ru = moment.defineLocale('ru', {
				months: {
					format: '___________'.split('_'),
					standalone: '___________'.split('_')
				},
				monthsShort: {
					//  CLDR  "."  ".",        ?
					format: '._._._.____._._._._.'.split('_'),
					standalone: '._.__.____._._._._.'.split('_')
				},
				weekdays: {
					standalone: '______'.split('_'),
					format: '______'.split('_'),
					isFormat: /\[ ?[] ?(?:||)? ?\] ?dddd/
				},
				weekdaysShort: '______'.split('_'),
				weekdaysMin: '______'.split('_'),
				monthsParse: monthsParse,
				longMonthsParse: monthsParse,
				shortMonthsParse: monthsParse,
				
				//    ,   ,  ,  4 ,      
				monthsRegex: /^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i,
				
				//  
				monthsShortRegex: /^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i,
				
				//    
				monthsStrictRegex: /^([]|[]|?|[]|[]|[]|[]|?|[]|[]|[]|[])/i,
				
				// ,     
				monthsShortStrictRegex: /^(\.|?\.|[.]|\.|[]|[.]|[.]|\.|?\.|\.|?\.|\.)/i,
				longDateFormat: {
					LT: 'H:mm',
					LTS: 'H:mm:ss',
					L: 'DD.MM.YYYY',
					LL: 'D MMMM YYYY .',
					LLL: 'D MMMM YYYY ., H:mm',
					LLLL: 'dddd, D MMMM YYYY ., H:mm'
				},
				calendar: {
					sameDay: '[, ] LT',
					nextDay: '[, ] LT',
					lastDay: '[, ] LT',
					nextWeek: function(now) {
						if(now.week() !== this.week()) {
							switch(this.day()) {
								case 0:
									return '[ ] dddd, [] LT';
								case 1:
								case 2:
								case 4:
									return '[ ] dddd, [] LT';
								case 3:
								case 5:
								case 6:
									return '[ ] dddd, [] LT';
							}
						} else {
							if(this.day() === 2) {
								return '[] dddd, [] LT';
							} else {
								return '[] dddd, [] LT';
							}
						}
					},
					lastWeek: function(now) {
						if(now.week() !== this.week()) {
							switch(this.day()) {
								case 0:
									return '[ ] dddd, [] LT';
								case 1:
								case 2:
								case 4:
									return '[ ] dddd, [] LT';
								case 3:
								case 5:
								case 6:
									return '[ ] dddd, [] LT';
							}
						} else {
							if(this.day() === 2) {
								return '[] dddd, [] LT';
							} else {
								return '[] dddd, [] LT';
							}
						}
					},
					sameElse: 'L'
				},
				relativeTime: {
					future: ' %s',
					past: '%s ',
					s: ' ',
					ss: relativeTimeWithPlural,
					m: relativeTimeWithPlural,
					mm: relativeTimeWithPlural,
					h: '',
					hh: relativeTimeWithPlural,
					d: '',
					dd: relativeTimeWithPlural,
					M: '',
					MM: relativeTimeWithPlural,
					y: '',
					yy: relativeTimeWithPlural
				},
				meridiemParse: /|||/i,
				isPM: function(input) {
					return /^(|)$/.test(input);
				},
				meridiem: function(hour, minute, isLower) {
					if(hour < 4) {
						return '';
					} else if(hour < 12) {
						return '';
					} else if(hour < 17) {
						return '';
					} else {
						return '';
					}
				},
				dayOfMonthOrdinalParse: /\d{1,2}-(||)/,
				ordinal: function(number, period) {
					switch(period) {
						case 'M':
						case 'd':
						case 'DDD':
							return number + '-';
						case 'D':
							return number + '-';
						case 'w':
						case 'W':
							return number + '-';
						default:
							return number;
					}
				},
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return ru;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/sd.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/sd.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var months = [
				'',
				'',
				'',
				'',
				'',
				'',
				'',
				'',
				'',
				'',
				'',
				''
			];
			var days = [
				'',
				'',
				'',
				'',
				'',
				'',
				''
			];
			
			var sd = moment.defineLocale('sd', {
				months: months,
				monthsShort: months,
				weekdays: days,
				weekdaysShort: days,
				weekdaysMin: days,
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY HH:mm',
					LLLL: 'dddd D MMMM YYYY HH:mm'
				},
				meridiemParse: /|/,
				isPM: function(input) {
					return '' === input;
				},
				meridiem: function(hour, minute, isLower) {
					if(hour < 12) {
						return '';
					}
					return '';
				},
				calendar: {
					sameDay: '[] LT',
					nextDay: '[] LT',
					nextWeek: 'dddd [  ] LT',
					lastDay: '[] LT',
					lastWeek: '[ ] dddd [] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: '%s ',
					past: '%s ',
					s: ' ',
					ss: '%d ',
					m: ' ',
					mm: '%d ',
					h: ' ',
					hh: '%d ',
					d: ' ',
					dd: '%d ',
					M: ' ',
					MM: '%d ',
					y: ' ',
					yy: '%d '
				},
				preparse: function(string) {
					return string.replace(//g, ',');
				},
				postformat: function(string) {
					return string.replace(/,/g, '');
				},
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return sd;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/se.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/se.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var se = moment.defineLocale('se', {
				months: 'oajagemnnu_guovvamnnu_njukamnnu_cuoomnnu_miessemnnu_geassemnnu_suoidnemnnu_borgemnnu_akamnnu_golggotmnnu_skbmamnnu_juovlamnnu'.split('_'),
				monthsShort: 'oj_guov_njuk_cuo_mies_geas_suoi_borg_ak_golg_skb_juov'.split('_'),
				weekdays: 'sotnabeaivi_vuossrga_maebrga_gaskavahkku_duorastat_bearjadat_lvvardat'.split('_'),
				weekdaysShort: 'sotn_vuos_ma_gask_duor_bear_lv'.split('_'),
				weekdaysMin: 's_v_m_g_d_b_L'.split('_'),
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD.MM.YYYY',
					LL: 'MMMM D. [b.] YYYY',
					LLL: 'MMMM D. [b.] YYYY [ti.] HH:mm',
					LLLL: 'dddd, MMMM D. [b.] YYYY [ti.] HH:mm'
				},
				calendar: {
					sameDay: '[otne ti] LT',
					nextDay: '[ihttin ti] LT',
					nextWeek: 'dddd [ti] LT',
					lastDay: '[ikte ti] LT',
					lastWeek: '[ovddit] dddd [ti] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: '%s geaes',
					past: 'mait %s',
					s: 'moadde sekunddat',
					ss: '%d sekunddat',
					m: 'okta minuhta',
					mm: '%d minuhtat',
					h: 'okta diimmu',
					hh: '%d diimmut',
					d: 'okta beaivi',
					dd: '%d beaivvit',
					M: 'okta mnnu',
					MM: '%d mnut',
					y: 'okta jahki',
					yy: '%d jagit'
				},
				dayOfMonthOrdinalParse: /\d{1,2}\./,
				ordinal: '%d.',
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return se;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/si.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/si.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			/*jshint -W100*/
			var si = moment.defineLocale('si', {
				months: '___________'.split('_'),
				monthsShort: '___________'.split('_'),
				weekdays: '______'.split('_'),
				weekdaysShort: '______'.split('_'),
				weekdaysMin: '______'.split('_'),
				weekdaysParseExact: true,
				longDateFormat: {
					LT: 'a h:mm',
					LTS: 'a h:mm:ss',
					L: 'YYYY/MM/DD',
					LL: 'YYYY MMMM D',
					LLL: 'YYYY MMMM D, a h:mm',
					LLLL: 'YYYY MMMM D [] dddd, a h:mm:ss'
				},
				calendar: {
					sameDay: '[] LT[]',
					nextDay: '[] LT[]',
					nextWeek: 'dddd LT[]',
					lastDay: '[] LT[]',
					lastWeek: '[] dddd LT[]',
					sameElse: 'L'
				},
				relativeTime: {
					future: '%s',
					past: '%s ',
					s: ' ',
					ss: ' %d',
					m: '',
					mm: ' %d',
					h: '',
					hh: ' %d',
					d: '',
					dd: ' %d',
					M: '',
					MM: ' %d',
					y: '',
					yy: ' %d'
				},
				dayOfMonthOrdinalParse: /\d{1,2} /,
				ordinal: function(number) {
					return number + ' ';
				},
				meridiemParse: / | |.|../,
				isPM: function(input) {
					return input === '..' || input === ' ';
				},
				meridiem: function(hours, minutes, isLower) {
					if(hours > 11) {
						return isLower ? '..' : ' ';
					} else {
						return isLower ? '..' : ' ';
					}
				}
			});
			
			return si;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/sk.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/sk.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var months = 'janur_februr_marec_aprl_mj_jn_jl_august_september_oktber_november_december'.split('_'),
				monthsShort = 'jan_feb_mar_apr_mj_jn_jl_aug_sep_okt_nov_dec'.split('_');
			
			function plural(n) {
				return (n > 1) && (n < 5);
			}
			
			function translate(number, withoutSuffix, key, isFuture) {
				var result = number + ' ';
				switch(key) {
					case 's':  // a few seconds / in a few seconds / a few seconds ago
						return (withoutSuffix || isFuture) ? 'pr seknd' : 'pr sekundami';
					case 'ss': // 9 seconds / in 9 seconds / 9 seconds ago
						if(withoutSuffix || isFuture) {
							return result + (plural(number) ? 'sekundy' : 'seknd');
						} else {
							return result + 'sekundami';
						}
						break;
					case 'm':  // a minute / in a minute / a minute ago
						return withoutSuffix ? 'minta' : (isFuture ? 'mintu' : 'mintou');
					case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
						if(withoutSuffix || isFuture) {
							return result + (plural(number) ? 'minty' : 'mint');
						} else {
							return result + 'mintami';
						}
						break;
					case 'h':  // an hour / in an hour / an hour ago
						return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
					case 'hh': // 9 hours / in 9 hours / 9 hours ago
						if(withoutSuffix || isFuture) {
							return result + (plural(number) ? 'hodiny' : 'hodn');
						} else {
							return result + 'hodinami';
						}
						break;
					case 'd':  // a day / in a day / a day ago
						return (withoutSuffix || isFuture) ? 'de' : 'dom';
					case 'dd': // 9 days / in 9 days / 9 days ago
						if(withoutSuffix || isFuture) {
							return result + (plural(number) ? 'dni' : 'dn');
						} else {
							return result + 'dami';
						}
						break;
					case 'M':  // a month / in a month / a month ago
						return (withoutSuffix || isFuture) ? 'mesiac' : 'mesiacom';
					case 'MM': // 9 months / in 9 months / 9 months ago
						if(withoutSuffix || isFuture) {
							return result + (plural(number) ? 'mesiace' : 'mesiacov');
						} else {
							return result + 'mesiacmi';
						}
						break;
					case 'y':  // a year / in a year / a year ago
						return (withoutSuffix || isFuture) ? 'rok' : 'rokom';
					case 'yy': // 9 years / in 9 years / 9 years ago
						if(withoutSuffix || isFuture) {
							return result + (plural(number) ? 'roky' : 'rokov');
						} else {
							return result + 'rokmi';
						}
						break;
				}
			}
			
			var sk = moment.defineLocale('sk', {
				months: months,
				monthsShort: monthsShort,
				weekdays: 'nedea_pondelok_utorok_streda_tvrtok_piatok_sobota'.split('_'),
				weekdaysShort: 'ne_po_ut_st_t_pi_so'.split('_'),
				weekdaysMin: 'ne_po_ut_st_t_pi_so'.split('_'),
				longDateFormat: {
					LT: 'H:mm',
					LTS: 'H:mm:ss',
					L: 'DD.MM.YYYY',
					LL: 'D. MMMM YYYY',
					LLL: 'D. MMMM YYYY H:mm',
					LLLL: 'dddd D. MMMM YYYY H:mm'
				},
				calendar: {
					sameDay: '[dnes o] LT',
					nextDay: '[zajtra o] LT',
					nextWeek: function() {
						switch(this.day()) {
							case 0:
								return '[v nedeu o] LT';
							case 1:
							case 2:
								return '[v] dddd [o] LT';
							case 3:
								return '[v stredu o] LT';
							case 4:
								return '[vo tvrtok o] LT';
							case 5:
								return '[v piatok o] LT';
							case 6:
								return '[v sobotu o] LT';
						}
					},
					lastDay: '[vera o] LT',
					lastWeek: function() {
						switch(this.day()) {
							case 0:
								return '[minul nedeu o] LT';
							case 1:
							case 2:
								return '[minul] dddd [o] LT';
							case 3:
								return '[minul stredu o] LT';
							case 4:
							case 5:
								return '[minul] dddd [o] LT';
							case 6:
								return '[minul sobotu o] LT';
						}
					},
					sameElse: 'L'
				},
				relativeTime: {
					future: 'za %s',
					past: 'pred %s',
					s: translate,
					ss: translate,
					m: translate,
					mm: translate,
					h: translate,
					hh: translate,
					d: translate,
					dd: translate,
					M: translate,
					MM: translate,
					y: translate,
					yy: translate
				},
				dayOfMonthOrdinalParse: /\d{1,2}\./,
				ordinal: '%d.',
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return sk;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/sl.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/sl.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			function processRelativeTime(number, withoutSuffix, key, isFuture) {
				var result = number + ' ';
				switch(key) {
					case 's':
						return withoutSuffix || isFuture ? 'nekaj sekund' : 'nekaj sekundami';
					case 'ss':
						if(number === 1) {
							result += withoutSuffix ? 'sekundo' : 'sekundi';
						} else if(number === 2) {
							result += withoutSuffix || isFuture ? 'sekundi' : 'sekundah';
						} else if(number < 5) {
							result += withoutSuffix || isFuture ? 'sekunde' : 'sekundah';
						} else {
							result += 'sekund';
						}
						return result;
					case 'm':
						return withoutSuffix ? 'ena minuta' : 'eno minuto';
					case 'mm':
						if(number === 1) {
							result += withoutSuffix ? 'minuta' : 'minuto';
						} else if(number === 2) {
							result += withoutSuffix || isFuture ? 'minuti' : 'minutama';
						} else if(number < 5) {
							result += withoutSuffix || isFuture ? 'minute' : 'minutami';
						} else {
							result += withoutSuffix || isFuture ? 'minut' : 'minutami';
						}
						return result;
					case 'h':
						return withoutSuffix ? 'ena ura' : 'eno uro';
					case 'hh':
						if(number === 1) {
							result += withoutSuffix ? 'ura' : 'uro';
						} else if(number === 2) {
							result += withoutSuffix || isFuture ? 'uri' : 'urama';
						} else if(number < 5) {
							result += withoutSuffix || isFuture ? 'ure' : 'urami';
						} else {
							result += withoutSuffix || isFuture ? 'ur' : 'urami';
						}
						return result;
					case 'd':
						return withoutSuffix || isFuture ? 'en dan' : 'enim dnem';
					case 'dd':
						if(number === 1) {
							result += withoutSuffix || isFuture ? 'dan' : 'dnem';
						} else if(number === 2) {
							result += withoutSuffix || isFuture ? 'dni' : 'dnevoma';
						} else {
							result += withoutSuffix || isFuture ? 'dni' : 'dnevi';
						}
						return result;
					case 'M':
						return withoutSuffix || isFuture ? 'en mesec' : 'enim mesecem';
					case 'MM':
						if(number === 1) {
							result += withoutSuffix || isFuture ? 'mesec' : 'mesecem';
						} else if(number === 2) {
							result += withoutSuffix || isFuture ? 'meseca' : 'mesecema';
						} else if(number < 5) {
							result += withoutSuffix || isFuture ? 'mesece' : 'meseci';
						} else {
							result += withoutSuffix || isFuture ? 'mesecev' : 'meseci';
						}
						return result;
					case 'y':
						return withoutSuffix || isFuture ? 'eno leto' : 'enim letom';
					case 'yy':
						if(number === 1) {
							result += withoutSuffix || isFuture ? 'leto' : 'letom';
						} else if(number === 2) {
							result += withoutSuffix || isFuture ? 'leti' : 'letoma';
						} else if(number < 5) {
							result += withoutSuffix || isFuture ? 'leta' : 'leti';
						} else {
							result += withoutSuffix || isFuture ? 'let' : 'leti';
						}
						return result;
				}
			}
			
			var sl = moment.defineLocale('sl', {
				months: 'januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december'.split('_'),
				monthsShort: 'jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.'.split('_'),
				monthsParseExact: true,
				weekdays: 'nedelja_ponedeljek_torek_sreda_etrtek_petek_sobota'.split('_'),
				weekdaysShort: 'ned._pon._tor._sre._et._pet._sob.'.split('_'),
				weekdaysMin: 'ne_po_to_sr_e_pe_so'.split('_'),
				weekdaysParseExact: true,
				longDateFormat: {
					LT: 'H:mm',
					LTS: 'H:mm:ss',
					L: 'DD.MM.YYYY',
					LL: 'D. MMMM YYYY',
					LLL: 'D. MMMM YYYY H:mm',
					LLLL: 'dddd, D. MMMM YYYY H:mm'
				},
				calendar: {
					sameDay: '[danes ob] LT',
					nextDay: '[jutri ob] LT',
					
					nextWeek: function() {
						switch(this.day()) {
							case 0:
								return '[v] [nedeljo] [ob] LT';
							case 3:
								return '[v] [sredo] [ob] LT';
							case 6:
								return '[v] [soboto] [ob] LT';
							case 1:
							case 2:
							case 4:
							case 5:
								return '[v] dddd [ob] LT';
						}
					},
					lastDay: '[veraj ob] LT',
					lastWeek: function() {
						switch(this.day()) {
							case 0:
								return '[prejnjo] [nedeljo] [ob] LT';
							case 3:
								return '[prejnjo] [sredo] [ob] LT';
							case 6:
								return '[prejnjo] [soboto] [ob] LT';
							case 1:
							case 2:
							case 4:
							case 5:
								return '[prejnji] dddd [ob] LT';
						}
					},
					sameElse: 'L'
				},
				relativeTime: {
					future: 'ez %s',
					past: 'pred %s',
					s: processRelativeTime,
					ss: processRelativeTime,
					m: processRelativeTime,
					mm: processRelativeTime,
					h: processRelativeTime,
					hh: processRelativeTime,
					d: processRelativeTime,
					dd: processRelativeTime,
					M: processRelativeTime,
					MM: processRelativeTime,
					y: processRelativeTime,
					yy: processRelativeTime
				},
				dayOfMonthOrdinalParse: /\d{1,2}\./,
				ordinal: '%d.',
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 7  // The week that contains Jan 7th is the first week of the year.
				}
			});
			
			return sl;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/sq.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/sq.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var sq = moment.defineLocale('sq', {
				months: 'Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nntor_Dhjetor'.split('_'),
				monthsShort: 'Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nn_Dhj'.split('_'),
				weekdays: 'E Diel_E Hn_E Mart_E Mrkur_E Enjte_E Premte_E Shtun'.split('_'),
				weekdaysShort: 'Die_Hn_Mar_Mr_Enj_Pre_Sht'.split('_'),
				weekdaysMin: 'D_H_Ma_M_E_P_Sh'.split('_'),
				weekdaysParseExact: true,
				meridiemParse: /PD|MD/,
				isPM: function(input) {
					return input.charAt(0) === 'M';
				},
				meridiem: function(hours, minutes, isLower) {
					return hours < 12 ? 'PD' : 'MD';
				},
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY HH:mm',
					LLLL: 'dddd, D MMMM YYYY HH:mm'
				},
				calendar: {
					sameDay: '[Sot n] LT',
					nextDay: '[Nesr n] LT',
					nextWeek: 'dddd [n] LT',
					lastDay: '[Dje n] LT',
					lastWeek: 'dddd [e kaluar n] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: 'n %s',
					past: '%s m par',
					s: 'disa sekonda',
					ss: '%d sekonda',
					m: 'nj minut',
					mm: '%d minuta',
					h: 'nj or',
					hh: '%d or',
					d: 'nj dit',
					dd: '%d dit',
					M: 'nj muaj',
					MM: '%d muaj',
					y: 'nj vit',
					yy: '%d vite'
				},
				dayOfMonthOrdinalParse: /\d{1,2}\./,
				ordinal: '%d.',
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return sq;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/sr-cyrl.js":
	/*!***********************************************!*\
  !*** ./node_modules/moment/locale/sr-cyrl.js ***!
  \***********************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var translator = {
				words: { //Different grammatical cases
					ss: ['', '', ''],
					m: [' ', ' '],
					mm: ['', '', ''],
					h: [' ', ' '],
					hh: ['', '', ''],
					dd: ['', '', ''],
					MM: ['', '', ''],
					yy: ['', '', '']
				},
				correctGrammaticalCase: function(number, wordKey) {
					return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
				},
				translate: function(number, withoutSuffix, key) {
					var wordKey = translator.words[key];
					if(key.length === 1) {
						return withoutSuffix ? wordKey[0] : wordKey[1];
					} else {
						return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
					}
				}
			};
			
			var srCyrl = moment.defineLocale('sr-cyrl', {
				months: '___________'.split('_'),
				monthsShort: '._._._.____._._._._.'.split('_'),
				monthsParseExact: true,
				weekdays: '______'.split('_'),
				weekdaysShort: '._._._._._._.'.split('_'),
				weekdaysMin: '______'.split('_'),
				weekdaysParseExact: true,
				longDateFormat: {
					LT: 'H:mm',
					LTS: 'H:mm:ss',
					L: 'DD.MM.YYYY',
					LL: 'D. MMMM YYYY',
					LLL: 'D. MMMM YYYY H:mm',
					LLLL: 'dddd, D. MMMM YYYY H:mm'
				},
				calendar: {
					sameDay: '[ ] LT',
					nextDay: '[ ] LT',
					nextWeek: function() {
						switch(this.day()) {
							case 0:
								return '[] [] [] LT';
							case 3:
								return '[] [] [] LT';
							case 6:
								return '[] [] [] LT';
							case 1:
							case 2:
							case 4:
							case 5:
								return '[] dddd [] LT';
						}
					},
					lastDay: '[ ] LT',
					lastWeek: function() {
						var lastWeekDays = [
							'[] [] [] LT',
							'[] [] [] LT',
							'[] [] [] LT',
							'[] [] [] LT',
							'[] [] [] LT',
							'[] [] [] LT',
							'[] [] [] LT'
						];
						return lastWeekDays[this.day()];
					},
					sameElse: 'L'
				},
				relativeTime: {
					future: ' %s',
					past: ' %s',
					s: ' ',
					ss: translator.translate,
					m: translator.translate,
					mm: translator.translate,
					h: translator.translate,
					hh: translator.translate,
					d: '',
					dd: translator.translate,
					M: '',
					MM: translator.translate,
					y: '',
					yy: translator.translate
				},
				dayOfMonthOrdinalParse: /\d{1,2}\./,
				ordinal: '%d.',
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 7  // The week that contains Jan 7th is the first week of the year.
				}
			});
			
			return srCyrl;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/sr.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/sr.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var translator = {
				words: { //Different grammatical cases
					ss: ['sekunda', 'sekunde', 'sekundi'],
					m: ['jedan minut', 'jedne minute'],
					mm: ['minut', 'minute', 'minuta'],
					h: ['jedan sat', 'jednog sata'],
					hh: ['sat', 'sata', 'sati'],
					dd: ['dan', 'dana', 'dana'],
					MM: ['mesec', 'meseca', 'meseci'],
					yy: ['godina', 'godine', 'godina']
				},
				correctGrammaticalCase: function(number, wordKey) {
					return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
				},
				translate: function(number, withoutSuffix, key) {
					var wordKey = translator.words[key];
					if(key.length === 1) {
						return withoutSuffix ? wordKey[0] : wordKey[1];
					} else {
						return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
					}
				}
			};
			
			var sr = moment.defineLocale('sr', {
				months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
				monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
				monthsParseExact: true,
				weekdays: 'nedelja_ponedeljak_utorak_sreda_etvrtak_petak_subota'.split('_'),
				weekdaysShort: 'ned._pon._uto._sre._et._pet._sub.'.split('_'),
				weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
				weekdaysParseExact: true,
				longDateFormat: {
					LT: 'H:mm',
					LTS: 'H:mm:ss',
					L: 'DD.MM.YYYY',
					LL: 'D. MMMM YYYY',
					LLL: 'D. MMMM YYYY H:mm',
					LLLL: 'dddd, D. MMMM YYYY H:mm'
				},
				calendar: {
					sameDay: '[danas u] LT',
					nextDay: '[sutra u] LT',
					nextWeek: function() {
						switch(this.day()) {
							case 0:
								return '[u] [nedelju] [u] LT';
							case 3:
								return '[u] [sredu] [u] LT';
							case 6:
								return '[u] [subotu] [u] LT';
							case 1:
							case 2:
							case 4:
							case 5:
								return '[u] dddd [u] LT';
						}
					},
					lastDay: '[jue u] LT',
					lastWeek: function() {
						var lastWeekDays = [
							'[prole] [nedelje] [u] LT',
							'[prolog] [ponedeljka] [u] LT',
							'[prolog] [utorka] [u] LT',
							'[prole] [srede] [u] LT',
							'[prolog] [etvrtka] [u] LT',
							'[prolog] [petka] [u] LT',
							'[prole] [subote] [u] LT'
						];
						return lastWeekDays[this.day()];
					},
					sameElse: 'L'
				},
				relativeTime: {
					future: 'za %s',
					past: 'pre %s',
					s: 'nekoliko sekundi',
					ss: translator.translate,
					m: translator.translate,
					mm: translator.translate,
					h: translator.translate,
					hh: translator.translate,
					d: 'dan',
					dd: translator.translate,
					M: 'mesec',
					MM: translator.translate,
					y: 'godinu',
					yy: translator.translate
				},
				dayOfMonthOrdinalParse: /\d{1,2}\./,
				ordinal: '%d.',
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 7  // The week that contains Jan 7th is the first week of the year.
				}
			});
			
			return sr;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/ss.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/ss.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var ss = moment.defineLocale('ss', {
				months: "Bhimbidvwane_Indlovana_Indlov'lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni".split('_'),
				monthsShort: 'Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo'.split('_'),
				weekdays: 'Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo'.split('_'),
				weekdaysShort: 'Lis_Umb_Lsb_Les_Lsi_Lsh_Umg'.split('_'),
				weekdaysMin: 'Li_Us_Lb_Lt_Ls_Lh_Ug'.split('_'),
				weekdaysParseExact: true,
				longDateFormat: {
					LT: 'h:mm A',
					LTS: 'h:mm:ss A',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY h:mm A',
					LLLL: 'dddd, D MMMM YYYY h:mm A'
				},
				calendar: {
					sameDay: '[Namuhla nga] LT',
					nextDay: '[Kusasa nga] LT',
					nextWeek: 'dddd [nga] LT',
					lastDay: '[Itolo nga] LT',
					lastWeek: 'dddd [leliphelile] [nga] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: 'nga %s',
					past: 'wenteka nga %s',
					s: 'emizuzwana lomcane',
					ss: '%d mzuzwana',
					m: 'umzuzu',
					mm: '%d emizuzu',
					h: 'lihora',
					hh: '%d emahora',
					d: 'lilanga',
					dd: '%d emalanga',
					M: 'inyanga',
					MM: '%d tinyanga',
					y: 'umnyaka',
					yy: '%d iminyaka'
				},
				meridiemParse: /ekuseni|emini|entsambama|ebusuku/,
				meridiem: function(hours, minutes, isLower) {
					if(hours < 11) {
						return 'ekuseni';
					} else if(hours < 15) {
						return 'emini';
					} else if(hours < 19) {
						return 'entsambama';
					} else {
						return 'ebusuku';
					}
				},
				meridiemHour: function(hour, meridiem) {
					if(hour === 12) {
						hour = 0;
					}
					if(meridiem === 'ekuseni') {
						return hour;
					} else if(meridiem === 'emini') {
						return hour >= 11 ? hour : hour + 12;
					} else if(meridiem === 'entsambama' || meridiem === 'ebusuku') {
						if(hour === 0) {
							return 0;
						}
						return hour + 12;
					}
				},
				dayOfMonthOrdinalParse: /\d{1,2}/,
				ordinal: '%d',
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return ss;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/sv.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/sv.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var sv = moment.defineLocale('sv', {
				months: 'januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december'.split('_'),
				monthsShort: 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
				weekdays: 'sndag_mndag_tisdag_onsdag_torsdag_fredag_lrdag'.split('_'),
				weekdaysShort: 'sn_mn_tis_ons_tor_fre_lr'.split('_'),
				weekdaysMin: 's_m_ti_on_to_fr_l'.split('_'),
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'YYYY-MM-DD',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY [kl.] HH:mm',
					LLLL: 'dddd D MMMM YYYY [kl.] HH:mm',
					lll: 'D MMM YYYY HH:mm',
					llll: 'ddd D MMM YYYY HH:mm'
				},
				calendar: {
					sameDay: '[Idag] LT',
					nextDay: '[Imorgon] LT',
					lastDay: '[Igr] LT',
					nextWeek: '[P] dddd LT',
					lastWeek: '[I] dddd[s] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: 'om %s',
					past: 'fr %s sedan',
					s: 'ngra sekunder',
					ss: '%d sekunder',
					m: 'en minut',
					mm: '%d minuter',
					h: 'en timme',
					hh: '%d timmar',
					d: 'en dag',
					dd: '%d dagar',
					M: 'en mnad',
					MM: '%d mnader',
					y: 'ett r',
					yy: '%d r'
				},
				dayOfMonthOrdinalParse: /\d{1,2}(e|a)/,
				ordinal: function(number) {
					var b = number % 10,
						output = (~~(number % 100 / 10) === 1) ? 'e' :
							(b === 1) ? 'a' :
								(b === 2) ? 'a' :
									(b === 3) ? 'e' : 'e';
					return number + output;
				},
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return sv;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/sw.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/sw.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var sw = moment.defineLocale('sw', {
				months: 'Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba'.split('_'),
				monthsShort: 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des'.split('_'),
				weekdays: 'Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi'.split('_'),
				weekdaysShort: 'Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos'.split('_'),
				weekdaysMin: 'J2_J3_J4_J5_Al_Ij_J1'.split('_'),
				weekdaysParseExact: true,
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD.MM.YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY HH:mm',
					LLLL: 'dddd, D MMMM YYYY HH:mm'
				},
				calendar: {
					sameDay: '[leo saa] LT',
					nextDay: '[kesho saa] LT',
					nextWeek: '[wiki ijayo] dddd [saat] LT',
					lastDay: '[jana] LT',
					lastWeek: '[wiki iliyopita] dddd [saat] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: '%s baadaye',
					past: 'tokea %s',
					s: 'hivi punde',
					ss: 'sekunde %d',
					m: 'dakika moja',
					mm: 'dakika %d',
					h: 'saa limoja',
					hh: 'masaa %d',
					d: 'siku moja',
					dd: 'masiku %d',
					M: 'mwezi mmoja',
					MM: 'miezi %d',
					y: 'mwaka mmoja',
					yy: 'miaka %d'
				},
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 7  // The week that contains Jan 7th is the first week of the year.
				}
			});
			
			return sw;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/ta.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/ta.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var symbolMap = {
				'1': '',
				'2': '',
				'3': '',
				'4': '',
				'5': '',
				'6': '',
				'7': '',
				'8': '',
				'9': '',
				'0': ''
			}, numberMap = {
				'': '1',
				'': '2',
				'': '3',
				'': '4',
				'': '5',
				'': '6',
				'': '7',
				'': '8',
				'': '9',
				'': '0'
			};
			
			var ta = moment.defineLocale('ta', {
				months: '___________'.split('_'),
				monthsShort: '___________'.split('_'),
				weekdays: '______'.split('_'),
				weekdaysShort: '______'.split('_'),
				weekdaysMin: '______'.split('_'),
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY, HH:mm',
					LLLL: 'dddd, D MMMM YYYY, HH:mm'
				},
				calendar: {
					sameDay: '[] LT',
					nextDay: '[] LT',
					nextWeek: 'dddd, LT',
					lastDay: '[] LT',
					lastWeek: '[ ] dddd, LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: '%s ',
					past: '%s ',
					s: '  ',
					ss: '%d ',
					m: ' ',
					mm: '%d ',
					h: '  ',
					hh: '%d  ',
					d: ' ',
					dd: '%d ',
					M: ' ',
					MM: '%d ',
					y: ' ',
					yy: '%d '
				},
				dayOfMonthOrdinalParse: /\d{1,2}/,
				ordinal: function(number) {
					return number + '';
				},
				preparse: function(string) {
					return string.replace(/[]/g, function(match) {
						return numberMap[match];
					});
				},
				postformat: function(string) {
					return string.replace(/\d/g, function(match) {
						return symbolMap[match];
					});
				},
				// refer http://ta.wikipedia.org/s/1er1
				meridiemParse: /|||||/,
				meridiem: function(hour, minute, isLower) {
					if(hour < 2) {
						return ' ';
					} else if(hour < 6) {
						return ' ';  // 
					} else if(hour < 10) {
						return ' '; // 
					} else if(hour < 14) {
						return ' '; // 
					} else if(hour < 18) {
						return ' '; // 
					} else if(hour < 22) {
						return ' '; // 
					} else {
						return ' ';
					}
				},
				meridiemHour: function(hour, meridiem) {
					if(hour === 12) {
						hour = 0;
					}
					if(meridiem === '') {
						return hour < 2 ? hour : hour + 12;
					} else if(meridiem === '' || meridiem === '') {
						return hour;
					} else if(meridiem === '') {
						return hour >= 10 ? hour : hour + 12;
					} else {
						return hour + 12;
					}
				},
				week: {
					dow: 0, // Sunday is the first day of the week.
					doy: 6  // The week that contains Jan 6th is the first week of the year.
				}
			});
			
			return ta;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/te.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/te.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var te = moment.defineLocale('te', {
				months: '___________'.split('_'),
				monthsShort: '._.__.____._._._._.'.split('_'),
				monthsParseExact: true,
				weekdays: '______'.split('_'),
				weekdaysShort: '______'.split('_'),
				weekdaysMin: '______'.split('_'),
				longDateFormat: {
					LT: 'A h:mm',
					LTS: 'A h:mm:ss',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY, A h:mm',
					LLLL: 'dddd, D MMMM YYYY, A h:mm'
				},
				calendar: {
					sameDay: '[] LT',
					nextDay: '[] LT',
					nextWeek: 'dddd, LT',
					lastDay: '[] LT',
					lastWeek: '[] dddd, LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: '%s ',
					past: '%s ',
					s: ' ',
					ss: '%d ',
					m: ' ',
					mm: '%d ',
					h: ' ',
					hh: '%d ',
					d: ' ',
					dd: '%d ',
					M: ' ',
					MM: '%d ',
					y: ' ',
					yy: '%d '
				},
				dayOfMonthOrdinalParse: /\d{1,2}/,
				ordinal: '%d',
				meridiemParse: /|||/,
				meridiemHour: function(hour, meridiem) {
					if(hour === 12) {
						hour = 0;
					}
					if(meridiem === '') {
						return hour < 4 ? hour : hour + 12;
					} else if(meridiem === '') {
						return hour;
					} else if(meridiem === '') {
						return hour >= 10 ? hour : hour + 12;
					} else if(meridiem === '') {
						return hour + 12;
					}
				},
				meridiem: function(hour, minute, isLower) {
					if(hour < 4) {
						return '';
					} else if(hour < 10) {
						return '';
					} else if(hour < 17) {
						return '';
					} else if(hour < 20) {
						return '';
					} else {
						return '';
					}
				},
				week: {
					dow: 0, // Sunday is the first day of the week.
					doy: 6  // The week that contains Jan 6th is the first week of the year.
				}
			});
			
			return te;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/tet.js":
	/*!*******************************************!*\
  !*** ./node_modules/moment/locale/tet.js ***!
  \*******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var tet = moment.defineLocale('tet', {
				months: 'Janeiru_Fevereiru_Marsu_Abril_Maiu_Juu_Jullu_Agustu_Setembru_Outubru_Novembru_Dezembru'.split('_'),
				monthsShort: 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
				weekdays: 'Domingu_Segunda_Tersa_Kuarta_Kinta_Sesta_Sabadu'.split('_'),
				weekdaysShort: 'Dom_Seg_Ters_Kua_Kint_Sest_Sab'.split('_'),
				weekdaysMin: 'Do_Seg_Te_Ku_Ki_Ses_Sa'.split('_'),
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY HH:mm',
					LLLL: 'dddd, D MMMM YYYY HH:mm'
				},
				calendar: {
					sameDay: '[Ohin iha] LT',
					nextDay: '[Aban iha] LT',
					nextWeek: 'dddd [iha] LT',
					lastDay: '[Horiseik iha] LT',
					lastWeek: 'dddd [semana kotuk] [iha] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: 'iha %s',
					past: '%s liuba',
					s: 'minutu balun',
					ss: 'minutu %d',
					m: 'minutu ida',
					mm: 'minutu %d',
					h: 'oras ida',
					hh: 'oras %d',
					d: 'loron ida',
					dd: 'loron %d',
					M: 'fulan ida',
					MM: 'fulan %d',
					y: 'tinan ida',
					yy: 'tinan %d'
				},
				dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
				ordinal: function(number) {
					var b = number % 10,
						output = (~~(number % 100 / 10) === 1) ? 'th' :
							(b === 1) ? 'st' :
								(b === 2) ? 'nd' :
									(b === 3) ? 'rd' : 'th';
					return number + output;
				},
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return tet;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/tg.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/tg.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var suffixes = {
				0: '-',
				1: '-',
				2: '-',
				3: '-',
				4: '-',
				5: '-',
				6: '-',
				7: '-',
				8: '-',
				9: '-',
				10: '-',
				12: '-',
				13: '-',
				20: '-',
				30: '-',
				40: '-',
				50: '-',
				60: '-',
				70: '-',
				80: '-',
				90: '-',
				100: '-'
			};
			
			var tg = moment.defineLocale('tg', {
				months: '___________'.split('_'),
				monthsShort: '___________'.split('_'),
				weekdays: '______'.split('_'),
				weekdaysShort: '______'.split('_'),
				weekdaysMin: '______'.split('_'),
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY HH:mm',
					LLLL: 'dddd, D MMMM YYYY HH:mm'
				},
				calendar: {
					sameDay: '[ ] LT',
					nextDay: '[ ] LT',
					lastDay: '[ ] LT',
					nextWeek: 'dddd[] [  ] LT',
					lastWeek: 'dddd[] [  ] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: ' %s',
					past: '%s ',
					s: ' ',
					m: ' ',
					mm: '%d ',
					h: ' ',
					hh: '%d ',
					d: ' ',
					dd: '%d ',
					M: ' ',
					MM: '%d ',
					y: ' ',
					yy: '%d '
				},
				meridiemParse: /|||/,
				meridiemHour: function(hour, meridiem) {
					if(hour === 12) {
						hour = 0;
					}
					if(meridiem === '') {
						return hour < 4 ? hour : hour + 12;
					} else if(meridiem === '') {
						return hour;
					} else if(meridiem === '') {
						return hour >= 11 ? hour : hour + 12;
					} else if(meridiem === '') {
						return hour + 12;
					}
				},
				meridiem: function(hour, minute, isLower) {
					if(hour < 4) {
						return '';
					} else if(hour < 11) {
						return '';
					} else if(hour < 16) {
						return '';
					} else if(hour < 19) {
						return '';
					} else {
						return '';
					}
				},
				dayOfMonthOrdinalParse: /\d{1,2}-(|)/,
				ordinal: function(number) {
					var a = number % 10,
						b = number >= 100 ? 100 : null;
					return number + (suffixes[number] || suffixes[a] || suffixes[b]);
				},
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 7  // The week that contains Jan 1th is the first week of the year.
				}
			});
			
			return tg;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/th.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/th.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var th = moment.defineLocale('th', {
				months: '___________'.split('_'),
				monthsShort: '.._.._.._.._.._.._.._.._.._.._.._..'.split('_'),
				monthsParseExact: true,
				weekdays: '______'.split('_'),
				weekdaysShort: '______'.split('_'), // yes, three characters difference
				weekdaysMin: '._._._._._._.'.split('_'),
				weekdaysParseExact: true,
				longDateFormat: {
					LT: 'H:mm',
					LTS: 'H:mm:ss',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY  H:mm',
					LLLL: 'dddd D MMMM YYYY  H:mm'
				},
				meridiemParse: /|/,
				isPM: function(input) {
					return input === '';
				},
				meridiem: function(hour, minute, isLower) {
					if(hour < 12) {
						return '';
					} else {
						return '';
					}
				},
				calendar: {
					sameDay: '[ ] LT',
					nextDay: '[ ] LT',
					nextWeek: 'dddd[ ] LT',
					lastDay: '[ ] LT',
					lastWeek: '[]dddd[ ] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: ' %s',
					past: '%s',
					s: '',
					ss: '%d ',
					m: '1 ',
					mm: '%d ',
					h: '1 ',
					hh: '%d ',
					d: '1 ',
					dd: '%d ',
					M: '1 ',
					MM: '%d ',
					y: '1 ',
					yy: '%d '
				}
			});
			
			return th;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/tl-ph.js":
	/*!*********************************************!*\
  !*** ./node_modules/moment/locale/tl-ph.js ***!
  \*********************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var tlPh = moment.defineLocale('tl-ph', {
				months: 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split('_'),
				monthsShort: 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),
				weekdays: 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split('_'),
				weekdaysShort: 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),
				weekdaysMin: 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'MM/D/YYYY',
					LL: 'MMMM D, YYYY',
					LLL: 'MMMM D, YYYY HH:mm',
					LLLL: 'dddd, MMMM DD, YYYY HH:mm'
				},
				calendar: {
					sameDay: 'LT [ngayong araw]',
					nextDay: '[Bukas ng] LT',
					nextWeek: 'LT [sa susunod na] dddd',
					lastDay: 'LT [kahapon]',
					lastWeek: 'LT [noong nakaraang] dddd',
					sameElse: 'L'
				},
				relativeTime: {
					future: 'sa loob ng %s',
					past: '%s ang nakalipas',
					s: 'ilang segundo',
					ss: '%d segundo',
					m: 'isang minuto',
					mm: '%d minuto',
					h: 'isang oras',
					hh: '%d oras',
					d: 'isang araw',
					dd: '%d araw',
					M: 'isang buwan',
					MM: '%d buwan',
					y: 'isang taon',
					yy: '%d taon'
				},
				dayOfMonthOrdinalParse: /\d{1,2}/,
				ordinal: function(number) {
					return number;
				},
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return tlPh;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/tlh.js":
	/*!*******************************************!*\
  !*** ./node_modules/moment/locale/tlh.js ***!
  \*******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var numbersNouns = 'pagh_wa_cha_wej_loS_vagh_jav_Soch_chorgh_Hut'.split('_');
			
			function translateFuture(output) {
				var time = output;
				time = (output.indexOf('jaj') !== -1) ?
					time.slice(0, -3) + 'leS' :
					(output.indexOf('jar') !== -1) ?
						time.slice(0, -3) + 'waQ' :
						(output.indexOf('DIS') !== -1) ?
							time.slice(0, -3) + 'nem' :
							time + ' pIq';
				return time;
			}
			
			function translatePast(output) {
				var time = output;
				time = (output.indexOf('jaj') !== -1) ?
					time.slice(0, -3) + 'Hu' :
					(output.indexOf('jar') !== -1) ?
						time.slice(0, -3) + 'wen' :
						(output.indexOf('DIS') !== -1) ?
							time.slice(0, -3) + 'ben' :
							time + ' ret';
				return time;
			}
			
			function translate(number, withoutSuffix, string, isFuture) {
				var numberNoun = numberAsNoun(number);
				switch(string) {
					case 'ss':
						return numberNoun + ' lup';
					case 'mm':
						return numberNoun + ' tup';
					case 'hh':
						return numberNoun + ' rep';
					case 'dd':
						return numberNoun + ' jaj';
					case 'MM':
						return numberNoun + ' jar';
					case 'yy':
						return numberNoun + ' DIS';
				}
			}
			
			function numberAsNoun(number) {
				var hundred = Math.floor((number % 1000) / 100),
					ten = Math.floor((number % 100) / 10),
					one = number % 10,
					word = '';
				if(hundred > 0) {
					word += numbersNouns[hundred] + 'vatlh';
				}
				if(ten > 0) {
					word += ((word !== '') ? ' ' : '') + numbersNouns[ten] + 'maH';
				}
				if(one > 0) {
					word += ((word !== '') ? ' ' : '') + numbersNouns[one];
				}
				return (word === '') ? 'pagh' : word;
			}
			
			var tlh = moment.defineLocale('tlh', {
				months: 'tera jar wa_tera jar cha_tera jar wej_tera jar loS_tera jar vagh_tera jar jav_tera jar Soch_tera jar chorgh_tera jar Hut_tera jar wamaH_tera jar wamaH wa_tera jar wamaH cha'.split('_'),
				monthsShort: 'jar wa_jar cha_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wamaH_jar wamaH wa_jar wamaH cha'.split('_'),
				monthsParseExact: true,
				weekdays: 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
				weekdaysShort: 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
				weekdaysMin: 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD.MM.YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY HH:mm',
					LLLL: 'dddd, D MMMM YYYY HH:mm'
				},
				calendar: {
					sameDay: '[DaHjaj] LT',
					nextDay: '[waleS] LT',
					nextWeek: 'LLL',
					lastDay: '[waHu] LT',
					lastWeek: 'LLL',
					sameElse: 'L'
				},
				relativeTime: {
					future: translateFuture,
					past: translatePast,
					s: 'puS lup',
					ss: translate,
					m: 'wa tup',
					mm: translate,
					h: 'wa rep',
					hh: translate,
					d: 'wa jaj',
					dd: translate,
					M: 'wa jar',
					MM: translate,
					y: 'wa DIS',
					yy: translate
				},
				dayOfMonthOrdinalParse: /\d{1,2}\./,
				ordinal: '%d.',
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return tlh;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/tr.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/tr.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined;
		}(this, (function(moment) {
			'use strict';
			
			var suffixes = {
				1: '\'inci',
				5: '\'inci',
				8: '\'inci',
				70: '\'inci',
				80: '\'inci',
				2: '\'nci',
				7: '\'nci',
				20: '\'nci',
				50: '\'nci',
				3: '\'nc',
				4: '\'nc',
				100: '\'nc',
				6: '\'nc',
				9: '\'uncu',
				10: '\'uncu',
				30: '\'uncu',
				60: '\'nc',
				90: '\'nc'
			};
			
			var tr = moment.defineLocale('tr', {
				months: 'Ocak_ubat_Mart_Nisan_Mays_Haziran_Temmuz_Austos_Eyll_Ekim_Kasm_Aralk'.split('_'),
				monthsShort: 'Oca_ub_Mar_Nis_May_Haz_Tem_Au_Eyl_Eki_Kas_Ara'.split('_'),
				weekdays: 'Pazar_Pazartesi_Sal_aramba_Perembe_Cuma_Cumartesi'.split('_'),
				weekdaysShort: 'Paz_Pts_Sal_ar_Per_Cum_Cts'.split('_'),
				weekdaysMin: 'Pz_Pt_Sa_a_Pe_Cu_Ct'.split('_'),
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD.MM.YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY HH:mm',
					LLLL: 'dddd, D MMMM YYYY HH:mm'
				},
				calendar: {
					sameDay: '[bugn saat] LT',
					nextDay: '[yarn saat] LT',
					nextWeek: '[gelecek] dddd [saat] LT',
					lastDay: '[dn] LT',
					lastWeek: '[geen] dddd [saat] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: '%s sonra',
					past: '%s nce',
					s: 'birka saniye',
					ss: '%d saniye',
					m: 'bir dakika',
					mm: '%d dakika',
					h: 'bir saat',
					hh: '%d saat',
					d: 'bir gn',
					dd: '%d gn',
					M: 'bir ay',
					MM: '%d ay',
					y: 'bir yl',
					yy: '%d yl'
				},
				ordinal: function(number, period) {
					switch(period) {
						case 'd':
						case 'D':
						case 'Do':
						case 'DD':
							return number;
						default:
							if(number === 0) {  // special case for zero
								return number + '\'nc';
							}
							var a = number % 10,
								b = number % 100 - a,
								c = number >= 100 ? 100 : null;
							return number + (suffixes[a] || suffixes[b] || suffixes[c]);
					}
				},
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 7  // The week that contains Jan 7th is the first week of the year.
				}
			});
			
			return tr;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/tzl.js":
	/*!*******************************************!*\
  !*** ./node_modules/moment/locale/tzl.js ***!
  \*******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			// After the year there should be a slash and the amount of years since December 26, 1979 in Roman numerals.
			// This is currently too difficult (maybe even impossible) to add.
			var tzl = moment.defineLocale('tzl', {
				months: 'Januar_Fevraglh_Mar_Avru_Mai_Gn_Julia_Guscht_Setemvar_Listopts_Noemvar_Zecemvar'.split('_'),
				monthsShort: 'Jan_Fev_Mar_Avr_Mai_Gn_Jul_Gus_Set_Lis_Noe_Zec'.split('_'),
				weekdays: 'Sladi_Lnei_Maitzi_Mrcuri_Xhadi_Vineri_Sturi'.split('_'),
				weekdaysShort: 'Sl_Ln_Mai_Mr_Xh_Vi_St'.split('_'),
				weekdaysMin: 'S_L_Ma_M_Xh_Vi_S'.split('_'),
				longDateFormat: {
					LT: 'HH.mm',
					LTS: 'HH.mm.ss',
					L: 'DD.MM.YYYY',
					LL: 'D. MMMM [dallas] YYYY',
					LLL: 'D. MMMM [dallas] YYYY HH.mm',
					LLLL: 'dddd, [li] D. MMMM [dallas] YYYY HH.mm'
				},
				meridiemParse: /d\'o|d\'a/i,
				isPM: function(input) {
					return 'd\'o' === input.toLowerCase();
				},
				meridiem: function(hours, minutes, isLower) {
					if(hours > 11) {
						return isLower ? 'd\'o' : 'D\'O';
					} else {
						return isLower ? 'd\'a' : 'D\'A';
					}
				},
				calendar: {
					sameDay: '[oxhi ] LT',
					nextDay: '[dem ] LT',
					nextWeek: 'dddd [] LT',
					lastDay: '[ieiri ] LT',
					lastWeek: '[sr el] dddd [lasteu ] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: 'osprei %s',
					past: 'ja%s',
					s: processRelativeTime,
					ss: processRelativeTime,
					m: processRelativeTime,
					mm: processRelativeTime,
					h: processRelativeTime,
					hh: processRelativeTime,
					d: processRelativeTime,
					dd: processRelativeTime,
					M: processRelativeTime,
					MM: processRelativeTime,
					y: processRelativeTime,
					yy: processRelativeTime
				},
				dayOfMonthOrdinalParse: /\d{1,2}\./,
				ordinal: '%d.',
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			function processRelativeTime(number, withoutSuffix, key, isFuture) {
				var format = {
					's': ['viensas secunds', '\'iensas secunds'],
					'ss': [number + ' secunds', '' + number + ' secunds'],
					'm': ['\'n mut', '\'iens mut'],
					'mm': [number + ' muts', '' + number + ' muts'],
					'h': ['\'n ora', '\'iensa ora'],
					'hh': [number + ' oras', '' + number + ' oras'],
					'd': ['\'n ziua', '\'iensa ziua'],
					'dd': [number + ' ziuas', '' + number + ' ziuas'],
					'M': ['\'n mes', '\'iens mes'],
					'MM': [number + ' mesen', '' + number + ' mesen'],
					'y': ['\'n ar', '\'iens ar'],
					'yy': [number + ' ars', '' + number + ' ars']
				};
				return isFuture ? format[key][0] : (withoutSuffix ? format[key][0] : format[key][1]);
			}
			
			return tzl;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/tzm-latn.js":
	/*!************************************************!*\
  !*** ./node_modules/moment/locale/tzm-latn.js ***!
  \************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var tzmLatn = moment.defineLocale('tzm-latn', {
				months: 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),
				monthsShort: 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),
				weekdays: 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
				weekdaysShort: 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
				weekdaysMin: 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY HH:mm',
					LLLL: 'dddd D MMMM YYYY HH:mm'
				},
				calendar: {
					sameDay: '[asdkh g] LT',
					nextDay: '[aska g] LT',
					nextWeek: 'dddd [g] LT',
					lastDay: '[assant g] LT',
					lastWeek: 'dddd [g] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: 'dadkh s yan %s',
					past: 'yan %s',
					s: 'imik',
					ss: '%d imik',
					m: 'minu',
					mm: '%d minu',
					h: 'saa',
					hh: '%d tassain',
					d: 'ass',
					dd: '%d ossan',
					M: 'ayowr',
					MM: '%d iyyirn',
					y: 'asgas',
					yy: '%d isgasn'
				},
				week: {
					dow: 6, // Saturday is the first day of the week.
					doy: 12  // The week that contains Jan 12th is the first week of the year.
				}
			});
			
			return tzmLatn;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/tzm.js":
	/*!*******************************************!*\
  !*** ./node_modules/moment/locale/tzm.js ***!
  \*******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var tzm = moment.defineLocale('tzm', {
				months: '___________'.split('_'),
				monthsShort: '___________'.split('_'),
				weekdays: '______'.split('_'),
				weekdaysShort: '______'.split('_'),
				weekdaysMin: '______'.split('_'),
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY HH:mm',
					LLLL: 'dddd D MMMM YYYY HH:mm'
				},
				calendar: {
					sameDay: '[ ] LT',
					nextDay: '[ ] LT',
					nextWeek: 'dddd [] LT',
					lastDay: '[ ] LT',
					lastWeek: 'dddd [] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: '   %s',
					past: ' %s',
					s: '',
					ss: '%d ',
					m: '',
					mm: '%d ',
					h: '',
					hh: '%d ',
					d: '',
					dd: '%d o',
					M: 'o',
					MM: '%d ',
					y: '',
					yy: '%d '
				},
				week: {
					dow: 6, // Saturday is the first day of the week.
					doy: 12  // The week that contains Jan 12th is the first week of the year.
				}
			});
			
			return tzm;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/ug-cn.js":
	/*!*********************************************!*\
  !*** ./node_modules/moment/locale/ug-cn.js ***!
  \*********************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js language configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var ugCn = moment.defineLocale('ug-cn', {
				months: '___________'.split(
					'_'
				),
				monthsShort: '___________'.split(
					'_'
				),
				weekdays: '______'.split(
					'_'
				),
				weekdaysShort: '______'.split('_'),
				weekdaysMin: '______'.split('_'),
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'YYYY-MM-DD',
					LL: 'YYYY-M-D-',
					LLL: 'YYYY-M-D- HH:mm',
					LLLL: 'dddd YYYY-M-D- HH:mm'
				},
				meridiemParse: / || || |/,
				meridiemHour: function(hour, meridiem) {
					if(hour === 12) {
						hour = 0;
					}
					if(
						meridiem === ' ' ||
						meridiem === '' ||
						meridiem === ' '
					) {
						return hour;
					} else if(meridiem === ' ' || meridiem === '') {
						return hour + 12;
					} else {
						return hour >= 11 ? hour : hour + 12;
					}
				},
				meridiem: function(hour, minute, isLower) {
					var hm = hour * 100 + minute;
					if(hm < 600) {
						return ' ';
					} else if(hm < 900) {
						return '';
					} else if(hm < 1130) {
						return ' ';
					} else if(hm < 1230) {
						return '';
					} else if(hm < 1800) {
						return ' ';
					} else {
						return '';
					}
				},
				calendar: {
					sameDay: '[ ] LT',
					nextDay: '[ ] LT',
					nextWeek: '[] dddd [] LT',
					lastDay: '[] LT',
					lastWeek: '[] dddd [] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: '%s ',
					past: '%s ',
					s: ' ',
					ss: '%d ',
					m: ' ',
					mm: '%d ',
					h: ' ',
					hh: '%d ',
					d: ' ',
					dd: '%d ',
					M: ' ',
					MM: '%d ',
					y: ' ',
					yy: '%d '
				},
				
				dayOfMonthOrdinalParse: /\d{1,2}(-|-|-)/,
				ordinal: function(number, period) {
					switch(period) {
						case 'd':
						case 'D':
						case 'DDD':
							return number + '-';
						case 'w':
						case 'W':
							return number + '-';
						default:
							return number;
					}
				},
				preparse: function(string) {
					return string.replace(//g, ',');
				},
				postformat: function(string) {
					return string.replace(/,/g, '');
				},
				week: {
					// GB/T 7408-1994ISO 8601:1988
					dow: 1, // Monday is the first day of the week.
					doy: 7 // The week that contains Jan 1st is the first week of the year.
				}
			});
			
			return ugCn;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/uk.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/uk.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			function plural(word, num) {
				var forms = word.split('_');
				return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
			}
			
			function relativeTimeWithPlural(number, withoutSuffix, key) {
				var format = {
					'ss': withoutSuffix ? '__' : '__',
					'mm': withoutSuffix ? '__' : '__',
					'hh': withoutSuffix ? '__' : '__',
					'dd': '__',
					'MM': '__',
					'yy': '__'
				};
				if(key === 'm') {
					return withoutSuffix ? '' : '';
				} else if(key === 'h') {
					return withoutSuffix ? '' : '';
				} else {
					return number + ' ' + plural(format[key], +number);
				}
			}
			
			function weekdaysCaseReplace(m, format) {
				var weekdays = {
					'nominative': '______'.split('_'),
					'accusative': '______'.split('_'),
					'genitive': '______'.split('_')
				};
				
				if(m === true) {
					return weekdays['nominative'].slice(1, 7).concat(weekdays['nominative'].slice(0, 1));
				}
				if(!m) {
					return weekdays['nominative'];
				}
				
				var nounCase = (/(\[[]\]) ?dddd/).test(format) ?
					'accusative' :
					((/\[?(?:|)? ?\] ?dddd/).test(format) ?
						'genitive' :
						'nominative');
				return weekdays[nounCase][m.day()];
			}
			
			function processHoursFunction(str) {
				return function() {
					return str + '' + (this.hours() === 11 ? '' : '') + '] LT';
				};
			}
			
			var uk = moment.defineLocale('uk', {
				months: {
					'format': '___________'.split('_'),
					'standalone': '___________'.split('_')
				},
				monthsShort: '___________'.split('_'),
				weekdays: weekdaysCaseReplace,
				weekdaysShort: '______'.split('_'),
				weekdaysMin: '______'.split('_'),
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD.MM.YYYY',
					LL: 'D MMMM YYYY .',
					LLL: 'D MMMM YYYY ., HH:mm',
					LLLL: 'dddd, D MMMM YYYY ., HH:mm'
				},
				calendar: {
					sameDay: processHoursFunction('[ '),
					nextDay: processHoursFunction('[ '),
					lastDay: processHoursFunction('[ '),
					nextWeek: processHoursFunction('[] dddd ['),
					lastWeek: function() {
						switch(this.day()) {
							case 0:
							case 3:
							case 5:
							case 6:
								return processHoursFunction('[] dddd [').call(this);
							case 1:
							case 2:
							case 4:
								return processHoursFunction('[] dddd [').call(this);
						}
					},
					sameElse: 'L'
				},
				relativeTime: {
					future: ' %s',
					past: '%s ',
					s: ' ',
					ss: relativeTimeWithPlural,
					m: relativeTimeWithPlural,
					mm: relativeTimeWithPlural,
					h: '',
					hh: relativeTimeWithPlural,
					d: '',
					dd: relativeTimeWithPlural,
					M: '',
					MM: relativeTimeWithPlural,
					y: '',
					yy: relativeTimeWithPlural
				},
				// M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason
				meridiemParse: /|||/,
				isPM: function(input) {
					return /^(|)$/.test(input);
				},
				meridiem: function(hour, minute, isLower) {
					if(hour < 4) {
						return '';
					} else if(hour < 12) {
						return '';
					} else if(hour < 17) {
						return '';
					} else {
						return '';
					}
				},
				dayOfMonthOrdinalParse: /\d{1,2}-(|)/,
				ordinal: function(number, period) {
					switch(period) {
						case 'M':
						case 'd':
						case 'DDD':
						case 'w':
						case 'W':
							return number + '-';
						case 'D':
							return number + '-';
						default:
							return number;
					}
				},
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 7  // The week that contains Jan 7th is the first week of the year.
				}
			});
			
			return uk;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/ur.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/ur.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var months = [
				'',
				'',
				'',
				'',
				'',
				'',
				'',
				'',
				'',
				'',
				'',
				''
			];
			var days = [
				'',
				'',
				'',
				'',
				'',
				'',
				''
			];
			
			var ur = moment.defineLocale('ur', {
				months: months,
				monthsShort: months,
				weekdays: days,
				weekdaysShort: days,
				weekdaysMin: days,
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY HH:mm',
					LLLL: 'dddd D MMMM YYYY HH:mm'
				},
				meridiemParse: /|/,
				isPM: function(input) {
					return '' === input;
				},
				meridiem: function(hour, minute, isLower) {
					if(hour < 12) {
						return '';
					}
					return '';
				},
				calendar: {
					sameDay: '[ ] LT',
					nextDay: '[ ] LT',
					nextWeek: 'dddd [] LT',
					lastDay: '[  ] LT',
					lastWeek: '[] dddd [] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: '%s ',
					past: '%s ',
					s: ' ',
					ss: '%d ',
					m: ' ',
					mm: '%d ',
					h: ' ',
					hh: '%d ',
					d: ' ',
					dd: '%d ',
					M: ' ',
					MM: '%d ',
					y: ' ',
					yy: '%d '
				},
				preparse: function(string) {
					return string.replace(//g, ',');
				},
				postformat: function(string) {
					return string.replace(/,/g, '');
				},
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return ur;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/uz-latn.js":
	/*!***********************************************!*\
  !*** ./node_modules/moment/locale/uz-latn.js ***!
  \***********************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var uzLatn = moment.defineLocale('uz-latn', {
				months: 'Yanvar_Fevral_Mart_Aprel_May_Iyun_Iyul_Avgust_Sentabr_Oktabr_Noyabr_Dekabr'.split('_'),
				monthsShort: 'Yan_Fev_Mar_Apr_May_Iyun_Iyul_Avg_Sen_Okt_Noy_Dek'.split('_'),
				weekdays: 'Yakshanba_Dushanba_Seshanba_Chorshanba_Payshanba_Juma_Shanba'.split('_'),
				weekdaysShort: 'Yak_Dush_Sesh_Chor_Pay_Jum_Shan'.split('_'),
				weekdaysMin: 'Ya_Du_Se_Cho_Pa_Ju_Sha'.split('_'),
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY HH:mm',
					LLLL: 'D MMMM YYYY, dddd HH:mm'
				},
				calendar: {
					sameDay: '[Bugun soat] LT [da]',
					nextDay: '[Ertaga] LT [da]',
					nextWeek: 'dddd [kuni soat] LT [da]',
					lastDay: '[Kecha soat] LT [da]',
					lastWeek: '[O\'tgan] dddd [kuni soat] LT [da]',
					sameElse: 'L'
				},
				relativeTime: {
					future: 'Yaqin %s ichida',
					past: 'Bir necha %s oldin',
					s: 'soniya',
					ss: '%d soniya',
					m: 'bir daqiqa',
					mm: '%d daqiqa',
					h: 'bir soat',
					hh: '%d soat',
					d: 'bir kun',
					dd: '%d kun',
					M: 'bir oy',
					MM: '%d oy',
					y: 'bir yil',
					yy: '%d yil'
				},
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 7  // The week that contains Jan 7th is the first week of the year.
				}
			});
			
			return uzLatn;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/uz.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/uz.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var uz = moment.defineLocale('uz', {
				months: '___________'.split('_'),
				monthsShort: '___________'.split('_'),
				weekdays: '______'.split('_'),
				weekdaysShort: '______'.split('_'),
				weekdaysMin: '______'.split('_'),
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY HH:mm',
					LLLL: 'D MMMM YYYY, dddd HH:mm'
				},
				calendar: {
					sameDay: '[ ] LT []',
					nextDay: '[] LT []',
					nextWeek: 'dddd [ ] LT []',
					lastDay: '[ ] LT []',
					lastWeek: '[] dddd [ ] LT []',
					sameElse: 'L'
				},
				relativeTime: {
					future: ' %s ',
					past: '  %s ',
					s: '',
					ss: '%d ',
					m: ' ',
					mm: '%d ',
					h: ' ',
					hh: '%d ',
					d: ' ',
					dd: '%d ',
					M: ' ',
					MM: '%d ',
					y: ' ',
					yy: '%d '
				},
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 7  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return uz;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/vi.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/vi.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var vi = moment.defineLocale('vi', {
				months: 'thng 1_thng 2_thng 3_thng 4_thng 5_thng 6_thng 7_thng 8_thng 9_thng 10_thng 11_thng 12'.split('_'),
				monthsShort: 'Th01_Th02_Th03_Th04_Th05_Th06_Th07_Th08_Th09_Th10_Th11_Th12'.split('_'),
				monthsParseExact: true,
				weekdays: 'ch nht_th hai_th ba_th t_th nm_th su_th by'.split('_'),
				weekdaysShort: 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
				weekdaysMin: 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
				weekdaysParseExact: true,
				meridiemParse: /sa|ch/i,
				isPM: function(input) {
					return /^ch$/i.test(input);
				},
				meridiem: function(hours, minutes, isLower) {
					if(hours < 12) {
						return isLower ? 'sa' : 'SA';
					} else {
						return isLower ? 'ch' : 'CH';
					}
				},
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM [nm] YYYY',
					LLL: 'D MMMM [nm] YYYY HH:mm',
					LLLL: 'dddd, D MMMM [nm] YYYY HH:mm',
					l: 'DD/M/YYYY',
					ll: 'D MMM YYYY',
					lll: 'D MMM YYYY HH:mm',
					llll: 'ddd, D MMM YYYY HH:mm'
				},
				calendar: {
					sameDay: '[Hm nay lc] LT',
					nextDay: '[Ngy mai lc] LT',
					nextWeek: 'dddd [tun ti lc] LT',
					lastDay: '[Hm qua lc] LT',
					lastWeek: 'dddd [tun ri lc] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: '%s ti',
					past: '%s trc',
					s: 'vi giy',
					ss: '%d giy',
					m: 'mt pht',
					mm: '%d pht',
					h: 'mt gi',
					hh: '%d gi',
					d: 'mt ngy',
					dd: '%d ngy',
					M: 'mt thng',
					MM: '%d thng',
					y: 'mt nm',
					yy: '%d nm'
				},
				dayOfMonthOrdinalParse: /\d{1,2}/,
				ordinal: function(number) {
					return number;
				},
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return vi;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/x-pseudo.js":
	/*!************************************************!*\
  !*** ./node_modules/moment/locale/x-pseudo.js ***!
  \************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var xPseudo = moment.defineLocale('x-pseudo', {
				months: 'J~~r_F~br~r_~Mrc~h_p~rl_~M_~J~_Jl~_~gst~_Sp~tmb~r_~ctb~r_~vm~br_~Dc~mbr'.split('_'),
				monthsShort: 'J~_~Fb_~Mr_~pr_~M_~J_~Jl_~g_~Sp_~ct_~v_~Dc'.split('_'),
				monthsParseExact: true,
				weekdays: 'S~d~_M~d~_T~sd~_Wd~sd~_T~hrs~d_~Frd~_S~tr~d'.split('_'),
				weekdaysShort: 'S~_~M_~T_~Wd_~Th_~Fr_~St'.split('_'),
				weekdaysMin: 'S~_M~_T_~W_T~h_Fr~_S'.split('_'),
				weekdaysParseExact: true,
				longDateFormat: {
					LT: 'HH:mm',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY HH:mm',
					LLLL: 'dddd, D MMMM YYYY HH:mm'
				},
				calendar: {
					sameDay: '[T~d~ t] LT',
					nextDay: '[T~m~rr~w t] LT',
					nextWeek: 'dddd [t] LT',
					lastDay: '[~st~rd~ t] LT',
					lastWeek: '[L~st] dddd [t] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: '~ %s',
					past: '%s ~g',
					s: ' ~fw ~sc~ds',
					ss: '%d s~c~ds',
					m: ' ~m~t',
					mm: '%d m~~ts',
					h: '~ h~r',
					hh: '%d h~rs',
					d: ' ~d',
					dd: '%d d~s',
					M: ' ~m~th',
					MM: '%d m~t~hs',
					y: ' ~r',
					yy: '%d ~rs'
				},
				dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
				ordinal: function(number) {
					var b = number % 10,
						output = (~~(number % 100 / 10) === 1) ? 'th' :
							(b === 1) ? 'st' :
								(b === 2) ? 'nd' :
									(b === 3) ? 'rd' : 'th';
					return number + output;
				},
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return xPseudo;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/yo.js":
	/*!******************************************!*\
  !*** ./node_modules/moment/locale/yo.js ***!
  \******************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var yo = moment.defineLocale('yo', {
				months: 'Sr_Erele_rna_Igbe_Ebibi_Okudu_Agmo_Ogun_Owewe_wara_Belu_p'.split('_'),
				monthsShort: 'Sr_Erl_rn_Igb_Ebi_Oku_Ag_Ogu_Owe_wa_Bel_p'.split('_'),
				weekdays: 'Aiku_Aje_Isgun_jru_jb_ti_Abamta'.split('_'),
				weekdaysShort: 'Aik_Aje_Is_jr_jb_ti_Aba'.split('_'),
				weekdaysMin: 'Ai_Aj_Is_r_b_t_Ab'.split('_'),
				longDateFormat: {
					LT: 'h:mm A',
					LTS: 'h:mm:ss A',
					L: 'DD/MM/YYYY',
					LL: 'D MMMM YYYY',
					LLL: 'D MMMM YYYY h:mm A',
					LLLL: 'dddd, D MMMM YYYY h:mm A'
				},
				calendar: {
					sameDay: '[Oni ni] LT',
					nextDay: '[la ni] LT',
					nextWeek: 'dddd [s ton\'b] [ni] LT',
					lastDay: '[Ana ni] LT',
					lastWeek: 'dddd [s tol] [ni] LT',
					sameElse: 'L'
				},
				relativeTime: {
					future: 'ni %s',
					past: '%s kja',
					s: 'isju aaya die',
					ss: 'aaya %d',
					m: 'isju kan',
					mm: 'isju %d',
					h: 'wakati kan',
					hh: 'wakati %d',
					d: 'j kan',
					dd: 'j %d',
					M: 'osu kan',
					MM: 'osu %d',
					y: 'dun kan',
					yy: 'dun %d'
				},
				dayOfMonthOrdinalParse: /j\s\d{1,2}/,
				ordinal: 'j %d',
				week: {
					dow: 1, // Monday is the first day of the week.
					doy: 4 // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return yo;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/zh-cn.js":
	/*!*********************************************!*\
  !*** ./node_modules/moment/locale/zh-cn.js ***!
  \*********************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var zhCn = moment.defineLocale('zh-cn', {
				months: '___________'.split('_'),
				monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
				weekdays: '______'.split('_'),
				weekdaysShort: '______'.split('_'),
				weekdaysMin: '______'.split('_'),
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'YYYY/MM/DD',
					LL: 'YYYYMD',
					LLL: 'YYYYMDAhmm',
					LLLL: 'YYYYMDddddAhmm',
					l: 'YYYY/M/D',
					ll: 'YYYYMD',
					lll: 'YYYYMD HH:mm',
					llll: 'YYYYMDdddd HH:mm'
				},
				meridiemParse: /|||||/,
				meridiemHour: function(hour, meridiem) {
					if(hour === 12) {
						hour = 0;
					}
					if(meridiem === '' || meridiem === '' ||
						meridiem === '') {
						return hour;
					} else if(meridiem === '' || meridiem === '') {
						return hour + 12;
					} else {
						// ''
						return hour >= 11 ? hour : hour + 12;
					}
				},
				meridiem: function(hour, minute, isLower) {
					var hm = hour * 100 + minute;
					if(hm < 600) {
						return '';
					} else if(hm < 900) {
						return '';
					} else if(hm < 1130) {
						return '';
					} else if(hm < 1230) {
						return '';
					} else if(hm < 1800) {
						return '';
					} else {
						return '';
					}
				},
				calendar: {
					sameDay: '[]LT',
					nextDay: '[]LT',
					nextWeek: '[]ddddLT',
					lastDay: '[]LT',
					lastWeek: '[]ddddLT',
					sameElse: 'L'
				},
				dayOfMonthOrdinalParse: /\d{1,2}(||)/,
				ordinal: function(number, period) {
					switch(period) {
						case 'd':
						case 'D':
						case 'DDD':
							return number + '';
						case 'M':
							return number + '';
						case 'w':
						case 'W':
							return number + '';
						default:
							return number;
					}
				},
				relativeTime: {
					future: '%s',
					past: '%s',
					s: '',
					ss: '%d ',
					m: '1 ',
					mm: '%d ',
					h: '1 ',
					hh: '%d ',
					d: '1 ',
					dd: '%d ',
					M: '1 ',
					MM: '%d ',
					y: '1 ',
					yy: '%d '
				},
				week: {
					// GB/T 7408-1994ISO 8601:1988
					dow: 1, // Monday is the first day of the week.
					doy: 4  // The week that contains Jan 4th is the first week of the year.
				}
			});
			
			return zhCn;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/zh-hk.js":
	/*!*********************************************!*\
  !*** ./node_modules/moment/locale/zh-hk.js ***!
  \*********************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var zhHk = moment.defineLocale('zh-hk', {
				months: '___________'.split('_'),
				monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
				weekdays: '______'.split('_'),
				weekdaysShort: '______'.split('_'),
				weekdaysMin: '______'.split('_'),
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'YYYY/MM/DD',
					LL: 'YYYYMD',
					LLL: 'YYYYMD HH:mm',
					LLLL: 'YYYYMDdddd HH:mm',
					l: 'YYYY/M/D',
					ll: 'YYYYMD',
					lll: 'YYYYMD HH:mm',
					llll: 'YYYYMDdddd HH:mm'
				},
				meridiemParse: /|||||/,
				meridiemHour: function(hour, meridiem) {
					if(hour === 12) {
						hour = 0;
					}
					if(meridiem === '' || meridiem === '' || meridiem === '') {
						return hour;
					} else if(meridiem === '') {
						return hour >= 11 ? hour : hour + 12;
					} else if(meridiem === '' || meridiem === '') {
						return hour + 12;
					}
				},
				meridiem: function(hour, minute, isLower) {
					var hm = hour * 100 + minute;
					if(hm < 600) {
						return '';
					} else if(hm < 900) {
						return '';
					} else if(hm < 1130) {
						return '';
					} else if(hm < 1230) {
						return '';
					} else if(hm < 1800) {
						return '';
					} else {
						return '';
					}
				},
				calendar: {
					sameDay: '[]LT',
					nextDay: '[]LT',
					nextWeek: '[]ddddLT',
					lastDay: '[]LT',
					lastWeek: '[]ddddLT',
					sameElse: 'L'
				},
				dayOfMonthOrdinalParse: /\d{1,2}(||)/,
				ordinal: function(number, period) {
					switch(period) {
						case 'd' :
						case 'D' :
						case 'DDD' :
							return number + '';
						case 'M' :
							return number + '';
						case 'w' :
						case 'W' :
							return number + '';
						default :
							return number;
					}
				},
				relativeTime: {
					future: '%s',
					past: '%s',
					s: '',
					ss: '%d ',
					m: '1 ',
					mm: '%d ',
					h: '1 ',
					hh: '%d ',
					d: '1 ',
					dd: '%d ',
					M: '1 ',
					MM: '%d ',
					y: '1 ',
					yy: '%d '
				}
			});
			
			return zhHk;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/locale/zh-tw.js":
	/*!*********************************************!*\
  !*** ./node_modules/moment/locale/zh-tw.js ***!
  \*********************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
		
		;(function(global, factory) {
			true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
				undefined
		}(this, (function(moment) {
			'use strict';
			
			
			var zhTw = moment.defineLocale('zh-tw', {
				months: '___________'.split('_'),
				monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
				weekdays: '______'.split('_'),
				weekdaysShort: '______'.split('_'),
				weekdaysMin: '______'.split('_'),
				longDateFormat: {
					LT: 'HH:mm',
					LTS: 'HH:mm:ss',
					L: 'YYYY/MM/DD',
					LL: 'YYYYMD',
					LLL: 'YYYYMD HH:mm',
					LLLL: 'YYYYMDdddd HH:mm',
					l: 'YYYY/M/D',
					ll: 'YYYYMD',
					lll: 'YYYYMD HH:mm',
					llll: 'YYYYMDdddd HH:mm'
				},
				meridiemParse: /|||||/,
				meridiemHour: function(hour, meridiem) {
					if(hour === 12) {
						hour = 0;
					}
					if(meridiem === '' || meridiem === '' || meridiem === '') {
						return hour;
					} else if(meridiem === '') {
						return hour >= 11 ? hour : hour + 12;
					} else if(meridiem === '' || meridiem === '') {
						return hour + 12;
					}
				},
				meridiem: function(hour, minute, isLower) {
					var hm = hour * 100 + minute;
					if(hm < 600) {
						return '';
					} else if(hm < 900) {
						return '';
					} else if(hm < 1130) {
						return '';
					} else if(hm < 1230) {
						return '';
					} else if(hm < 1800) {
						return '';
					} else {
						return '';
					}
				},
				calendar: {
					sameDay: '[] LT',
					nextDay: '[] LT',
					nextWeek: '[]dddd LT',
					lastDay: '[] LT',
					lastWeek: '[]dddd LT',
					sameElse: 'L'
				},
				dayOfMonthOrdinalParse: /\d{1,2}(||)/,
				ordinal: function(number, period) {
					switch(period) {
						case 'd' :
						case 'D' :
						case 'DDD' :
							return number + '';
						case 'M' :
							return number + '';
						case 'w' :
						case 'W' :
							return number + '';
						default :
							return number;
					}
				},
				relativeTime: {
					future: '%s',
					past: '%s',
					s: '',
					ss: '%d ',
					m: '1 ',
					mm: '%d ',
					h: '1 ',
					hh: '%d ',
					d: '1 ',
					dd: '%d ',
					M: '1 ',
					MM: '%d ',
					y: '1 ',
					yy: '%d '
				}
			});
			
			return zhTw;
			
		})));
		
		
		/***/
	}),
	
	/***/ "./node_modules/moment/moment.js":
	/*!***************************************!*\
  !*** ./node_modules/moment/moment.js ***!
  \***************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		/* WEBPACK VAR INJECTION */
		(function(module) {
			var require;//! moment.js
			
			;(function(global, factory) {
				true ? module.exports = factory() :
					undefined;
			}(this, (function() {
				'use strict';
				
				var hookCallback;
				
				function hooks() {
					return hookCallback.apply(null, arguments);
				}
				
				// This is done to register the method called with moment()
				// without creating circular dependencies.
				function setHookCallback(callback) {
					hookCallback = callback;
				}
				
				function isArray(input) {
					return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
				}
				
				function isObject(input) {
					// IE8 will treat undefined and null as object if it wasn't for
					// input != null
					return input != null && Object.prototype.toString.call(input) === '[object Object]';
				}
				
				function isObjectEmpty(obj) {
					if(Object.getOwnPropertyNames) {
						return (Object.getOwnPropertyNames(obj).length === 0);
					} else {
						var k;
						for(k in obj) {
							if(obj.hasOwnProperty(k)) {
								return false;
							}
						}
						return true;
					}
				}
				
				function isUndefined(input) {
					return input === void 0;
				}
				
				function isNumber(input) {
					return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
				}
				
				function isDate(input) {
					return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
				}
				
				function map(arr, fn) {
					var res = [], i;
					for(i = 0; i < arr.length; ++i) {
						res.push(fn(arr[i], i));
					}
					return res;
				}
				
				function hasOwnProp(a, b) {
					return Object.prototype.hasOwnProperty.call(a, b);
				}
				
				function extend(a, b) {
					for(var i in b) {
						if(hasOwnProp(b, i)) {
							a[i] = b[i];
						}
					}
					
					if(hasOwnProp(b, 'toString')) {
						a.toString = b.toString;
					}
					
					if(hasOwnProp(b, 'valueOf')) {
						a.valueOf = b.valueOf;
					}
					
					return a;
				}
				
				function createUTC(input, format, locale, strict) {
					return createLocalOrUTC(input, format, locale, strict, true).utc();
				}
				
				function defaultParsingFlags() {
					// We need to deep clone this object.
					return {
						empty: false,
						unusedTokens: [],
						unusedInput: [],
						overflow: -2,
						charsLeftOver: 0,
						nullInput: false,
						invalidMonth: null,
						invalidFormat: false,
						userInvalidated: false,
						iso: false,
						parsedDateParts: [],
						meridiem: null,
						rfc2822: false,
						weekdayMismatch: false
					};
				}
				
				function getParsingFlags(m) {
					if(m._pf == null) {
						m._pf = defaultParsingFlags();
					}
					return m._pf;
				}
				
				var some;
				if(Array.prototype.some) {
					some = Array.prototype.some;
				} else {
					some = function(fun) {
						var t = Object(this);
						var len = t.length >>> 0;
						
						for(var i = 0; i < len; i++) {
							if(i in t && fun.call(this, t[i], i, t)) {
								return true;
							}
						}
						
						return false;
					};
				}
				
				function isValid(m) {
					if(m._isValid == null) {
						var flags = getParsingFlags(m);
						var parsedParts = some.call(flags.parsedDateParts, function(i) {
							return i != null;
						});
						var isNowValid = !isNaN(m._d.getTime()) &&
							flags.overflow < 0 &&
							!flags.empty &&
							!flags.invalidMonth &&
							!flags.invalidWeekday &&
							!flags.weekdayMismatch &&
							!flags.nullInput &&
							!flags.invalidFormat &&
							!flags.userInvalidated &&
							(!flags.meridiem || (flags.meridiem && parsedParts));
						
						if(m._strict) {
							isNowValid = isNowValid &&
								flags.charsLeftOver === 0 &&
								flags.unusedTokens.length === 0 &&
								flags.bigHour === undefined;
						}
						
						if(Object.isFrozen == null || !Object.isFrozen(m)) {
							m._isValid = isNowValid;
						} else {
							return isNowValid;
						}
					}
					return m._isValid;
				}
				
				function createInvalid(flags) {
					var m = createUTC(NaN);
					if(flags != null) {
						extend(getParsingFlags(m), flags);
					} else {
						getParsingFlags(m).userInvalidated = true;
					}
					
					return m;
				}
				
				// Plugins that add properties should also add the key here (null value),
				// so we can properly clone ourselves.
				var momentProperties = hooks.momentProperties = [];
				
				function copyConfig(to, from) {
					var i, prop, val;
					
					if(!isUndefined(from._isAMomentObject)) {
						to._isAMomentObject = from._isAMomentObject;
					}
					if(!isUndefined(from._i)) {
						to._i = from._i;
					}
					if(!isUndefined(from._f)) {
						to._f = from._f;
					}
					if(!isUndefined(from._l)) {
						to._l = from._l;
					}
					if(!isUndefined(from._strict)) {
						to._strict = from._strict;
					}
					if(!isUndefined(from._tzm)) {
						to._tzm = from._tzm;
					}
					if(!isUndefined(from._isUTC)) {
						to._isUTC = from._isUTC;
					}
					if(!isUndefined(from._offset)) {
						to._offset = from._offset;
					}
					if(!isUndefined(from._pf)) {
						to._pf = getParsingFlags(from);
					}
					if(!isUndefined(from._locale)) {
						to._locale = from._locale;
					}
					
					if(momentProperties.length > 0) {
						for(i = 0; i < momentProperties.length; i++) {
							prop = momentProperties[i];
							val = from[prop];
							if(!isUndefined(val)) {
								to[prop] = val;
							}
						}
					}
					
					return to;
				}
				
				var updateInProgress = false;
				
				// Moment prototype object
				function Moment(config) {
					copyConfig(this, config);
					this._d = new Date(config._d != null ? config._d.getTime() : NaN);
					if(!this.isValid()) {
						this._d = new Date(NaN);
					}
					// Prevent infinite loop in case updateOffset creates new moment
					// objects.
					if(updateInProgress === false) {
						updateInProgress = true;
						hooks.updateOffset(this);
						updateInProgress = false;
					}
				}
				
				function isMoment(obj) {
					return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
				}
				
				function absFloor(number) {
					if(number < 0) {
						// -0 -> 0
						return Math.ceil(number) || 0;
					} else {
						return Math.floor(number);
					}
				}
				
				function toInt(argumentForCoercion) {
					var coercedNumber = +argumentForCoercion,
						value = 0;
					
					if(coercedNumber !== 0 && isFinite(coercedNumber)) {
						value = absFloor(coercedNumber);
					}
					
					return value;
				}
				
				// compare two arrays, return the number of differences
				function compareArrays(array1, array2, dontConvert) {
					var len = Math.min(array1.length, array2.length),
						lengthDiff = Math.abs(array1.length - array2.length),
						diffs = 0,
						i;
					for(i = 0; i < len; i++) {
						if((dontConvert && array1[i] !== array2[i]) ||
							(!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
							diffs++;
						}
					}
					return diffs + lengthDiff;
				}
				
				function warn(msg) {
					if(hooks.suppressDeprecationWarnings === false &&
						(typeof console !== 'undefined') && console.warn) {
						console.warn('Deprecation warning: ' + msg);
					}
				}
				
				function deprecate(msg, fn) {
					var firstTime = true;
					
					return extend(function() {
						if(hooks.deprecationHandler != null) {
							hooks.deprecationHandler(null, msg);
						}
						if(firstTime) {
							var args = [];
							var arg;
							for(var i = 0; i < arguments.length; i++) {
								arg = '';
								if(typeof arguments[i] === 'object') {
									arg += '\n[' + i + '] ';
									for(var key in arguments[0]) {
										arg += key + ': ' + arguments[0][key] + ', ';
									}
									arg = arg.slice(0, -2); // Remove trailing comma and space
								} else {
									arg = arguments[i];
								}
								args.push(arg);
							}
							warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
							firstTime = false;
						}
						return fn.apply(this, arguments);
					}, fn);
				}
				
				var deprecations = {};
				
				function deprecateSimple(name, msg) {
					if(hooks.deprecationHandler != null) {
						hooks.deprecationHandler(name, msg);
					}
					if(!deprecations[name]) {
						warn(msg);
						deprecations[name] = true;
					}
				}
				
				hooks.suppressDeprecationWarnings = false;
				hooks.deprecationHandler = null;
				
				function isFunction(input) {
					return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
				}
				
				function set(config) {
					var prop, i;
					for(i in config) {
						prop = config[i];
						if(isFunction(prop)) {
							this[i] = prop;
						} else {
							this['_' + i] = prop;
						}
					}
					this._config = config;
					// Lenient ordinal parsing accepts just a number in addition to
					// number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
					// TODO: Remove "ordinalParse" fallback in next major release.
					this._dayOfMonthOrdinalParseLenient = new RegExp(
						(this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
						'|' + (/\d{1,2}/).source);
				}
				
				function mergeConfigs(parentConfig, childConfig) {
					var res = extend({}, parentConfig), prop;
					for(prop in childConfig) {
						if(hasOwnProp(childConfig, prop)) {
							if(isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
								res[prop] = {};
								extend(res[prop], parentConfig[prop]);
								extend(res[prop], childConfig[prop]);
							} else if(childConfig[prop] != null) {
								res[prop] = childConfig[prop];
							} else {
								delete res[prop];
							}
						}
					}
					for(prop in parentConfig) {
						if(hasOwnProp(parentConfig, prop) &&
							!hasOwnProp(childConfig, prop) &&
							isObject(parentConfig[prop])) {
							// make sure changes to properties don't modify parent config
							res[prop] = extend({}, res[prop]);
						}
					}
					return res;
				}
				
				function Locale(config) {
					if(config != null) {
						this.set(config);
					}
				}
				
				var keys;
				
				if(Object.keys) {
					keys = Object.keys;
				} else {
					keys = function(obj) {
						var i, res = [];
						for(i in obj) {
							if(hasOwnProp(obj, i)) {
								res.push(i);
							}
						}
						return res;
					};
				}
				
				var defaultCalendar = {
					sameDay: '[Today at] LT',
					nextDay: '[Tomorrow at] LT',
					nextWeek: 'dddd [at] LT',
					lastDay: '[Yesterday at] LT',
					lastWeek: '[Last] dddd [at] LT',
					sameElse: 'L'
				};
				
				function calendar(key, mom, now) {
					var output = this._calendar[key] || this._calendar['sameElse'];
					return isFunction(output) ? output.call(mom, now) : output;
				}
				
				var defaultLongDateFormat = {
					LTS: 'h:mm:ss A',
					LT: 'h:mm A',
					L: 'MM/DD/YYYY',
					LL: 'MMMM D, YYYY',
					LLL: 'MMMM D, YYYY h:mm A',
					LLLL: 'dddd, MMMM D, YYYY h:mm A'
				};
				
				function longDateFormat(key) {
					var format = this._longDateFormat[key],
						formatUpper = this._longDateFormat[key.toUpperCase()];
					
					if(format || !formatUpper) {
						return format;
					}
					
					this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function(val) {
						return val.slice(1);
					});
					
					return this._longDateFormat[key];
				}
				
				var defaultInvalidDate = 'Invalid date';
				
				function invalidDate() {
					return this._invalidDate;
				}
				
				var defaultOrdinal = '%d';
				var defaultDayOfMonthOrdinalParse = /\d{1,2}/;
				
				function ordinal(number) {
					return this._ordinal.replace('%d', number);
				}
				
				var defaultRelativeTime = {
					future: 'in %s',
					past: '%s ago',
					s: 'a few seconds',
					ss: '%d seconds',
					m: 'a minute',
					mm: '%d minutes',
					h: 'an hour',
					hh: '%d hours',
					d: 'a day',
					dd: '%d days',
					M: 'a month',
					MM: '%d months',
					y: 'a year',
					yy: '%d years'
				};
				
				function relativeTime(number, withoutSuffix, string, isFuture) {
					var output = this._relativeTime[string];
					return (isFunction(output)) ?
						output(number, withoutSuffix, string, isFuture) :
						output.replace(/%d/i, number);
				}
				
				function pastFuture(diff, output) {
					var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
					return isFunction(format) ? format(output) : format.replace(/%s/i, output);
				}
				
				var aliases = {};
				
				function addUnitAlias(unit, shorthand) {
					var lowerCase = unit.toLowerCase();
					aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
				}
				
				function normalizeUnits(units) {
					return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
				}
				
				function normalizeObjectUnits(inputObject) {
					var normalizedInput = {},
						normalizedProp,
						prop;
					
					for(prop in inputObject) {
						if(hasOwnProp(inputObject, prop)) {
							normalizedProp = normalizeUnits(prop);
							if(normalizedProp) {
								normalizedInput[normalizedProp] = inputObject[prop];
							}
						}
					}
					
					return normalizedInput;
				}
				
				var priorities = {};
				
				function addUnitPriority(unit, priority) {
					priorities[unit] = priority;
				}
				
				function getPrioritizedUnits(unitsObj) {
					var units = [];
					for(var u in unitsObj) {
						units.push({unit: u, priority: priorities[u]});
					}
					units.sort(function(a, b) {
						return a.priority - b.priority;
					});
					return units;
				}
				
				function zeroFill(number, targetLength, forceSign) {
					var absNumber = '' + Math.abs(number),
						zerosToFill = targetLength - absNumber.length,
						sign = number >= 0;
					return (sign ? (forceSign ? '+' : '') : '-') +
						Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
				}
				
				var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
				
				var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
				
				var formatFunctions = {};
				
				var formatTokenFunctions = {};
				
				// token:    'M'
				// padded:   ['MM', 2]
				// ordinal:  'Mo'
				// callback: function () { this.month() + 1 }
				function addFormatToken(token, padded, ordinal, callback) {
					var func = callback;
					if(typeof callback === 'string') {
						func = function() {
							return this[callback]();
						};
					}
					if(token) {
						formatTokenFunctions[token] = func;
					}
					if(padded) {
						formatTokenFunctions[padded[0]] = function() {
							return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
						};
					}
					if(ordinal) {
						formatTokenFunctions[ordinal] = function() {
							return this.localeData().ordinal(func.apply(this, arguments), token);
						};
					}
				}
				
				function removeFormattingTokens(input) {
					if(input.match(/\[[\s\S]/)) {
						return input.replace(/^\[|\]$/g, '');
					}
					return input.replace(/\\/g, '');
				}
				
				function makeFormatFunction(format) {
					var array = format.match(formattingTokens), i, length;
					
					for(i = 0, length = array.length; i < length; i++) {
						if(formatTokenFunctions[array[i]]) {
							array[i] = formatTokenFunctions[array[i]];
						} else {
							array[i] = removeFormattingTokens(array[i]);
						}
					}
					
					return function(mom) {
						var output = '', i;
						for(i = 0; i < length; i++) {
							output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
						}
						return output;
					};
				}
				
				// format date using native date object
				function formatMoment(m, format) {
					if(!m.isValid()) {
						return m.localeData().invalidDate();
					}
					
					format = expandFormat(format, m.localeData());
					formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
					
					return formatFunctions[format](m);
				}
				
				function expandFormat(format, locale) {
					var i = 5;
					
					function replaceLongDateFormatTokens(input) {
						return locale.longDateFormat(input) || input;
					}
					
					localFormattingTokens.lastIndex = 0;
					while(i >= 0 && localFormattingTokens.test(format)) {
						format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
						localFormattingTokens.lastIndex = 0;
						i -= 1;
					}
					
					return format;
				}
				
				var match1 = /\d/;            //       0 - 9
				var match2 = /\d\d/;          //      00 - 99
				var match3 = /\d{3}/;         //     000 - 999
				var match4 = /\d{4}/;         //    0000 - 9999
				var match6 = /[+-]?\d{6}/;    // -999999 - 999999
				var match1to2 = /\d\d?/;         //       0 - 99
				var match3to4 = /\d\d\d\d?/;     //     999 - 9999
				var match5to6 = /\d\d\d\d\d\d?/; //   99999 - 999999
				var match1to3 = /\d{1,3}/;       //       0 - 999
				var match1to4 = /\d{1,4}/;       //       0 - 9999
				var match1to6 = /[+-]?\d{1,6}/;  // -999999 - 999999
				
				var matchUnsigned = /\d+/;           //       0 - inf
				var matchSigned = /[+-]?\d+/;      //    -inf - inf
				
				var matchOffset = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
				var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z
				
				var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123
				
				// any word (or two) characters or numbers including two/three word month in arabic.
				// includes scottish gaelic two word and hyphenated months
				var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;
				
				var regexes = {};
				
				function addRegexToken(token, regex, strictRegex) {
					regexes[token] = isFunction(regex) ? regex : function(isStrict, localeData) {
						return (isStrict && strictRegex) ? strictRegex : regex;
					};
				}
				
				function getParseRegexForToken(token, config) {
					if(!hasOwnProp(regexes, token)) {
						return new RegExp(unescapeFormat(token));
					}
					
					return regexes[token](config._strict, config._locale);
				}
				
				// Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
				function unescapeFormat(s) {
					return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
						return p1 || p2 || p3 || p4;
					}));
				}
				
				function regexEscape(s) {
					return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
				}
				
				var tokens = {};
				
				function addParseToken(token, callback) {
					var i, func = callback;
					if(typeof token === 'string') {
						token = [token];
					}
					if(isNumber(callback)) {
						func = function(input, array) {
							array[callback] = toInt(input);
						};
					}
					for(i = 0; i < token.length; i++) {
						tokens[token[i]] = func;
					}
				}
				
				function addWeekParseToken(token, callback) {
					addParseToken(token, function(input, array, config, token) {
						config._w = config._w || {};
						callback(input, config._w, config, token);
					});
				}
				
				function addTimeToArrayFromToken(token, input, config) {
					if(input != null && hasOwnProp(tokens, token)) {
						tokens[token](input, config._a, config, token);
					}
				}
				
				var YEAR = 0;
				var MONTH = 1;
				var DATE = 2;
				var HOUR = 3;
				var MINUTE = 4;
				var SECOND = 5;
				var MILLISECOND = 6;
				var WEEK = 7;
				var WEEKDAY = 8;
				
				// FORMATTING
				
				addFormatToken('Y', 0, 0, function() {
					var y = this.year();
					return y <= 9999 ? '' + y : '+' + y;
				});
				
				addFormatToken(0, ['YY', 2], 0, function() {
					return this.year() % 100;
				});
				
				addFormatToken(0, ['YYYY', 4], 0, 'year');
				addFormatToken(0, ['YYYYY', 5], 0, 'year');
				addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');
				
				// ALIASES
				
				addUnitAlias('year', 'y');
				
				// PRIORITIES
				
				addUnitPriority('year', 1);
				
				// PARSING
				
				addRegexToken('Y', matchSigned);
				addRegexToken('YY', match1to2, match2);
				addRegexToken('YYYY', match1to4, match4);
				addRegexToken('YYYYY', match1to6, match6);
				addRegexToken('YYYYYY', match1to6, match6);
				
				addParseToken(['YYYYY', 'YYYYYY'], YEAR);
				addParseToken('YYYY', function(input, array) {
					array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
				});
				addParseToken('YY', function(input, array) {
					array[YEAR] = hooks.parseTwoDigitYear(input);
				});
				addParseToken('Y', function(input, array) {
					array[YEAR] = parseInt(input, 10);
				});
				
				// HELPERS
				
				function daysInYear(year) {
					return isLeapYear(year) ? 366 : 365;
				}
				
				function isLeapYear(year) {
					return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
				}
				
				// HOOKS
				
				hooks.parseTwoDigitYear = function(input) {
					return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
				};
				
				// MOMENTS
				
				var getSetYear = makeGetSet('FullYear', true);
				
				function getIsLeapYear() {
					return isLeapYear(this.year());
				}
				
				function makeGetSet(unit, keepTime) {
					return function(value) {
						if(value != null) {
							set$1(this, unit, value);
							hooks.updateOffset(this, keepTime);
							return this;
						} else {
							return get(this, unit);
						}
					};
				}
				
				function get(mom, unit) {
					return mom.isValid() ?
						mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
				}
				
				function set$1(mom, unit, value) {
					if(mom.isValid() && !isNaN(value)) {
						if(unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
							mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
						} else {
							mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
						}
					}
				}
				
				// MOMENTS
				
				function stringGet(units) {
					units = normalizeUnits(units);
					if(isFunction(this[units])) {
						return this[units]();
					}
					return this;
				}
				
				
				function stringSet(units, value) {
					if(typeof units === 'object') {
						units = normalizeObjectUnits(units);
						var prioritized = getPrioritizedUnits(units);
						for(var i = 0; i < prioritized.length; i++) {
							this[prioritized[i].unit](units[prioritized[i].unit]);
						}
					} else {
						units = normalizeUnits(units);
						if(isFunction(this[units])) {
							return this[units](value);
						}
					}
					return this;
				}
				
				function mod(n, x) {
					return ((n % x) + x) % x;
				}
				
				var indexOf;
				
				if(Array.prototype.indexOf) {
					indexOf = Array.prototype.indexOf;
				} else {
					indexOf = function(o) {
						// I know
						var i;
						for(i = 0; i < this.length; ++i) {
							if(this[i] === o) {
								return i;
							}
						}
						return -1;
					};
				}
				
				function daysInMonth(year, month) {
					if(isNaN(year) || isNaN(month)) {
						return NaN;
					}
					var modMonth = mod(month, 12);
					year += (month - modMonth) / 12;
					return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);
				}
				
				// FORMATTING
				
				addFormatToken('M', ['MM', 2], 'Mo', function() {
					return this.month() + 1;
				});
				
				addFormatToken('MMM', 0, 0, function(format) {
					return this.localeData().monthsShort(this, format);
				});
				
				addFormatToken('MMMM', 0, 0, function(format) {
					return this.localeData().months(this, format);
				});
				
				// ALIASES
				
				addUnitAlias('month', 'M');
				
				// PRIORITY
				
				addUnitPriority('month', 8);
				
				// PARSING
				
				addRegexToken('M', match1to2);
				addRegexToken('MM', match1to2, match2);
				addRegexToken('MMM', function(isStrict, locale) {
					return locale.monthsShortRegex(isStrict);
				});
				addRegexToken('MMMM', function(isStrict, locale) {
					return locale.monthsRegex(isStrict);
				});
				
				addParseToken(['M', 'MM'], function(input, array) {
					array[MONTH] = toInt(input) - 1;
				});
				
				addParseToken(['MMM', 'MMMM'], function(input, array, config, token) {
					var month = config._locale.monthsParse(input, token, config._strict);
					// if we didn't find a month name, mark the date as invalid.
					if(month != null) {
						array[MONTH] = month;
					} else {
						getParsingFlags(config).invalidMonth = input;
					}
				});
				
				// LOCALES
				
				var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
				var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
				
				function localeMonths(m, format) {
					if(!m) {
						return isArray(this._months) ? this._months :
							this._months['standalone'];
					}
					return isArray(this._months) ? this._months[m.month()] :
						this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
				}
				
				var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
				
				function localeMonthsShort(m, format) {
					if(!m) {
						return isArray(this._monthsShort) ? this._monthsShort :
							this._monthsShort['standalone'];
					}
					return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
						this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
				}
				
				function handleStrictParse(monthName, format, strict) {
					var i, ii, mom, llc = monthName.toLocaleLowerCase();
					if(!this._monthsParse) {
						// this is not used
						this._monthsParse = [];
						this._longMonthsParse = [];
						this._shortMonthsParse = [];
						for(i = 0; i < 12; ++i) {
							mom = createUTC([2000, i]);
							this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
							this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
						}
					}
					
					if(strict) {
						if(format === 'MMM') {
							ii = indexOf.call(this._shortMonthsParse, llc);
							return ii !== -1 ? ii : null;
						} else {
							ii = indexOf.call(this._longMonthsParse, llc);
							return ii !== -1 ? ii : null;
						}
					} else {
						if(format === 'MMM') {
							ii = indexOf.call(this._shortMonthsParse, llc);
							if(ii !== -1) {
								return ii;
							}
							ii = indexOf.call(this._longMonthsParse, llc);
							return ii !== -1 ? ii : null;
						} else {
							ii = indexOf.call(this._longMonthsParse, llc);
							if(ii !== -1) {
								return ii;
							}
							ii = indexOf.call(this._shortMonthsParse, llc);
							return ii !== -1 ? ii : null;
						}
					}
				}
				
				function localeMonthsParse(monthName, format, strict) {
					var i, mom, regex;
					
					if(this._monthsParseExact) {
						return handleStrictParse.call(this, monthName, format, strict);
					}
					
					if(!this._monthsParse) {
						this._monthsParse = [];
						this._longMonthsParse = [];
						this._shortMonthsParse = [];
					}
					
					// TODO: add sorting
					// Sorting makes sure if one month (or abbr) is a prefix of another
					// see sorting in computeMonthsParse
					for(i = 0; i < 12; i++) {
						// make the regex if we don't have it already
						mom = createUTC([2000, i]);
						if(strict && !this._longMonthsParse[i]) {
							this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
							this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
						}
						if(!strict && !this._monthsParse[i]) {
							regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
							this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
						}
						// test the regex
						if(strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
							return i;
						} else if(strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
							return i;
						} else if(!strict && this._monthsParse[i].test(monthName)) {
							return i;
						}
					}
				}
				
				// MOMENTS
				
				function setMonth(mom, value) {
					var dayOfMonth;
					
					if(!mom.isValid()) {
						// No op
						return mom;
					}
					
					if(typeof value === 'string') {
						if(/^\d+$/.test(value)) {
							value = toInt(value);
						} else {
							value = mom.localeData().monthsParse(value);
							// TODO: Another silent failure?
							if(!isNumber(value)) {
								return mom;
							}
						}
					}
					
					dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
					mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
					return mom;
				}
				
				function getSetMonth(value) {
					if(value != null) {
						setMonth(this, value);
						hooks.updateOffset(this, true);
						return this;
					} else {
						return get(this, 'Month');
					}
				}
				
				function getDaysInMonth() {
					return daysInMonth(this.year(), this.month());
				}
				
				var defaultMonthsShortRegex = matchWord;
				
				function monthsShortRegex(isStrict) {
					if(this._monthsParseExact) {
						if(!hasOwnProp(this, '_monthsRegex')) {
							computeMonthsParse.call(this);
						}
						if(isStrict) {
							return this._monthsShortStrictRegex;
						} else {
							return this._monthsShortRegex;
						}
					} else {
						if(!hasOwnProp(this, '_monthsShortRegex')) {
							this._monthsShortRegex = defaultMonthsShortRegex;
						}
						return this._monthsShortStrictRegex && isStrict ?
							this._monthsShortStrictRegex : this._monthsShortRegex;
					}
				}
				
				var defaultMonthsRegex = matchWord;
				
				function monthsRegex(isStrict) {
					if(this._monthsParseExact) {
						if(!hasOwnProp(this, '_monthsRegex')) {
							computeMonthsParse.call(this);
						}
						if(isStrict) {
							return this._monthsStrictRegex;
						} else {
							return this._monthsRegex;
						}
					} else {
						if(!hasOwnProp(this, '_monthsRegex')) {
							this._monthsRegex = defaultMonthsRegex;
						}
						return this._monthsStrictRegex && isStrict ?
							this._monthsStrictRegex : this._monthsRegex;
					}
				}
				
				function computeMonthsParse() {
					function cmpLenRev(a, b) {
						return b.length - a.length;
					}
					
					var shortPieces = [], longPieces = [], mixedPieces = [],
						i, mom;
					for(i = 0; i < 12; i++) {
						// make the regex if we don't have it already
						mom = createUTC([2000, i]);
						shortPieces.push(this.monthsShort(mom, ''));
						longPieces.push(this.months(mom, ''));
						mixedPieces.push(this.months(mom, ''));
						mixedPieces.push(this.monthsShort(mom, ''));
					}
					// Sorting makes sure if one month (or abbr) is a prefix of another it
					// will match the longer piece.
					shortPieces.sort(cmpLenRev);
					longPieces.sort(cmpLenRev);
					mixedPieces.sort(cmpLenRev);
					for(i = 0; i < 12; i++) {
						shortPieces[i] = regexEscape(shortPieces[i]);
						longPieces[i] = regexEscape(longPieces[i]);
					}
					for(i = 0; i < 24; i++) {
						mixedPieces[i] = regexEscape(mixedPieces[i]);
					}
					
					this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
					this._monthsShortRegex = this._monthsRegex;
					this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
					this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
				}
				
				function createDate(y, m, d, h, M, s, ms) {
					// can't just apply() to create a date:
					// https://stackoverflow.com/q/181348
					var date;
					// the date constructor remaps years 0-99 to 1900-1999
					if(y < 100 && y >= 0) {
						// preserve leap years using a full 400 year cycle, then reset
						date = new Date(y + 400, m, d, h, M, s, ms);
						if(isFinite(date.getFullYear())) {
							date.setFullYear(y);
						}
					} else {
						date = new Date(y, m, d, h, M, s, ms);
					}
					
					return date;
				}
				
				function createUTCDate(y) {
					var date;
					// the Date.UTC function remaps years 0-99 to 1900-1999
					if(y < 100 && y >= 0) {
						var args = Array.prototype.slice.call(arguments);
						// preserve leap years using a full 400 year cycle, then reset
						args[0] = y + 400;
						date = new Date(Date.UTC.apply(null, args));
						if(isFinite(date.getUTCFullYear())) {
							date.setUTCFullYear(y);
						}
					} else {
						date = new Date(Date.UTC.apply(null, arguments));
					}
					
					return date;
				}
				
				// start-of-first-week - start-of-year
				function firstWeekOffset(year, dow, doy) {
					var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
						fwd = 7 + dow - doy,
						// first-week day local weekday -- which local weekday is fwd
						fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
					
					return -fwdlw + fwd - 1;
				}
				
				// https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
				function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
					var localWeekday = (7 + weekday - dow) % 7,
						weekOffset = firstWeekOffset(year, dow, doy),
						dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
						resYear, resDayOfYear;
					
					if(dayOfYear <= 0) {
						resYear = year - 1;
						resDayOfYear = daysInYear(resYear) + dayOfYear;
					} else if(dayOfYear > daysInYear(year)) {
						resYear = year + 1;
						resDayOfYear = dayOfYear - daysInYear(year);
					} else {
						resYear = year;
						resDayOfYear = dayOfYear;
					}
					
					return {
						year: resYear,
						dayOfYear: resDayOfYear
					};
				}
				
				function weekOfYear(mom, dow, doy) {
					var weekOffset = firstWeekOffset(mom.year(), dow, doy),
						week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
						resWeek, resYear;
					
					if(week < 1) {
						resYear = mom.year() - 1;
						resWeek = week + weeksInYear(resYear, dow, doy);
					} else if(week > weeksInYear(mom.year(), dow, doy)) {
						resWeek = week - weeksInYear(mom.year(), dow, doy);
						resYear = mom.year() + 1;
					} else {
						resYear = mom.year();
						resWeek = week;
					}
					
					return {
						week: resWeek,
						year: resYear
					};
				}
				
				function weeksInYear(year, dow, doy) {
					var weekOffset = firstWeekOffset(year, dow, doy),
						weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
					return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
				}
				
				// FORMATTING
				
				addFormatToken('w', ['ww', 2], 'wo', 'week');
				addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');
				
				// ALIASES
				
				addUnitAlias('week', 'w');
				addUnitAlias('isoWeek', 'W');
				
				// PRIORITIES
				
				addUnitPriority('week', 5);
				addUnitPriority('isoWeek', 5);
				
				// PARSING
				
				addRegexToken('w', match1to2);
				addRegexToken('ww', match1to2, match2);
				addRegexToken('W', match1to2);
				addRegexToken('WW', match1to2, match2);
				
				addWeekParseToken(['w', 'ww', 'W', 'WW'], function(input, week, config, token) {
					week[token.substr(0, 1)] = toInt(input);
				});
				
				// HELPERS
				
				// LOCALES
				
				function localeWeek(mom) {
					return weekOfYear(mom, this._week.dow, this._week.doy).week;
				}
				
				var defaultLocaleWeek = {
					dow: 0, // Sunday is the first day of the week.
					doy: 6  // The week that contains Jan 6th is the first week of the year.
				};
				
				function localeFirstDayOfWeek() {
					return this._week.dow;
				}
				
				function localeFirstDayOfYear() {
					return this._week.doy;
				}
				
				// MOMENTS
				
				function getSetWeek(input) {
					var week = this.localeData().week(this);
					return input == null ? week : this.add((input - week) * 7, 'd');
				}
				
				function getSetISOWeek(input) {
					var week = weekOfYear(this, 1, 4).week;
					return input == null ? week : this.add((input - week) * 7, 'd');
				}
				
				// FORMATTING
				
				addFormatToken('d', 0, 'do', 'day');
				
				addFormatToken('dd', 0, 0, function(format) {
					return this.localeData().weekdaysMin(this, format);
				});
				
				addFormatToken('ddd', 0, 0, function(format) {
					return this.localeData().weekdaysShort(this, format);
				});
				
				addFormatToken('dddd', 0, 0, function(format) {
					return this.localeData().weekdays(this, format);
				});
				
				addFormatToken('e', 0, 0, 'weekday');
				addFormatToken('E', 0, 0, 'isoWeekday');
				
				// ALIASES
				
				addUnitAlias('day', 'd');
				addUnitAlias('weekday', 'e');
				addUnitAlias('isoWeekday', 'E');
				
				// PRIORITY
				addUnitPriority('day', 11);
				addUnitPriority('weekday', 11);
				addUnitPriority('isoWeekday', 11);
				
				// PARSING
				
				addRegexToken('d', match1to2);
				addRegexToken('e', match1to2);
				addRegexToken('E', match1to2);
				addRegexToken('dd', function(isStrict, locale) {
					return locale.weekdaysMinRegex(isStrict);
				});
				addRegexToken('ddd', function(isStrict, locale) {
					return locale.weekdaysShortRegex(isStrict);
				});
				addRegexToken('dddd', function(isStrict, locale) {
					return locale.weekdaysRegex(isStrict);
				});
				
				addWeekParseToken(['dd', 'ddd', 'dddd'], function(input, week, config, token) {
					var weekday = config._locale.weekdaysParse(input, token, config._strict);
					// if we didn't get a weekday name, mark the date as invalid
					if(weekday != null) {
						week.d = weekday;
					} else {
						getParsingFlags(config).invalidWeekday = input;
					}
				});
				
				addWeekParseToken(['d', 'e', 'E'], function(input, week, config, token) {
					week[token] = toInt(input);
				});
				
				// HELPERS
				
				function parseWeekday(input, locale) {
					if(typeof input !== 'string') {
						return input;
					}
					
					if(!isNaN(input)) {
						return parseInt(input, 10);
					}
					
					input = locale.weekdaysParse(input);
					if(typeof input === 'number') {
						return input;
					}
					
					return null;
				}
				
				function parseIsoWeekday(input, locale) {
					if(typeof input === 'string') {
						return locale.weekdaysParse(input) % 7 || 7;
					}
					return isNaN(input) ? null : input;
				}
				
				// LOCALES
				function shiftWeekdays(ws, n) {
					return ws.slice(n, 7).concat(ws.slice(0, n));
				}
				
				var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
				
				function localeWeekdays(m, format) {
					var weekdays = isArray(this._weekdays) ? this._weekdays :
						this._weekdays[(m && m !== true && this._weekdays.isFormat.test(format)) ? 'format' : 'standalone'];
					return (m === true) ? shiftWeekdays(weekdays, this._week.dow)
						: (m) ? weekdays[m.day()] : weekdays;
				}
				
				var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
				
				function localeWeekdaysShort(m) {
					return (m === true) ? shiftWeekdays(this._weekdaysShort, this._week.dow)
						: (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
				}
				
				var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
				
				function localeWeekdaysMin(m) {
					return (m === true) ? shiftWeekdays(this._weekdaysMin, this._week.dow)
						: (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
				}
				
				function handleStrictParse$1(weekdayName, format, strict) {
					var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
					if(!this._weekdaysParse) {
						this._weekdaysParse = [];
						this._shortWeekdaysParse = [];
						this._minWeekdaysParse = [];
						
						for(i = 0; i < 7; ++i) {
							mom = createUTC([2000, 1]).day(i);
							this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
							this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
							this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
						}
					}
					
					if(strict) {
						if(format === 'dddd') {
							ii = indexOf.call(this._weekdaysParse, llc);
							return ii !== -1 ? ii : null;
						} else if(format === 'ddd') {
							ii = indexOf.call(this._shortWeekdaysParse, llc);
							return ii !== -1 ? ii : null;
						} else {
							ii = indexOf.call(this._minWeekdaysParse, llc);
							return ii !== -1 ? ii : null;
						}
					} else {
						if(format === 'dddd') {
							ii = indexOf.call(this._weekdaysParse, llc);
							if(ii !== -1) {
								return ii;
							}
							ii = indexOf.call(this._shortWeekdaysParse, llc);
							if(ii !== -1) {
								return ii;
							}
							ii = indexOf.call(this._minWeekdaysParse, llc);
							return ii !== -1 ? ii : null;
						} else if(format === 'ddd') {
							ii = indexOf.call(this._shortWeekdaysParse, llc);
							if(ii !== -1) {
								return ii;
							}
							ii = indexOf.call(this._weekdaysParse, llc);
							if(ii !== -1) {
								return ii;
							}
							ii = indexOf.call(this._minWeekdaysParse, llc);
							return ii !== -1 ? ii : null;
						} else {
							ii = indexOf.call(this._minWeekdaysParse, llc);
							if(ii !== -1) {
								return ii;
							}
							ii = indexOf.call(this._weekdaysParse, llc);
							if(ii !== -1) {
								return ii;
							}
							ii = indexOf.call(this._shortWeekdaysParse, llc);
							return ii !== -1 ? ii : null;
						}
					}
				}
				
				function localeWeekdaysParse(weekdayName, format, strict) {
					var i, mom, regex;
					
					if(this._weekdaysParseExact) {
						return handleStrictParse$1.call(this, weekdayName, format, strict);
					}
					
					if(!this._weekdaysParse) {
						this._weekdaysParse = [];
						this._minWeekdaysParse = [];
						this._shortWeekdaysParse = [];
						this._fullWeekdaysParse = [];
					}
					
					for(i = 0; i < 7; i++) {
						// make the regex if we don't have it already
						
						mom = createUTC([2000, 1]).day(i);
						if(strict && !this._fullWeekdaysParse[i]) {
							this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
							this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
							this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
						}
						if(!this._weekdaysParse[i]) {
							regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
							this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
						}
						// test the regex
						if(strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
							return i;
						} else if(strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
							return i;
						} else if(strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
							return i;
						} else if(!strict && this._weekdaysParse[i].test(weekdayName)) {
							return i;
						}
					}
				}
				
				// MOMENTS
				
				function getSetDayOfWeek(input) {
					if(!this.isValid()) {
						return input != null ? this : NaN;
					}
					var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
					if(input != null) {
						input = parseWeekday(input, this.localeData());
						return this.add(input - day, 'd');
					} else {
						return day;
					}
				}
				
				function getSetLocaleDayOfWeek(input) {
					if(!this.isValid()) {
						return input != null ? this : NaN;
					}
					var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
					return input == null ? weekday : this.add(input - weekday, 'd');
				}
				
				function getSetISODayOfWeek(input) {
					if(!this.isValid()) {
						return input != null ? this : NaN;
					}
					
					// behaves the same as moment#day except
					// as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
					// as a setter, sunday should belong to the previous week.
					
					if(input != null) {
						var weekday = parseIsoWeekday(input, this.localeData());
						return this.day(this.day() % 7 ? weekday : weekday - 7);
					} else {
						return this.day() || 7;
					}
				}
				
				var defaultWeekdaysRegex = matchWord;
				
				function weekdaysRegex(isStrict) {
					if(this._weekdaysParseExact) {
						if(!hasOwnProp(this, '_weekdaysRegex')) {
							computeWeekdaysParse.call(this);
						}
						if(isStrict) {
							return this._weekdaysStrictRegex;
						} else {
							return this._weekdaysRegex;
						}
					} else {
						if(!hasOwnProp(this, '_weekdaysRegex')) {
							this._weekdaysRegex = defaultWeekdaysRegex;
						}
						return this._weekdaysStrictRegex && isStrict ?
							this._weekdaysStrictRegex : this._weekdaysRegex;
					}
				}
				
				var defaultWeekdaysShortRegex = matchWord;
				
				function weekdaysShortRegex(isStrict) {
					if(this._weekdaysParseExact) {
						if(!hasOwnProp(this, '_weekdaysRegex')) {
							computeWeekdaysParse.call(this);
						}
						if(isStrict) {
							return this._weekdaysShortStrictRegex;
						} else {
							return this._weekdaysShortRegex;
						}
					} else {
						if(!hasOwnProp(this, '_weekdaysShortRegex')) {
							this._weekdaysShortRegex = defaultWeekdaysShortRegex;
						}
						return this._weekdaysShortStrictRegex && isStrict ?
							this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
					}
				}
				
				var defaultWeekdaysMinRegex = matchWord;
				
				function weekdaysMinRegex(isStrict) {
					if(this._weekdaysParseExact) {
						if(!hasOwnProp(this, '_weekdaysRegex')) {
							computeWeekdaysParse.call(this);
						}
						if(isStrict) {
							return this._weekdaysMinStrictRegex;
						} else {
							return this._weekdaysMinRegex;
						}
					} else {
						if(!hasOwnProp(this, '_weekdaysMinRegex')) {
							this._weekdaysMinRegex = defaultWeekdaysMinRegex;
						}
						return this._weekdaysMinStrictRegex && isStrict ?
							this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
					}
				}
				
				
				function computeWeekdaysParse() {
					function cmpLenRev(a, b) {
						return b.length - a.length;
					}
					
					var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
						i, mom, minp, shortp, longp;
					for(i = 0; i < 7; i++) {
						// make the regex if we don't have it already
						mom = createUTC([2000, 1]).day(i);
						minp = this.weekdaysMin(mom, '');
						shortp = this.weekdaysShort(mom, '');
						longp = this.weekdays(mom, '');
						minPieces.push(minp);
						shortPieces.push(shortp);
						longPieces.push(longp);
						mixedPieces.push(minp);
						mixedPieces.push(shortp);
						mixedPieces.push(longp);
					}
					// Sorting makes sure if one weekday (or abbr) is a prefix of another it
					// will match the longer piece.
					minPieces.sort(cmpLenRev);
					shortPieces.sort(cmpLenRev);
					longPieces.sort(cmpLenRev);
					mixedPieces.sort(cmpLenRev);
					for(i = 0; i < 7; i++) {
						shortPieces[i] = regexEscape(shortPieces[i]);
						longPieces[i] = regexEscape(longPieces[i]);
						mixedPieces[i] = regexEscape(mixedPieces[i]);
					}
					
					this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
					this._weekdaysShortRegex = this._weekdaysRegex;
					this._weekdaysMinRegex = this._weekdaysRegex;
					
					this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
					this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
					this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
				}
				
				// FORMATTING
				
				function hFormat() {
					return this.hours() % 12 || 12;
				}
				
				function kFormat() {
					return this.hours() || 24;
				}
				
				addFormatToken('H', ['HH', 2], 0, 'hour');
				addFormatToken('h', ['hh', 2], 0, hFormat);
				addFormatToken('k', ['kk', 2], 0, kFormat);
				
				addFormatToken('hmm', 0, 0, function() {
					return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
				});
				
				addFormatToken('hmmss', 0, 0, function() {
					return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
						zeroFill(this.seconds(), 2);
				});
				
				addFormatToken('Hmm', 0, 0, function() {
					return '' + this.hours() + zeroFill(this.minutes(), 2);
				});
				
				addFormatToken('Hmmss', 0, 0, function() {
					return '' + this.hours() + zeroFill(this.minutes(), 2) +
						zeroFill(this.seconds(), 2);
				});
				
				function meridiem(token, lowercase) {
					addFormatToken(token, 0, 0, function() {
						return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
					});
				}
				
				meridiem('a', true);
				meridiem('A', false);
				
				// ALIASES
				
				addUnitAlias('hour', 'h');
				
				// PRIORITY
				addUnitPriority('hour', 13);
				
				// PARSING
				
				function matchMeridiem(isStrict, locale) {
					return locale._meridiemParse;
				}
				
				addRegexToken('a', matchMeridiem);
				addRegexToken('A', matchMeridiem);
				addRegexToken('H', match1to2);
				addRegexToken('h', match1to2);
				addRegexToken('k', match1to2);
				addRegexToken('HH', match1to2, match2);
				addRegexToken('hh', match1to2, match2);
				addRegexToken('kk', match1to2, match2);
				
				addRegexToken('hmm', match3to4);
				addRegexToken('hmmss', match5to6);
				addRegexToken('Hmm', match3to4);
				addRegexToken('Hmmss', match5to6);
				
				addParseToken(['H', 'HH'], HOUR);
				addParseToken(['k', 'kk'], function(input, array, config) {
					var kInput = toInt(input);
					array[HOUR] = kInput === 24 ? 0 : kInput;
				});
				addParseToken(['a', 'A'], function(input, array, config) {
					config._isPm = config._locale.isPM(input);
					config._meridiem = input;
				});
				addParseToken(['h', 'hh'], function(input, array, config) {
					array[HOUR] = toInt(input);
					getParsingFlags(config).bigHour = true;
				});
				addParseToken('hmm', function(input, array, config) {
					var pos = input.length - 2;
					array[HOUR] = toInt(input.substr(0, pos));
					array[MINUTE] = toInt(input.substr(pos));
					getParsingFlags(config).bigHour = true;
				});
				addParseToken('hmmss', function(input, array, config) {
					var pos1 = input.length - 4;
					var pos2 = input.length - 2;
					array[HOUR] = toInt(input.substr(0, pos1));
					array[MINUTE] = toInt(input.substr(pos1, 2));
					array[SECOND] = toInt(input.substr(pos2));
					getParsingFlags(config).bigHour = true;
				});
				addParseToken('Hmm', function(input, array, config) {
					var pos = input.length - 2;
					array[HOUR] = toInt(input.substr(0, pos));
					array[MINUTE] = toInt(input.substr(pos));
				});
				addParseToken('Hmmss', function(input, array, config) {
					var pos1 = input.length - 4;
					var pos2 = input.length - 2;
					array[HOUR] = toInt(input.substr(0, pos1));
					array[MINUTE] = toInt(input.substr(pos1, 2));
					array[SECOND] = toInt(input.substr(pos2));
				});
				
				// LOCALES
				
				function localeIsPM(input) {
					// IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
					// Using charAt should be more compatible.
					return ((input + '').toLowerCase().charAt(0) === 'p');
				}
				
				var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
				
				function localeMeridiem(hours, minutes, isLower) {
					if(hours > 11) {
						return isLower ? 'pm' : 'PM';
					} else {
						return isLower ? 'am' : 'AM';
					}
				}
				
				
				// MOMENTS
				
				// Setting the hour should keep the time, because the user explicitly
				// specified which hour they want. So trying to maintain the same hour (in
				// a new timezone) makes sense. Adding/subtracting hours does not follow
				// this rule.
				var getSetHour = makeGetSet('Hours', true);
				
				var baseConfig = {
					calendar: defaultCalendar,
					longDateFormat: defaultLongDateFormat,
					invalidDate: defaultInvalidDate,
					ordinal: defaultOrdinal,
					dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
					relativeTime: defaultRelativeTime,
					
					months: defaultLocaleMonths,
					monthsShort: defaultLocaleMonthsShort,
					
					week: defaultLocaleWeek,
					
					weekdays: defaultLocaleWeekdays,
					weekdaysMin: defaultLocaleWeekdaysMin,
					weekdaysShort: defaultLocaleWeekdaysShort,
					
					meridiemParse: defaultLocaleMeridiemParse
				};
				
				// internal storage for locale config files
				var locales = {};
				var localeFamilies = {};
				var globalLocale;
				
				function normalizeLocale(key) {
					return key ? key.toLowerCase().replace('_', '-') : key;
				}
				
				// pick the locale from the array
				// try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
				// substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
				function chooseLocale(names) {
					var i = 0, j, next, locale, split;
					
					while(i < names.length) {
						split = normalizeLocale(names[i]).split('-');
						j = split.length;
						next = normalizeLocale(names[i + 1]);
						next = next ? next.split('-') : null;
						while(j > 0) {
							locale = loadLocale(split.slice(0, j).join('-'));
							if(locale) {
								return locale;
							}
							if(next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
								//the next array item is better than a shallower substring of this one
								break;
							}
							j--;
						}
						i++;
					}
					return globalLocale;
				}
				
				function loadLocale(name) {
					var oldLocale = null;
					// TODO: Find a better way to register and load all the locales in Node
					if(!locales[name] && (typeof module !== 'undefined') &&
						module && module.exports) {
						try {
							oldLocale = globalLocale._abbr;
							var aliasedRequire = require;
							__webpack_require__("./node_modules/moment/locale sync recursive ^\\.\\/.*$")("./" + name);
							getSetGlobalLocale(oldLocale);
						} catch(e) {
						}
					}
					return locales[name];
				}
				
				// This function will load locale and then set the global locale.  If
				// no arguments are passed in, it will simply return the current global
				// locale key.
				function getSetGlobalLocale(key, values) {
					var data;
					if(key) {
						if(isUndefined(values)) {
							data = getLocale(key);
						} else {
							data = defineLocale(key, values);
						}
						
						if(data) {
							// moment.duration._locale = moment._locale = data;
							globalLocale = data;
						} else {
							if((typeof console !== 'undefined') && console.warn) {
								//warn user if arguments are passed but the locale could not be set
								console.warn('Locale ' + key + ' not found. Did you forget to load it?');
							}
						}
					}
					
					return globalLocale._abbr;
				}
				
				function defineLocale(name, config) {
					if(config !== null) {
						var locale, parentConfig = baseConfig;
						config.abbr = name;
						if(locales[name] != null) {
							deprecateSimple('defineLocaleOverride',
								'use moment.updateLocale(localeName, config) to change ' +
								'an existing locale. moment.defineLocale(localeName, ' +
								'config) should only be used for creating a new locale ' +
								'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
							parentConfig = locales[name]._config;
						} else if(config.parentLocale != null) {
							if(locales[config.parentLocale] != null) {
								parentConfig = locales[config.parentLocale]._config;
							} else {
								locale = loadLocale(config.parentLocale);
								if(locale != null) {
									parentConfig = locale._config;
								} else {
									if(!localeFamilies[config.parentLocale]) {
										localeFamilies[config.parentLocale] = [];
									}
									localeFamilies[config.parentLocale].push({
										name: name,
										config: config
									});
									return null;
								}
							}
						}
						locales[name] = new Locale(mergeConfigs(parentConfig, config));
						
						if(localeFamilies[name]) {
							localeFamilies[name].forEach(function(x) {
								defineLocale(x.name, x.config);
							});
						}
						
						// backwards compat for now: also set the locale
						// make sure we set the locale AFTER all child locales have been
						// created, so we won't end up with the child locale set.
						getSetGlobalLocale(name);
						
						
						return locales[name];
					} else {
						// useful for testing
						delete locales[name];
						return null;
					}
				}
				
				function updateLocale(name, config) {
					if(config != null) {
						var locale, tmpLocale, parentConfig = baseConfig;
						// MERGE
						tmpLocale = loadLocale(name);
						if(tmpLocale != null) {
							parentConfig = tmpLocale._config;
						}
						config = mergeConfigs(parentConfig, config);
						locale = new Locale(config);
						locale.parentLocale = locales[name];
						locales[name] = locale;
						
						// backwards compat for now: also set the locale
						getSetGlobalLocale(name);
					} else {
						// pass null for config to unupdate, useful for tests
						if(locales[name] != null) {
							if(locales[name].parentLocale != null) {
								locales[name] = locales[name].parentLocale;
							} else if(locales[name] != null) {
								delete locales[name];
							}
						}
					}
					return locales[name];
				}
				
				// returns locale data
				function getLocale(key) {
					var locale;
					
					if(key && key._locale && key._locale._abbr) {
						key = key._locale._abbr;
					}
					
					if(!key) {
						return globalLocale;
					}
					
					if(!isArray(key)) {
						//short-circuit everything else
						locale = loadLocale(key);
						if(locale) {
							return locale;
						}
						key = [key];
					}
					
					return chooseLocale(key);
				}
				
				function listLocales() {
					return keys(locales);
				}
				
				function checkOverflow(m) {
					var overflow;
					var a = m._a;
					
					if(a && getParsingFlags(m).overflow === -2) {
						overflow =
							a[MONTH] < 0 || a[MONTH] > 11 ? MONTH :
								a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
									a[HOUR] < 0 || a[HOUR] > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
										a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE :
											a[SECOND] < 0 || a[SECOND] > 59 ? SECOND :
												a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
													-1;
						
						if(getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
							overflow = DATE;
						}
						if(getParsingFlags(m)._overflowWeeks && overflow === -1) {
							overflow = WEEK;
						}
						if(getParsingFlags(m)._overflowWeekday && overflow === -1) {
							overflow = WEEKDAY;
						}
						
						getParsingFlags(m).overflow = overflow;
					}
					
					return m;
				}
				
				// Pick the first defined of two or three arguments.
				function defaults(a, b, c) {
					if(a != null) {
						return a;
					}
					if(b != null) {
						return b;
					}
					return c;
				}
				
				function currentDateArray(config) {
					// hooks is actually the exported moment object
					var nowValue = new Date(hooks.now());
					if(config._useUTC) {
						return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
					}
					return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
				}
				
				// convert an array to a date.
				// the array should mirror the parameters below
				// note: all values past the year are optional and will default to the lowest possible value.
				// [year, month, day , hour, minute, second, millisecond]
				function configFromArray(config) {
					var i, date, input = [], currentDate, expectedWeekday, yearToUse;
					
					if(config._d) {
						return;
					}
					
					currentDate = currentDateArray(config);
					
					//compute day of the year from weeks and weekdays
					if(config._w && config._a[DATE] == null && config._a[MONTH] == null) {
						dayOfYearFromWeekInfo(config);
					}
					
					//if the day of the year is set, figure out what it is
					if(config._dayOfYear != null) {
						yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
						
						if(config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
							getParsingFlags(config)._overflowDayOfYear = true;
						}
						
						date = createUTCDate(yearToUse, 0, config._dayOfYear);
						config._a[MONTH] = date.getUTCMonth();
						config._a[DATE] = date.getUTCDate();
					}
					
					// Default to current date.
					// * if no year, month, day of month are given, default to today
					// * if day of month is given, default month and year
					// * if month is given, default only year
					// * if year is given, don't default anything
					for(i = 0; i < 3 && config._a[i] == null; ++i) {
						config._a[i] = input[i] = currentDate[i];
					}
					
					// Zero out whatever was not defaulted, including time
					for(; i < 7; i++) {
						config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
					}
					
					// Check for 24:00:00.000
					if(config._a[HOUR] === 24 &&
						config._a[MINUTE] === 0 &&
						config._a[SECOND] === 0 &&
						config._a[MILLISECOND] === 0) {
						config._nextDay = true;
						config._a[HOUR] = 0;
					}
					
					config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
					expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
					
					// Apply timezone offset from input. The actual utcOffset can be changed
					// with parseZone.
					if(config._tzm != null) {
						config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
					}
					
					if(config._nextDay) {
						config._a[HOUR] = 24;
					}
					
					// check for mismatching day of week
					if(config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
						getParsingFlags(config).weekdayMismatch = true;
					}
				}
				
				function dayOfYearFromWeekInfo(config) {
					var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;
					
					w = config._w;
					if(w.GG != null || w.W != null || w.E != null) {
						dow = 1;
						doy = 4;
						
						// TODO: We need to take the current isoWeekYear, but that depends on
						// how we interpret now (local, utc, fixed offset). So create
						// a now version of current config (take local/utc/offset flags, and
						// create now).
						weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
						week = defaults(w.W, 1);
						weekday = defaults(w.E, 1);
						if(weekday < 1 || weekday > 7) {
							weekdayOverflow = true;
						}
					} else {
						dow = config._locale._week.dow;
						doy = config._locale._week.doy;
						
						var curWeek = weekOfYear(createLocal(), dow, doy);
						
						weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);
						
						// Default to current week.
						week = defaults(w.w, curWeek.week);
						
						if(w.d != null) {
							// weekday -- low day numbers are considered next week
							weekday = w.d;
							if(weekday < 0 || weekday > 6) {
								weekdayOverflow = true;
							}
						} else if(w.e != null) {
							// local weekday -- counting starts from beginning of week
							weekday = w.e + dow;
							if(w.e < 0 || w.e > 6) {
								weekdayOverflow = true;
							}
						} else {
							// default to beginning of week
							weekday = dow;
						}
					}
					if(week < 1 || week > weeksInYear(weekYear, dow, doy)) {
						getParsingFlags(config)._overflowWeeks = true;
					} else if(weekdayOverflow != null) {
						getParsingFlags(config)._overflowWeekday = true;
					} else {
						temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
						config._a[YEAR] = temp.year;
						config._dayOfYear = temp.dayOfYear;
					}
				}
				
				// iso 8601 regex
				// 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
				var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
				var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
				
				var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;
				
				var isoDates = [
					['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
					['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
					['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
					['GGGG-[W]WW', /\d{4}-W\d\d/, false],
					['YYYY-DDD', /\d{4}-\d{3}/],
					['YYYY-MM', /\d{4}-\d\d/, false],
					['YYYYYYMMDD', /[+-]\d{10}/],
					['YYYYMMDD', /\d{8}/],
					// YYYYMM is NOT allowed by the standard
					['GGGG[W]WWE', /\d{4}W\d{3}/],
					['GGGG[W]WW', /\d{4}W\d{2}/, false],
					['YYYYDDD', /\d{7}/]
				];
				
				// iso time formats and regexes
				var isoTimes = [
					['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
					['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
					['HH:mm:ss', /\d\d:\d\d:\d\d/],
					['HH:mm', /\d\d:\d\d/],
					['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
					['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
					['HHmmss', /\d\d\d\d\d\d/],
					['HHmm', /\d\d\d\d/],
					['HH', /\d\d/]
				];
				
				var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;
				
				// date from iso format
				function configFromISO(config) {
					var i, l,
						string = config._i,
						match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
						allowTime, dateFormat, timeFormat, tzFormat;
					
					if(match) {
						getParsingFlags(config).iso = true;
						
						for(i = 0, l = isoDates.length; i < l; i++) {
							if(isoDates[i][1].exec(match[1])) {
								dateFormat = isoDates[i][0];
								allowTime = isoDates[i][2] !== false;
								break;
							}
						}
						if(dateFormat == null) {
							config._isValid = false;
							return;
						}
						if(match[3]) {
							for(i = 0, l = isoTimes.length; i < l; i++) {
								if(isoTimes[i][1].exec(match[3])) {
									// match[2] should be 'T' or space
									timeFormat = (match[2] || ' ') + isoTimes[i][0];
									break;
								}
							}
							if(timeFormat == null) {
								config._isValid = false;
								return;
							}
						}
						if(!allowTime && timeFormat != null) {
							config._isValid = false;
							return;
						}
						if(match[4]) {
							if(tzRegex.exec(match[4])) {
								tzFormat = 'Z';
							} else {
								config._isValid = false;
								return;
							}
						}
						config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
						configFromStringAndFormat(config);
					} else {
						config._isValid = false;
					}
				}
				
				// RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
				var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;
				
				function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
					var result = [
						untruncateYear(yearStr),
						defaultLocaleMonthsShort.indexOf(monthStr),
						parseInt(dayStr, 10),
						parseInt(hourStr, 10),
						parseInt(minuteStr, 10)
					];
					
					if(secondStr) {
						result.push(parseInt(secondStr, 10));
					}
					
					return result;
				}
				
				function untruncateYear(yearStr) {
					var year = parseInt(yearStr, 10);
					if(year <= 49) {
						return 2000 + year;
					} else if(year <= 999) {
						return 1900 + year;
					}
					return year;
				}
				
				function preprocessRFC2822(s) {
					// Remove comments and folding whitespace and replace multiple-spaces with a single space
					return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
				}
				
				function checkWeekday(weekdayStr, parsedInput, config) {
					if(weekdayStr) {
						// TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
						var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
							weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
						if(weekdayProvided !== weekdayActual) {
							getParsingFlags(config).weekdayMismatch = true;
							config._isValid = false;
							return false;
						}
					}
					return true;
				}
				
				var obsOffsets = {
					UT: 0,
					GMT: 0,
					EDT: -4 * 60,
					EST: -5 * 60,
					CDT: -5 * 60,
					CST: -6 * 60,
					MDT: -6 * 60,
					MST: -7 * 60,
					PDT: -7 * 60,
					PST: -8 * 60
				};
				
				function calculateOffset(obsOffset, militaryOffset, numOffset) {
					if(obsOffset) {
						return obsOffsets[obsOffset];
					} else if(militaryOffset) {
						// the only allowed military tz is Z
						return 0;
					} else {
						var hm = parseInt(numOffset, 10);
						var m = hm % 100, h = (hm - m) / 100;
						return h * 60 + m;
					}
				}
				
				// date and time from ref 2822 format
				function configFromRFC2822(config) {
					var match = rfc2822.exec(preprocessRFC2822(config._i));
					if(match) {
						var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
						if(!checkWeekday(match[1], parsedArray, config)) {
							return;
						}
						
						config._a = parsedArray;
						config._tzm = calculateOffset(match[8], match[9], match[10]);
						
						config._d = createUTCDate.apply(null, config._a);
						config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
						
						getParsingFlags(config).rfc2822 = true;
					} else {
						config._isValid = false;
					}
				}
				
				// date from iso format or fallback
				function configFromString(config) {
					var matched = aspNetJsonRegex.exec(config._i);
					
					if(matched !== null) {
						config._d = new Date(+matched[1]);
						return;
					}
					
					configFromISO(config);
					if(config._isValid === false) {
						delete config._isValid;
					} else {
						return;
					}
					
					configFromRFC2822(config);
					if(config._isValid === false) {
						delete config._isValid;
					} else {
						return;
					}
					
					// Final attempt, use Input Fallback
					hooks.createFromInputFallback(config);
				}
				
				hooks.createFromInputFallback = deprecate(
					'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
					'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
					'discouraged and will be removed in an upcoming major release. Please refer to ' +
					'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
					function(config) {
						config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
					}
				);
				
				// constant that refers to the ISO standard
				hooks.ISO_8601 = function() {
				};
				
				// constant that refers to the RFC 2822 form
				hooks.RFC_2822 = function() {
				};
				
				// date from string and format string
				function configFromStringAndFormat(config) {
					// TODO: Move this to another part of the creation flow to prevent circular deps
					if(config._f === hooks.ISO_8601) {
						configFromISO(config);
						return;
					}
					if(config._f === hooks.RFC_2822) {
						configFromRFC2822(config);
						return;
					}
					config._a = [];
					getParsingFlags(config).empty = true;
					
					// This array is used to make a Date, either with `new Date` or `Date.UTC`
					var string = '' + config._i,
						i, parsedInput, tokens, token, skipped,
						stringLength = string.length,
						totalParsedInputLength = 0;
					
					tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
					
					for(i = 0; i < tokens.length; i++) {
						token = tokens[i];
						parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
						// console.log('token', token, 'parsedInput', parsedInput,
						//         'regex', getParseRegexForToken(token, config));
						if(parsedInput) {
							skipped = string.substr(0, string.indexOf(parsedInput));
							if(skipped.length > 0) {
								getParsingFlags(config).unusedInput.push(skipped);
							}
							string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
							totalParsedInputLength += parsedInput.length;
						}
						// don't parse if it's not a known token
						if(formatTokenFunctions[token]) {
							if(parsedInput) {
								getParsingFlags(config).empty = false;
							} else {
								getParsingFlags(config).unusedTokens.push(token);
							}
							addTimeToArrayFromToken(token, parsedInput, config);
						} else if(config._strict && !parsedInput) {
							getParsingFlags(config).unusedTokens.push(token);
						}
					}
					
					// add remaining unparsed input length to the string
					getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
					if(string.length > 0) {
						getParsingFlags(config).unusedInput.push(string);
					}
					
					// clear _12h flag if hour is <= 12
					if(config._a[HOUR] <= 12 &&
						getParsingFlags(config).bigHour === true &&
						config._a[HOUR] > 0) {
						getParsingFlags(config).bigHour = undefined;
					}
					
					getParsingFlags(config).parsedDateParts = config._a.slice(0);
					getParsingFlags(config).meridiem = config._meridiem;
					// handle meridiem
					config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
					
					configFromArray(config);
					checkOverflow(config);
				}
				
				
				function meridiemFixWrap(locale, hour, meridiem) {
					var isPm;
					
					if(meridiem == null) {
						// nothing to do
						return hour;
					}
					if(locale.meridiemHour != null) {
						return locale.meridiemHour(hour, meridiem);
					} else if(locale.isPM != null) {
						// Fallback
						isPm = locale.isPM(meridiem);
						if(isPm && hour < 12) {
							hour += 12;
						}
						if(!isPm && hour === 12) {
							hour = 0;
						}
						return hour;
					} else {
						// this is not supposed to happen
						return hour;
					}
				}
				
				// date from string and array of format strings
				function configFromStringAndArray(config) {
					var tempConfig,
						bestMoment,
						
						scoreToBeat,
						i,
						currentScore;
					
					if(config._f.length === 0) {
						getParsingFlags(config).invalidFormat = true;
						config._d = new Date(NaN);
						return;
					}
					
					for(i = 0; i < config._f.length; i++) {
						currentScore = 0;
						tempConfig = copyConfig({}, config);
						if(config._useUTC != null) {
							tempConfig._useUTC = config._useUTC;
						}
						tempConfig._f = config._f[i];
						configFromStringAndFormat(tempConfig);
						
						if(!isValid(tempConfig)) {
							continue;
						}
						
						// if there is any input that was not parsed add a penalty for that format
						currentScore += getParsingFlags(tempConfig).charsLeftOver;
						
						//or tokens
						currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
						
						getParsingFlags(tempConfig).score = currentScore;
						
						if(scoreToBeat == null || currentScore < scoreToBeat) {
							scoreToBeat = currentScore;
							bestMoment = tempConfig;
						}
					}
					
					extend(config, bestMoment || tempConfig);
				}
				
				function configFromObject(config) {
					if(config._d) {
						return;
					}
					
					var i = normalizeObjectUnits(config._i);
					config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function(obj) {
						return obj && parseInt(obj, 10);
					});
					
					configFromArray(config);
				}
				
				function createFromConfig(config) {
					var res = new Moment(checkOverflow(prepareConfig(config)));
					if(res._nextDay) {
						// Adding is smart enough around DST
						res.add(1, 'd');
						res._nextDay = undefined;
					}
					
					return res;
				}
				
				function prepareConfig(config) {
					var input = config._i,
						format = config._f;
					
					config._locale = config._locale || getLocale(config._l);
					
					if(input === null || (format === undefined && input === '')) {
						return createInvalid({nullInput: true});
					}
					
					if(typeof input === 'string') {
						config._i = input = config._locale.preparse(input);
					}
					
					if(isMoment(input)) {
						return new Moment(checkOverflow(input));
					} else if(isDate(input)) {
						config._d = input;
					} else if(isArray(format)) {
						configFromStringAndArray(config);
					} else if(format) {
						configFromStringAndFormat(config);
					} else {
						configFromInput(config);
					}
					
					if(!isValid(config)) {
						config._d = null;
					}
					
					return config;
				}
				
				function configFromInput(config) {
					var input = config._i;
					if(isUndefined(input)) {
						config._d = new Date(hooks.now());
					} else if(isDate(input)) {
						config._d = new Date(input.valueOf());
					} else if(typeof input === 'string') {
						configFromString(config);
					} else if(isArray(input)) {
						config._a = map(input.slice(0), function(obj) {
							return parseInt(obj, 10);
						});
						configFromArray(config);
					} else if(isObject(input)) {
						configFromObject(config);
					} else if(isNumber(input)) {
						// from milliseconds
						config._d = new Date(input);
					} else {
						hooks.createFromInputFallback(config);
					}
				}
				
				function createLocalOrUTC(input, format, locale, strict, isUTC) {
					var c = {};
					
					if(locale === true || locale === false) {
						strict = locale;
						locale = undefined;
					}
					
					if((isObject(input) && isObjectEmpty(input)) ||
						(isArray(input) && input.length === 0)) {
						input = undefined;
					}
					// object construction must be done this way.
					// https://github.com/moment/moment/issues/1423
					c._isAMomentObject = true;
					c._useUTC = c._isUTC = isUTC;
					c._l = locale;
					c._i = input;
					c._f = format;
					c._strict = strict;
					
					return createFromConfig(c);
				}
				
				function createLocal(input, format, locale, strict) {
					return createLocalOrUTC(input, format, locale, strict, false);
				}
				
				var prototypeMin = deprecate(
					'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
					function() {
						var other = createLocal.apply(null, arguments);
						if(this.isValid() && other.isValid()) {
							return other < this ? this : other;
						} else {
							return createInvalid();
						}
					}
				);
				
				var prototypeMax = deprecate(
					'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
					function() {
						var other = createLocal.apply(null, arguments);
						if(this.isValid() && other.isValid()) {
							return other > this ? this : other;
						} else {
							return createInvalid();
						}
					}
				);
				
				// Pick a moment m from moments so that m[fn](other) is true for all
				// other. This relies on the function fn to be transitive.
				//
				// moments should either be an array of moment objects or an array, whose
				// first element is an array of moment objects.
				function pickBy(fn, moments) {
					var res, i;
					if(moments.length === 1 && isArray(moments[0])) {
						moments = moments[0];
					}
					if(!moments.length) {
						return createLocal();
					}
					res = moments[0];
					for(i = 1; i < moments.length; ++i) {
						if(!moments[i].isValid() || moments[i][fn](res)) {
							res = moments[i];
						}
					}
					return res;
				}
				
				// TODO: Use [].sort instead?
				function min() {
					var args = [].slice.call(arguments, 0);
					
					return pickBy('isBefore', args);
				}
				
				function max() {
					var args = [].slice.call(arguments, 0);
					
					return pickBy('isAfter', args);
				}
				
				var now = function() {
					return Date.now ? Date.now() : +(new Date());
				};
				
				var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];
				
				function isDurationValid(m) {
					for(var key in m) {
						if(!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
							return false;
						}
					}
					
					var unitHasDecimal = false;
					for(var i = 0; i < ordering.length; ++i) {
						if(m[ordering[i]]) {
							if(unitHasDecimal) {
								return false; // only allow non-integers for smallest unit
							}
							if(parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
								unitHasDecimal = true;
							}
						}
					}
					
					return true;
				}
				
				function isValid$1() {
					return this._isValid;
				}
				
				function createInvalid$1() {
					return createDuration(NaN);
				}
				
				function Duration(duration) {
					var normalizedInput = normalizeObjectUnits(duration),
						years = normalizedInput.year || 0,
						quarters = normalizedInput.quarter || 0,
						months = normalizedInput.month || 0,
						weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
						days = normalizedInput.day || 0,
						hours = normalizedInput.hour || 0,
						minutes = normalizedInput.minute || 0,
						seconds = normalizedInput.second || 0,
						milliseconds = normalizedInput.millisecond || 0;
					
					this._isValid = isDurationValid(normalizedInput);
					
					// representation for dateAddRemove
					this._milliseconds = +milliseconds +
						seconds * 1e3 + // 1000
						minutes * 6e4 + // 1000 * 60
						hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
					// Because of dateAddRemove treats 24 hours as different from a
					// day when working around DST, we need to store them separately
					this._days = +days +
						weeks * 7;
					// It is impossible to translate months into days without knowing
					// which months you are are talking about, so we have to store
					// it separately.
					this._months = +months +
						quarters * 3 +
						years * 12;
					
					this._data = {};
					
					this._locale = getLocale();
					
					this._bubble();
				}
				
				function isDuration(obj) {
					return obj instanceof Duration;
				}
				
				function absRound(number) {
					if(number < 0) {
						return Math.round(-1 * number) * -1;
					} else {
						return Math.round(number);
					}
				}
				
				// FORMATTING
				
				function offset(token, separator) {
					addFormatToken(token, 0, 0, function() {
						var offset = this.utcOffset();
						var sign = '+';
						if(offset < 0) {
							offset = -offset;
							sign = '-';
						}
						return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
					});
				}
				
				offset('Z', ':');
				offset('ZZ', '');
				
				// PARSING
				
				addRegexToken('Z', matchShortOffset);
				addRegexToken('ZZ', matchShortOffset);
				addParseToken(['Z', 'ZZ'], function(input, array, config) {
					config._useUTC = true;
					config._tzm = offsetFromString(matchShortOffset, input);
				});
				
				// HELPERS
				
				// timezone chunker
				// '+10:00' > ['10',  '00']
				// '-1530'  > ['-15', '30']
				var chunkOffset = /([\+\-]|\d\d)/gi;
				
				function offsetFromString(matcher, string) {
					var matches = (string || '').match(matcher);
					
					if(matches === null) {
						return null;
					}
					
					var chunk = matches[matches.length - 1] || [];
					var parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
					var minutes = +(parts[1] * 60) + toInt(parts[2]);
					
					return minutes === 0 ?
						0 :
						parts[0] === '+' ? minutes : -minutes;
				}
				
				// Return a moment from input, that is local/utc/zone equivalent to model.
				function cloneWithOffset(input, model) {
					var res, diff;
					if(model._isUTC) {
						res = model.clone();
						diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
						// Use low-level api, because this fn is low-level api.
						res._d.setTime(res._d.valueOf() + diff);
						hooks.updateOffset(res, false);
						return res;
					} else {
						return createLocal(input).local();
					}
				}
				
				function getDateOffset(m) {
					// On Firefox.24 Date#getTimezoneOffset returns a floating point.
					// https://github.com/moment/moment/pull/1871
					return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
				}
				
				// HOOKS
				
				// This function will be called whenever a moment is mutated.
				// It is intended to keep the offset in sync with the timezone.
				hooks.updateOffset = function() {
				};
				
				// MOMENTS
				
				// keepLocalTime = true means only change the timezone, without
				// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
				// 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
				// +0200, so we adjust the time as needed, to be valid.
				//
				// Keeping the time actually adds/subtracts (one hour)
				// from the actual represented time. That is why we call updateOffset
				// a second time. In case it wants us to change the offset again
				// _changeInProgress == true case, then we have to adjust, because
				// there is no such time in the given timezone.
				function getSetOffset(input, keepLocalTime, keepMinutes) {
					var offset = this._offset || 0,
						localAdjust;
					if(!this.isValid()) {
						return input != null ? this : NaN;
					}
					if(input != null) {
						if(typeof input === 'string') {
							input = offsetFromString(matchShortOffset, input);
							if(input === null) {
								return this;
							}
						} else if(Math.abs(input) < 16 && !keepMinutes) {
							input = input * 60;
						}
						if(!this._isUTC && keepLocalTime) {
							localAdjust = getDateOffset(this);
						}
						this._offset = input;
						this._isUTC = true;
						if(localAdjust != null) {
							this.add(localAdjust, 'm');
						}
						if(offset !== input) {
							if(!keepLocalTime || this._changeInProgress) {
								addSubtract(this, createDuration(input - offset, 'm'), 1, false);
							} else if(!this._changeInProgress) {
								this._changeInProgress = true;
								hooks.updateOffset(this, true);
								this._changeInProgress = null;
							}
						}
						return this;
					} else {
						return this._isUTC ? offset : getDateOffset(this);
					}
				}
				
				function getSetZone(input, keepLocalTime) {
					if(input != null) {
						if(typeof input !== 'string') {
							input = -input;
						}
						
						this.utcOffset(input, keepLocalTime);
						
						return this;
					} else {
						return -this.utcOffset();
					}
				}
				
				function setOffsetToUTC(keepLocalTime) {
					return this.utcOffset(0, keepLocalTime);
				}
				
				function setOffsetToLocal(keepLocalTime) {
					if(this._isUTC) {
						this.utcOffset(0, keepLocalTime);
						this._isUTC = false;
						
						if(keepLocalTime) {
							this.subtract(getDateOffset(this), 'm');
						}
					}
					return this;
				}
				
				function setOffsetToParsedOffset() {
					if(this._tzm != null) {
						this.utcOffset(this._tzm, false, true);
					} else if(typeof this._i === 'string') {
						var tZone = offsetFromString(matchOffset, this._i);
						if(tZone != null) {
							this.utcOffset(tZone);
						} else {
							this.utcOffset(0, true);
						}
					}
					return this;
				}
				
				function hasAlignedHourOffset(input) {
					if(!this.isValid()) {
						return false;
					}
					input = input ? createLocal(input).utcOffset() : 0;
					
					return (this.utcOffset() - input) % 60 === 0;
				}
				
				function isDaylightSavingTime() {
					return (
						this.utcOffset() > this.clone().month(0).utcOffset() ||
						this.utcOffset() > this.clone().month(5).utcOffset()
					);
				}
				
				function isDaylightSavingTimeShifted() {
					if(!isUndefined(this._isDSTShifted)) {
						return this._isDSTShifted;
					}
					
					var c = {};
					
					copyConfig(c, this);
					c = prepareConfig(c);
					
					if(c._a) {
						var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
						this._isDSTShifted = this.isValid() &&
							compareArrays(c._a, other.toArray()) > 0;
					} else {
						this._isDSTShifted = false;
					}
					
					return this._isDSTShifted;
				}
				
				function isLocal() {
					return this.isValid() ? !this._isUTC : false;
				}
				
				function isUtcOffset() {
					return this.isValid() ? this._isUTC : false;
				}
				
				function isUtc() {
					return this.isValid() ? this._isUTC && this._offset === 0 : false;
				}
				
				// ASP.NET json date format regex
				var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;
				
				// from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
				// somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
				// and further modified to allow for strings containing both week and day
				var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
				
				function createDuration(input, key) {
					var duration = input,
						// matching against regexp is expensive, do it on demand
						match = null,
						sign,
						ret,
						diffRes;
					
					if(isDuration(input)) {
						duration = {
							ms: input._milliseconds,
							d: input._days,
							M: input._months
						};
					} else if(isNumber(input)) {
						duration = {};
						if(key) {
							duration[key] = input;
						} else {
							duration.milliseconds = input;
						}
					} else if(!!(match = aspNetRegex.exec(input))) {
						sign = (match[1] === '-') ? -1 : 1;
						duration = {
							y: 0,
							d: toInt(match[DATE]) * sign,
							h: toInt(match[HOUR]) * sign,
							m: toInt(match[MINUTE]) * sign,
							s: toInt(match[SECOND]) * sign,
							ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
						};
					} else if(!!(match = isoRegex.exec(input))) {
						sign = (match[1] === '-') ? -1 : 1;
						duration = {
							y: parseIso(match[2], sign),
							M: parseIso(match[3], sign),
							w: parseIso(match[4], sign),
							d: parseIso(match[5], sign),
							h: parseIso(match[6], sign),
							m: parseIso(match[7], sign),
							s: parseIso(match[8], sign)
						};
					} else if(duration == null) {// checks for null or undefined
						duration = {};
					} else if(typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
						diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
						
						duration = {};
						duration.ms = diffRes.milliseconds;
						duration.M = diffRes.months;
					}
					
					ret = new Duration(duration);
					
					if(isDuration(input) && hasOwnProp(input, '_locale')) {
						ret._locale = input._locale;
					}
					
					return ret;
				}
				
				createDuration.fn = Duration.prototype;
				createDuration.invalid = createInvalid$1;
				
				function parseIso(inp, sign) {
					// We'd normally use ~~inp for this, but unfortunately it also
					// converts floats to ints.
					// inp may be undefined, so careful calling replace on it.
					var res = inp && parseFloat(inp.replace(',', '.'));
					// apply sign while we're at it
					return (isNaN(res) ? 0 : res) * sign;
				}
				
				function positiveMomentsDifference(base, other) {
					var res = {};
					
					res.months = other.month() - base.month() +
						(other.year() - base.year()) * 12;
					if(base.clone().add(res.months, 'M').isAfter(other)) {
						--res.months;
					}
					
					res.milliseconds = +other - +(base.clone().add(res.months, 'M'));
					
					return res;
				}
				
				function momentsDifference(base, other) {
					var res;
					if(!(base.isValid() && other.isValid())) {
						return {milliseconds: 0, months: 0};
					}
					
					other = cloneWithOffset(other, base);
					if(base.isBefore(other)) {
						res = positiveMomentsDifference(base, other);
					} else {
						res = positiveMomentsDifference(other, base);
						res.milliseconds = -res.milliseconds;
						res.months = -res.months;
					}
					
					return res;
				}
				
				// TODO: remove 'name' arg after deprecation is removed
				function createAdder(direction, name) {
					return function(val, period) {
						var dur, tmp;
						//invert the arguments, but complain about it
						if(period !== null && !isNaN(+period)) {
							deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
								'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
							tmp = val;
							val = period;
							period = tmp;
						}
						
						val = typeof val === 'string' ? +val : val;
						dur = createDuration(val, period);
						addSubtract(this, dur, direction);
						return this;
					};
				}
				
				function addSubtract(mom, duration, isAdding, updateOffset) {
					var milliseconds = duration._milliseconds,
						days = absRound(duration._days),
						months = absRound(duration._months);
					
					if(!mom.isValid()) {
						// No op
						return;
					}
					
					updateOffset = updateOffset == null ? true : updateOffset;
					
					if(months) {
						setMonth(mom, get(mom, 'Month') + months * isAdding);
					}
					if(days) {
						set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
					}
					if(milliseconds) {
						mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
					}
					if(updateOffset) {
						hooks.updateOffset(mom, days || months);
					}
				}
				
				var add = createAdder(1, 'add');
				var subtract = createAdder(-1, 'subtract');
				
				function getCalendarFormat(myMoment, now) {
					var diff = myMoment.diff(now, 'days', true);
					return diff < -6 ? 'sameElse' :
						diff < -1 ? 'lastWeek' :
							diff < 0 ? 'lastDay' :
								diff < 1 ? 'sameDay' :
									diff < 2 ? 'nextDay' :
										diff < 7 ? 'nextWeek' : 'sameElse';
				}
				
				function calendar$1(time, formats) {
					// We want to compare the start of today, vs this.
					// Getting start-of-today depends on whether we're local/utc/offset or not.
					var now = time || createLocal(),
						sod = cloneWithOffset(now, this).startOf('day'),
						format = hooks.calendarFormat(this, sod) || 'sameElse';
					
					var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);
					
					return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
				}
				
				function clone() {
					return new Moment(this);
				}
				
				function isAfter(input, units) {
					var localInput = isMoment(input) ? input : createLocal(input);
					if(!(this.isValid() && localInput.isValid())) {
						return false;
					}
					units = normalizeUnits(units) || 'millisecond';
					if(units === 'millisecond') {
						return this.valueOf() > localInput.valueOf();
					} else {
						return localInput.valueOf() < this.clone().startOf(units).valueOf();
					}
				}
				
				function isBefore(input, units) {
					var localInput = isMoment(input) ? input : createLocal(input);
					if(!(this.isValid() && localInput.isValid())) {
						return false;
					}
					units = normalizeUnits(units) || 'millisecond';
					if(units === 'millisecond') {
						return this.valueOf() < localInput.valueOf();
					} else {
						return this.clone().endOf(units).valueOf() < localInput.valueOf();
					}
				}
				
				function isBetween(from, to, units, inclusivity) {
					var localFrom = isMoment(from) ? from : createLocal(from),
						localTo = isMoment(to) ? to : createLocal(to);
					if(!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
						return false;
					}
					inclusivity = inclusivity || '()';
					return (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) &&
						(inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
				}
				
				function isSame(input, units) {
					var localInput = isMoment(input) ? input : createLocal(input),
						inputMs;
					if(!(this.isValid() && localInput.isValid())) {
						return false;
					}
					units = normalizeUnits(units) || 'millisecond';
					if(units === 'millisecond') {
						return this.valueOf() === localInput.valueOf();
					} else {
						inputMs = localInput.valueOf();
						return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
					}
				}
				
				function isSameOrAfter(input, units) {
					return this.isSame(input, units) || this.isAfter(input, units);
				}
				
				function isSameOrBefore(input, units) {
					return this.isSame(input, units) || this.isBefore(input, units);
				}
				
				function diff(input, units, asFloat) {
					var that,
						zoneDelta,
						output;
					
					if(!this.isValid()) {
						return NaN;
					}
					
					that = cloneWithOffset(input, this);
					
					if(!that.isValid()) {
						return NaN;
					}
					
					zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
					
					units = normalizeUnits(units);
					
					switch(units) {
						case 'year':
							output = monthDiff(this, that) / 12;
							break;
						case 'month':
							output = monthDiff(this, that);
							break;
						case 'quarter':
							output = monthDiff(this, that) / 3;
							break;
						case 'second':
							output = (this - that) / 1e3;
							break; // 1000
						case 'minute':
							output = (this - that) / 6e4;
							break; // 1000 * 60
						case 'hour':
							output = (this - that) / 36e5;
							break; // 1000 * 60 * 60
						case 'day':
							output = (this - that - zoneDelta) / 864e5;
							break; // 1000 * 60 * 60 * 24, negate dst
						case 'week':
							output = (this - that - zoneDelta) / 6048e5;
							break; // 1000 * 60 * 60 * 24 * 7, negate dst
						default:
							output = this - that;
					}
					
					return asFloat ? output : absFloor(output);
				}
				
				function monthDiff(a, b) {
					// difference in months
					var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
						// b is in (anchor - 1 month, anchor + 1 month)
						anchor = a.clone().add(wholeMonthDiff, 'months'),
						anchor2, adjust;
					
					if(b - anchor < 0) {
						anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
						// linear across the month
						adjust = (b - anchor) / (anchor - anchor2);
					} else {
						anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
						// linear across the month
						adjust = (b - anchor) / (anchor2 - anchor);
					}
					
					//check for negative zero, return zero if negative zero
					return -(wholeMonthDiff + adjust) || 0;
				}
				
				hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
				hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';
				
				function toString() {
					return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
				}
				
				function toISOString(keepOffset) {
					if(!this.isValid()) {
						return null;
					}
					var utc = keepOffset !== true;
					var m = utc ? this.clone().utc() : this;
					if(m.year() < 0 || m.year() > 9999) {
						return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
					}
					if(isFunction(Date.prototype.toISOString)) {
						// native implementation is ~50x faster, use it when we can
						if(utc) {
							return this.toDate().toISOString();
						} else {
							return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
						}
					}
					return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
				}
				
				/**
				 * Return a human readable representation of a moment that can
				 * also be evaluated to get a new moment which is the same
				 *
				 * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
				 */
				function inspect() {
					if(!this.isValid()) {
						return 'moment.invalid(/* ' + this._i + ' */)';
					}
					var func = 'moment';
					var zone = '';
					if(!this.isLocal()) {
						func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
						zone = 'Z';
					}
					var prefix = '[' + func + '("]';
					var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
					var datetime = '-MM-DD[T]HH:mm:ss.SSS';
					var suffix = zone + '[")]';
					
					return this.format(prefix + year + datetime + suffix);
				}
				
				function format(inputString) {
					if(!inputString) {
						inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
					}
					var output = formatMoment(this, inputString);
					return this.localeData().postformat(output);
				}
				
				function from(time, withoutSuffix) {
					if(this.isValid() &&
						((isMoment(time) && time.isValid()) ||
							createLocal(time).isValid())) {
						return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
					} else {
						return this.localeData().invalidDate();
					}
				}
				
				function fromNow(withoutSuffix) {
					return this.from(createLocal(), withoutSuffix);
				}
				
				function to(time, withoutSuffix) {
					if(this.isValid() &&
						((isMoment(time) && time.isValid()) ||
							createLocal(time).isValid())) {
						return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
					} else {
						return this.localeData().invalidDate();
					}
				}
				
				function toNow(withoutSuffix) {
					return this.to(createLocal(), withoutSuffix);
				}
				
				// If passed a locale key, it will set the locale for this
				// instance.  Otherwise, it will return the locale configuration
				// variables for this instance.
				function locale(key) {
					var newLocaleData;
					
					if(key === undefined) {
						return this._locale._abbr;
					} else {
						newLocaleData = getLocale(key);
						if(newLocaleData != null) {
							this._locale = newLocaleData;
						}
						return this;
					}
				}
				
				var lang = deprecate(
					'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
					function(key) {
						if(key === undefined) {
							return this.localeData();
						} else {
							return this.locale(key);
						}
					}
				);
				
				function localeData() {
					return this._locale;
				}
				
				var MS_PER_SECOND = 1000;
				var MS_PER_MINUTE = 60 * MS_PER_SECOND;
				var MS_PER_HOUR = 60 * MS_PER_MINUTE;
				var MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
				
				// actual modulo - handles negative numbers (for dates before 1970):
				function mod$1(dividend, divisor) {
					return (dividend % divisor + divisor) % divisor;
				}
				
				function localStartOfDate(y, m, d) {
					// the date constructor remaps years 0-99 to 1900-1999
					if(y < 100 && y >= 0) {
						// preserve leap years using a full 400 year cycle, then reset
						return new Date(y + 400, m, d) - MS_PER_400_YEARS;
					} else {
						return new Date(y, m, d).valueOf();
					}
				}
				
				function utcStartOfDate(y, m, d) {
					// Date.UTC remaps years 0-99 to 1900-1999
					if(y < 100 && y >= 0) {
						// preserve leap years using a full 400 year cycle, then reset
						return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
					} else {
						return Date.UTC(y, m, d);
					}
				}
				
				function startOf(units) {
					var time;
					units = normalizeUnits(units);
					if(units === undefined || units === 'millisecond' || !this.isValid()) {
						return this;
					}
					
					var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
					
					switch(units) {
						case 'year':
							time = startOfDate(this.year(), 0, 1);
							break;
						case 'quarter':
							time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
							break;
						case 'month':
							time = startOfDate(this.year(), this.month(), 1);
							break;
						case 'week':
							time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
							break;
						case 'isoWeek':
							time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
							break;
						case 'day':
						case 'date':
							time = startOfDate(this.year(), this.month(), this.date());
							break;
						case 'hour':
							time = this._d.valueOf();
							time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
							break;
						case 'minute':
							time = this._d.valueOf();
							time -= mod$1(time, MS_PER_MINUTE);
							break;
						case 'second':
							time = this._d.valueOf();
							time -= mod$1(time, MS_PER_SECOND);
							break;
					}
					
					this._d.setTime(time);
					hooks.updateOffset(this, true);
					return this;
				}
				
				function endOf(units) {
					var time;
					units = normalizeUnits(units);
					if(units === undefined || units === 'millisecond' || !this.isValid()) {
						return this;
					}
					
					var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
					
					switch(units) {
						case 'year':
							time = startOfDate(this.year() + 1, 0, 1) - 1;
							break;
						case 'quarter':
							time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
							break;
						case 'month':
							time = startOfDate(this.year(), this.month() + 1, 1) - 1;
							break;
						case 'week':
							time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
							break;
						case 'isoWeek':
							time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
							break;
						case 'day':
						case 'date':
							time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
							break;
						case 'hour':
							time = this._d.valueOf();
							time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
							break;
						case 'minute':
							time = this._d.valueOf();
							time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
							break;
						case 'second':
							time = this._d.valueOf();
							time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
							break;
					}
					
					this._d.setTime(time);
					hooks.updateOffset(this, true);
					return this;
				}
				
				function valueOf() {
					return this._d.valueOf() - ((this._offset || 0) * 60000);
				}
				
				function unix() {
					return Math.floor(this.valueOf() / 1000);
				}
				
				function toDate() {
					return new Date(this.valueOf());
				}
				
				function toArray() {
					var m = this;
					return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
				}
				
				function toObject() {
					var m = this;
					return {
						years: m.year(),
						months: m.month(),
						date: m.date(),
						hours: m.hours(),
						minutes: m.minutes(),
						seconds: m.seconds(),
						milliseconds: m.milliseconds()
					};
				}
				
				function toJSON() {
					// new Date(NaN).toJSON() === null
					return this.isValid() ? this.toISOString() : null;
				}
				
				function isValid$2() {
					return isValid(this);
				}
				
				function parsingFlags() {
					return extend({}, getParsingFlags(this));
				}
				
				function invalidAt() {
					return getParsingFlags(this).overflow;
				}
				
				function creationData() {
					return {
						input: this._i,
						format: this._f,
						locale: this._locale,
						isUTC: this._isUTC,
						strict: this._strict
					};
				}
				
				// FORMATTING
				
				addFormatToken(0, ['gg', 2], 0, function() {
					return this.weekYear() % 100;
				});
				
				addFormatToken(0, ['GG', 2], 0, function() {
					return this.isoWeekYear() % 100;
				});
				
				function addWeekYearFormatToken(token, getter) {
					addFormatToken(0, [token, token.length], 0, getter);
				}
				
				addWeekYearFormatToken('gggg', 'weekYear');
				addWeekYearFormatToken('ggggg', 'weekYear');
				addWeekYearFormatToken('GGGG', 'isoWeekYear');
				addWeekYearFormatToken('GGGGG', 'isoWeekYear');
				
				// ALIASES
				
				addUnitAlias('weekYear', 'gg');
				addUnitAlias('isoWeekYear', 'GG');
				
				// PRIORITY
				
				addUnitPriority('weekYear', 1);
				addUnitPriority('isoWeekYear', 1);
				
				
				// PARSING
				
				addRegexToken('G', matchSigned);
				addRegexToken('g', matchSigned);
				addRegexToken('GG', match1to2, match2);
				addRegexToken('gg', match1to2, match2);
				addRegexToken('GGGG', match1to4, match4);
				addRegexToken('gggg', match1to4, match4);
				addRegexToken('GGGGG', match1to6, match6);
				addRegexToken('ggggg', match1to6, match6);
				
				addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function(input, week, config, token) {
					week[token.substr(0, 2)] = toInt(input);
				});
				
				addWeekParseToken(['gg', 'GG'], function(input, week, config, token) {
					week[token] = hooks.parseTwoDigitYear(input);
				});
				
				// MOMENTS
				
				function getSetWeekYear(input) {
					return getSetWeekYearHelper.call(this,
						input,
						this.week(),
						this.weekday(),
						this.localeData()._week.dow,
						this.localeData()._week.doy);
				}
				
				function getSetISOWeekYear(input) {
					return getSetWeekYearHelper.call(this,
						input, this.isoWeek(), this.isoWeekday(), 1, 4);
				}
				
				function getISOWeeksInYear() {
					return weeksInYear(this.year(), 1, 4);
				}
				
				function getWeeksInYear() {
					var weekInfo = this.localeData()._week;
					return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
				}
				
				function getSetWeekYearHelper(input, week, weekday, dow, doy) {
					var weeksTarget;
					if(input == null) {
						return weekOfYear(this, dow, doy).year;
					} else {
						weeksTarget = weeksInYear(input, dow, doy);
						if(week > weeksTarget) {
							week = weeksTarget;
						}
						return setWeekAll.call(this, input, week, weekday, dow, doy);
					}
				}
				
				function setWeekAll(weekYear, week, weekday, dow, doy) {
					var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
						date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
					
					this.year(date.getUTCFullYear());
					this.month(date.getUTCMonth());
					this.date(date.getUTCDate());
					return this;
				}
				
				// FORMATTING
				
				addFormatToken('Q', 0, 'Qo', 'quarter');
				
				// ALIASES
				
				addUnitAlias('quarter', 'Q');
				
				// PRIORITY
				
				addUnitPriority('quarter', 7);
				
				// PARSING
				
				addRegexToken('Q', match1);
				addParseToken('Q', function(input, array) {
					array[MONTH] = (toInt(input) - 1) * 3;
				});
				
				// MOMENTS
				
				function getSetQuarter(input) {
					return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
				}
				
				// FORMATTING
				
				addFormatToken('D', ['DD', 2], 'Do', 'date');
				
				// ALIASES
				
				addUnitAlias('date', 'D');
				
				// PRIORITY
				addUnitPriority('date', 9);
				
				// PARSING
				
				addRegexToken('D', match1to2);
				addRegexToken('DD', match1to2, match2);
				addRegexToken('Do', function(isStrict, locale) {
					// TODO: Remove "ordinalParse" fallback in next major release.
					return isStrict ?
						(locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
						locale._dayOfMonthOrdinalParseLenient;
				});
				
				addParseToken(['D', 'DD'], DATE);
				addParseToken('Do', function(input, array) {
					array[DATE] = toInt(input.match(match1to2)[0]);
				});
				
				// MOMENTS
				
				var getSetDayOfMonth = makeGetSet('Date', true);
				
				// FORMATTING
				
				addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');
				
				// ALIASES
				
				addUnitAlias('dayOfYear', 'DDD');
				
				// PRIORITY
				addUnitPriority('dayOfYear', 4);
				
				// PARSING
				
				addRegexToken('DDD', match1to3);
				addRegexToken('DDDD', match3);
				addParseToken(['DDD', 'DDDD'], function(input, array, config) {
					config._dayOfYear = toInt(input);
				});
				
				// HELPERS
				
				// MOMENTS
				
				function getSetDayOfYear(input) {
					var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
					return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
				}
				
				// FORMATTING
				
				addFormatToken('m', ['mm', 2], 0, 'minute');
				
				// ALIASES
				
				addUnitAlias('minute', 'm');
				
				// PRIORITY
				
				addUnitPriority('minute', 14);
				
				// PARSING
				
				addRegexToken('m', match1to2);
				addRegexToken('mm', match1to2, match2);
				addParseToken(['m', 'mm'], MINUTE);
				
				// MOMENTS
				
				var getSetMinute = makeGetSet('Minutes', false);
				
				// FORMATTING
				
				addFormatToken('s', ['ss', 2], 0, 'second');
				
				// ALIASES
				
				addUnitAlias('second', 's');
				
				// PRIORITY
				
				addUnitPriority('second', 15);
				
				// PARSING
				
				addRegexToken('s', match1to2);
				addRegexToken('ss', match1to2, match2);
				addParseToken(['s', 'ss'], SECOND);
				
				// MOMENTS
				
				var getSetSecond = makeGetSet('Seconds', false);
				
				// FORMATTING
				
				addFormatToken('S', 0, 0, function() {
					return ~~(this.millisecond() / 100);
				});
				
				addFormatToken(0, ['SS', 2], 0, function() {
					return ~~(this.millisecond() / 10);
				});
				
				addFormatToken(0, ['SSS', 3], 0, 'millisecond');
				addFormatToken(0, ['SSSS', 4], 0, function() {
					return this.millisecond() * 10;
				});
				addFormatToken(0, ['SSSSS', 5], 0, function() {
					return this.millisecond() * 100;
				});
				addFormatToken(0, ['SSSSSS', 6], 0, function() {
					return this.millisecond() * 1000;
				});
				addFormatToken(0, ['SSSSSSS', 7], 0, function() {
					return this.millisecond() * 10000;
				});
				addFormatToken(0, ['SSSSSSSS', 8], 0, function() {
					return this.millisecond() * 100000;
				});
				addFormatToken(0, ['SSSSSSSSS', 9], 0, function() {
					return this.millisecond() * 1000000;
				});
				
				
				// ALIASES
				
				addUnitAlias('millisecond', 'ms');
				
				// PRIORITY
				
				addUnitPriority('millisecond', 16);
				
				// PARSING
				
				addRegexToken('S', match1to3, match1);
				addRegexToken('SS', match1to3, match2);
				addRegexToken('SSS', match1to3, match3);
				
				var token;
				for(token = 'SSSS'; token.length <= 9; token += 'S') {
					addRegexToken(token, matchUnsigned);
				}
				
				function parseMs(input, array) {
					array[MILLISECOND] = toInt(('0.' + input) * 1000);
				}
				
				for(token = 'S'; token.length <= 9; token += 'S') {
					addParseToken(token, parseMs);
				}
				// MOMENTS
				
				var getSetMillisecond = makeGetSet('Milliseconds', false);
				
				// FORMATTING
				
				addFormatToken('z', 0, 0, 'zoneAbbr');
				addFormatToken('zz', 0, 0, 'zoneName');
				
				// MOMENTS
				
				function getZoneAbbr() {
					return this._isUTC ? 'UTC' : '';
				}
				
				function getZoneName() {
					return this._isUTC ? 'Coordinated Universal Time' : '';
				}
				
				var proto = Moment.prototype;
				
				proto.add = add;
				proto.calendar = calendar$1;
				proto.clone = clone;
				proto.diff = diff;
				proto.endOf = endOf;
				proto.format = format;
				proto.from = from;
				proto.fromNow = fromNow;
				proto.to = to;
				proto.toNow = toNow;
				proto.get = stringGet;
				proto.invalidAt = invalidAt;
				proto.isAfter = isAfter;
				proto.isBefore = isBefore;
				proto.isBetween = isBetween;
				proto.isSame = isSame;
				proto.isSameOrAfter = isSameOrAfter;
				proto.isSameOrBefore = isSameOrBefore;
				proto.isValid = isValid$2;
				proto.lang = lang;
				proto.locale = locale;
				proto.localeData = localeData;
				proto.max = prototypeMax;
				proto.min = prototypeMin;
				proto.parsingFlags = parsingFlags;
				proto.set = stringSet;
				proto.startOf = startOf;
				proto.subtract = subtract;
				proto.toArray = toArray;
				proto.toObject = toObject;
				proto.toDate = toDate;
				proto.toISOString = toISOString;
				proto.inspect = inspect;
				proto.toJSON = toJSON;
				proto.toString = toString;
				proto.unix = unix;
				proto.valueOf = valueOf;
				proto.creationData = creationData;
				proto.year = getSetYear;
				proto.isLeapYear = getIsLeapYear;
				proto.weekYear = getSetWeekYear;
				proto.isoWeekYear = getSetISOWeekYear;
				proto.quarter = proto.quarters = getSetQuarter;
				proto.month = getSetMonth;
				proto.daysInMonth = getDaysInMonth;
				proto.week = proto.weeks = getSetWeek;
				proto.isoWeek = proto.isoWeeks = getSetISOWeek;
				proto.weeksInYear = getWeeksInYear;
				proto.isoWeeksInYear = getISOWeeksInYear;
				proto.date = getSetDayOfMonth;
				proto.day = proto.days = getSetDayOfWeek;
				proto.weekday = getSetLocaleDayOfWeek;
				proto.isoWeekday = getSetISODayOfWeek;
				proto.dayOfYear = getSetDayOfYear;
				proto.hour = proto.hours = getSetHour;
				proto.minute = proto.minutes = getSetMinute;
				proto.second = proto.seconds = getSetSecond;
				proto.millisecond = proto.milliseconds = getSetMillisecond;
				proto.utcOffset = getSetOffset;
				proto.utc = setOffsetToUTC;
				proto.local = setOffsetToLocal;
				proto.parseZone = setOffsetToParsedOffset;
				proto.hasAlignedHourOffset = hasAlignedHourOffset;
				proto.isDST = isDaylightSavingTime;
				proto.isLocal = isLocal;
				proto.isUtcOffset = isUtcOffset;
				proto.isUtc = isUtc;
				proto.isUTC = isUtc;
				proto.zoneAbbr = getZoneAbbr;
				proto.zoneName = getZoneName;
				proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
				proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
				proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);
				proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
				proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);
				
				function createUnix(input) {
					return createLocal(input * 1000);
				}
				
				function createInZone() {
					return createLocal.apply(null, arguments).parseZone();
				}
				
				function preParsePostFormat(string) {
					return string;
				}
				
				var proto$1 = Locale.prototype;
				
				proto$1.calendar = calendar;
				proto$1.longDateFormat = longDateFormat;
				proto$1.invalidDate = invalidDate;
				proto$1.ordinal = ordinal;
				proto$1.preparse = preParsePostFormat;
				proto$1.postformat = preParsePostFormat;
				proto$1.relativeTime = relativeTime;
				proto$1.pastFuture = pastFuture;
				proto$1.set = set;
				
				proto$1.months = localeMonths;
				proto$1.monthsShort = localeMonthsShort;
				proto$1.monthsParse = localeMonthsParse;
				proto$1.monthsRegex = monthsRegex;
				proto$1.monthsShortRegex = monthsShortRegex;
				proto$1.week = localeWeek;
				proto$1.firstDayOfYear = localeFirstDayOfYear;
				proto$1.firstDayOfWeek = localeFirstDayOfWeek;
				
				proto$1.weekdays = localeWeekdays;
				proto$1.weekdaysMin = localeWeekdaysMin;
				proto$1.weekdaysShort = localeWeekdaysShort;
				proto$1.weekdaysParse = localeWeekdaysParse;
				
				proto$1.weekdaysRegex = weekdaysRegex;
				proto$1.weekdaysShortRegex = weekdaysShortRegex;
				proto$1.weekdaysMinRegex = weekdaysMinRegex;
				
				proto$1.isPM = localeIsPM;
				proto$1.meridiem = localeMeridiem;
				
				function get$1(format, index, field, setter) {
					var locale = getLocale();
					var utc = createUTC().set(setter, index);
					return locale[field](utc, format);
				}
				
				function listMonthsImpl(format, index, field) {
					if(isNumber(format)) {
						index = format;
						format = undefined;
					}
					
					format = format || '';
					
					if(index != null) {
						return get$1(format, index, field, 'month');
					}
					
					var i;
					var out = [];
					for(i = 0; i < 12; i++) {
						out[i] = get$1(format, i, field, 'month');
					}
					return out;
				}
				
				// ()
				// (5)
				// (fmt, 5)
				// (fmt)
				// (true)
				// (true, 5)
				// (true, fmt, 5)
				// (true, fmt)
				function listWeekdaysImpl(localeSorted, format, index, field) {
					if(typeof localeSorted === 'boolean') {
						if(isNumber(format)) {
							index = format;
							format = undefined;
						}
						
						format = format || '';
					} else {
						format = localeSorted;
						index = format;
						localeSorted = false;
						
						if(isNumber(format)) {
							index = format;
							format = undefined;
						}
						
						format = format || '';
					}
					
					var locale = getLocale(),
						shift = localeSorted ? locale._week.dow : 0;
					
					if(index != null) {
						return get$1(format, (index + shift) % 7, field, 'day');
					}
					
					var i;
					var out = [];
					for(i = 0; i < 7; i++) {
						out[i] = get$1(format, (i + shift) % 7, field, 'day');
					}
					return out;
				}
				
				function listMonths(format, index) {
					return listMonthsImpl(format, index, 'months');
				}
				
				function listMonthsShort(format, index) {
					return listMonthsImpl(format, index, 'monthsShort');
				}
				
				function listWeekdays(localeSorted, format, index) {
					return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
				}
				
				function listWeekdaysShort(localeSorted, format, index) {
					return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
				}
				
				function listWeekdaysMin(localeSorted, format, index) {
					return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
				}
				
				getSetGlobalLocale('en', {
					dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
					ordinal: function(number) {
						var b = number % 10,
							output = (toInt(number % 100 / 10) === 1) ? 'th' :
								(b === 1) ? 'st' :
									(b === 2) ? 'nd' :
										(b === 3) ? 'rd' : 'th';
						return number + output;
					}
				});
				
				// Side effect imports
				
				hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
				hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);
				
				var mathAbs = Math.abs;
				
				function abs() {
					var data = this._data;
					
					this._milliseconds = mathAbs(this._milliseconds);
					this._days = mathAbs(this._days);
					this._months = mathAbs(this._months);
					
					data.milliseconds = mathAbs(data.milliseconds);
					data.seconds = mathAbs(data.seconds);
					data.minutes = mathAbs(data.minutes);
					data.hours = mathAbs(data.hours);
					data.months = mathAbs(data.months);
					data.years = mathAbs(data.years);
					
					return this;
				}
				
				function addSubtract$1(duration, input, value, direction) {
					var other = createDuration(input, value);
					
					duration._milliseconds += direction * other._milliseconds;
					duration._days += direction * other._days;
					duration._months += direction * other._months;
					
					return duration._bubble();
				}
				
				// supports only 2.0-style add(1, 's') or add(duration)
				function add$1(input, value) {
					return addSubtract$1(this, input, value, 1);
				}
				
				// supports only 2.0-style subtract(1, 's') or subtract(duration)
				function subtract$1(input, value) {
					return addSubtract$1(this, input, value, -1);
				}
				
				function absCeil(number) {
					if(number < 0) {
						return Math.floor(number);
					} else {
						return Math.ceil(number);
					}
				}
				
				function bubble() {
					var milliseconds = this._milliseconds;
					var days = this._days;
					var months = this._months;
					var data = this._data;
					var seconds, minutes, hours, years, monthsFromDays;
					
					// if we have a mix of positive and negative values, bubble down first
					// check: https://github.com/moment/moment/issues/2166
					if(!((milliseconds >= 0 && days >= 0 && months >= 0) ||
						(milliseconds <= 0 && days <= 0 && months <= 0))) {
						milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
						days = 0;
						months = 0;
					}
					
					// The following code bubbles up values, see the tests for
					// examples of what that means.
					data.milliseconds = milliseconds % 1000;
					
					seconds = absFloor(milliseconds / 1000);
					data.seconds = seconds % 60;
					
					minutes = absFloor(seconds / 60);
					data.minutes = minutes % 60;
					
					hours = absFloor(minutes / 60);
					data.hours = hours % 24;
					
					days += absFloor(hours / 24);
					
					// convert days to months
					monthsFromDays = absFloor(daysToMonths(days));
					months += monthsFromDays;
					days -= absCeil(monthsToDays(monthsFromDays));
					
					// 12 months -> 1 year
					years = absFloor(months / 12);
					months %= 12;
					
					data.days = days;
					data.months = months;
					data.years = years;
					
					return this;
				}
				
				function daysToMonths(days) {
					// 400 years have 146097 days (taking into account leap year rules)
					// 400 years have 12 months === 4800
					return days * 4800 / 146097;
				}
				
				function monthsToDays(months) {
					// the reverse of daysToMonths
					return months * 146097 / 4800;
				}
				
				function as(units) {
					if(!this.isValid()) {
						return NaN;
					}
					var days;
					var months;
					var milliseconds = this._milliseconds;
					
					units = normalizeUnits(units);
					
					if(units === 'month' || units === 'quarter' || units === 'year') {
						days = this._days + milliseconds / 864e5;
						months = this._months + daysToMonths(days);
						switch(units) {
							case 'month':
								return months;
							case 'quarter':
								return months / 3;
							case 'year':
								return months / 12;
						}
					} else {
						// handle milliseconds separately because of floating point math errors (issue #1867)
						days = this._days + Math.round(monthsToDays(this._months));
						switch(units) {
							case 'week'   :
								return days / 7 + milliseconds / 6048e5;
							case 'day'    :
								return days + milliseconds / 864e5;
							case 'hour'   :
								return days * 24 + milliseconds / 36e5;
							case 'minute' :
								return days * 1440 + milliseconds / 6e4;
							case 'second' :
								return days * 86400 + milliseconds / 1000;
							// Math.floor prevents floating point math errors here
							case 'millisecond':
								return Math.floor(days * 864e5) + milliseconds;
							default:
								throw new Error('Unknown unit ' + units);
						}
					}
				}
				
				// TODO: Use this.as('ms')?
				function valueOf$1() {
					if(!this.isValid()) {
						return NaN;
					}
					return (
						this._milliseconds +
						this._days * 864e5 +
						(this._months % 12) * 2592e6 +
						toInt(this._months / 12) * 31536e6
					);
				}
				
				function makeAs(alias) {
					return function() {
						return this.as(alias);
					};
				}
				
				var asMilliseconds = makeAs('ms');
				var asSeconds = makeAs('s');
				var asMinutes = makeAs('m');
				var asHours = makeAs('h');
				var asDays = makeAs('d');
				var asWeeks = makeAs('w');
				var asMonths = makeAs('M');
				var asQuarters = makeAs('Q');
				var asYears = makeAs('y');
				
				function clone$1() {
					return createDuration(this);
				}
				
				function get$2(units) {
					units = normalizeUnits(units);
					return this.isValid() ? this[units + 's']() : NaN;
				}
				
				function makeGetter(name) {
					return function() {
						return this.isValid() ? this._data[name] : NaN;
					};
				}
				
				var milliseconds = makeGetter('milliseconds');
				var seconds = makeGetter('seconds');
				var minutes = makeGetter('minutes');
				var hours = makeGetter('hours');
				var days = makeGetter('days');
				var months = makeGetter('months');
				var years = makeGetter('years');
				
				function weeks() {
					return absFloor(this.days() / 7);
				}
				
				var round = Math.round;
				var thresholds = {
					ss: 44,         // a few seconds to seconds
					s: 45,         // seconds to minute
					m: 45,         // minutes to hour
					h: 22,         // hours to day
					d: 26,         // days to month
					M: 11          // months to year
				};
				
				// helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
				function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
					return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
				}
				
				function relativeTime$1(posNegDuration, withoutSuffix, locale) {
					var duration = createDuration(posNegDuration).abs();
					var seconds = round(duration.as('s'));
					var minutes = round(duration.as('m'));
					var hours = round(duration.as('h'));
					var days = round(duration.as('d'));
					var months = round(duration.as('M'));
					var years = round(duration.as('y'));
					
					var a = seconds <= thresholds.ss && ['s', seconds] ||
						seconds < thresholds.s && ['ss', seconds] ||
						minutes <= 1 && ['m'] ||
						minutes < thresholds.m && ['mm', minutes] ||
						hours <= 1 && ['h'] ||
						hours < thresholds.h && ['hh', hours] ||
						days <= 1 && ['d'] ||
						days < thresholds.d && ['dd', days] ||
						months <= 1 && ['M'] ||
						months < thresholds.M && ['MM', months] ||
						years <= 1 && ['y'] || ['yy', years];
					
					a[2] = withoutSuffix;
					a[3] = +posNegDuration > 0;
					a[4] = locale;
					return substituteTimeAgo.apply(null, a);
				}
				
				// This function allows you to set the rounding function for relative time strings
				function getSetRelativeTimeRounding(roundingFunction) {
					if(roundingFunction === undefined) {
						return round;
					}
					if(typeof (roundingFunction) === 'function') {
						round = roundingFunction;
						return true;
					}
					return false;
				}
				
				// This function allows you to set a threshold for relative time strings
				function getSetRelativeTimeThreshold(threshold, limit) {
					if(thresholds[threshold] === undefined) {
						return false;
					}
					if(limit === undefined) {
						return thresholds[threshold];
					}
					thresholds[threshold] = limit;
					if(threshold === 's') {
						thresholds.ss = limit - 1;
					}
					return true;
				}
				
				function humanize(withSuffix) {
					if(!this.isValid()) {
						return this.localeData().invalidDate();
					}
					
					var locale = this.localeData();
					var output = relativeTime$1(this, !withSuffix, locale);
					
					if(withSuffix) {
						output = locale.pastFuture(+this, output);
					}
					
					return locale.postformat(output);
				}
				
				var abs$1 = Math.abs;
				
				function sign(x) {
					return ((x > 0) - (x < 0)) || +x;
				}
				
				function toISOString$1() {
					// for ISO strings we do not use the normal bubbling rules:
					//  * milliseconds bubble up until they become hours
					//  * days do not bubble at all
					//  * months bubble up until they become years
					// This is because there is no context-free conversion between hours and days
					// (think of clock changes)
					// and also not between days and months (28-31 days per month)
					if(!this.isValid()) {
						return this.localeData().invalidDate();
					}
					
					var seconds = abs$1(this._milliseconds) / 1000;
					var days = abs$1(this._days);
					var months = abs$1(this._months);
					var minutes, hours, years;
					
					// 3600 seconds -> 60 minutes -> 1 hour
					minutes = absFloor(seconds / 60);
					hours = absFloor(minutes / 60);
					seconds %= 60;
					minutes %= 60;
					
					// 12 months -> 1 year
					years = absFloor(months / 12);
					months %= 12;
					
					
					// inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
					var Y = years;
					var M = months;
					var D = days;
					var h = hours;
					var m = minutes;
					var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
					var total = this.asSeconds();
					
					if(!total) {
						// this is the same as C#'s (Noda) and python (isodate)...
						// but not other JS (goog.date)
						return 'P0D';
					}
					
					var totalSign = total < 0 ? '-' : '';
					var ymSign = sign(this._months) !== sign(total) ? '-' : '';
					var daysSign = sign(this._days) !== sign(total) ? '-' : '';
					var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';
					
					return totalSign + 'P' +
						(Y ? ymSign + Y + 'Y' : '') +
						(M ? ymSign + M + 'M' : '') +
						(D ? daysSign + D + 'D' : '') +
						((h || m || s) ? 'T' : '') +
						(h ? hmsSign + h + 'H' : '') +
						(m ? hmsSign + m + 'M' : '') +
						(s ? hmsSign + s + 'S' : '');
				}
				
				var proto$2 = Duration.prototype;
				
				proto$2.isValid = isValid$1;
				proto$2.abs = abs;
				proto$2.add = add$1;
				proto$2.subtract = subtract$1;
				proto$2.as = as;
				proto$2.asMilliseconds = asMilliseconds;
				proto$2.asSeconds = asSeconds;
				proto$2.asMinutes = asMinutes;
				proto$2.asHours = asHours;
				proto$2.asDays = asDays;
				proto$2.asWeeks = asWeeks;
				proto$2.asMonths = asMonths;
				proto$2.asQuarters = asQuarters;
				proto$2.asYears = asYears;
				proto$2.valueOf = valueOf$1;
				proto$2._bubble = bubble;
				proto$2.clone = clone$1;
				proto$2.get = get$2;
				proto$2.milliseconds = milliseconds;
				proto$2.seconds = seconds;
				proto$2.minutes = minutes;
				proto$2.hours = hours;
				proto$2.days = days;
				proto$2.weeks = weeks;
				proto$2.months = months;
				proto$2.years = years;
				proto$2.humanize = humanize;
				proto$2.toISOString = toISOString$1;
				proto$2.toString = toISOString$1;
				proto$2.toJSON = toISOString$1;
				proto$2.locale = locale;
				proto$2.localeData = localeData;
				
				proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
				proto$2.lang = lang;
				
				// Side effect imports
				
				// FORMATTING
				
				addFormatToken('X', 0, 0, 'unix');
				addFormatToken('x', 0, 0, 'valueOf');
				
				// PARSING
				
				addRegexToken('x', matchSigned);
				addRegexToken('X', matchTimestamp);
				addParseToken('X', function(input, array, config) {
					config._d = new Date(parseFloat(input, 10) * 1000);
				});
				addParseToken('x', function(input, array, config) {
					config._d = new Date(toInt(input));
				});
				
				// Side effect imports
				
				
				hooks.version = '2.24.0';
				
				setHookCallback(createLocal);
				
				hooks.fn = proto;
				hooks.min = min;
				hooks.max = max;
				hooks.now = now;
				hooks.utc = createUTC;
				hooks.unix = createUnix;
				hooks.months = listMonths;
				hooks.isDate = isDate;
				hooks.locale = getSetGlobalLocale;
				hooks.invalid = createInvalid;
				hooks.duration = createDuration;
				hooks.isMoment = isMoment;
				hooks.weekdays = listWeekdays;
				hooks.parseZone = createInZone;
				hooks.localeData = getLocale;
				hooks.isDuration = isDuration;
				hooks.monthsShort = listMonthsShort;
				hooks.weekdaysMin = listWeekdaysMin;
				hooks.defineLocale = defineLocale;
				hooks.updateLocale = updateLocale;
				hooks.locales = listLocales;
				hooks.weekdaysShort = listWeekdaysShort;
				hooks.normalizeUnits = normalizeUnits;
				hooks.relativeTimeRounding = getSetRelativeTimeRounding;
				hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
				hooks.calendarFormat = getCalendarFormat;
				hooks.prototype = proto;
				
				// currently HTML5 input type only supports 24-hour formats
				hooks.HTML5_FMT = {
					DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',             // <input type="datetime-local" />
					DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',  // <input type="datetime-local" step="1" />
					DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',   // <input type="datetime-local" step="0.001" />
					DATE: 'YYYY-MM-DD',                             // <input type="date" />
					TIME: 'HH:mm',                                  // <input type="time" />
					TIME_SECONDS: 'HH:mm:ss',                       // <input type="time" step="1" />
					TIME_MS: 'HH:mm:ss.SSS',                        // <input type="time" step="0.001" />
					WEEK: 'GGGG-[W]WW',                             // <input type="week" />
					MONTH: 'YYYY-MM'                                // <input type="month" />
				};
				
				return hooks;
				
			})));
			
			/* WEBPACK VAR INJECTION */
		}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)));
		
		/***/
	}),
	
	/***/ "./node_modules/webpack/buildin/global.js":
	/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
	/*! no static exports found */
	/***/ (function(module, exports) {
		
		var g;

// This works in non-strict mode
		g = (function() {
			return this;
		})();
		
		try {
			// This works if eval is allowed (see CSP)
			g = g || new Function("return this")();
		} catch(e) {
			// This works if the window reference is available
			if(typeof window === "object") g = window;
		}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}
		
		module.exports = g;
		
		
		/***/
	}),
	
	/***/ "./node_modules/webpack/buildin/module.js":
	/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
	/*! no static exports found */
	/***/ (function(module, exports) {
		
		module.exports = function(module) {
			if(!module.webpackPolyfill) {
				module.deprecate = function() {
				};
				module.paths = [];
				// module.parent = undefined by default
				if(!module.children) module.children = [];
				Object.defineProperty(module, "loaded", {
					enumerable: true,
					get: function() {
						return module.l;
					}
				});
				Object.defineProperty(module, "id", {
					enumerable: true,
					get: function() {
						return module.i;
					}
				});
				module.webpackPolyfill = 1;
			}
			return module;
		};
		
		
		/***/
	}),
	
	/***/ "./src/resources/assets/js/components/widgets/widgets.ts":
	/*!***************************************************************!*\
  !*** ./src/resources/assets/js/components/widgets/widgets.ts ***!
  \***************************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		Object.defineProperty(exports, "__esModule", {value: true});
		var widgets_1 = __webpack_require__(/*! ../../modules/widgets/widgets */ "./src/resources/assets/js/modules/widgets/widgets.ts");
		__webpack_require__(/*! datatables.net */ "./node_modules/datatables.net/js/jquery.dataTables.js");
		$(function() {
			var widgets = new widgets_1.default();
			widgets.init();
			widgets.createRow();
			widgets.getWidgetContent();
		});
		
		
		/***/
	}),
	
	/***/ "./src/resources/assets/js/modules/widgets/widgets.ts":
	/*!************************************************************!*\
  !*** ./src/resources/assets/js/modules/widgets/widgets.ts ***!
  \************************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		/*
 *  Copyright (C) Interactive Knowledge Development, Inc - All Rights Reserved
 *  * Unauthorized copying of this file, via any medium is strictly prohibited
 *  * Proprietary and confidential
 *  * Written by Roberto Ferro <roberto.ferro@ikdev.eu>, March 2019
 *
 */
		Object.defineProperty(exports, "__esModule", {value: true});
		var BaseWidgets = __webpack_require__(/*! ../../templates/widget/base.hbs */ "./src/resources/assets/js/templates/widget/base.hbs");
		var WidgetTable = __webpack_require__(/*! ../../templates/widget/table.hbs */ "./src/resources/assets/js/templates/widget/table.hbs");
		var Chart = __webpack_require__(/*! chart.js */ "./node_modules/chart.js/src/chart.js");
		var Widgets = /** @class */ (function() {
			function Widgets() {
			}
			
			/**
			 * Load all role widget
			 */
			Widgets.prototype.init = function() {
				var main = this;
				$.ajax({
					type: "GET",
					async: false,
					url: admin_panel_url + "/widgets/load",
					success: function(data) {
						main.Widgets = data;
					}
				});
			};
			/**
			 * Create row
			 */
			Widgets.prototype.createRow = function() {
				var main = this, widgets = main.Widgets;
				for(var row in widgets) {
					$('.cards_container').append(BaseWidgets({rows: widgets[row], id: row}));
				}
			};
			/**
			 * Get all widget data
			 */
			Widgets.prototype.getWidgetContent = function() {
				var main = this, widgets = main.Widgets;
				for(var row in widgets) {
					var _loop_1 = function(widget) {
						var singleWidget = widgets[row][widget], container = "#widget-body-" + singleWidget.id,
							type = singleWidget.id_category;
						$.ajax({
							type: "GET",
							url: admin_panel_url + "/" + singleWidget.path,
							success: function(data) {
								switch(type) {
									case "TABLE":
										$(container).append(WidgetTable(data));
										main.processTableElement(data.table_id);
										break;
									case "GRAPH":
										$(container).append("<div class=\"graph-container\" style=\"position:relative; height: 90%;\"><canvas id=\"" + data.graph_id + "\"></canvas></div>");
										main.processGraph(data);
										break;
								}
							},
							error: function() {
								$(container).append("errore");
							},
							complete: function() {
								$("#widget-" + singleWidget.id + " .widget-loader").hide();
								$(".widget-animation-" + singleWidget.id).slideDown(200);
								$(container).animate({opacity: 1}, 300);
							}
						});
					};
					for(var widget in widgets[row]) {
						_loop_1(widget);
					}
				}
			};
			/**
			 * Create datatable and searchbox
			 * @param id
			 */
			Widgets.prototype.processTableElement = function(id) {
				var table = $("#" + id).DataTable({
					paging: false,
					info: false,
					dom: "<'table-responsive't><'row'<p i>>"
				});
				$("#widget-search-" + id).on('keyup', function() {
					table.search($(this).val().toString()).draw();
				});
			};
			/**
			 * Create graph
			 * @param data
			 */
			Widgets.prototype.processGraph = function(data) {
				new Chart(data.graph_id, {
					type: data.type,
					options: data.options,
					data: {
						labels: data.labels,
						datasets: [{
							data: data.data,
							backgroundColor: data.colors,
							label: data.dataset_labels
						}]
					}
				});
			};
			return Widgets;
		}());
		exports.default = Widgets;
		
		
		/***/
	}),
	
	/***/ "./src/resources/assets/js/templates/widget/base.hbs":
	/*!***********************************************************!*\
  !*** ./src/resources/assets/js/templates/widget/base.hbs ***!
  \***********************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		var Handlebars = __webpack_require__(/*! ../../../../../../node_modules/handlebars/runtime.js */ "./node_modules/handlebars/runtime.js");
		
		function __default(obj) {
			return obj && (obj.__esModule ? obj["default"] : obj);
		}
		
		module.exports = (Handlebars["default"] || Handlebars).template({
			"1": function(container, depth0, helpers, partials, data) {
				var stack1, helper, alias1 = container.escapeExpression,
					alias2 = depth0 != null ? depth0 : (container.nullContext || {}), alias3 = helpers.helperMissing,
					alias4 = "function";
				
				return "		<div class=\"col-md-"
					+ alias1(container.lambda(((stack1 = (depth0 != null ? depth0.pivot : depth0)) != null ? stack1.span : stack1), depth0))
					+ " mb-2 widget-sorting\" id=\"widget-"
					+ alias1(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : alias3), (typeof helper === alias4 ? helper.call(alias2, {
						"name": "id",
						"hash": {},
						"data": data
					}) : helper)))
					+ "\" style=\"float: left\">\n			<div class='widget-loader text-center'>\n				<i class='fas fa-circle-notch fa-spin loader'></i>\n			</div>\n			<div class=\"card\" style=\"height: 100%; max-height: 400px; min-height: 150px;overflow:auto\">\n				<div class=\"card-header\">\n					<div class=\"card-title\">\n						"
					+ alias1(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : alias3), (typeof helper === alias4 ? helper.call(alias2, {
						"name": "name",
						"hash": {},
						"data": data
					}) : helper)))
					+ "\n					</div>\n				</div>\n				<div class=\"card-body widget-animation-"
					+ alias1(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : alias3), (typeof helper === alias4 ? helper.call(alias2, {
						"name": "id",
						"hash": {},
						"data": data
					}) : helper)))
					+ "\">\n					<div id=\"widget-body-"
					+ alias1(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : alias3), (typeof helper === alias4 ? helper.call(alias2, {
						"name": "id",
						"hash": {},
						"data": data
					}) : helper)))
					+ "\" style=\"opacity: 0; height: 100%\">\n\n					</div>\n				</div>\n			</div>\n		</div>\n";
			}, "compiler": [7, ">= 4.0.0"], "main": function(container, depth0, helpers, partials, data) {
				var stack1, helper, alias1 = depth0 != null ? depth0 : (container.nullContext || {});
				
				return "<div class=\"row\" id=\""
					+ container.escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helpers.helperMissing), (typeof helper === "function" ? helper.call(alias1, {
						"name": "id",
						"hash": {},
						"data": data
					}) : helper)))
					+ "\">\n"
					+ ((stack1 = helpers.each.call(alias1, (depth0 != null ? depth0.rows : depth0), {
						"name": "each",
						"hash": {},
						"fn": container.program(1, data, 0),
						"inverse": container.noop,
						"data": data
					})) != null ? stack1 : "")
					+ "</div>\n";
			}, "useData": true
		});
		
		/***/
	}),
	
	/***/ "./src/resources/assets/js/templates/widget/table.hbs":
	/*!************************************************************!*\
  !*** ./src/resources/assets/js/templates/widget/table.hbs ***!
  \************************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		var Handlebars = __webpack_require__(/*! ../../../../../../node_modules/handlebars/runtime.js */ "./node_modules/handlebars/runtime.js");
		
		function __default(obj) {
			return obj && (obj.__esModule ? obj["default"] : obj);
		}
		
		module.exports = (Handlebars["default"] || Handlebars).template({
			"1": function(container, depth0, helpers, partials, data) {
				var helper, alias1 = depth0 != null ? depth0 : (container.nullContext || {}),
					alias2 = helpers.helperMissing, alias3 = "function", alias4 = container.escapeExpression;
				
				return "			<th class=\""
					+ alias4(((helper = (helper = helpers.text || (depth0 != null ? depth0.text : depth0)) != null ? helper : alias2), (typeof helper === alias3 ? helper.call(alias1, {
						"name": "text",
						"hash": {},
						"data": data
					}) : helper)))
					+ " sorting\">\r\n				"
					+ alias4(((helper = (helper = helpers.text || (depth0 != null ? depth0.text : depth0)) != null ? helper : alias2), (typeof helper === alias3 ? helper.call(alias1, {
						"name": "text",
						"hash": {},
						"data": data
					}) : helper)))
					+ "\r\n			</th>\r\n";
			}, "3": function(container, depth0, helpers, partials, data) {
				var stack1, helper, options, buffer =
					"		<tr>\r\n";
				stack1 = ((helper = (helper = helpers.td || (depth0 != null ? depth0.td : depth0)) != null ? helper : helpers.helperMissing), (options = {
					"name": "td",
					"hash": {},
					"fn": container.program(4, data, 0),
					"inverse": container.noop,
					"data": data
				}), (typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}), options) : helper));
				if(!helpers.td) {
					stack1 = helpers.blockHelperMissing.call(depth0, stack1, options);
				}
				if(stack1 != null) {
					buffer += stack1;
				}
				return buffer + "		</tr>\r\n";
			}, "4": function(container, depth0, helpers, partials, data) {
				var helper;
				
				return "				<td>\r\n					"
					+ container.escapeExpression(((helper = (helper = helpers.value || (depth0 != null ? depth0.value : depth0)) != null ? helper : helpers.helperMissing), (typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}), {
						"name": "value",
						"hash": {},
						"data": data
					}) : helper)))
					+ "\r\n				</td>\r\n";
			}, "compiler": [7, ">= 4.0.0"], "main": function(container, depth0, helpers, partials, data) {
				var stack1, helper, options, alias1 = depth0 != null ? depth0 : (container.nullContext || {}),
					alias2 = helpers.helperMissing, alias3 = "function", alias4 = container.escapeExpression,
					alias5 = helpers.blockHelperMissing, buffer =
					"<div class=\"row\">\r\n	<div class=\"col-md-8\"></div>\r\n	<div class=\"col-md-4\">\r\n		<div class=\"form-group form-group-default\">\r\n			<label for=\"widget-search-"
					+ alias4(((helper = (helper = helpers.table_id || (depth0 != null ? depth0.table_id : depth0)) != null ? helper : alias2), (typeof helper === alias3 ? helper.call(alias1, {
						"name": "table_id",
						"hash": {},
						"data": data
					}) : helper)))
					+ "\">Cerca</label>\r\n			<input type=\"text\" class=\"form-control input-sm\" id=\"widget-search-"
					+ alias4(((helper = (helper = helpers.table_id || (depth0 != null ? depth0.table_id : depth0)) != null ? helper : alias2), (typeof helper === alias3 ? helper.call(alias1, {
						"name": "table_id",
						"hash": {},
						"data": data
					}) : helper)))
					+ "\" autocomplete=\"off\">\r\n		</div>\r\n	</div>\r\n</div>\r\n<table id=\""
					+ alias4(((helper = (helper = helpers.table_id || (depth0 != null ? depth0.table_id : depth0)) != null ? helper : alias2), (typeof helper === alias3 ? helper.call(alias1, {
						"name": "table_id",
						"hash": {},
						"data": data
					}) : helper)))
					+ "\" class=\"table table-striped table-valign dataTable no-footer\">\r\n	<thead>\r\n	<tr>\r\n";
				stack1 = ((helper = (helper = helpers.th || (depth0 != null ? depth0.th : depth0)) != null ? helper : alias2), (options = {
					"name": "th",
					"hash": {},
					"fn": container.program(1, data, 0),
					"inverse": container.noop,
					"data": data
				}), (typeof helper === alias3 ? helper.call(alias1, options) : helper));
				if(!helpers.th) {
					stack1 = alias5.call(depth0, stack1, options);
				}
				if(stack1 != null) {
					buffer += stack1;
				}
				buffer += "	</tr>\r\n	</thead>\r\n	<tbody>\r\n";
				stack1 = ((helper = (helper = helpers.tr || (depth0 != null ? depth0.tr : depth0)) != null ? helper : alias2), (options = {
					"name": "tr",
					"hash": {},
					"fn": container.program(3, data, 0),
					"inverse": container.noop,
					"data": data
				}), (typeof helper === alias3 ? helper.call(alias1, options) : helper));
				if(!helpers.tr) {
					stack1 = alias5.call(depth0, stack1, options);
				}
				if(stack1 != null) {
					buffer += stack1;
				}
				return buffer + "	</tbody>\r\n</table>\r\n";
			}, "useData": true
		});
		
		/***/
	}),
	
	/***/ 12:
	/*!*********************************************************************!*\
  !*** multi ./src/resources/assets/js/components/widgets/widgets.ts ***!
  \*********************************************************************/
	/*! no static exports found */
	/***/ (function(module, exports, __webpack_require__) {
		
		module.exports = __webpack_require__(/*! C:\Users\roberto.ferro\PhpstormProjects\OmniGarden\packages\ikdev\ikpanel\src\resources\assets\js\components\widgets\widgets.ts */"./src/resources/assets/js/components/widgets/widgets.ts");
		
		
		/***/
	})
	
	/******/
});
//# sourceMappingURL=widgets.js.map
